{"id":"166a11e7df385be5","source_id_to_path":{"0":"lib/forge-std/src/Base.sol","1":"lib/forge-std/src/StdAssertions.sol","2":"lib/forge-std/src/StdChains.sol","3":"lib/forge-std/src/StdCheats.sol","4":"lib/forge-std/src/StdError.sol","5":"lib/forge-std/src/StdInvariant.sol","6":"lib/forge-std/src/StdJson.sol","7":"lib/forge-std/src/StdMath.sol","8":"lib/forge-std/src/StdStorage.sol","9":"lib/forge-std/src/StdStyle.sol","10":"lib/forge-std/src/StdToml.sol","11":"lib/forge-std/src/StdUtils.sol","12":"lib/forge-std/src/Test.sol","13":"lib/forge-std/src/Vm.sol","14":"lib/forge-std/src/console.sol","15":"lib/forge-std/src/console2.sol","16":"lib/forge-std/src/interfaces/IMulticall3.sol","17":"lib/forge-std/src/safeconsole.sol","18":"lib/openzeppelin-contracts/contracts/access/AccessControl.sol","19":"lib/openzeppelin-contracts/contracts/access/IAccessControl.sol","20":"lib/openzeppelin-contracts/contracts/access/Ownable.sol","21":"lib/openzeppelin-contracts/contracts/access/Ownable2Step.sol","22":"lib/openzeppelin-contracts/contracts/token/ERC20/IERC20.sol","23":"lib/openzeppelin-contracts/contracts/token/ERC721/IERC721.sol","24":"lib/openzeppelin-contracts/contracts/utils/Context.sol","25":"lib/openzeppelin-contracts/contracts/utils/Panic.sol","26":"lib/openzeppelin-contracts/contracts/utils/introspection/ERC165.sol","27":"lib/openzeppelin-contracts/contracts/utils/introspection/IERC165.sol","28":"lib/openzeppelin-contracts/contracts/utils/math/Math.sol","29":"lib/openzeppelin-contracts/contracts/utils/math/SafeCast.sol","30":"lib/openzeppelin-contracts/contracts/utils/structs/EnumerableSet.sol","31":"lib/v4-core/lib/solmate/src/auth/Owned.sol","32":"lib/v4-core/lib/solmate/src/test/utils/mocks/MockERC20.sol","33":"lib/v4-core/lib/solmate/src/tokens/ERC20.sol","34":"lib/v4-core/lib/solmate/src/tokens/ERC721.sol","35":"lib/v4-core/src/libraries/BitMath.sol","36":"lib/v4-core/src/libraries/CustomRevert.sol","37":"lib/v4-core/src/libraries/FixedPoint96.sol","38":"lib/v4-core/src/libraries/FullMath.sol","39":"lib/v4-core/src/libraries/TickMath.sol","40":"lib/v4-core/test/utils/LiquidityAmounts.sol","41":"lib/v4-periphery/lib/permit2/src/interfaces/IAllowanceTransfer.sol","42":"lib/v4-periphery/lib/permit2/src/interfaces/IEIP712.sol","43":"lib/v4-periphery/lib/permit2/src/interfaces/IERC1271.sol","44":"lib/v4-periphery/lib/permit2/src/libraries/SignatureVerification.sol","45":"lib/v4-periphery/lib/v4-core/src/ERC6909.sol","46":"lib/v4-periphery/lib/v4-core/src/ERC6909Claims.sol","47":"lib/v4-periphery/lib/v4-core/src/Extsload.sol","48":"lib/v4-periphery/lib/v4-core/src/Exttload.sol","49":"lib/v4-periphery/lib/v4-core/src/NoDelegateCall.sol","50":"lib/v4-periphery/lib/v4-core/src/PoolManager.sol","51":"lib/v4-periphery/lib/v4-core/src/ProtocolFees.sol","52":"lib/v4-periphery/lib/v4-core/src/interfaces/IExtsload.sol","53":"lib/v4-periphery/lib/v4-core/src/interfaces/IExttload.sol","54":"lib/v4-periphery/lib/v4-core/src/interfaces/IHooks.sol","55":"lib/v4-periphery/lib/v4-core/src/interfaces/IPoolManager.sol","56":"lib/v4-periphery/lib/v4-core/src/interfaces/IProtocolFees.sol","57":"lib/v4-periphery/lib/v4-core/src/interfaces/callback/IUnlockCallback.sol","58":"lib/v4-periphery/lib/v4-core/src/interfaces/external/IERC20Minimal.sol","59":"lib/v4-periphery/lib/v4-core/src/interfaces/external/IERC6909Claims.sol","60":"lib/v4-periphery/lib/v4-core/src/libraries/BitMath.sol","61":"lib/v4-periphery/lib/v4-core/src/libraries/CurrencyDelta.sol","62":"lib/v4-periphery/lib/v4-core/src/libraries/CurrencyReserves.sol","63":"lib/v4-periphery/lib/v4-core/src/libraries/CustomRevert.sol","64":"lib/v4-periphery/lib/v4-core/src/libraries/FixedPoint128.sol","65":"lib/v4-periphery/lib/v4-core/src/libraries/FixedPoint96.sol","66":"lib/v4-periphery/lib/v4-core/src/libraries/FullMath.sol","67":"lib/v4-periphery/lib/v4-core/src/libraries/Hooks.sol","68":"lib/v4-periphery/lib/v4-core/src/libraries/LPFeeLibrary.sol","69":"lib/v4-periphery/lib/v4-core/src/libraries/LiquidityMath.sol","70":"lib/v4-periphery/lib/v4-core/src/libraries/Lock.sol","71":"lib/v4-periphery/lib/v4-core/src/libraries/NonzeroDeltaCount.sol","72":"lib/v4-periphery/lib/v4-core/src/libraries/ParseBytes.sol","73":"lib/v4-periphery/lib/v4-core/src/libraries/Pool.sol","74":"lib/v4-periphery/lib/v4-core/src/libraries/Position.sol","75":"lib/v4-periphery/lib/v4-core/src/libraries/ProtocolFeeLibrary.sol","76":"lib/v4-periphery/lib/v4-core/src/libraries/SafeCast.sol","77":"lib/v4-periphery/lib/v4-core/src/libraries/SqrtPriceMath.sol","78":"lib/v4-periphery/lib/v4-core/src/libraries/StateLibrary.sol","79":"lib/v4-periphery/lib/v4-core/src/libraries/SwapMath.sol","80":"lib/v4-periphery/lib/v4-core/src/libraries/TickBitmap.sol","81":"lib/v4-periphery/lib/v4-core/src/libraries/TickMath.sol","82":"lib/v4-periphery/lib/v4-core/src/libraries/TransientStateLibrary.sol","83":"lib/v4-periphery/lib/v4-core/src/libraries/UnsafeMath.sol","84":"lib/v4-periphery/lib/v4-core/src/test/ActionsRouter.sol","85":"lib/v4-periphery/lib/v4-core/src/test/PoolClaimsTest.sol","86":"lib/v4-periphery/lib/v4-core/src/test/PoolDonateTest.sol","87":"lib/v4-periphery/lib/v4-core/src/test/PoolModifyLiquidityTest.sol","88":"lib/v4-periphery/lib/v4-core/src/test/PoolModifyLiquidityTestNoChecks.sol","89":"lib/v4-periphery/lib/v4-core/src/test/PoolNestedActionsTest.sol","90":"lib/v4-periphery/lib/v4-core/src/test/PoolSwapTest.sol","91":"lib/v4-periphery/lib/v4-core/src/test/PoolTakeTest.sol","92":"lib/v4-periphery/lib/v4-core/src/test/PoolTestBase.sol","93":"lib/v4-periphery/lib/v4-core/src/test/SwapRouterNoChecks.sol","94":"lib/v4-periphery/lib/v4-core/src/types/BalanceDelta.sol","95":"lib/v4-periphery/lib/v4-core/src/types/BeforeSwapDelta.sol","96":"lib/v4-periphery/lib/v4-core/src/types/Currency.sol","97":"lib/v4-periphery/lib/v4-core/src/types/PoolId.sol","98":"lib/v4-periphery/lib/v4-core/src/types/PoolKey.sol","99":"lib/v4-periphery/lib/v4-core/src/types/Slot0.sol","100":"lib/v4-periphery/lib/v4-core/test/utils/Constants.sol","101":"lib/v4-periphery/lib/v4-core/test/utils/CurrencySettler.sol","102":"lib/v4-periphery/lib/v4-core/test/utils/Deployers.sol","103":"lib/v4-periphery/lib/v4-core/test/utils/LiquidityAmounts.sol","104":"lib/v4-periphery/lib/v4-core/test/utils/SortTokens.sol","105":"lib/v4-periphery/src/PositionManager.sol","106":"lib/v4-periphery/src/base/BaseActionsRouter.sol","107":"lib/v4-periphery/src/base/DeltaResolver.sol","108":"lib/v4-periphery/src/base/EIP712_v4.sol","109":"lib/v4-periphery/src/base/ERC721Permit_v4.sol","110":"lib/v4-periphery/src/base/ImmutableState.sol","111":"lib/v4-periphery/src/base/Multicall_v4.sol","112":"lib/v4-periphery/src/base/NativeWrapper.sol","113":"lib/v4-periphery/src/base/Notifier.sol","114":"lib/v4-periphery/src/base/Permit2Forwarder.sol","115":"lib/v4-periphery/src/base/PoolInitializer_v4.sol","116":"lib/v4-periphery/src/base/ReentrancyLock.sol","117":"lib/v4-periphery/src/base/SafeCallback.sol","118":"lib/v4-periphery/src/base/UnorderedNonce.sol","119":"lib/v4-periphery/src/interfaces/IEIP712_v4.sol","120":"lib/v4-periphery/src/interfaces/IERC721Permit_v4.sol","121":"lib/v4-periphery/src/interfaces/IImmutableState.sol","122":"lib/v4-periphery/src/interfaces/IMulticall_v4.sol","123":"lib/v4-periphery/src/interfaces/INotifier.sol","124":"lib/v4-periphery/src/interfaces/IPermit2Forwarder.sol","125":"lib/v4-periphery/src/interfaces/IPoolInitializer_v4.sol","126":"lib/v4-periphery/src/interfaces/IPositionDescriptor.sol","127":"lib/v4-periphery/src/interfaces/IPositionManager.sol","128":"lib/v4-periphery/src/interfaces/ISubscriber.sol","129":"lib/v4-periphery/src/interfaces/IUnorderedNonce.sol","130":"lib/v4-periphery/src/interfaces/IV4Router.sol","131":"lib/v4-periphery/src/interfaces/external/IWETH9.sol","132":"lib/v4-periphery/src/libraries/ActionConstants.sol","133":"lib/v4-periphery/src/libraries/Actions.sol","134":"lib/v4-periphery/src/libraries/CalldataDecoder.sol","135":"lib/v4-periphery/src/libraries/ERC721PermitHash.sol","136":"lib/v4-periphery/src/libraries/LiquidityAmounts.sol","137":"lib/v4-periphery/src/libraries/Locker.sol","138":"lib/v4-periphery/src/libraries/PathKey.sol","139":"lib/v4-periphery/src/libraries/PositionInfoLibrary.sol","140":"lib/v4-periphery/src/libraries/SlippageCheck.sol","141":"lib/v4-periphery/src/utils/BaseHook.sol","142":"src/SuperDCAGauge.sol","143":"src/SuperDCAListing.sol","144":"src/SuperDCAStaking.sol","145":"src/interfaces/IMsgSender.sol","146":"src/interfaces/ISuperDCAGauge.sol","147":"src/interfaces/ISuperDCAListing.sol","148":"src/interfaces/ISuperDCAStaking.sol","149":"src/interfaces/ISuperchainERC20.sol","150":"test/AuditTest/MaliciousUserCanObtainSoloRewards.t.sol","151":"test/mocks/FeesCollectionMock.sol","152":"test/mocks/MockERC20Token.sol"},"language":"Solidity","_format":"ethers-rs-sol-build-info-1","input":{"version":"0.8.26","language":"Solidity","sources":{"lib/forge-std/src/Base.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity >=0.6.2 <0.9.0;\n\nimport {StdStorage} from \"./StdStorage.sol\";\nimport {Vm, VmSafe} from \"./Vm.sol\";\n\nabstract contract CommonBase {\n    // Cheat code address, 0x7109709ECfa91a80626fF3989D68f67F5b1DD12D.\n    address internal constant VM_ADDRESS = address(uint160(uint256(keccak256(\"hevm cheat code\"))));\n    // console.sol and console2.sol work by executing a staticcall to this address.\n    address internal constant CONSOLE = 0x000000000000000000636F6e736F6c652e6c6f67;\n    // Used when deploying with create2, https://github.com/Arachnid/deterministic-deployment-proxy.\n    address internal constant CREATE2_FACTORY = 0x4e59b44847b379578588920cA78FbF26c0B4956C;\n    // Default address for tx.origin and msg.sender, 0x1804c8AB1F12E6bbf3894d4083f33e07309d1f38.\n    address internal constant DEFAULT_SENDER = address(uint160(uint256(keccak256(\"foundry default caller\"))));\n    // Address of the test contract, deployed by the DEFAULT_SENDER.\n    address internal constant DEFAULT_TEST_CONTRACT = 0x5615dEB798BB3E4dFa0139dFa1b3D433Cc23b72f;\n    // Deterministic deployment address of the Multicall3 contract.\n    address internal constant MULTICALL3_ADDRESS = 0xcA11bde05977b3631167028862bE2a173976CA11;\n    // The order of the secp256k1 curve.\n    uint256 internal constant SECP256K1_ORDER =\n        115792089237316195423570985008687907852837564279074904382605163141518161494337;\n\n    uint256 internal constant UINT256_MAX =\n        115792089237316195423570985008687907853269984665640564039457584007913129639935;\n\n    Vm internal constant vm = Vm(VM_ADDRESS);\n    StdStorage internal stdstore;\n}\n\nabstract contract TestBase is CommonBase {}\n\nabstract contract ScriptBase is CommonBase {\n    VmSafe internal constant vmSafe = VmSafe(VM_ADDRESS);\n}\n"},"lib/forge-std/src/StdAssertions.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity >=0.6.2 <0.9.0;\npragma experimental ABIEncoderV2;\n\nimport {Vm} from \"./Vm.sol\";\n\nabstract contract StdAssertions {\n    Vm private constant vm = Vm(address(uint160(uint256(keccak256(\"hevm cheat code\")))));\n\n    event log(string);\n    event logs(bytes);\n\n    event log_address(address);\n    event log_bytes32(bytes32);\n    event log_int(int256);\n    event log_uint(uint256);\n    event log_bytes(bytes);\n    event log_string(string);\n\n    event log_named_address(string key, address val);\n    event log_named_bytes32(string key, bytes32 val);\n    event log_named_decimal_int(string key, int256 val, uint256 decimals);\n    event log_named_decimal_uint(string key, uint256 val, uint256 decimals);\n    event log_named_int(string key, int256 val);\n    event log_named_uint(string key, uint256 val);\n    event log_named_bytes(string key, bytes val);\n    event log_named_string(string key, string val);\n\n    event log_array(uint256[] val);\n    event log_array(int256[] val);\n    event log_array(address[] val);\n    event log_named_array(string key, uint256[] val);\n    event log_named_array(string key, int256[] val);\n    event log_named_array(string key, address[] val);\n\n    bool private _failed;\n\n    function failed() public view returns (bool) {\n        if (_failed) {\n            return _failed;\n        } else {\n            return vm.load(address(vm), bytes32(\"failed\")) != bytes32(0);\n        }\n    }\n\n    function fail() internal virtual {\n        vm.store(address(vm), bytes32(\"failed\"), bytes32(uint256(1)));\n        _failed = true;\n    }\n\n    function assertTrue(bool data) internal pure virtual {\n        vm.assertTrue(data);\n    }\n\n    function assertTrue(bool data, string memory err) internal pure virtual {\n        vm.assertTrue(data, err);\n    }\n\n    function assertFalse(bool data) internal pure virtual {\n        vm.assertFalse(data);\n    }\n\n    function assertFalse(bool data, string memory err) internal pure virtual {\n        vm.assertFalse(data, err);\n    }\n\n    function assertEq(bool left, bool right) internal pure virtual {\n        vm.assertEq(left, right);\n    }\n\n    function assertEq(bool left, bool right, string memory err) internal pure virtual {\n        vm.assertEq(left, right, err);\n    }\n\n    function assertEq(uint256 left, uint256 right) internal pure virtual {\n        vm.assertEq(left, right);\n    }\n\n    function assertEq(uint256 left, uint256 right, string memory err) internal pure virtual {\n        vm.assertEq(left, right, err);\n    }\n\n    function assertEqDecimal(uint256 left, uint256 right, uint256 decimals) internal pure virtual {\n        vm.assertEqDecimal(left, right, decimals);\n    }\n\n    function assertEqDecimal(uint256 left, uint256 right, uint256 decimals, string memory err) internal pure virtual {\n        vm.assertEqDecimal(left, right, decimals, err);\n    }\n\n    function assertEq(int256 left, int256 right) internal pure virtual {\n        vm.assertEq(left, right);\n    }\n\n    function assertEq(int256 left, int256 right, string memory err) internal pure virtual {\n        vm.assertEq(left, right, err);\n    }\n\n    function assertEqDecimal(int256 left, int256 right, uint256 decimals) internal pure virtual {\n        vm.assertEqDecimal(left, right, decimals);\n    }\n\n    function assertEqDecimal(int256 left, int256 right, uint256 decimals, string memory err) internal pure virtual {\n        vm.assertEqDecimal(left, right, decimals, err);\n    }\n\n    function assertEq(address left, address right) internal pure virtual {\n        vm.assertEq(left, right);\n    }\n\n    function assertEq(address left, address right, string memory err) internal pure virtual {\n        vm.assertEq(left, right, err);\n    }\n\n    function assertEq(bytes32 left, bytes32 right) internal pure virtual {\n        vm.assertEq(left, right);\n    }\n\n    function assertEq(bytes32 left, bytes32 right, string memory err) internal pure virtual {\n        vm.assertEq(left, right, err);\n    }\n\n    function assertEq32(bytes32 left, bytes32 right) internal pure virtual {\n        assertEq(left, right);\n    }\n\n    function assertEq32(bytes32 left, bytes32 right, string memory err) internal pure virtual {\n        assertEq(left, right, err);\n    }\n\n    function assertEq(string memory left, string memory right) internal pure virtual {\n        vm.assertEq(left, right);\n    }\n\n    function assertEq(string memory left, string memory right, string memory err) internal pure virtual {\n        vm.assertEq(left, right, err);\n    }\n\n    function assertEq(bytes memory left, bytes memory right) internal pure virtual {\n        vm.assertEq(left, right);\n    }\n\n    function assertEq(bytes memory left, bytes memory right, string memory err) internal pure virtual {\n        vm.assertEq(left, right, err);\n    }\n\n    function assertEq(bool[] memory left, bool[] memory right) internal pure virtual {\n        vm.assertEq(left, right);\n    }\n\n    function assertEq(bool[] memory left, bool[] memory right, string memory err) internal pure virtual {\n        vm.assertEq(left, right, err);\n    }\n\n    function assertEq(uint256[] memory left, uint256[] memory right) internal pure virtual {\n        vm.assertEq(left, right);\n    }\n\n    function assertEq(uint256[] memory left, uint256[] memory right, string memory err) internal pure virtual {\n        vm.assertEq(left, right, err);\n    }\n\n    function assertEq(int256[] memory left, int256[] memory right) internal pure virtual {\n        vm.assertEq(left, right);\n    }\n\n    function assertEq(int256[] memory left, int256[] memory right, string memory err) internal pure virtual {\n        vm.assertEq(left, right, err);\n    }\n\n    function assertEq(address[] memory left, address[] memory right) internal pure virtual {\n        vm.assertEq(left, right);\n    }\n\n    function assertEq(address[] memory left, address[] memory right, string memory err) internal pure virtual {\n        vm.assertEq(left, right, err);\n    }\n\n    function assertEq(bytes32[] memory left, bytes32[] memory right) internal pure virtual {\n        vm.assertEq(left, right);\n    }\n\n    function assertEq(bytes32[] memory left, bytes32[] memory right, string memory err) internal pure virtual {\n        vm.assertEq(left, right, err);\n    }\n\n    function assertEq(string[] memory left, string[] memory right) internal pure virtual {\n        vm.assertEq(left, right);\n    }\n\n    function assertEq(string[] memory left, string[] memory right, string memory err) internal pure virtual {\n        vm.assertEq(left, right, err);\n    }\n\n    function assertEq(bytes[] memory left, bytes[] memory right) internal pure virtual {\n        vm.assertEq(left, right);\n    }\n\n    function assertEq(bytes[] memory left, bytes[] memory right, string memory err) internal pure virtual {\n        vm.assertEq(left, right, err);\n    }\n\n    // Legacy helper\n    function assertEqUint(uint256 left, uint256 right) internal pure virtual {\n        assertEq(left, right);\n    }\n\n    function assertNotEq(bool left, bool right) internal pure virtual {\n        vm.assertNotEq(left, right);\n    }\n\n    function assertNotEq(bool left, bool right, string memory err) internal pure virtual {\n        vm.assertNotEq(left, right, err);\n    }\n\n    function assertNotEq(uint256 left, uint256 right) internal pure virtual {\n        vm.assertNotEq(left, right);\n    }\n\n    function assertNotEq(uint256 left, uint256 right, string memory err) internal pure virtual {\n        vm.assertNotEq(left, right, err);\n    }\n\n    function assertNotEqDecimal(uint256 left, uint256 right, uint256 decimals) internal pure virtual {\n        vm.assertNotEqDecimal(left, right, decimals);\n    }\n\n    function assertNotEqDecimal(uint256 left, uint256 right, uint256 decimals, string memory err)\n        internal\n        pure\n        virtual\n    {\n        vm.assertNotEqDecimal(left, right, decimals, err);\n    }\n\n    function assertNotEq(int256 left, int256 right) internal pure virtual {\n        vm.assertNotEq(left, right);\n    }\n\n    function assertNotEq(int256 left, int256 right, string memory err) internal pure virtual {\n        vm.assertNotEq(left, right, err);\n    }\n\n    function assertNotEqDecimal(int256 left, int256 right, uint256 decimals) internal pure virtual {\n        vm.assertNotEqDecimal(left, right, decimals);\n    }\n\n    function assertNotEqDecimal(int256 left, int256 right, uint256 decimals, string memory err) internal pure virtual {\n        vm.assertNotEqDecimal(left, right, decimals, err);\n    }\n\n    function assertNotEq(address left, address right) internal pure virtual {\n        vm.assertNotEq(left, right);\n    }\n\n    function assertNotEq(address left, address right, string memory err) internal pure virtual {\n        vm.assertNotEq(left, right, err);\n    }\n\n    function assertNotEq(bytes32 left, bytes32 right) internal pure virtual {\n        vm.assertNotEq(left, right);\n    }\n\n    function assertNotEq(bytes32 left, bytes32 right, string memory err) internal pure virtual {\n        vm.assertNotEq(left, right, err);\n    }\n\n    function assertNotEq32(bytes32 left, bytes32 right) internal pure virtual {\n        assertNotEq(left, right);\n    }\n\n    function assertNotEq32(bytes32 left, bytes32 right, string memory err) internal pure virtual {\n        assertNotEq(left, right, err);\n    }\n\n    function assertNotEq(string memory left, string memory right) internal pure virtual {\n        vm.assertNotEq(left, right);\n    }\n\n    function assertNotEq(string memory left, string memory right, string memory err) internal pure virtual {\n        vm.assertNotEq(left, right, err);\n    }\n\n    function assertNotEq(bytes memory left, bytes memory right) internal pure virtual {\n        vm.assertNotEq(left, right);\n    }\n\n    function assertNotEq(bytes memory left, bytes memory right, string memory err) internal pure virtual {\n        vm.assertNotEq(left, right, err);\n    }\n\n    function assertNotEq(bool[] memory left, bool[] memory right) internal pure virtual {\n        vm.assertNotEq(left, right);\n    }\n\n    function assertNotEq(bool[] memory left, bool[] memory right, string memory err) internal pure virtual {\n        vm.assertNotEq(left, right, err);\n    }\n\n    function assertNotEq(uint256[] memory left, uint256[] memory right) internal pure virtual {\n        vm.assertNotEq(left, right);\n    }\n\n    function assertNotEq(uint256[] memory left, uint256[] memory right, string memory err) internal pure virtual {\n        vm.assertNotEq(left, right, err);\n    }\n\n    function assertNotEq(int256[] memory left, int256[] memory right) internal pure virtual {\n        vm.assertNotEq(left, right);\n    }\n\n    function assertNotEq(int256[] memory left, int256[] memory right, string memory err) internal pure virtual {\n        vm.assertNotEq(left, right, err);\n    }\n\n    function assertNotEq(address[] memory left, address[] memory right) internal pure virtual {\n        vm.assertNotEq(left, right);\n    }\n\n    function assertNotEq(address[] memory left, address[] memory right, string memory err) internal pure virtual {\n        vm.assertNotEq(left, right, err);\n    }\n\n    function assertNotEq(bytes32[] memory left, bytes32[] memory right) internal pure virtual {\n        vm.assertNotEq(left, right);\n    }\n\n    function assertNotEq(bytes32[] memory left, bytes32[] memory right, string memory err) internal pure virtual {\n        vm.assertNotEq(left, right, err);\n    }\n\n    function assertNotEq(string[] memory left, string[] memory right) internal pure virtual {\n        vm.assertNotEq(left, right);\n    }\n\n    function assertNotEq(string[] memory left, string[] memory right, string memory err) internal pure virtual {\n        vm.assertNotEq(left, right, err);\n    }\n\n    function assertNotEq(bytes[] memory left, bytes[] memory right) internal pure virtual {\n        vm.assertNotEq(left, right);\n    }\n\n    function assertNotEq(bytes[] memory left, bytes[] memory right, string memory err) internal pure virtual {\n        vm.assertNotEq(left, right, err);\n    }\n\n    function assertLt(uint256 left, uint256 right) internal pure virtual {\n        vm.assertLt(left, right);\n    }\n\n    function assertLt(uint256 left, uint256 right, string memory err) internal pure virtual {\n        vm.assertLt(left, right, err);\n    }\n\n    function assertLtDecimal(uint256 left, uint256 right, uint256 decimals) internal pure virtual {\n        vm.assertLtDecimal(left, right, decimals);\n    }\n\n    function assertLtDecimal(uint256 left, uint256 right, uint256 decimals, string memory err) internal pure virtual {\n        vm.assertLtDecimal(left, right, decimals, err);\n    }\n\n    function assertLt(int256 left, int256 right) internal pure virtual {\n        vm.assertLt(left, right);\n    }\n\n    function assertLt(int256 left, int256 right, string memory err) internal pure virtual {\n        vm.assertLt(left, right, err);\n    }\n\n    function assertLtDecimal(int256 left, int256 right, uint256 decimals) internal pure virtual {\n        vm.assertLtDecimal(left, right, decimals);\n    }\n\n    function assertLtDecimal(int256 left, int256 right, uint256 decimals, string memory err) internal pure virtual {\n        vm.assertLtDecimal(left, right, decimals, err);\n    }\n\n    function assertGt(uint256 left, uint256 right) internal pure virtual {\n        vm.assertGt(left, right);\n    }\n\n    function assertGt(uint256 left, uint256 right, string memory err) internal pure virtual {\n        vm.assertGt(left, right, err);\n    }\n\n    function assertGtDecimal(uint256 left, uint256 right, uint256 decimals) internal pure virtual {\n        vm.assertGtDecimal(left, right, decimals);\n    }\n\n    function assertGtDecimal(uint256 left, uint256 right, uint256 decimals, string memory err) internal pure virtual {\n        vm.assertGtDecimal(left, right, decimals, err);\n    }\n\n    function assertGt(int256 left, int256 right) internal pure virtual {\n        vm.assertGt(left, right);\n    }\n\n    function assertGt(int256 left, int256 right, string memory err) internal pure virtual {\n        vm.assertGt(left, right, err);\n    }\n\n    function assertGtDecimal(int256 left, int256 right, uint256 decimals) internal pure virtual {\n        vm.assertGtDecimal(left, right, decimals);\n    }\n\n    function assertGtDecimal(int256 left, int256 right, uint256 decimals, string memory err) internal pure virtual {\n        vm.assertGtDecimal(left, right, decimals, err);\n    }\n\n    function assertLe(uint256 left, uint256 right) internal pure virtual {\n        vm.assertLe(left, right);\n    }\n\n    function assertLe(uint256 left, uint256 right, string memory err) internal pure virtual {\n        vm.assertLe(left, right, err);\n    }\n\n    function assertLeDecimal(uint256 left, uint256 right, uint256 decimals) internal pure virtual {\n        vm.assertLeDecimal(left, right, decimals);\n    }\n\n    function assertLeDecimal(uint256 left, uint256 right, uint256 decimals, string memory err) internal pure virtual {\n        vm.assertLeDecimal(left, right, decimals, err);\n    }\n\n    function assertLe(int256 left, int256 right) internal pure virtual {\n        vm.assertLe(left, right);\n    }\n\n    function assertLe(int256 left, int256 right, string memory err) internal pure virtual {\n        vm.assertLe(left, right, err);\n    }\n\n    function assertLeDecimal(int256 left, int256 right, uint256 decimals) internal pure virtual {\n        vm.assertLeDecimal(left, right, decimals);\n    }\n\n    function assertLeDecimal(int256 left, int256 right, uint256 decimals, string memory err) internal pure virtual {\n        vm.assertLeDecimal(left, right, decimals, err);\n    }\n\n    function assertGe(uint256 left, uint256 right) internal pure virtual {\n        vm.assertGe(left, right);\n    }\n\n    function assertGe(uint256 left, uint256 right, string memory err) internal pure virtual {\n        vm.assertGe(left, right, err);\n    }\n\n    function assertGeDecimal(uint256 left, uint256 right, uint256 decimals) internal pure virtual {\n        vm.assertGeDecimal(left, right, decimals);\n    }\n\n    function assertGeDecimal(uint256 left, uint256 right, uint256 decimals, string memory err) internal pure virtual {\n        vm.assertGeDecimal(left, right, decimals, err);\n    }\n\n    function assertGe(int256 left, int256 right) internal pure virtual {\n        vm.assertGe(left, right);\n    }\n\n    function assertGe(int256 left, int256 right, string memory err) internal pure virtual {\n        vm.assertGe(left, right, err);\n    }\n\n    function assertGeDecimal(int256 left, int256 right, uint256 decimals) internal pure virtual {\n        vm.assertGeDecimal(left, right, decimals);\n    }\n\n    function assertGeDecimal(int256 left, int256 right, uint256 decimals, string memory err) internal pure virtual {\n        vm.assertGeDecimal(left, right, decimals, err);\n    }\n\n    function assertApproxEqAbs(uint256 left, uint256 right, uint256 maxDelta) internal pure virtual {\n        vm.assertApproxEqAbs(left, right, maxDelta);\n    }\n\n    function assertApproxEqAbs(uint256 left, uint256 right, uint256 maxDelta, string memory err)\n        internal\n        pure\n        virtual\n    {\n        vm.assertApproxEqAbs(left, right, maxDelta, err);\n    }\n\n    function assertApproxEqAbsDecimal(uint256 left, uint256 right, uint256 maxDelta, uint256 decimals)\n        internal\n        pure\n        virtual\n    {\n        vm.assertApproxEqAbsDecimal(left, right, maxDelta, decimals);\n    }\n\n    function assertApproxEqAbsDecimal(\n        uint256 left,\n        uint256 right,\n        uint256 maxDelta,\n        uint256 decimals,\n        string memory err\n    ) internal pure virtual {\n        vm.assertApproxEqAbsDecimal(left, right, maxDelta, decimals, err);\n    }\n\n    function assertApproxEqAbs(int256 left, int256 right, uint256 maxDelta) internal pure virtual {\n        vm.assertApproxEqAbs(left, right, maxDelta);\n    }\n\n    function assertApproxEqAbs(int256 left, int256 right, uint256 maxDelta, string memory err) internal pure virtual {\n        vm.assertApproxEqAbs(left, right, maxDelta, err);\n    }\n\n    function assertApproxEqAbsDecimal(int256 left, int256 right, uint256 maxDelta, uint256 decimals)\n        internal\n        pure\n        virtual\n    {\n        vm.assertApproxEqAbsDecimal(left, right, maxDelta, decimals);\n    }\n\n    function assertApproxEqAbsDecimal(int256 left, int256 right, uint256 maxDelta, uint256 decimals, string memory err)\n        internal\n        pure\n        virtual\n    {\n        vm.assertApproxEqAbsDecimal(left, right, maxDelta, decimals, err);\n    }\n\n    function assertApproxEqRel(\n        uint256 left,\n        uint256 right,\n        uint256 maxPercentDelta // An 18 decimal fixed point number, where 1e18 == 100%\n    ) internal pure virtual {\n        vm.assertApproxEqRel(left, right, maxPercentDelta);\n    }\n\n    function assertApproxEqRel(\n        uint256 left,\n        uint256 right,\n        uint256 maxPercentDelta, // An 18 decimal fixed point number, where 1e18 == 100%\n        string memory err\n    ) internal pure virtual {\n        vm.assertApproxEqRel(left, right, maxPercentDelta, err);\n    }\n\n    function assertApproxEqRelDecimal(\n        uint256 left,\n        uint256 right,\n        uint256 maxPercentDelta, // An 18 decimal fixed point number, where 1e18 == 100%\n        uint256 decimals\n    ) internal pure virtual {\n        vm.assertApproxEqRelDecimal(left, right, maxPercentDelta, decimals);\n    }\n\n    function assertApproxEqRelDecimal(\n        uint256 left,\n        uint256 right,\n        uint256 maxPercentDelta, // An 18 decimal fixed point number, where 1e18 == 100%\n        uint256 decimals,\n        string memory err\n    ) internal pure virtual {\n        vm.assertApproxEqRelDecimal(left, right, maxPercentDelta, decimals, err);\n    }\n\n    function assertApproxEqRel(int256 left, int256 right, uint256 maxPercentDelta) internal pure virtual {\n        vm.assertApproxEqRel(left, right, maxPercentDelta);\n    }\n\n    function assertApproxEqRel(\n        int256 left,\n        int256 right,\n        uint256 maxPercentDelta, // An 18 decimal fixed point number, where 1e18 == 100%\n        string memory err\n    ) internal pure virtual {\n        vm.assertApproxEqRel(left, right, maxPercentDelta, err);\n    }\n\n    function assertApproxEqRelDecimal(\n        int256 left,\n        int256 right,\n        uint256 maxPercentDelta, // An 18 decimal fixed point number, where 1e18 == 100%\n        uint256 decimals\n    ) internal pure virtual {\n        vm.assertApproxEqRelDecimal(left, right, maxPercentDelta, decimals);\n    }\n\n    function assertApproxEqRelDecimal(\n        int256 left,\n        int256 right,\n        uint256 maxPercentDelta, // An 18 decimal fixed point number, where 1e18 == 100%\n        uint256 decimals,\n        string memory err\n    ) internal pure virtual {\n        vm.assertApproxEqRelDecimal(left, right, maxPercentDelta, decimals, err);\n    }\n\n    // Inherited from DSTest, not used but kept for backwards-compatibility\n    function checkEq0(bytes memory left, bytes memory right) internal pure returns (bool) {\n        return keccak256(left) == keccak256(right);\n    }\n\n    function assertEq0(bytes memory left, bytes memory right) internal pure virtual {\n        assertEq(left, right);\n    }\n\n    function assertEq0(bytes memory left, bytes memory right, string memory err) internal pure virtual {\n        assertEq(left, right, err);\n    }\n\n    function assertNotEq0(bytes memory left, bytes memory right) internal pure virtual {\n        assertNotEq(left, right);\n    }\n\n    function assertNotEq0(bytes memory left, bytes memory right, string memory err) internal pure virtual {\n        assertNotEq(left, right, err);\n    }\n\n    function assertEqCall(address target, bytes memory callDataA, bytes memory callDataB) internal virtual {\n        assertEqCall(target, callDataA, target, callDataB, true);\n    }\n\n    function assertEqCall(address targetA, bytes memory callDataA, address targetB, bytes memory callDataB)\n        internal\n        virtual\n    {\n        assertEqCall(targetA, callDataA, targetB, callDataB, true);\n    }\n\n    function assertEqCall(address target, bytes memory callDataA, bytes memory callDataB, bool strictRevertData)\n        internal\n        virtual\n    {\n        assertEqCall(target, callDataA, target, callDataB, strictRevertData);\n    }\n\n    function assertEqCall(\n        address targetA,\n        bytes memory callDataA,\n        address targetB,\n        bytes memory callDataB,\n        bool strictRevertData\n    ) internal virtual {\n        (bool successA, bytes memory returnDataA) = address(targetA).call(callDataA);\n        (bool successB, bytes memory returnDataB) = address(targetB).call(callDataB);\n\n        if (successA && successB) {\n            assertEq(returnDataA, returnDataB, \"Call return data does not match\");\n        }\n\n        if (!successA && !successB && strictRevertData) {\n            assertEq(returnDataA, returnDataB, \"Call revert data does not match\");\n        }\n\n        if (!successA && successB) {\n            emit log(\"Error: Calls were not equal\");\n            emit log_named_bytes(\"  Left call revert data\", returnDataA);\n            emit log_named_bytes(\" Right call return data\", returnDataB);\n            revert(\"assertion failed\");\n        }\n\n        if (successA && !successB) {\n            emit log(\"Error: Calls were not equal\");\n            emit log_named_bytes(\"  Left call return data\", returnDataA);\n            emit log_named_bytes(\" Right call revert data\", returnDataB);\n            revert(\"assertion failed\");\n        }\n    }\n}\n"},"lib/forge-std/src/StdChains.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity >=0.6.2 <0.9.0;\n\nimport {VmSafe} from \"./Vm.sol\";\n\n/**\n * StdChains provides information about EVM compatible chains that can be used in scripts/tests.\n * For each chain, the chain's name, chain ID, and a default RPC URL are provided. Chains are\n * identified by their alias, which is the same as the alias in the `[rpc_endpoints]` section of\n * the `foundry.toml` file. For best UX, ensure the alias in the `foundry.toml` file match the\n * alias used in this contract, which can be found as the first argument to the\n * `setChainWithDefaultRpcUrl` call in the `initializeStdChains` function.\n *\n * There are two main ways to use this contract:\n *   1. Set a chain with `setChain(string memory chainAlias, ChainData memory chain)` or\n *      `setChain(string memory chainAlias, Chain memory chain)`\n *   2. Get a chain with `getChain(string memory chainAlias)` or `getChain(uint256 chainId)`.\n *\n * The first time either of those are used, chains are initialized with the default set of RPC URLs.\n * This is done in `initializeStdChains`, which uses `setChainWithDefaultRpcUrl`. Defaults are recorded in\n * `defaultRpcUrls`.\n *\n * The `setChain` function is straightforward, and it simply saves off the given chain data.\n *\n * The `getChain` methods use `getChainWithUpdatedRpcUrl` to return a chain. For example, let's say\n * we want to retrieve the RPC URL for `mainnet`:\n *   - If you have specified data with `setChain`, it will return that.\n *   - If you have configured a mainnet RPC URL in `foundry.toml`, it will return the URL, provided it\n *     is valid (e.g. a URL is specified, or an environment variable is given and exists).\n *   - If neither of the above conditions is met, the default data is returned.\n *\n * Summarizing the above, the prioritization hierarchy is `setChain` -> `foundry.toml` -> environment variable -> defaults.\n */\nabstract contract StdChains {\n    VmSafe private constant vm = VmSafe(address(uint160(uint256(keccak256(\"hevm cheat code\")))));\n\n    bool private stdChainsInitialized;\n\n    struct ChainData {\n        string name;\n        uint256 chainId;\n        string rpcUrl;\n    }\n\n    struct Chain {\n        // The chain name.\n        string name;\n        // The chain's Chain ID.\n        uint256 chainId;\n        // The chain's alias. (i.e. what gets specified in `foundry.toml`).\n        string chainAlias;\n        // A default RPC endpoint for this chain.\n        // NOTE: This default RPC URL is included for convenience to facilitate quick tests and\n        // experimentation. Do not use this RPC URL for production test suites, CI, or other heavy\n        // usage as you will be throttled and this is a disservice to others who need this endpoint.\n        string rpcUrl;\n    }\n\n    // Maps from the chain's alias (matching the alias in the `foundry.toml` file) to chain data.\n    mapping(string => Chain) private chains;\n    // Maps from the chain's alias to it's default RPC URL.\n    mapping(string => string) private defaultRpcUrls;\n    // Maps from a chain ID to it's alias.\n    mapping(uint256 => string) private idToAlias;\n\n    bool private fallbackToDefaultRpcUrls = true;\n\n    // The RPC URL will be fetched from config or defaultRpcUrls if possible.\n    function getChain(string memory chainAlias) internal virtual returns (Chain memory chain) {\n        require(bytes(chainAlias).length != 0, \"StdChains getChain(string): Chain alias cannot be the empty string.\");\n\n        initializeStdChains();\n        chain = chains[chainAlias];\n        require(\n            chain.chainId != 0,\n            string(abi.encodePacked(\"StdChains getChain(string): Chain with alias \\\"\", chainAlias, \"\\\" not found.\"))\n        );\n\n        chain = getChainWithUpdatedRpcUrl(chainAlias, chain);\n    }\n\n    function getChain(uint256 chainId) internal virtual returns (Chain memory chain) {\n        require(chainId != 0, \"StdChains getChain(uint256): Chain ID cannot be 0.\");\n        initializeStdChains();\n        string memory chainAlias = idToAlias[chainId];\n\n        chain = chains[chainAlias];\n\n        require(\n            chain.chainId != 0,\n            string(abi.encodePacked(\"StdChains getChain(uint256): Chain with ID \", vm.toString(chainId), \" not found.\"))\n        );\n\n        chain = getChainWithUpdatedRpcUrl(chainAlias, chain);\n    }\n\n    // set chain info, with priority to argument's rpcUrl field.\n    function setChain(string memory chainAlias, ChainData memory chain) internal virtual {\n        require(\n            bytes(chainAlias).length != 0,\n            \"StdChains setChain(string,ChainData): Chain alias cannot be the empty string.\"\n        );\n\n        require(chain.chainId != 0, \"StdChains setChain(string,ChainData): Chain ID cannot be 0.\");\n\n        initializeStdChains();\n        string memory foundAlias = idToAlias[chain.chainId];\n\n        require(\n            bytes(foundAlias).length == 0 || keccak256(bytes(foundAlias)) == keccak256(bytes(chainAlias)),\n            string(\n                abi.encodePacked(\n                    \"StdChains setChain(string,ChainData): Chain ID \",\n                    vm.toString(chain.chainId),\n                    \" already used by \\\"\",\n                    foundAlias,\n                    \"\\\".\"\n                )\n            )\n        );\n\n        uint256 oldChainId = chains[chainAlias].chainId;\n        delete idToAlias[oldChainId];\n\n        chains[chainAlias] =\n            Chain({name: chain.name, chainId: chain.chainId, chainAlias: chainAlias, rpcUrl: chain.rpcUrl});\n        idToAlias[chain.chainId] = chainAlias;\n    }\n\n    // set chain info, with priority to argument's rpcUrl field.\n    function setChain(string memory chainAlias, Chain memory chain) internal virtual {\n        setChain(chainAlias, ChainData({name: chain.name, chainId: chain.chainId, rpcUrl: chain.rpcUrl}));\n    }\n\n    function _toUpper(string memory str) private pure returns (string memory) {\n        bytes memory strb = bytes(str);\n        bytes memory copy = new bytes(strb.length);\n        for (uint256 i = 0; i < strb.length; i++) {\n            bytes1 b = strb[i];\n            if (b >= 0x61 && b <= 0x7A) {\n                copy[i] = bytes1(uint8(b) - 32);\n            } else {\n                copy[i] = b;\n            }\n        }\n        return string(copy);\n    }\n\n    // lookup rpcUrl, in descending order of priority:\n    // current -> config (foundry.toml) -> environment variable -> default\n    function getChainWithUpdatedRpcUrl(string memory chainAlias, Chain memory chain)\n        private\n        view\n        returns (Chain memory)\n    {\n        if (bytes(chain.rpcUrl).length == 0) {\n            try vm.rpcUrl(chainAlias) returns (string memory configRpcUrl) {\n                chain.rpcUrl = configRpcUrl;\n            } catch (bytes memory err) {\n                string memory envName = string(abi.encodePacked(_toUpper(chainAlias), \"_RPC_URL\"));\n                if (fallbackToDefaultRpcUrls) {\n                    chain.rpcUrl = vm.envOr(envName, defaultRpcUrls[chainAlias]);\n                } else {\n                    chain.rpcUrl = vm.envString(envName);\n                }\n                // Distinguish 'not found' from 'cannot read'\n                // The upstream error thrown by forge for failing cheats changed so we check both the old and new versions\n                bytes memory oldNotFoundError =\n                    abi.encodeWithSignature(\"CheatCodeError\", string(abi.encodePacked(\"invalid rpc url \", chainAlias)));\n                bytes memory newNotFoundError = abi.encodeWithSignature(\n                    \"CheatcodeError(string)\", string(abi.encodePacked(\"invalid rpc url: \", chainAlias))\n                );\n                bytes32 errHash = keccak256(err);\n                if (\n                    (errHash != keccak256(oldNotFoundError) && errHash != keccak256(newNotFoundError))\n                        || bytes(chain.rpcUrl).length == 0\n                ) {\n                    /// @solidity memory-safe-assembly\n                    assembly {\n                        revert(add(32, err), mload(err))\n                    }\n                }\n            }\n        }\n        return chain;\n    }\n\n    function setFallbackToDefaultRpcUrls(bool useDefault) internal {\n        fallbackToDefaultRpcUrls = useDefault;\n    }\n\n    function initializeStdChains() private {\n        if (stdChainsInitialized) return;\n\n        stdChainsInitialized = true;\n\n        // If adding an RPC here, make sure to test the default RPC URL in `test_Rpcs` in `StdChains.t.sol`\n        setChainWithDefaultRpcUrl(\"anvil\", ChainData(\"Anvil\", 31337, \"http://127.0.0.1:8545\"));\n        setChainWithDefaultRpcUrl(\n            \"mainnet\", ChainData(\"Mainnet\", 1, \"https://eth-mainnet.alchemyapi.io/v2/pwc5rmJhrdoaSEfimoKEmsvOjKSmPDrP\")\n        );\n        setChainWithDefaultRpcUrl(\n            \"sepolia\", ChainData(\"Sepolia\", 11155111, \"https://sepolia.infura.io/v3/b9794ad1ddf84dfb8c34d6bb5dca2001\")\n        );\n        setChainWithDefaultRpcUrl(\"holesky\", ChainData(\"Holesky\", 17000, \"https://rpc.holesky.ethpandaops.io\"));\n        setChainWithDefaultRpcUrl(\"optimism\", ChainData(\"Optimism\", 10, \"https://mainnet.optimism.io\"));\n        setChainWithDefaultRpcUrl(\n            \"optimism_sepolia\", ChainData(\"Optimism Sepolia\", 11155420, \"https://sepolia.optimism.io\")\n        );\n        setChainWithDefaultRpcUrl(\"arbitrum_one\", ChainData(\"Arbitrum One\", 42161, \"https://arb1.arbitrum.io/rpc\"));\n        setChainWithDefaultRpcUrl(\n            \"arbitrum_one_sepolia\", ChainData(\"Arbitrum One Sepolia\", 421614, \"https://sepolia-rollup.arbitrum.io/rpc\")\n        );\n        setChainWithDefaultRpcUrl(\"arbitrum_nova\", ChainData(\"Arbitrum Nova\", 42170, \"https://nova.arbitrum.io/rpc\"));\n        setChainWithDefaultRpcUrl(\"polygon\", ChainData(\"Polygon\", 137, \"https://polygon-rpc.com\"));\n        setChainWithDefaultRpcUrl(\n            \"polygon_amoy\", ChainData(\"Polygon Amoy\", 80002, \"https://rpc-amoy.polygon.technology\")\n        );\n        setChainWithDefaultRpcUrl(\"avalanche\", ChainData(\"Avalanche\", 43114, \"https://api.avax.network/ext/bc/C/rpc\"));\n        setChainWithDefaultRpcUrl(\n            \"avalanche_fuji\", ChainData(\"Avalanche Fuji\", 43113, \"https://api.avax-test.network/ext/bc/C/rpc\")\n        );\n        setChainWithDefaultRpcUrl(\n            \"bnb_smart_chain\", ChainData(\"BNB Smart Chain\", 56, \"https://bsc-dataseed1.binance.org\")\n        );\n        setChainWithDefaultRpcUrl(\n            \"bnb_smart_chain_testnet\",\n            ChainData(\"BNB Smart Chain Testnet\", 97, \"https://rpc.ankr.com/bsc_testnet_chapel\")\n        );\n        setChainWithDefaultRpcUrl(\"gnosis_chain\", ChainData(\"Gnosis Chain\", 100, \"https://rpc.gnosischain.com\"));\n        setChainWithDefaultRpcUrl(\"moonbeam\", ChainData(\"Moonbeam\", 1284, \"https://rpc.api.moonbeam.network\"));\n        setChainWithDefaultRpcUrl(\n            \"moonriver\", ChainData(\"Moonriver\", 1285, \"https://rpc.api.moonriver.moonbeam.network\")\n        );\n        setChainWithDefaultRpcUrl(\"moonbase\", ChainData(\"Moonbase\", 1287, \"https://rpc.testnet.moonbeam.network\"));\n        setChainWithDefaultRpcUrl(\"base_sepolia\", ChainData(\"Base Sepolia\", 84532, \"https://sepolia.base.org\"));\n        setChainWithDefaultRpcUrl(\"base\", ChainData(\"Base\", 8453, \"https://mainnet.base.org\"));\n        setChainWithDefaultRpcUrl(\"blast_sepolia\", ChainData(\"Blast Sepolia\", 168587773, \"https://sepolia.blast.io\"));\n        setChainWithDefaultRpcUrl(\"blast\", ChainData(\"Blast\", 81457, \"https://rpc.blast.io\"));\n        setChainWithDefaultRpcUrl(\"fantom_opera\", ChainData(\"Fantom Opera\", 250, \"https://rpc.ankr.com/fantom/\"));\n        setChainWithDefaultRpcUrl(\n            \"fantom_opera_testnet\", ChainData(\"Fantom Opera Testnet\", 4002, \"https://rpc.ankr.com/fantom_testnet/\")\n        );\n        setChainWithDefaultRpcUrl(\"fraxtal\", ChainData(\"Fraxtal\", 252, \"https://rpc.frax.com\"));\n        setChainWithDefaultRpcUrl(\"fraxtal_testnet\", ChainData(\"Fraxtal Testnet\", 2522, \"https://rpc.testnet.frax.com\"));\n        setChainWithDefaultRpcUrl(\n            \"berachain_bartio_testnet\", ChainData(\"Berachain bArtio Testnet\", 80084, \"https://bartio.rpc.berachain.com\")\n        );\n        setChainWithDefaultRpcUrl(\"flare\", ChainData(\"Flare\", 14, \"https://flare-api.flare.network/ext/C/rpc\"));\n        setChainWithDefaultRpcUrl(\n            \"flare_coston2\", ChainData(\"Flare Coston2\", 114, \"https://coston2-api.flare.network/ext/C/rpc\")\n        );\n\n        setChainWithDefaultRpcUrl(\"mode\", ChainData(\"Mode\", 34443, \"https://mode.drpc.org\"));\n        setChainWithDefaultRpcUrl(\"mode_sepolia\", ChainData(\"Mode Sepolia\", 919, \"https://sepolia.mode.network\"));\n\n        setChainWithDefaultRpcUrl(\"zora\", ChainData(\"Zora\", 7777777, \"https://zora.drpc.org\"));\n        setChainWithDefaultRpcUrl(\n            \"zora_sepolia\", ChainData(\"Zora Sepolia\", 999999999, \"https://sepolia.rpc.zora.energy\")\n        );\n\n        setChainWithDefaultRpcUrl(\"race\", ChainData(\"Race\", 6805, \"https://racemainnet.io\"));\n        setChainWithDefaultRpcUrl(\"race_sepolia\", ChainData(\"Race Sepolia\", 6806, \"https://racemainnet.io\"));\n\n        setChainWithDefaultRpcUrl(\"metal\", ChainData(\"Metal\", 1750, \"https://metall2.drpc.org\"));\n        setChainWithDefaultRpcUrl(\"metal_sepolia\", ChainData(\"Metal Sepolia\", 1740, \"https://testnet.rpc.metall2.com\"));\n\n        setChainWithDefaultRpcUrl(\"binary\", ChainData(\"Binary\", 624, \"https://rpc.zero.thebinaryholdings.com\"));\n        setChainWithDefaultRpcUrl(\n            \"binary_sepolia\", ChainData(\"Binary Sepolia\", 625, \"https://rpc.zero.thebinaryholdings.com\")\n        );\n\n        setChainWithDefaultRpcUrl(\"orderly\", ChainData(\"Orderly\", 291, \"https://rpc.orderly.network\"));\n        setChainWithDefaultRpcUrl(\n            \"orderly_sepolia\", ChainData(\"Orderly Sepolia\", 4460, \"https://testnet-rpc.orderly.org\")\n        );\n    }\n\n    // set chain info, with priority to chainAlias' rpc url in foundry.toml\n    function setChainWithDefaultRpcUrl(string memory chainAlias, ChainData memory chain) private {\n        string memory rpcUrl = chain.rpcUrl;\n        defaultRpcUrls[chainAlias] = rpcUrl;\n        chain.rpcUrl = \"\";\n        setChain(chainAlias, chain);\n        chain.rpcUrl = rpcUrl; // restore argument\n    }\n}\n"},"lib/forge-std/src/StdCheats.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity >=0.6.2 <0.9.0;\n\npragma experimental ABIEncoderV2;\n\nimport {StdStorage, stdStorage} from \"./StdStorage.sol\";\nimport {console2} from \"./console2.sol\";\nimport {Vm} from \"./Vm.sol\";\n\nabstract contract StdCheatsSafe {\n    Vm private constant vm = Vm(address(uint160(uint256(keccak256(\"hevm cheat code\")))));\n\n    uint256 private constant UINT256_MAX =\n        115792089237316195423570985008687907853269984665640564039457584007913129639935;\n\n    bool private gasMeteringOff;\n\n    // Data structures to parse Transaction objects from the broadcast artifact\n    // that conform to EIP1559. The Raw structs is what is parsed from the JSON\n    // and then converted to the one that is used by the user for better UX.\n\n    struct RawTx1559 {\n        string[] arguments;\n        address contractAddress;\n        string contractName;\n        // json value name = function\n        string functionSig;\n        bytes32 hash;\n        // json value name = tx\n        RawTx1559Detail txDetail;\n        // json value name = type\n        string opcode;\n    }\n\n    struct RawTx1559Detail {\n        AccessList[] accessList;\n        bytes data;\n        address from;\n        bytes gas;\n        bytes nonce;\n        address to;\n        bytes txType;\n        bytes value;\n    }\n\n    struct Tx1559 {\n        string[] arguments;\n        address contractAddress;\n        string contractName;\n        string functionSig;\n        bytes32 hash;\n        Tx1559Detail txDetail;\n        string opcode;\n    }\n\n    struct Tx1559Detail {\n        AccessList[] accessList;\n        bytes data;\n        address from;\n        uint256 gas;\n        uint256 nonce;\n        address to;\n        uint256 txType;\n        uint256 value;\n    }\n\n    // Data structures to parse Transaction objects from the broadcast artifact\n    // that DO NOT conform to EIP1559. The Raw structs is what is parsed from the JSON\n    // and then converted to the one that is used by the user for better UX.\n\n    struct TxLegacy {\n        string[] arguments;\n        address contractAddress;\n        string contractName;\n        string functionSig;\n        string hash;\n        string opcode;\n        TxDetailLegacy transaction;\n    }\n\n    struct TxDetailLegacy {\n        AccessList[] accessList;\n        uint256 chainId;\n        bytes data;\n        address from;\n        uint256 gas;\n        uint256 gasPrice;\n        bytes32 hash;\n        uint256 nonce;\n        bytes1 opcode;\n        bytes32 r;\n        bytes32 s;\n        uint256 txType;\n        address to;\n        uint8 v;\n        uint256 value;\n    }\n\n    struct AccessList {\n        address accessAddress;\n        bytes32[] storageKeys;\n    }\n\n    // Data structures to parse Receipt objects from the broadcast artifact.\n    // The Raw structs is what is parsed from the JSON\n    // and then converted to the one that is used by the user for better UX.\n\n    struct RawReceipt {\n        bytes32 blockHash;\n        bytes blockNumber;\n        address contractAddress;\n        bytes cumulativeGasUsed;\n        bytes effectiveGasPrice;\n        address from;\n        bytes gasUsed;\n        RawReceiptLog[] logs;\n        bytes logsBloom;\n        bytes status;\n        address to;\n        bytes32 transactionHash;\n        bytes transactionIndex;\n    }\n\n    struct Receipt {\n        bytes32 blockHash;\n        uint256 blockNumber;\n        address contractAddress;\n        uint256 cumulativeGasUsed;\n        uint256 effectiveGasPrice;\n        address from;\n        uint256 gasUsed;\n        ReceiptLog[] logs;\n        bytes logsBloom;\n        uint256 status;\n        address to;\n        bytes32 transactionHash;\n        uint256 transactionIndex;\n    }\n\n    // Data structures to parse the entire broadcast artifact, assuming the\n    // transactions conform to EIP1559.\n\n    struct EIP1559ScriptArtifact {\n        string[] libraries;\n        string path;\n        string[] pending;\n        Receipt[] receipts;\n        uint256 timestamp;\n        Tx1559[] transactions;\n        TxReturn[] txReturns;\n    }\n\n    struct RawEIP1559ScriptArtifact {\n        string[] libraries;\n        string path;\n        string[] pending;\n        RawReceipt[] receipts;\n        TxReturn[] txReturns;\n        uint256 timestamp;\n        RawTx1559[] transactions;\n    }\n\n    struct RawReceiptLog {\n        // json value = address\n        address logAddress;\n        bytes32 blockHash;\n        bytes blockNumber;\n        bytes data;\n        bytes logIndex;\n        bool removed;\n        bytes32[] topics;\n        bytes32 transactionHash;\n        bytes transactionIndex;\n        bytes transactionLogIndex;\n    }\n\n    struct ReceiptLog {\n        // json value = address\n        address logAddress;\n        bytes32 blockHash;\n        uint256 blockNumber;\n        bytes data;\n        uint256 logIndex;\n        bytes32[] topics;\n        uint256 transactionIndex;\n        uint256 transactionLogIndex;\n        bool removed;\n    }\n\n    struct TxReturn {\n        string internalType;\n        string value;\n    }\n\n    struct Account {\n        address addr;\n        uint256 key;\n    }\n\n    enum AddressType {\n        Payable,\n        NonPayable,\n        ZeroAddress,\n        Precompile,\n        ForgeAddress\n    }\n\n    // Checks that `addr` is not blacklisted by token contracts that have a blacklist.\n    function assumeNotBlacklisted(address token, address addr) internal view virtual {\n        // Nothing to check if `token` is not a contract.\n        uint256 tokenCodeSize;\n        assembly {\n            tokenCodeSize := extcodesize(token)\n        }\n        require(tokenCodeSize > 0, \"StdCheats assumeNotBlacklisted(address,address): Token address is not a contract.\");\n\n        bool success;\n        bytes memory returnData;\n\n        // 4-byte selector for `isBlacklisted(address)`, used by USDC.\n        (success, returnData) = token.staticcall(abi.encodeWithSelector(0xfe575a87, addr));\n        vm.assume(!success || abi.decode(returnData, (bool)) == false);\n\n        // 4-byte selector for `isBlackListed(address)`, used by USDT.\n        (success, returnData) = token.staticcall(abi.encodeWithSelector(0xe47d6060, addr));\n        vm.assume(!success || abi.decode(returnData, (bool)) == false);\n    }\n\n    // Checks that `addr` is not blacklisted by token contracts that have a blacklist.\n    // This is identical to `assumeNotBlacklisted(address,address)` but with a different name, for\n    // backwards compatibility, since this name was used in the original PR which already has\n    // a release. This function can be removed in a future release once we want a breaking change.\n    function assumeNoBlacklisted(address token, address addr) internal view virtual {\n        assumeNotBlacklisted(token, addr);\n    }\n\n    function assumeAddressIsNot(address addr, AddressType addressType) internal virtual {\n        if (addressType == AddressType.Payable) {\n            assumeNotPayable(addr);\n        } else if (addressType == AddressType.NonPayable) {\n            assumePayable(addr);\n        } else if (addressType == AddressType.ZeroAddress) {\n            assumeNotZeroAddress(addr);\n        } else if (addressType == AddressType.Precompile) {\n            assumeNotPrecompile(addr);\n        } else if (addressType == AddressType.ForgeAddress) {\n            assumeNotForgeAddress(addr);\n        }\n    }\n\n    function assumeAddressIsNot(address addr, AddressType addressType1, AddressType addressType2) internal virtual {\n        assumeAddressIsNot(addr, addressType1);\n        assumeAddressIsNot(addr, addressType2);\n    }\n\n    function assumeAddressIsNot(\n        address addr,\n        AddressType addressType1,\n        AddressType addressType2,\n        AddressType addressType3\n    ) internal virtual {\n        assumeAddressIsNot(addr, addressType1);\n        assumeAddressIsNot(addr, addressType2);\n        assumeAddressIsNot(addr, addressType3);\n    }\n\n    function assumeAddressIsNot(\n        address addr,\n        AddressType addressType1,\n        AddressType addressType2,\n        AddressType addressType3,\n        AddressType addressType4\n    ) internal virtual {\n        assumeAddressIsNot(addr, addressType1);\n        assumeAddressIsNot(addr, addressType2);\n        assumeAddressIsNot(addr, addressType3);\n        assumeAddressIsNot(addr, addressType4);\n    }\n\n    // This function checks whether an address, `addr`, is payable. It works by sending 1 wei to\n    // `addr` and checking the `success` return value.\n    // NOTE: This function may result in state changes depending on the fallback/receive logic\n    // implemented by `addr`, which should be taken into account when this function is used.\n    function _isPayable(address addr) private returns (bool) {\n        require(\n            addr.balance < UINT256_MAX,\n            \"StdCheats _isPayable(address): Balance equals max uint256, so it cannot receive any more funds\"\n        );\n        uint256 origBalanceTest = address(this).balance;\n        uint256 origBalanceAddr = address(addr).balance;\n\n        vm.deal(address(this), 1);\n        (bool success,) = payable(addr).call{value: 1}(\"\");\n\n        // reset balances\n        vm.deal(address(this), origBalanceTest);\n        vm.deal(addr, origBalanceAddr);\n\n        return success;\n    }\n\n    // NOTE: This function may result in state changes depending on the fallback/receive logic\n    // implemented by `addr`, which should be taken into account when this function is used. See the\n    // `_isPayable` method for more information.\n    function assumePayable(address addr) internal virtual {\n        vm.assume(_isPayable(addr));\n    }\n\n    function assumeNotPayable(address addr) internal virtual {\n        vm.assume(!_isPayable(addr));\n    }\n\n    function assumeNotZeroAddress(address addr) internal pure virtual {\n        vm.assume(addr != address(0));\n    }\n\n    function assumeNotPrecompile(address addr) internal pure virtual {\n        assumeNotPrecompile(addr, _pureChainId());\n    }\n\n    function assumeNotPrecompile(address addr, uint256 chainId) internal pure virtual {\n        // Note: For some chains like Optimism these are technically predeploys (i.e. bytecode placed at a specific\n        // address), but the same rationale for excluding them applies so we include those too.\n\n        // These are reserved by Ethereum and may be on all EVM-compatible chains.\n        vm.assume(addr < address(0x1) || addr > address(0xff));\n\n        // forgefmt: disable-start\n        if (chainId == 10 || chainId == 420) {\n            // https://github.com/ethereum-optimism/optimism/blob/eaa371a0184b56b7ca6d9eb9cb0a2b78b2ccd864/op-bindings/predeploys/addresses.go#L6-L21\n            vm.assume(addr < address(0x4200000000000000000000000000000000000000) || addr > address(0x4200000000000000000000000000000000000800));\n        } else if (chainId == 42161 || chainId == 421613) {\n            // https://developer.arbitrum.io/useful-addresses#arbitrum-precompiles-l2-same-on-all-arb-chains\n            vm.assume(addr < address(0x0000000000000000000000000000000000000064) || addr > address(0x0000000000000000000000000000000000000068));\n        } else if (chainId == 43114 || chainId == 43113) {\n            // https://github.com/ava-labs/subnet-evm/blob/47c03fd007ecaa6de2c52ea081596e0a88401f58/precompile/params.go#L18-L59\n            vm.assume(addr < address(0x0100000000000000000000000000000000000000) || addr > address(0x01000000000000000000000000000000000000ff));\n            vm.assume(addr < address(0x0200000000000000000000000000000000000000) || addr > address(0x02000000000000000000000000000000000000FF));\n            vm.assume(addr < address(0x0300000000000000000000000000000000000000) || addr > address(0x03000000000000000000000000000000000000Ff));\n        }\n        // forgefmt: disable-end\n    }\n\n    function assumeNotForgeAddress(address addr) internal pure virtual {\n        // vm, console, and Create2Deployer addresses\n        vm.assume(\n            addr != address(vm) && addr != 0x000000000000000000636F6e736F6c652e6c6f67\n                && addr != 0x4e59b44847b379578588920cA78FbF26c0B4956C\n        );\n    }\n\n    function assumeUnusedAddress(address addr) internal view virtual {\n        uint256 size;\n        assembly {\n            size := extcodesize(addr)\n        }\n        vm.assume(size == 0);\n\n        assumeNotPrecompile(addr);\n        assumeNotZeroAddress(addr);\n        assumeNotForgeAddress(addr);\n    }\n\n    function readEIP1559ScriptArtifact(string memory path)\n        internal\n        view\n        virtual\n        returns (EIP1559ScriptArtifact memory)\n    {\n        string memory data = vm.readFile(path);\n        bytes memory parsedData = vm.parseJson(data);\n        RawEIP1559ScriptArtifact memory rawArtifact = abi.decode(parsedData, (RawEIP1559ScriptArtifact));\n        EIP1559ScriptArtifact memory artifact;\n        artifact.libraries = rawArtifact.libraries;\n        artifact.path = rawArtifact.path;\n        artifact.timestamp = rawArtifact.timestamp;\n        artifact.pending = rawArtifact.pending;\n        artifact.txReturns = rawArtifact.txReturns;\n        artifact.receipts = rawToConvertedReceipts(rawArtifact.receipts);\n        artifact.transactions = rawToConvertedEIPTx1559s(rawArtifact.transactions);\n        return artifact;\n    }\n\n    function rawToConvertedEIPTx1559s(RawTx1559[] memory rawTxs) internal pure virtual returns (Tx1559[] memory) {\n        Tx1559[] memory txs = new Tx1559[](rawTxs.length);\n        for (uint256 i; i < rawTxs.length; i++) {\n            txs[i] = rawToConvertedEIPTx1559(rawTxs[i]);\n        }\n        return txs;\n    }\n\n    function rawToConvertedEIPTx1559(RawTx1559 memory rawTx) internal pure virtual returns (Tx1559 memory) {\n        Tx1559 memory transaction;\n        transaction.arguments = rawTx.arguments;\n        transaction.contractName = rawTx.contractName;\n        transaction.functionSig = rawTx.functionSig;\n        transaction.hash = rawTx.hash;\n        transaction.txDetail = rawToConvertedEIP1559Detail(rawTx.txDetail);\n        transaction.opcode = rawTx.opcode;\n        return transaction;\n    }\n\n    function rawToConvertedEIP1559Detail(RawTx1559Detail memory rawDetail)\n        internal\n        pure\n        virtual\n        returns (Tx1559Detail memory)\n    {\n        Tx1559Detail memory txDetail;\n        txDetail.data = rawDetail.data;\n        txDetail.from = rawDetail.from;\n        txDetail.to = rawDetail.to;\n        txDetail.nonce = _bytesToUint(rawDetail.nonce);\n        txDetail.txType = _bytesToUint(rawDetail.txType);\n        txDetail.value = _bytesToUint(rawDetail.value);\n        txDetail.gas = _bytesToUint(rawDetail.gas);\n        txDetail.accessList = rawDetail.accessList;\n        return txDetail;\n    }\n\n    function readTx1559s(string memory path) internal view virtual returns (Tx1559[] memory) {\n        string memory deployData = vm.readFile(path);\n        bytes memory parsedDeployData = vm.parseJson(deployData, \".transactions\");\n        RawTx1559[] memory rawTxs = abi.decode(parsedDeployData, (RawTx1559[]));\n        return rawToConvertedEIPTx1559s(rawTxs);\n    }\n\n    function readTx1559(string memory path, uint256 index) internal view virtual returns (Tx1559 memory) {\n        string memory deployData = vm.readFile(path);\n        string memory key = string(abi.encodePacked(\".transactions[\", vm.toString(index), \"]\"));\n        bytes memory parsedDeployData = vm.parseJson(deployData, key);\n        RawTx1559 memory rawTx = abi.decode(parsedDeployData, (RawTx1559));\n        return rawToConvertedEIPTx1559(rawTx);\n    }\n\n    // Analogous to readTransactions, but for receipts.\n    function readReceipts(string memory path) internal view virtual returns (Receipt[] memory) {\n        string memory deployData = vm.readFile(path);\n        bytes memory parsedDeployData = vm.parseJson(deployData, \".receipts\");\n        RawReceipt[] memory rawReceipts = abi.decode(parsedDeployData, (RawReceipt[]));\n        return rawToConvertedReceipts(rawReceipts);\n    }\n\n    function readReceipt(string memory path, uint256 index) internal view virtual returns (Receipt memory) {\n        string memory deployData = vm.readFile(path);\n        string memory key = string(abi.encodePacked(\".receipts[\", vm.toString(index), \"]\"));\n        bytes memory parsedDeployData = vm.parseJson(deployData, key);\n        RawReceipt memory rawReceipt = abi.decode(parsedDeployData, (RawReceipt));\n        return rawToConvertedReceipt(rawReceipt);\n    }\n\n    function rawToConvertedReceipts(RawReceipt[] memory rawReceipts) internal pure virtual returns (Receipt[] memory) {\n        Receipt[] memory receipts = new Receipt[](rawReceipts.length);\n        for (uint256 i; i < rawReceipts.length; i++) {\n            receipts[i] = rawToConvertedReceipt(rawReceipts[i]);\n        }\n        return receipts;\n    }\n\n    function rawToConvertedReceipt(RawReceipt memory rawReceipt) internal pure virtual returns (Receipt memory) {\n        Receipt memory receipt;\n        receipt.blockHash = rawReceipt.blockHash;\n        receipt.to = rawReceipt.to;\n        receipt.from = rawReceipt.from;\n        receipt.contractAddress = rawReceipt.contractAddress;\n        receipt.effectiveGasPrice = _bytesToUint(rawReceipt.effectiveGasPrice);\n        receipt.cumulativeGasUsed = _bytesToUint(rawReceipt.cumulativeGasUsed);\n        receipt.gasUsed = _bytesToUint(rawReceipt.gasUsed);\n        receipt.status = _bytesToUint(rawReceipt.status);\n        receipt.transactionIndex = _bytesToUint(rawReceipt.transactionIndex);\n        receipt.blockNumber = _bytesToUint(rawReceipt.blockNumber);\n        receipt.logs = rawToConvertedReceiptLogs(rawReceipt.logs);\n        receipt.logsBloom = rawReceipt.logsBloom;\n        receipt.transactionHash = rawReceipt.transactionHash;\n        return receipt;\n    }\n\n    function rawToConvertedReceiptLogs(RawReceiptLog[] memory rawLogs)\n        internal\n        pure\n        virtual\n        returns (ReceiptLog[] memory)\n    {\n        ReceiptLog[] memory logs = new ReceiptLog[](rawLogs.length);\n        for (uint256 i; i < rawLogs.length; i++) {\n            logs[i].logAddress = rawLogs[i].logAddress;\n            logs[i].blockHash = rawLogs[i].blockHash;\n            logs[i].blockNumber = _bytesToUint(rawLogs[i].blockNumber);\n            logs[i].data = rawLogs[i].data;\n            logs[i].logIndex = _bytesToUint(rawLogs[i].logIndex);\n            logs[i].topics = rawLogs[i].topics;\n            logs[i].transactionIndex = _bytesToUint(rawLogs[i].transactionIndex);\n            logs[i].transactionLogIndex = _bytesToUint(rawLogs[i].transactionLogIndex);\n            logs[i].removed = rawLogs[i].removed;\n        }\n        return logs;\n    }\n\n    // Deploy a contract by fetching the contract bytecode from\n    // the artifacts directory\n    // e.g. `deployCode(code, abi.encode(arg1,arg2,arg3))`\n    function deployCode(string memory what, bytes memory args) internal virtual returns (address addr) {\n        bytes memory bytecode = abi.encodePacked(vm.getCode(what), args);\n        /// @solidity memory-safe-assembly\n        assembly {\n            addr := create(0, add(bytecode, 0x20), mload(bytecode))\n        }\n\n        require(addr != address(0), \"StdCheats deployCode(string,bytes): Deployment failed.\");\n    }\n\n    function deployCode(string memory what) internal virtual returns (address addr) {\n        bytes memory bytecode = vm.getCode(what);\n        /// @solidity memory-safe-assembly\n        assembly {\n            addr := create(0, add(bytecode, 0x20), mload(bytecode))\n        }\n\n        require(addr != address(0), \"StdCheats deployCode(string): Deployment failed.\");\n    }\n\n    /// @dev deploy contract with value on construction\n    function deployCode(string memory what, bytes memory args, uint256 val) internal virtual returns (address addr) {\n        bytes memory bytecode = abi.encodePacked(vm.getCode(what), args);\n        /// @solidity memory-safe-assembly\n        assembly {\n            addr := create(val, add(bytecode, 0x20), mload(bytecode))\n        }\n\n        require(addr != address(0), \"StdCheats deployCode(string,bytes,uint256): Deployment failed.\");\n    }\n\n    function deployCode(string memory what, uint256 val) internal virtual returns (address addr) {\n        bytes memory bytecode = vm.getCode(what);\n        /// @solidity memory-safe-assembly\n        assembly {\n            addr := create(val, add(bytecode, 0x20), mload(bytecode))\n        }\n\n        require(addr != address(0), \"StdCheats deployCode(string,uint256): Deployment failed.\");\n    }\n\n    // creates a labeled address and the corresponding private key\n    function makeAddrAndKey(string memory name) internal virtual returns (address addr, uint256 privateKey) {\n        privateKey = uint256(keccak256(abi.encodePacked(name)));\n        addr = vm.addr(privateKey);\n        vm.label(addr, name);\n    }\n\n    // creates a labeled address\n    function makeAddr(string memory name) internal virtual returns (address addr) {\n        (addr,) = makeAddrAndKey(name);\n    }\n\n    // Destroys an account immediately, sending the balance to beneficiary.\n    // Destroying means: balance will be zero, code will be empty, and nonce will be 0\n    // This is similar to selfdestruct but not identical: selfdestruct destroys code and nonce\n    // only after tx ends, this will run immediately.\n    function destroyAccount(address who, address beneficiary) internal virtual {\n        uint256 currBalance = who.balance;\n        vm.etch(who, abi.encode());\n        vm.deal(who, 0);\n        vm.resetNonce(who);\n\n        uint256 beneficiaryBalance = beneficiary.balance;\n        vm.deal(beneficiary, currBalance + beneficiaryBalance);\n    }\n\n    // creates a struct containing both a labeled address and the corresponding private key\n    function makeAccount(string memory name) internal virtual returns (Account memory account) {\n        (account.addr, account.key) = makeAddrAndKey(name);\n    }\n\n    function deriveRememberKey(string memory mnemonic, uint32 index)\n        internal\n        virtual\n        returns (address who, uint256 privateKey)\n    {\n        privateKey = vm.deriveKey(mnemonic, index);\n        who = vm.rememberKey(privateKey);\n    }\n\n    function _bytesToUint(bytes memory b) private pure returns (uint256) {\n        require(b.length <= 32, \"StdCheats _bytesToUint(bytes): Bytes length exceeds 32.\");\n        return abi.decode(abi.encodePacked(new bytes(32 - b.length), b), (uint256));\n    }\n\n    function isFork() internal view virtual returns (bool status) {\n        try vm.activeFork() {\n            status = true;\n        } catch (bytes memory) {}\n    }\n\n    modifier skipWhenForking() {\n        if (!isFork()) {\n            _;\n        }\n    }\n\n    modifier skipWhenNotForking() {\n        if (isFork()) {\n            _;\n        }\n    }\n\n    modifier noGasMetering() {\n        vm.pauseGasMetering();\n        // To prevent turning gas monitoring back on with nested functions that use this modifier,\n        // we check if gasMetering started in the off position. If it did, we don't want to turn\n        // it back on until we exit the top level function that used the modifier\n        //\n        // i.e. funcA() noGasMetering { funcB() }, where funcB has noGasMetering as well.\n        // funcA will have `gasStartedOff` as false, funcB will have it as true,\n        // so we only turn metering back on at the end of the funcA\n        bool gasStartedOff = gasMeteringOff;\n        gasMeteringOff = true;\n\n        _;\n\n        // if gas metering was on when this modifier was called, turn it back on at the end\n        if (!gasStartedOff) {\n            gasMeteringOff = false;\n            vm.resumeGasMetering();\n        }\n    }\n\n    // We use this complex approach of `_viewChainId` and `_pureChainId` to ensure there are no\n    // compiler warnings when accessing chain ID in any solidity version supported by forge-std. We\n    // can't simply access the chain ID in a normal view or pure function because the solc View Pure\n    // Checker changed `chainid` from pure to view in 0.8.0.\n    function _viewChainId() private view returns (uint256 chainId) {\n        // Assembly required since `block.chainid` was introduced in 0.8.0.\n        assembly {\n            chainId := chainid()\n        }\n\n        address(this); // Silence warnings in older Solc versions.\n    }\n\n    function _pureChainId() private pure returns (uint256 chainId) {\n        function() internal view returns (uint256) fnIn = _viewChainId;\n        function() internal pure returns (uint256) pureChainId;\n        assembly {\n            pureChainId := fnIn\n        }\n        chainId = pureChainId();\n    }\n}\n\n// Wrappers around cheatcodes to avoid footguns\nabstract contract StdCheats is StdCheatsSafe {\n    using stdStorage for StdStorage;\n\n    StdStorage private stdstore;\n    Vm private constant vm = Vm(address(uint160(uint256(keccak256(\"hevm cheat code\")))));\n    address private constant CONSOLE2_ADDRESS = 0x000000000000000000636F6e736F6c652e6c6f67;\n\n    // Skip forward or rewind time by the specified number of seconds\n    function skip(uint256 time) internal virtual {\n        vm.warp(vm.getBlockTimestamp() + time);\n    }\n\n    function rewind(uint256 time) internal virtual {\n        vm.warp(vm.getBlockTimestamp() - time);\n    }\n\n    // Setup a prank from an address that has some ether\n    function hoax(address msgSender) internal virtual {\n        vm.deal(msgSender, 1 << 128);\n        vm.prank(msgSender);\n    }\n\n    function hoax(address msgSender, uint256 give) internal virtual {\n        vm.deal(msgSender, give);\n        vm.prank(msgSender);\n    }\n\n    function hoax(address msgSender, address origin) internal virtual {\n        vm.deal(msgSender, 1 << 128);\n        vm.prank(msgSender, origin);\n    }\n\n    function hoax(address msgSender, address origin, uint256 give) internal virtual {\n        vm.deal(msgSender, give);\n        vm.prank(msgSender, origin);\n    }\n\n    // Start perpetual prank from an address that has some ether\n    function startHoax(address msgSender) internal virtual {\n        vm.deal(msgSender, 1 << 128);\n        vm.startPrank(msgSender);\n    }\n\n    function startHoax(address msgSender, uint256 give) internal virtual {\n        vm.deal(msgSender, give);\n        vm.startPrank(msgSender);\n    }\n\n    // Start perpetual prank from an address that has some ether\n    // tx.origin is set to the origin parameter\n    function startHoax(address msgSender, address origin) internal virtual {\n        vm.deal(msgSender, 1 << 128);\n        vm.startPrank(msgSender, origin);\n    }\n\n    function startHoax(address msgSender, address origin, uint256 give) internal virtual {\n        vm.deal(msgSender, give);\n        vm.startPrank(msgSender, origin);\n    }\n\n    function changePrank(address msgSender) internal virtual {\n        console2_log_StdCheats(\"changePrank is deprecated. Please use vm.startPrank instead.\");\n        vm.stopPrank();\n        vm.startPrank(msgSender);\n    }\n\n    function changePrank(address msgSender, address txOrigin) internal virtual {\n        vm.stopPrank();\n        vm.startPrank(msgSender, txOrigin);\n    }\n\n    // The same as Vm's `deal`\n    // Use the alternative signature for ERC20 tokens\n    function deal(address to, uint256 give) internal virtual {\n        vm.deal(to, give);\n    }\n\n    // Set the balance of an account for any ERC20 token\n    // Use the alternative signature to update `totalSupply`\n    function deal(address token, address to, uint256 give) internal virtual {\n        deal(token, to, give, false);\n    }\n\n    // Set the balance of an account for any ERC1155 token\n    // Use the alternative signature to update `totalSupply`\n    function dealERC1155(address token, address to, uint256 id, uint256 give) internal virtual {\n        dealERC1155(token, to, id, give, false);\n    }\n\n    function deal(address token, address to, uint256 give, bool adjust) internal virtual {\n        // get current balance\n        (, bytes memory balData) = token.staticcall(abi.encodeWithSelector(0x70a08231, to));\n        uint256 prevBal = abi.decode(balData, (uint256));\n\n        // update balance\n        stdstore.target(token).sig(0x70a08231).with_key(to).checked_write(give);\n\n        // update total supply\n        if (adjust) {\n            (, bytes memory totSupData) = token.staticcall(abi.encodeWithSelector(0x18160ddd));\n            uint256 totSup = abi.decode(totSupData, (uint256));\n            if (give < prevBal) {\n                totSup -= (prevBal - give);\n            } else {\n                totSup += (give - prevBal);\n            }\n            stdstore.target(token).sig(0x18160ddd).checked_write(totSup);\n        }\n    }\n\n    function dealERC1155(address token, address to, uint256 id, uint256 give, bool adjust) internal virtual {\n        // get current balance\n        (, bytes memory balData) = token.staticcall(abi.encodeWithSelector(0x00fdd58e, to, id));\n        uint256 prevBal = abi.decode(balData, (uint256));\n\n        // update balance\n        stdstore.target(token).sig(0x00fdd58e).with_key(to).with_key(id).checked_write(give);\n\n        // update total supply\n        if (adjust) {\n            (, bytes memory totSupData) = token.staticcall(abi.encodeWithSelector(0xbd85b039, id));\n            require(\n                totSupData.length != 0,\n                \"StdCheats deal(address,address,uint,uint,bool): target contract is not ERC1155Supply.\"\n            );\n            uint256 totSup = abi.decode(totSupData, (uint256));\n            if (give < prevBal) {\n                totSup -= (prevBal - give);\n            } else {\n                totSup += (give - prevBal);\n            }\n            stdstore.target(token).sig(0xbd85b039).with_key(id).checked_write(totSup);\n        }\n    }\n\n    function dealERC721(address token, address to, uint256 id) internal virtual {\n        // check if token id is already minted and the actual owner.\n        (bool successMinted, bytes memory ownerData) = token.staticcall(abi.encodeWithSelector(0x6352211e, id));\n        require(successMinted, \"StdCheats deal(address,address,uint,bool): id not minted.\");\n\n        // get owner current balance\n        (, bytes memory fromBalData) =\n            token.staticcall(abi.encodeWithSelector(0x70a08231, abi.decode(ownerData, (address))));\n        uint256 fromPrevBal = abi.decode(fromBalData, (uint256));\n\n        // get new user current balance\n        (, bytes memory toBalData) = token.staticcall(abi.encodeWithSelector(0x70a08231, to));\n        uint256 toPrevBal = abi.decode(toBalData, (uint256));\n\n        // update balances\n        stdstore.target(token).sig(0x70a08231).with_key(abi.decode(ownerData, (address))).checked_write(--fromPrevBal);\n        stdstore.target(token).sig(0x70a08231).with_key(to).checked_write(++toPrevBal);\n\n        // update owner\n        stdstore.target(token).sig(0x6352211e).with_key(id).checked_write(to);\n    }\n\n    function deployCodeTo(string memory what, address where) internal virtual {\n        deployCodeTo(what, \"\", 0, where);\n    }\n\n    function deployCodeTo(string memory what, bytes memory args, address where) internal virtual {\n        deployCodeTo(what, args, 0, where);\n    }\n\n    function deployCodeTo(string memory what, bytes memory args, uint256 value, address where) internal virtual {\n        bytes memory creationCode = vm.getCode(what);\n        vm.etch(where, abi.encodePacked(creationCode, args));\n        (bool success, bytes memory runtimeBytecode) = where.call{value: value}(\"\");\n        require(success, \"StdCheats deployCodeTo(string,bytes,uint256,address): Failed to create runtime bytecode.\");\n        vm.etch(where, runtimeBytecode);\n    }\n\n    // Used to prevent the compilation of console, which shortens the compilation time when console is not used elsewhere.\n    function console2_log_StdCheats(string memory p0) private view {\n        (bool status,) = address(CONSOLE2_ADDRESS).staticcall(abi.encodeWithSignature(\"log(string)\", p0));\n        status;\n    }\n}\n"},"lib/forge-std/src/StdError.sol":{"content":"// SPDX-License-Identifier: MIT\n// Panics work for versions >=0.8.0, but we lowered the pragma to make this compatible with Test\npragma solidity >=0.6.2 <0.9.0;\n\nlibrary stdError {\n    bytes public constant assertionError = abi.encodeWithSignature(\"Panic(uint256)\", 0x01);\n    bytes public constant arithmeticError = abi.encodeWithSignature(\"Panic(uint256)\", 0x11);\n    bytes public constant divisionError = abi.encodeWithSignature(\"Panic(uint256)\", 0x12);\n    bytes public constant enumConversionError = abi.encodeWithSignature(\"Panic(uint256)\", 0x21);\n    bytes public constant encodeStorageError = abi.encodeWithSignature(\"Panic(uint256)\", 0x22);\n    bytes public constant popError = abi.encodeWithSignature(\"Panic(uint256)\", 0x31);\n    bytes public constant indexOOBError = abi.encodeWithSignature(\"Panic(uint256)\", 0x32);\n    bytes public constant memOverflowError = abi.encodeWithSignature(\"Panic(uint256)\", 0x41);\n    bytes public constant zeroVarError = abi.encodeWithSignature(\"Panic(uint256)\", 0x51);\n}\n"},"lib/forge-std/src/StdInvariant.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity >=0.6.2 <0.9.0;\n\npragma experimental ABIEncoderV2;\n\nabstract contract StdInvariant {\n    struct FuzzSelector {\n        address addr;\n        bytes4[] selectors;\n    }\n\n    struct FuzzArtifactSelector {\n        string artifact;\n        bytes4[] selectors;\n    }\n\n    struct FuzzInterface {\n        address addr;\n        string[] artifacts;\n    }\n\n    address[] private _excludedContracts;\n    address[] private _excludedSenders;\n    address[] private _targetedContracts;\n    address[] private _targetedSenders;\n\n    string[] private _excludedArtifacts;\n    string[] private _targetedArtifacts;\n\n    FuzzArtifactSelector[] private _targetedArtifactSelectors;\n\n    FuzzSelector[] private _excludedSelectors;\n    FuzzSelector[] private _targetedSelectors;\n\n    FuzzInterface[] private _targetedInterfaces;\n\n    // Functions for users:\n    // These are intended to be called in tests.\n\n    function excludeContract(address newExcludedContract_) internal {\n        _excludedContracts.push(newExcludedContract_);\n    }\n\n    function excludeSelector(FuzzSelector memory newExcludedSelector_) internal {\n        _excludedSelectors.push(newExcludedSelector_);\n    }\n\n    function excludeSender(address newExcludedSender_) internal {\n        _excludedSenders.push(newExcludedSender_);\n    }\n\n    function excludeArtifact(string memory newExcludedArtifact_) internal {\n        _excludedArtifacts.push(newExcludedArtifact_);\n    }\n\n    function targetArtifact(string memory newTargetedArtifact_) internal {\n        _targetedArtifacts.push(newTargetedArtifact_);\n    }\n\n    function targetArtifactSelector(FuzzArtifactSelector memory newTargetedArtifactSelector_) internal {\n        _targetedArtifactSelectors.push(newTargetedArtifactSelector_);\n    }\n\n    function targetContract(address newTargetedContract_) internal {\n        _targetedContracts.push(newTargetedContract_);\n    }\n\n    function targetSelector(FuzzSelector memory newTargetedSelector_) internal {\n        _targetedSelectors.push(newTargetedSelector_);\n    }\n\n    function targetSender(address newTargetedSender_) internal {\n        _targetedSenders.push(newTargetedSender_);\n    }\n\n    function targetInterface(FuzzInterface memory newTargetedInterface_) internal {\n        _targetedInterfaces.push(newTargetedInterface_);\n    }\n\n    // Functions for forge:\n    // These are called by forge to run invariant tests and don't need to be called in tests.\n\n    function excludeArtifacts() public view returns (string[] memory excludedArtifacts_) {\n        excludedArtifacts_ = _excludedArtifacts;\n    }\n\n    function excludeContracts() public view returns (address[] memory excludedContracts_) {\n        excludedContracts_ = _excludedContracts;\n    }\n\n    function excludeSelectors() public view returns (FuzzSelector[] memory excludedSelectors_) {\n        excludedSelectors_ = _excludedSelectors;\n    }\n\n    function excludeSenders() public view returns (address[] memory excludedSenders_) {\n        excludedSenders_ = _excludedSenders;\n    }\n\n    function targetArtifacts() public view returns (string[] memory targetedArtifacts_) {\n        targetedArtifacts_ = _targetedArtifacts;\n    }\n\n    function targetArtifactSelectors() public view returns (FuzzArtifactSelector[] memory targetedArtifactSelectors_) {\n        targetedArtifactSelectors_ = _targetedArtifactSelectors;\n    }\n\n    function targetContracts() public view returns (address[] memory targetedContracts_) {\n        targetedContracts_ = _targetedContracts;\n    }\n\n    function targetSelectors() public view returns (FuzzSelector[] memory targetedSelectors_) {\n        targetedSelectors_ = _targetedSelectors;\n    }\n\n    function targetSenders() public view returns (address[] memory targetedSenders_) {\n        targetedSenders_ = _targetedSenders;\n    }\n\n    function targetInterfaces() public view returns (FuzzInterface[] memory targetedInterfaces_) {\n        targetedInterfaces_ = _targetedInterfaces;\n    }\n}\n"},"lib/forge-std/src/StdJson.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity >=0.6.0 <0.9.0;\n\npragma experimental ABIEncoderV2;\n\nimport {VmSafe} from \"./Vm.sol\";\n\n// Helpers for parsing and writing JSON files\n// To parse:\n// ```\n// using stdJson for string;\n// string memory json = vm.readFile(\"<some_path>\");\n// json.readUint(\"<json_path>\");\n// ```\n// To write:\n// ```\n// using stdJson for string;\n// string memory json = \"json\";\n// json.serialize(\"a\", uint256(123));\n// string memory semiFinal = json.serialize(\"b\", string(\"test\"));\n// string memory finalJson = json.serialize(\"c\", semiFinal);\n// finalJson.write(\"<some_path>\");\n// ```\n\nlibrary stdJson {\n    VmSafe private constant vm = VmSafe(address(uint160(uint256(keccak256(\"hevm cheat code\")))));\n\n    function keyExists(string memory json, string memory key) internal view returns (bool) {\n        return vm.keyExistsJson(json, key);\n    }\n\n    function parseRaw(string memory json, string memory key) internal pure returns (bytes memory) {\n        return vm.parseJson(json, key);\n    }\n\n    function readUint(string memory json, string memory key) internal pure returns (uint256) {\n        return vm.parseJsonUint(json, key);\n    }\n\n    function readUintArray(string memory json, string memory key) internal pure returns (uint256[] memory) {\n        return vm.parseJsonUintArray(json, key);\n    }\n\n    function readInt(string memory json, string memory key) internal pure returns (int256) {\n        return vm.parseJsonInt(json, key);\n    }\n\n    function readIntArray(string memory json, string memory key) internal pure returns (int256[] memory) {\n        return vm.parseJsonIntArray(json, key);\n    }\n\n    function readBytes32(string memory json, string memory key) internal pure returns (bytes32) {\n        return vm.parseJsonBytes32(json, key);\n    }\n\n    function readBytes32Array(string memory json, string memory key) internal pure returns (bytes32[] memory) {\n        return vm.parseJsonBytes32Array(json, key);\n    }\n\n    function readString(string memory json, string memory key) internal pure returns (string memory) {\n        return vm.parseJsonString(json, key);\n    }\n\n    function readStringArray(string memory json, string memory key) internal pure returns (string[] memory) {\n        return vm.parseJsonStringArray(json, key);\n    }\n\n    function readAddress(string memory json, string memory key) internal pure returns (address) {\n        return vm.parseJsonAddress(json, key);\n    }\n\n    function readAddressArray(string memory json, string memory key) internal pure returns (address[] memory) {\n        return vm.parseJsonAddressArray(json, key);\n    }\n\n    function readBool(string memory json, string memory key) internal pure returns (bool) {\n        return vm.parseJsonBool(json, key);\n    }\n\n    function readBoolArray(string memory json, string memory key) internal pure returns (bool[] memory) {\n        return vm.parseJsonBoolArray(json, key);\n    }\n\n    function readBytes(string memory json, string memory key) internal pure returns (bytes memory) {\n        return vm.parseJsonBytes(json, key);\n    }\n\n    function readBytesArray(string memory json, string memory key) internal pure returns (bytes[] memory) {\n        return vm.parseJsonBytesArray(json, key);\n    }\n\n    function readUintOr(string memory json, string memory key, uint256 defaultValue) internal view returns (uint256) {\n        return keyExists(json, key) ? readUint(json, key) : defaultValue;\n    }\n\n    function readUintArrayOr(string memory json, string memory key, uint256[] memory defaultValue)\n        internal\n        view\n        returns (uint256[] memory)\n    {\n        return keyExists(json, key) ? readUintArray(json, key) : defaultValue;\n    }\n\n    function readIntOr(string memory json, string memory key, int256 defaultValue) internal view returns (int256) {\n        return keyExists(json, key) ? readInt(json, key) : defaultValue;\n    }\n\n    function readIntArrayOr(string memory json, string memory key, int256[] memory defaultValue)\n        internal\n        view\n        returns (int256[] memory)\n    {\n        return keyExists(json, key) ? readIntArray(json, key) : defaultValue;\n    }\n\n    function readBytes32Or(string memory json, string memory key, bytes32 defaultValue)\n        internal\n        view\n        returns (bytes32)\n    {\n        return keyExists(json, key) ? readBytes32(json, key) : defaultValue;\n    }\n\n    function readBytes32ArrayOr(string memory json, string memory key, bytes32[] memory defaultValue)\n        internal\n        view\n        returns (bytes32[] memory)\n    {\n        return keyExists(json, key) ? readBytes32Array(json, key) : defaultValue;\n    }\n\n    function readStringOr(string memory json, string memory key, string memory defaultValue)\n        internal\n        view\n        returns (string memory)\n    {\n        return keyExists(json, key) ? readString(json, key) : defaultValue;\n    }\n\n    function readStringArrayOr(string memory json, string memory key, string[] memory defaultValue)\n        internal\n        view\n        returns (string[] memory)\n    {\n        return keyExists(json, key) ? readStringArray(json, key) : defaultValue;\n    }\n\n    function readAddressOr(string memory json, string memory key, address defaultValue)\n        internal\n        view\n        returns (address)\n    {\n        return keyExists(json, key) ? readAddress(json, key) : defaultValue;\n    }\n\n    function readAddressArrayOr(string memory json, string memory key, address[] memory defaultValue)\n        internal\n        view\n        returns (address[] memory)\n    {\n        return keyExists(json, key) ? readAddressArray(json, key) : defaultValue;\n    }\n\n    function readBoolOr(string memory json, string memory key, bool defaultValue) internal view returns (bool) {\n        return keyExists(json, key) ? readBool(json, key) : defaultValue;\n    }\n\n    function readBoolArrayOr(string memory json, string memory key, bool[] memory defaultValue)\n        internal\n        view\n        returns (bool[] memory)\n    {\n        return keyExists(json, key) ? readBoolArray(json, key) : defaultValue;\n    }\n\n    function readBytesOr(string memory json, string memory key, bytes memory defaultValue)\n        internal\n        view\n        returns (bytes memory)\n    {\n        return keyExists(json, key) ? readBytes(json, key) : defaultValue;\n    }\n\n    function readBytesArrayOr(string memory json, string memory key, bytes[] memory defaultValue)\n        internal\n        view\n        returns (bytes[] memory)\n    {\n        return keyExists(json, key) ? readBytesArray(json, key) : defaultValue;\n    }\n\n    function serialize(string memory jsonKey, string memory rootObject) internal returns (string memory) {\n        return vm.serializeJson(jsonKey, rootObject);\n    }\n\n    function serialize(string memory jsonKey, string memory key, bool value) internal returns (string memory) {\n        return vm.serializeBool(jsonKey, key, value);\n    }\n\n    function serialize(string memory jsonKey, string memory key, bool[] memory value)\n        internal\n        returns (string memory)\n    {\n        return vm.serializeBool(jsonKey, key, value);\n    }\n\n    function serialize(string memory jsonKey, string memory key, uint256 value) internal returns (string memory) {\n        return vm.serializeUint(jsonKey, key, value);\n    }\n\n    function serialize(string memory jsonKey, string memory key, uint256[] memory value)\n        internal\n        returns (string memory)\n    {\n        return vm.serializeUint(jsonKey, key, value);\n    }\n\n    function serialize(string memory jsonKey, string memory key, int256 value) internal returns (string memory) {\n        return vm.serializeInt(jsonKey, key, value);\n    }\n\n    function serialize(string memory jsonKey, string memory key, int256[] memory value)\n        internal\n        returns (string memory)\n    {\n        return vm.serializeInt(jsonKey, key, value);\n    }\n\n    function serialize(string memory jsonKey, string memory key, address value) internal returns (string memory) {\n        return vm.serializeAddress(jsonKey, key, value);\n    }\n\n    function serialize(string memory jsonKey, string memory key, address[] memory value)\n        internal\n        returns (string memory)\n    {\n        return vm.serializeAddress(jsonKey, key, value);\n    }\n\n    function serialize(string memory jsonKey, string memory key, bytes32 value) internal returns (string memory) {\n        return vm.serializeBytes32(jsonKey, key, value);\n    }\n\n    function serialize(string memory jsonKey, string memory key, bytes32[] memory value)\n        internal\n        returns (string memory)\n    {\n        return vm.serializeBytes32(jsonKey, key, value);\n    }\n\n    function serialize(string memory jsonKey, string memory key, bytes memory value) internal returns (string memory) {\n        return vm.serializeBytes(jsonKey, key, value);\n    }\n\n    function serialize(string memory jsonKey, string memory key, bytes[] memory value)\n        internal\n        returns (string memory)\n    {\n        return vm.serializeBytes(jsonKey, key, value);\n    }\n\n    function serialize(string memory jsonKey, string memory key, string memory value)\n        internal\n        returns (string memory)\n    {\n        return vm.serializeString(jsonKey, key, value);\n    }\n\n    function serialize(string memory jsonKey, string memory key, string[] memory value)\n        internal\n        returns (string memory)\n    {\n        return vm.serializeString(jsonKey, key, value);\n    }\n\n    function write(string memory jsonKey, string memory path) internal {\n        vm.writeJson(jsonKey, path);\n    }\n\n    function write(string memory jsonKey, string memory path, string memory valueKey) internal {\n        vm.writeJson(jsonKey, path, valueKey);\n    }\n}\n"},"lib/forge-std/src/StdMath.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity >=0.6.2 <0.9.0;\n\nlibrary stdMath {\n    int256 private constant INT256_MIN = -57896044618658097711785492504343953926634992332820282019728792003956564819968;\n\n    function abs(int256 a) internal pure returns (uint256) {\n        // Required or it will fail when `a = type(int256).min`\n        if (a == INT256_MIN) {\n            return 57896044618658097711785492504343953926634992332820282019728792003956564819968;\n        }\n\n        return uint256(a > 0 ? a : -a);\n    }\n\n    function delta(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a > b ? a - b : b - a;\n    }\n\n    function delta(int256 a, int256 b) internal pure returns (uint256) {\n        // a and b are of the same sign\n        // this works thanks to two's complement, the left-most bit is the sign bit\n        if ((a ^ b) > -1) {\n            return delta(abs(a), abs(b));\n        }\n\n        // a and b are of opposite signs\n        return abs(a) + abs(b);\n    }\n\n    function percentDelta(uint256 a, uint256 b) internal pure returns (uint256) {\n        uint256 absDelta = delta(a, b);\n\n        return absDelta * 1e18 / b;\n    }\n\n    function percentDelta(int256 a, int256 b) internal pure returns (uint256) {\n        uint256 absDelta = delta(a, b);\n        uint256 absB = abs(b);\n\n        return absDelta * 1e18 / absB;\n    }\n}\n"},"lib/forge-std/src/StdStorage.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity >=0.6.2 <0.9.0;\n\nimport {Vm} from \"./Vm.sol\";\n\nstruct FindData {\n    uint256 slot;\n    uint256 offsetLeft;\n    uint256 offsetRight;\n    bool found;\n}\n\nstruct StdStorage {\n    mapping(address => mapping(bytes4 => mapping(bytes32 => FindData))) finds;\n    bytes32[] _keys;\n    bytes4 _sig;\n    uint256 _depth;\n    address _target;\n    bytes32 _set;\n    bool _enable_packed_slots;\n    bytes _calldata;\n}\n\nlibrary stdStorageSafe {\n    event SlotFound(address who, bytes4 fsig, bytes32 keysHash, uint256 slot);\n    event WARNING_UninitedSlot(address who, uint256 slot);\n\n    Vm private constant vm = Vm(address(uint160(uint256(keccak256(\"hevm cheat code\")))));\n    uint256 constant UINT256_MAX = 115792089237316195423570985008687907853269984665640564039457584007913129639935;\n\n    function sigs(string memory sigStr) internal pure returns (bytes4) {\n        return bytes4(keccak256(bytes(sigStr)));\n    }\n\n    function getCallParams(StdStorage storage self) internal view returns (bytes memory) {\n        if (self._calldata.length == 0) {\n            return flatten(self._keys);\n        } else {\n            return self._calldata;\n        }\n    }\n\n    // Calls target contract with configured parameters\n    function callTarget(StdStorage storage self) internal view returns (bool, bytes32) {\n        bytes memory cald = abi.encodePacked(self._sig, getCallParams(self));\n        (bool success, bytes memory rdat) = self._target.staticcall(cald);\n        bytes32 result = bytesToBytes32(rdat, 32 * self._depth);\n\n        return (success, result);\n    }\n\n    // Tries mutating slot value to determine if the targeted value is stored in it.\n    // If current value is 0, then we are setting slot value to type(uint256).max\n    // Otherwise, we set it to 0. That way, return value should always be affected.\n    function checkSlotMutatesCall(StdStorage storage self, bytes32 slot) internal returns (bool) {\n        bytes32 prevSlotValue = vm.load(self._target, slot);\n        (bool success, bytes32 prevReturnValue) = callTarget(self);\n\n        bytes32 testVal = prevReturnValue == bytes32(0) ? bytes32(UINT256_MAX) : bytes32(0);\n        vm.store(self._target, slot, testVal);\n\n        (, bytes32 newReturnValue) = callTarget(self);\n\n        vm.store(self._target, slot, prevSlotValue);\n\n        return (success && (prevReturnValue != newReturnValue));\n    }\n\n    // Tries setting one of the bits in slot to 1 until return value changes.\n    // Index of resulted bit is an offset packed slot has from left/right side\n    function findOffset(StdStorage storage self, bytes32 slot, bool left) internal returns (bool, uint256) {\n        for (uint256 offset = 0; offset < 256; offset++) {\n            uint256 valueToPut = left ? (1 << (255 - offset)) : (1 << offset);\n            vm.store(self._target, slot, bytes32(valueToPut));\n\n            (bool success, bytes32 data) = callTarget(self);\n\n            if (success && (uint256(data) > 0)) {\n                return (true, offset);\n            }\n        }\n        return (false, 0);\n    }\n\n    function findOffsets(StdStorage storage self, bytes32 slot) internal returns (bool, uint256, uint256) {\n        bytes32 prevSlotValue = vm.load(self._target, slot);\n\n        (bool foundLeft, uint256 offsetLeft) = findOffset(self, slot, true);\n        (bool foundRight, uint256 offsetRight) = findOffset(self, slot, false);\n\n        // `findOffset` may mutate slot value, so we are setting it to initial value\n        vm.store(self._target, slot, prevSlotValue);\n        return (foundLeft && foundRight, offsetLeft, offsetRight);\n    }\n\n    function find(StdStorage storage self) internal returns (FindData storage) {\n        return find(self, true);\n    }\n\n    /// @notice find an arbitrary storage slot given a function sig, input data, address of the contract and a value to check against\n    // slot complexity:\n    //  if flat, will be bytes32(uint256(uint));\n    //  if map, will be keccak256(abi.encode(key, uint(slot)));\n    //  if deep map, will be keccak256(abi.encode(key1, keccak256(abi.encode(key0, uint(slot)))));\n    //  if map struct, will be bytes32(uint256(keccak256(abi.encode(key1, keccak256(abi.encode(key0, uint(slot)))))) + structFieldDepth);\n    function find(StdStorage storage self, bool _clear) internal returns (FindData storage) {\n        address who = self._target;\n        bytes4 fsig = self._sig;\n        uint256 field_depth = self._depth;\n        bytes memory params = getCallParams(self);\n\n        // calldata to test against\n        if (self.finds[who][fsig][keccak256(abi.encodePacked(params, field_depth))].found) {\n            if (_clear) {\n                clear(self);\n            }\n            return self.finds[who][fsig][keccak256(abi.encodePacked(params, field_depth))];\n        }\n        vm.record();\n        (, bytes32 callResult) = callTarget(self);\n        (bytes32[] memory reads,) = vm.accesses(address(who));\n\n        if (reads.length == 0) {\n            revert(\"stdStorage find(StdStorage): No storage use detected for target.\");\n        } else {\n            for (uint256 i = reads.length; --i >= 0;) {\n                bytes32 prev = vm.load(who, reads[i]);\n                if (prev == bytes32(0)) {\n                    emit WARNING_UninitedSlot(who, uint256(reads[i]));\n                }\n\n                if (!checkSlotMutatesCall(self, reads[i])) {\n                    continue;\n                }\n\n                (uint256 offsetLeft, uint256 offsetRight) = (0, 0);\n\n                if (self._enable_packed_slots) {\n                    bool found;\n                    (found, offsetLeft, offsetRight) = findOffsets(self, reads[i]);\n                    if (!found) {\n                        continue;\n                    }\n                }\n\n                // Check that value between found offsets is equal to the current call result\n                uint256 curVal = (uint256(prev) & getMaskByOffsets(offsetLeft, offsetRight)) >> offsetRight;\n\n                if (uint256(callResult) != curVal) {\n                    continue;\n                }\n\n                emit SlotFound(who, fsig, keccak256(abi.encodePacked(params, field_depth)), uint256(reads[i]));\n                self.finds[who][fsig][keccak256(abi.encodePacked(params, field_depth))] =\n                    FindData(uint256(reads[i]), offsetLeft, offsetRight, true);\n                break;\n            }\n        }\n\n        require(\n            self.finds[who][fsig][keccak256(abi.encodePacked(params, field_depth))].found,\n            \"stdStorage find(StdStorage): Slot(s) not found.\"\n        );\n\n        if (_clear) {\n            clear(self);\n        }\n        return self.finds[who][fsig][keccak256(abi.encodePacked(params, field_depth))];\n    }\n\n    function target(StdStorage storage self, address _target) internal returns (StdStorage storage) {\n        self._target = _target;\n        return self;\n    }\n\n    function sig(StdStorage storage self, bytes4 _sig) internal returns (StdStorage storage) {\n        self._sig = _sig;\n        return self;\n    }\n\n    function sig(StdStorage storage self, string memory _sig) internal returns (StdStorage storage) {\n        self._sig = sigs(_sig);\n        return self;\n    }\n\n    function with_calldata(StdStorage storage self, bytes memory _calldata) internal returns (StdStorage storage) {\n        self._calldata = _calldata;\n        return self;\n    }\n\n    function with_key(StdStorage storage self, address who) internal returns (StdStorage storage) {\n        self._keys.push(bytes32(uint256(uint160(who))));\n        return self;\n    }\n\n    function with_key(StdStorage storage self, uint256 amt) internal returns (StdStorage storage) {\n        self._keys.push(bytes32(amt));\n        return self;\n    }\n\n    function with_key(StdStorage storage self, bytes32 key) internal returns (StdStorage storage) {\n        self._keys.push(key);\n        return self;\n    }\n\n    function enable_packed_slots(StdStorage storage self) internal returns (StdStorage storage) {\n        self._enable_packed_slots = true;\n        return self;\n    }\n\n    function depth(StdStorage storage self, uint256 _depth) internal returns (StdStorage storage) {\n        self._depth = _depth;\n        return self;\n    }\n\n    function read(StdStorage storage self) private returns (bytes memory) {\n        FindData storage data = find(self, false);\n        uint256 mask = getMaskByOffsets(data.offsetLeft, data.offsetRight);\n        uint256 value = (uint256(vm.load(self._target, bytes32(data.slot))) & mask) >> data.offsetRight;\n        clear(self);\n        return abi.encode(value);\n    }\n\n    function read_bytes32(StdStorage storage self) internal returns (bytes32) {\n        return abi.decode(read(self), (bytes32));\n    }\n\n    function read_bool(StdStorage storage self) internal returns (bool) {\n        int256 v = read_int(self);\n        if (v == 0) return false;\n        if (v == 1) return true;\n        revert(\"stdStorage read_bool(StdStorage): Cannot decode. Make sure you are reading a bool.\");\n    }\n\n    function read_address(StdStorage storage self) internal returns (address) {\n        return abi.decode(read(self), (address));\n    }\n\n    function read_uint(StdStorage storage self) internal returns (uint256) {\n        return abi.decode(read(self), (uint256));\n    }\n\n    function read_int(StdStorage storage self) internal returns (int256) {\n        return abi.decode(read(self), (int256));\n    }\n\n    function parent(StdStorage storage self) internal returns (uint256, bytes32) {\n        address who = self._target;\n        uint256 field_depth = self._depth;\n        vm.startMappingRecording();\n        uint256 child = find(self, true).slot - field_depth;\n        (bool found, bytes32 key, bytes32 parent_slot) = vm.getMappingKeyAndParentOf(who, bytes32(child));\n        if (!found) {\n            revert(\n                \"stdStorage read_bool(StdStorage): Cannot find parent. Make sure you give a slot and startMappingRecording() has been called.\"\n            );\n        }\n        return (uint256(parent_slot), key);\n    }\n\n    function root(StdStorage storage self) internal returns (uint256) {\n        address who = self._target;\n        uint256 field_depth = self._depth;\n        vm.startMappingRecording();\n        uint256 child = find(self, true).slot - field_depth;\n        bool found;\n        bytes32 root_slot;\n        bytes32 parent_slot;\n        (found,, parent_slot) = vm.getMappingKeyAndParentOf(who, bytes32(child));\n        if (!found) {\n            revert(\n                \"stdStorage read_bool(StdStorage): Cannot find parent. Make sure you give a slot and startMappingRecording() has been called.\"\n            );\n        }\n        while (found) {\n            root_slot = parent_slot;\n            (found,, parent_slot) = vm.getMappingKeyAndParentOf(who, bytes32(root_slot));\n        }\n        return uint256(root_slot);\n    }\n\n    function bytesToBytes32(bytes memory b, uint256 offset) private pure returns (bytes32) {\n        bytes32 out;\n\n        uint256 max = b.length > 32 ? 32 : b.length;\n        for (uint256 i = 0; i < max; i++) {\n            out |= bytes32(b[offset + i] & 0xFF) >> (i * 8);\n        }\n        return out;\n    }\n\n    function flatten(bytes32[] memory b) private pure returns (bytes memory) {\n        bytes memory result = new bytes(b.length * 32);\n        for (uint256 i = 0; i < b.length; i++) {\n            bytes32 k = b[i];\n            /// @solidity memory-safe-assembly\n            assembly {\n                mstore(add(result, add(32, mul(32, i))), k)\n            }\n        }\n\n        return result;\n    }\n\n    function clear(StdStorage storage self) internal {\n        delete self._target;\n        delete self._sig;\n        delete self._keys;\n        delete self._depth;\n        delete self._enable_packed_slots;\n        delete self._calldata;\n    }\n\n    // Returns mask which contains non-zero bits for values between `offsetLeft` and `offsetRight`\n    // (slotValue & mask) >> offsetRight will be the value of the given packed variable\n    function getMaskByOffsets(uint256 offsetLeft, uint256 offsetRight) internal pure returns (uint256 mask) {\n        // mask = ((1 << (256 - (offsetRight + offsetLeft))) - 1) << offsetRight;\n        // using assembly because (1 << 256) causes overflow\n        assembly {\n            mask := shl(offsetRight, sub(shl(sub(256, add(offsetRight, offsetLeft)), 1), 1))\n        }\n    }\n\n    // Returns slot value with updated packed variable.\n    function getUpdatedSlotValue(bytes32 curValue, uint256 varValue, uint256 offsetLeft, uint256 offsetRight)\n        internal\n        pure\n        returns (bytes32 newValue)\n    {\n        return bytes32((uint256(curValue) & ~getMaskByOffsets(offsetLeft, offsetRight)) | (varValue << offsetRight));\n    }\n}\n\nlibrary stdStorage {\n    Vm private constant vm = Vm(address(uint160(uint256(keccak256(\"hevm cheat code\")))));\n\n    function sigs(string memory sigStr) internal pure returns (bytes4) {\n        return stdStorageSafe.sigs(sigStr);\n    }\n\n    function find(StdStorage storage self) internal returns (uint256) {\n        return find(self, true);\n    }\n\n    function find(StdStorage storage self, bool _clear) internal returns (uint256) {\n        return stdStorageSafe.find(self, _clear).slot;\n    }\n\n    function target(StdStorage storage self, address _target) internal returns (StdStorage storage) {\n        return stdStorageSafe.target(self, _target);\n    }\n\n    function sig(StdStorage storage self, bytes4 _sig) internal returns (StdStorage storage) {\n        return stdStorageSafe.sig(self, _sig);\n    }\n\n    function sig(StdStorage storage self, string memory _sig) internal returns (StdStorage storage) {\n        return stdStorageSafe.sig(self, _sig);\n    }\n\n    function with_key(StdStorage storage self, address who) internal returns (StdStorage storage) {\n        return stdStorageSafe.with_key(self, who);\n    }\n\n    function with_key(StdStorage storage self, uint256 amt) internal returns (StdStorage storage) {\n        return stdStorageSafe.with_key(self, amt);\n    }\n\n    function with_key(StdStorage storage self, bytes32 key) internal returns (StdStorage storage) {\n        return stdStorageSafe.with_key(self, key);\n    }\n\n    function with_calldata(StdStorage storage self, bytes memory _calldata) internal returns (StdStorage storage) {\n        return stdStorageSafe.with_calldata(self, _calldata);\n    }\n\n    function enable_packed_slots(StdStorage storage self) internal returns (StdStorage storage) {\n        return stdStorageSafe.enable_packed_slots(self);\n    }\n\n    function depth(StdStorage storage self, uint256 _depth) internal returns (StdStorage storage) {\n        return stdStorageSafe.depth(self, _depth);\n    }\n\n    function clear(StdStorage storage self) internal {\n        stdStorageSafe.clear(self);\n    }\n\n    function checked_write(StdStorage storage self, address who) internal {\n        checked_write(self, bytes32(uint256(uint160(who))));\n    }\n\n    function checked_write(StdStorage storage self, uint256 amt) internal {\n        checked_write(self, bytes32(amt));\n    }\n\n    function checked_write_int(StdStorage storage self, int256 val) internal {\n        checked_write(self, bytes32(uint256(val)));\n    }\n\n    function checked_write(StdStorage storage self, bool write) internal {\n        bytes32 t;\n        /// @solidity memory-safe-assembly\n        assembly {\n            t := write\n        }\n        checked_write(self, t);\n    }\n\n    function checked_write(StdStorage storage self, bytes32 set) internal {\n        address who = self._target;\n        bytes4 fsig = self._sig;\n        uint256 field_depth = self._depth;\n        bytes memory params = stdStorageSafe.getCallParams(self);\n\n        if (!self.finds[who][fsig][keccak256(abi.encodePacked(params, field_depth))].found) {\n            find(self, false);\n        }\n        FindData storage data = self.finds[who][fsig][keccak256(abi.encodePacked(params, field_depth))];\n        if ((data.offsetLeft + data.offsetRight) > 0) {\n            uint256 maxVal = 2 ** (256 - (data.offsetLeft + data.offsetRight));\n            require(\n                uint256(set) < maxVal,\n                string(\n                    abi.encodePacked(\n                        \"stdStorage find(StdStorage): Packed slot. We can't fit value greater than \",\n                        vm.toString(maxVal)\n                    )\n                )\n            );\n        }\n        bytes32 curVal = vm.load(who, bytes32(data.slot));\n        bytes32 valToSet = stdStorageSafe.getUpdatedSlotValue(curVal, uint256(set), data.offsetLeft, data.offsetRight);\n\n        vm.store(who, bytes32(data.slot), valToSet);\n\n        (bool success, bytes32 callResult) = stdStorageSafe.callTarget(self);\n\n        if (!success || callResult != set) {\n            vm.store(who, bytes32(data.slot), curVal);\n            revert(\"stdStorage find(StdStorage): Failed to write value.\");\n        }\n        clear(self);\n    }\n\n    function read_bytes32(StdStorage storage self) internal returns (bytes32) {\n        return stdStorageSafe.read_bytes32(self);\n    }\n\n    function read_bool(StdStorage storage self) internal returns (bool) {\n        return stdStorageSafe.read_bool(self);\n    }\n\n    function read_address(StdStorage storage self) internal returns (address) {\n        return stdStorageSafe.read_address(self);\n    }\n\n    function read_uint(StdStorage storage self) internal returns (uint256) {\n        return stdStorageSafe.read_uint(self);\n    }\n\n    function read_int(StdStorage storage self) internal returns (int256) {\n        return stdStorageSafe.read_int(self);\n    }\n\n    function parent(StdStorage storage self) internal returns (uint256, bytes32) {\n        return stdStorageSafe.parent(self);\n    }\n\n    function root(StdStorage storage self) internal returns (uint256) {\n        return stdStorageSafe.root(self);\n    }\n}\n"},"lib/forge-std/src/StdStyle.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity >=0.4.22 <0.9.0;\n\nimport {VmSafe} from \"./Vm.sol\";\n\nlibrary StdStyle {\n    VmSafe private constant vm = VmSafe(address(uint160(uint256(keccak256(\"hevm cheat code\")))));\n\n    string constant RED = \"\\u001b[91m\";\n    string constant GREEN = \"\\u001b[92m\";\n    string constant YELLOW = \"\\u001b[93m\";\n    string constant BLUE = \"\\u001b[94m\";\n    string constant MAGENTA = \"\\u001b[95m\";\n    string constant CYAN = \"\\u001b[96m\";\n    string constant BOLD = \"\\u001b[1m\";\n    string constant DIM = \"\\u001b[2m\";\n    string constant ITALIC = \"\\u001b[3m\";\n    string constant UNDERLINE = \"\\u001b[4m\";\n    string constant INVERSE = \"\\u001b[7m\";\n    string constant RESET = \"\\u001b[0m\";\n\n    function styleConcat(string memory style, string memory self) private pure returns (string memory) {\n        return string(abi.encodePacked(style, self, RESET));\n    }\n\n    function red(string memory self) internal pure returns (string memory) {\n        return styleConcat(RED, self);\n    }\n\n    function red(uint256 self) internal pure returns (string memory) {\n        return red(vm.toString(self));\n    }\n\n    function red(int256 self) internal pure returns (string memory) {\n        return red(vm.toString(self));\n    }\n\n    function red(address self) internal pure returns (string memory) {\n        return red(vm.toString(self));\n    }\n\n    function red(bool self) internal pure returns (string memory) {\n        return red(vm.toString(self));\n    }\n\n    function redBytes(bytes memory self) internal pure returns (string memory) {\n        return red(vm.toString(self));\n    }\n\n    function redBytes32(bytes32 self) internal pure returns (string memory) {\n        return red(vm.toString(self));\n    }\n\n    function green(string memory self) internal pure returns (string memory) {\n        return styleConcat(GREEN, self);\n    }\n\n    function green(uint256 self) internal pure returns (string memory) {\n        return green(vm.toString(self));\n    }\n\n    function green(int256 self) internal pure returns (string memory) {\n        return green(vm.toString(self));\n    }\n\n    function green(address self) internal pure returns (string memory) {\n        return green(vm.toString(self));\n    }\n\n    function green(bool self) internal pure returns (string memory) {\n        return green(vm.toString(self));\n    }\n\n    function greenBytes(bytes memory self) internal pure returns (string memory) {\n        return green(vm.toString(self));\n    }\n\n    function greenBytes32(bytes32 self) internal pure returns (string memory) {\n        return green(vm.toString(self));\n    }\n\n    function yellow(string memory self) internal pure returns (string memory) {\n        return styleConcat(YELLOW, self);\n    }\n\n    function yellow(uint256 self) internal pure returns (string memory) {\n        return yellow(vm.toString(self));\n    }\n\n    function yellow(int256 self) internal pure returns (string memory) {\n        return yellow(vm.toString(self));\n    }\n\n    function yellow(address self) internal pure returns (string memory) {\n        return yellow(vm.toString(self));\n    }\n\n    function yellow(bool self) internal pure returns (string memory) {\n        return yellow(vm.toString(self));\n    }\n\n    function yellowBytes(bytes memory self) internal pure returns (string memory) {\n        return yellow(vm.toString(self));\n    }\n\n    function yellowBytes32(bytes32 self) internal pure returns (string memory) {\n        return yellow(vm.toString(self));\n    }\n\n    function blue(string memory self) internal pure returns (string memory) {\n        return styleConcat(BLUE, self);\n    }\n\n    function blue(uint256 self) internal pure returns (string memory) {\n        return blue(vm.toString(self));\n    }\n\n    function blue(int256 self) internal pure returns (string memory) {\n        return blue(vm.toString(self));\n    }\n\n    function blue(address self) internal pure returns (string memory) {\n        return blue(vm.toString(self));\n    }\n\n    function blue(bool self) internal pure returns (string memory) {\n        return blue(vm.toString(self));\n    }\n\n    function blueBytes(bytes memory self) internal pure returns (string memory) {\n        return blue(vm.toString(self));\n    }\n\n    function blueBytes32(bytes32 self) internal pure returns (string memory) {\n        return blue(vm.toString(self));\n    }\n\n    function magenta(string memory self) internal pure returns (string memory) {\n        return styleConcat(MAGENTA, self);\n    }\n\n    function magenta(uint256 self) internal pure returns (string memory) {\n        return magenta(vm.toString(self));\n    }\n\n    function magenta(int256 self) internal pure returns (string memory) {\n        return magenta(vm.toString(self));\n    }\n\n    function magenta(address self) internal pure returns (string memory) {\n        return magenta(vm.toString(self));\n    }\n\n    function magenta(bool self) internal pure returns (string memory) {\n        return magenta(vm.toString(self));\n    }\n\n    function magentaBytes(bytes memory self) internal pure returns (string memory) {\n        return magenta(vm.toString(self));\n    }\n\n    function magentaBytes32(bytes32 self) internal pure returns (string memory) {\n        return magenta(vm.toString(self));\n    }\n\n    function cyan(string memory self) internal pure returns (string memory) {\n        return styleConcat(CYAN, self);\n    }\n\n    function cyan(uint256 self) internal pure returns (string memory) {\n        return cyan(vm.toString(self));\n    }\n\n    function cyan(int256 self) internal pure returns (string memory) {\n        return cyan(vm.toString(self));\n    }\n\n    function cyan(address self) internal pure returns (string memory) {\n        return cyan(vm.toString(self));\n    }\n\n    function cyan(bool self) internal pure returns (string memory) {\n        return cyan(vm.toString(self));\n    }\n\n    function cyanBytes(bytes memory self) internal pure returns (string memory) {\n        return cyan(vm.toString(self));\n    }\n\n    function cyanBytes32(bytes32 self) internal pure returns (string memory) {\n        return cyan(vm.toString(self));\n    }\n\n    function bold(string memory self) internal pure returns (string memory) {\n        return styleConcat(BOLD, self);\n    }\n\n    function bold(uint256 self) internal pure returns (string memory) {\n        return bold(vm.toString(self));\n    }\n\n    function bold(int256 self) internal pure returns (string memory) {\n        return bold(vm.toString(self));\n    }\n\n    function bold(address self) internal pure returns (string memory) {\n        return bold(vm.toString(self));\n    }\n\n    function bold(bool self) internal pure returns (string memory) {\n        return bold(vm.toString(self));\n    }\n\n    function boldBytes(bytes memory self) internal pure returns (string memory) {\n        return bold(vm.toString(self));\n    }\n\n    function boldBytes32(bytes32 self) internal pure returns (string memory) {\n        return bold(vm.toString(self));\n    }\n\n    function dim(string memory self) internal pure returns (string memory) {\n        return styleConcat(DIM, self);\n    }\n\n    function dim(uint256 self) internal pure returns (string memory) {\n        return dim(vm.toString(self));\n    }\n\n    function dim(int256 self) internal pure returns (string memory) {\n        return dim(vm.toString(self));\n    }\n\n    function dim(address self) internal pure returns (string memory) {\n        return dim(vm.toString(self));\n    }\n\n    function dim(bool self) internal pure returns (string memory) {\n        return dim(vm.toString(self));\n    }\n\n    function dimBytes(bytes memory self) internal pure returns (string memory) {\n        return dim(vm.toString(self));\n    }\n\n    function dimBytes32(bytes32 self) internal pure returns (string memory) {\n        return dim(vm.toString(self));\n    }\n\n    function italic(string memory self) internal pure returns (string memory) {\n        return styleConcat(ITALIC, self);\n    }\n\n    function italic(uint256 self) internal pure returns (string memory) {\n        return italic(vm.toString(self));\n    }\n\n    function italic(int256 self) internal pure returns (string memory) {\n        return italic(vm.toString(self));\n    }\n\n    function italic(address self) internal pure returns (string memory) {\n        return italic(vm.toString(self));\n    }\n\n    function italic(bool self) internal pure returns (string memory) {\n        return italic(vm.toString(self));\n    }\n\n    function italicBytes(bytes memory self) internal pure returns (string memory) {\n        return italic(vm.toString(self));\n    }\n\n    function italicBytes32(bytes32 self) internal pure returns (string memory) {\n        return italic(vm.toString(self));\n    }\n\n    function underline(string memory self) internal pure returns (string memory) {\n        return styleConcat(UNDERLINE, self);\n    }\n\n    function underline(uint256 self) internal pure returns (string memory) {\n        return underline(vm.toString(self));\n    }\n\n    function underline(int256 self) internal pure returns (string memory) {\n        return underline(vm.toString(self));\n    }\n\n    function underline(address self) internal pure returns (string memory) {\n        return underline(vm.toString(self));\n    }\n\n    function underline(bool self) internal pure returns (string memory) {\n        return underline(vm.toString(self));\n    }\n\n    function underlineBytes(bytes memory self) internal pure returns (string memory) {\n        return underline(vm.toString(self));\n    }\n\n    function underlineBytes32(bytes32 self) internal pure returns (string memory) {\n        return underline(vm.toString(self));\n    }\n\n    function inverse(string memory self) internal pure returns (string memory) {\n        return styleConcat(INVERSE, self);\n    }\n\n    function inverse(uint256 self) internal pure returns (string memory) {\n        return inverse(vm.toString(self));\n    }\n\n    function inverse(int256 self) internal pure returns (string memory) {\n        return inverse(vm.toString(self));\n    }\n\n    function inverse(address self) internal pure returns (string memory) {\n        return inverse(vm.toString(self));\n    }\n\n    function inverse(bool self) internal pure returns (string memory) {\n        return inverse(vm.toString(self));\n    }\n\n    function inverseBytes(bytes memory self) internal pure returns (string memory) {\n        return inverse(vm.toString(self));\n    }\n\n    function inverseBytes32(bytes32 self) internal pure returns (string memory) {\n        return inverse(vm.toString(self));\n    }\n}\n"},"lib/forge-std/src/StdToml.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity >=0.6.0 <0.9.0;\n\npragma experimental ABIEncoderV2;\n\nimport {VmSafe} from \"./Vm.sol\";\n\n// Helpers for parsing and writing TOML files\n// To parse:\n// ```\n// using stdToml for string;\n// string memory toml = vm.readFile(\"<some_path>\");\n// toml.readUint(\"<json_path>\");\n// ```\n// To write:\n// ```\n// using stdToml for string;\n// string memory json = \"json\";\n// json.serialize(\"a\", uint256(123));\n// string memory semiFinal = json.serialize(\"b\", string(\"test\"));\n// string memory finalJson = json.serialize(\"c\", semiFinal);\n// finalJson.write(\"<some_path>\");\n// ```\n\nlibrary stdToml {\n    VmSafe private constant vm = VmSafe(address(uint160(uint256(keccak256(\"hevm cheat code\")))));\n\n    function keyExists(string memory toml, string memory key) internal view returns (bool) {\n        return vm.keyExistsToml(toml, key);\n    }\n\n    function parseRaw(string memory toml, string memory key) internal pure returns (bytes memory) {\n        return vm.parseToml(toml, key);\n    }\n\n    function readUint(string memory toml, string memory key) internal pure returns (uint256) {\n        return vm.parseTomlUint(toml, key);\n    }\n\n    function readUintArray(string memory toml, string memory key) internal pure returns (uint256[] memory) {\n        return vm.parseTomlUintArray(toml, key);\n    }\n\n    function readInt(string memory toml, string memory key) internal pure returns (int256) {\n        return vm.parseTomlInt(toml, key);\n    }\n\n    function readIntArray(string memory toml, string memory key) internal pure returns (int256[] memory) {\n        return vm.parseTomlIntArray(toml, key);\n    }\n\n    function readBytes32(string memory toml, string memory key) internal pure returns (bytes32) {\n        return vm.parseTomlBytes32(toml, key);\n    }\n\n    function readBytes32Array(string memory toml, string memory key) internal pure returns (bytes32[] memory) {\n        return vm.parseTomlBytes32Array(toml, key);\n    }\n\n    function readString(string memory toml, string memory key) internal pure returns (string memory) {\n        return vm.parseTomlString(toml, key);\n    }\n\n    function readStringArray(string memory toml, string memory key) internal pure returns (string[] memory) {\n        return vm.parseTomlStringArray(toml, key);\n    }\n\n    function readAddress(string memory toml, string memory key) internal pure returns (address) {\n        return vm.parseTomlAddress(toml, key);\n    }\n\n    function readAddressArray(string memory toml, string memory key) internal pure returns (address[] memory) {\n        return vm.parseTomlAddressArray(toml, key);\n    }\n\n    function readBool(string memory toml, string memory key) internal pure returns (bool) {\n        return vm.parseTomlBool(toml, key);\n    }\n\n    function readBoolArray(string memory toml, string memory key) internal pure returns (bool[] memory) {\n        return vm.parseTomlBoolArray(toml, key);\n    }\n\n    function readBytes(string memory toml, string memory key) internal pure returns (bytes memory) {\n        return vm.parseTomlBytes(toml, key);\n    }\n\n    function readBytesArray(string memory toml, string memory key) internal pure returns (bytes[] memory) {\n        return vm.parseTomlBytesArray(toml, key);\n    }\n\n    function readUintOr(string memory toml, string memory key, uint256 defaultValue) internal view returns (uint256) {\n        return keyExists(toml, key) ? readUint(toml, key) : defaultValue;\n    }\n\n    function readUintArrayOr(string memory toml, string memory key, uint256[] memory defaultValue)\n        internal\n        view\n        returns (uint256[] memory)\n    {\n        return keyExists(toml, key) ? readUintArray(toml, key) : defaultValue;\n    }\n\n    function readIntOr(string memory toml, string memory key, int256 defaultValue) internal view returns (int256) {\n        return keyExists(toml, key) ? readInt(toml, key) : defaultValue;\n    }\n\n    function readIntArrayOr(string memory toml, string memory key, int256[] memory defaultValue)\n        internal\n        view\n        returns (int256[] memory)\n    {\n        return keyExists(toml, key) ? readIntArray(toml, key) : defaultValue;\n    }\n\n    function readBytes32Or(string memory toml, string memory key, bytes32 defaultValue)\n        internal\n        view\n        returns (bytes32)\n    {\n        return keyExists(toml, key) ? readBytes32(toml, key) : defaultValue;\n    }\n\n    function readBytes32ArrayOr(string memory toml, string memory key, bytes32[] memory defaultValue)\n        internal\n        view\n        returns (bytes32[] memory)\n    {\n        return keyExists(toml, key) ? readBytes32Array(toml, key) : defaultValue;\n    }\n\n    function readStringOr(string memory toml, string memory key, string memory defaultValue)\n        internal\n        view\n        returns (string memory)\n    {\n        return keyExists(toml, key) ? readString(toml, key) : defaultValue;\n    }\n\n    function readStringArrayOr(string memory toml, string memory key, string[] memory defaultValue)\n        internal\n        view\n        returns (string[] memory)\n    {\n        return keyExists(toml, key) ? readStringArray(toml, key) : defaultValue;\n    }\n\n    function readAddressOr(string memory toml, string memory key, address defaultValue)\n        internal\n        view\n        returns (address)\n    {\n        return keyExists(toml, key) ? readAddress(toml, key) : defaultValue;\n    }\n\n    function readAddressArrayOr(string memory toml, string memory key, address[] memory defaultValue)\n        internal\n        view\n        returns (address[] memory)\n    {\n        return keyExists(toml, key) ? readAddressArray(toml, key) : defaultValue;\n    }\n\n    function readBoolOr(string memory toml, string memory key, bool defaultValue) internal view returns (bool) {\n        return keyExists(toml, key) ? readBool(toml, key) : defaultValue;\n    }\n\n    function readBoolArrayOr(string memory toml, string memory key, bool[] memory defaultValue)\n        internal\n        view\n        returns (bool[] memory)\n    {\n        return keyExists(toml, key) ? readBoolArray(toml, key) : defaultValue;\n    }\n\n    function readBytesOr(string memory toml, string memory key, bytes memory defaultValue)\n        internal\n        view\n        returns (bytes memory)\n    {\n        return keyExists(toml, key) ? readBytes(toml, key) : defaultValue;\n    }\n\n    function readBytesArrayOr(string memory toml, string memory key, bytes[] memory defaultValue)\n        internal\n        view\n        returns (bytes[] memory)\n    {\n        return keyExists(toml, key) ? readBytesArray(toml, key) : defaultValue;\n    }\n\n    function serialize(string memory jsonKey, string memory rootObject) internal returns (string memory) {\n        return vm.serializeJson(jsonKey, rootObject);\n    }\n\n    function serialize(string memory jsonKey, string memory key, bool value) internal returns (string memory) {\n        return vm.serializeBool(jsonKey, key, value);\n    }\n\n    function serialize(string memory jsonKey, string memory key, bool[] memory value)\n        internal\n        returns (string memory)\n    {\n        return vm.serializeBool(jsonKey, key, value);\n    }\n\n    function serialize(string memory jsonKey, string memory key, uint256 value) internal returns (string memory) {\n        return vm.serializeUint(jsonKey, key, value);\n    }\n\n    function serialize(string memory jsonKey, string memory key, uint256[] memory value)\n        internal\n        returns (string memory)\n    {\n        return vm.serializeUint(jsonKey, key, value);\n    }\n\n    function serialize(string memory jsonKey, string memory key, int256 value) internal returns (string memory) {\n        return vm.serializeInt(jsonKey, key, value);\n    }\n\n    function serialize(string memory jsonKey, string memory key, int256[] memory value)\n        internal\n        returns (string memory)\n    {\n        return vm.serializeInt(jsonKey, key, value);\n    }\n\n    function serialize(string memory jsonKey, string memory key, address value) internal returns (string memory) {\n        return vm.serializeAddress(jsonKey, key, value);\n    }\n\n    function serialize(string memory jsonKey, string memory key, address[] memory value)\n        internal\n        returns (string memory)\n    {\n        return vm.serializeAddress(jsonKey, key, value);\n    }\n\n    function serialize(string memory jsonKey, string memory key, bytes32 value) internal returns (string memory) {\n        return vm.serializeBytes32(jsonKey, key, value);\n    }\n\n    function serialize(string memory jsonKey, string memory key, bytes32[] memory value)\n        internal\n        returns (string memory)\n    {\n        return vm.serializeBytes32(jsonKey, key, value);\n    }\n\n    function serialize(string memory jsonKey, string memory key, bytes memory value) internal returns (string memory) {\n        return vm.serializeBytes(jsonKey, key, value);\n    }\n\n    function serialize(string memory jsonKey, string memory key, bytes[] memory value)\n        internal\n        returns (string memory)\n    {\n        return vm.serializeBytes(jsonKey, key, value);\n    }\n\n    function serialize(string memory jsonKey, string memory key, string memory value)\n        internal\n        returns (string memory)\n    {\n        return vm.serializeString(jsonKey, key, value);\n    }\n\n    function serialize(string memory jsonKey, string memory key, string[] memory value)\n        internal\n        returns (string memory)\n    {\n        return vm.serializeString(jsonKey, key, value);\n    }\n\n    function write(string memory jsonKey, string memory path) internal {\n        vm.writeToml(jsonKey, path);\n    }\n\n    function write(string memory jsonKey, string memory path, string memory valueKey) internal {\n        vm.writeToml(jsonKey, path, valueKey);\n    }\n}\n"},"lib/forge-std/src/StdUtils.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity >=0.6.2 <0.9.0;\n\npragma experimental ABIEncoderV2;\n\nimport {IMulticall3} from \"./interfaces/IMulticall3.sol\";\nimport {VmSafe} from \"./Vm.sol\";\n\nabstract contract StdUtils {\n    /*//////////////////////////////////////////////////////////////////////////\n                                     CONSTANTS\n    //////////////////////////////////////////////////////////////////////////*/\n\n    IMulticall3 private constant multicall = IMulticall3(0xcA11bde05977b3631167028862bE2a173976CA11);\n    VmSafe private constant vm = VmSafe(address(uint160(uint256(keccak256(\"hevm cheat code\")))));\n    address private constant CONSOLE2_ADDRESS = 0x000000000000000000636F6e736F6c652e6c6f67;\n    uint256 private constant INT256_MIN_ABS =\n        57896044618658097711785492504343953926634992332820282019728792003956564819968;\n    uint256 private constant SECP256K1_ORDER =\n        115792089237316195423570985008687907852837564279074904382605163141518161494337;\n    uint256 private constant UINT256_MAX =\n        115792089237316195423570985008687907853269984665640564039457584007913129639935;\n\n    // Used by default when deploying with create2, https://github.com/Arachnid/deterministic-deployment-proxy.\n    address private constant CREATE2_FACTORY = 0x4e59b44847b379578588920cA78FbF26c0B4956C;\n\n    /*//////////////////////////////////////////////////////////////////////////\n                                 INTERNAL FUNCTIONS\n    //////////////////////////////////////////////////////////////////////////*/\n\n    function _bound(uint256 x, uint256 min, uint256 max) internal pure virtual returns (uint256 result) {\n        require(min <= max, \"StdUtils bound(uint256,uint256,uint256): Max is less than min.\");\n        // If x is between min and max, return x directly. This is to ensure that dictionary values\n        // do not get shifted if the min is nonzero. More info: https://github.com/foundry-rs/forge-std/issues/188\n        if (x >= min && x <= max) return x;\n\n        uint256 size = max - min + 1;\n\n        // If the value is 0, 1, 2, 3, wrap that to min, min+1, min+2, min+3. Similarly for the UINT256_MAX side.\n        // This helps ensure coverage of the min/max values.\n        if (x <= 3 && size > x) return min + x;\n        if (x >= UINT256_MAX - 3 && size > UINT256_MAX - x) return max - (UINT256_MAX - x);\n\n        // Otherwise, wrap x into the range [min, max], i.e. the range is inclusive.\n        if (x > max) {\n            uint256 diff = x - max;\n            uint256 rem = diff % size;\n            if (rem == 0) return max;\n            result = min + rem - 1;\n        } else if (x < min) {\n            uint256 diff = min - x;\n            uint256 rem = diff % size;\n            if (rem == 0) return min;\n            result = max - rem + 1;\n        }\n    }\n\n    function bound(uint256 x, uint256 min, uint256 max) internal pure virtual returns (uint256 result) {\n        result = _bound(x, min, max);\n        console2_log_StdUtils(\"Bound result\", result);\n    }\n\n    function _bound(int256 x, int256 min, int256 max) internal pure virtual returns (int256 result) {\n        require(min <= max, \"StdUtils bound(int256,int256,int256): Max is less than min.\");\n\n        // Shifting all int256 values to uint256 to use _bound function. The range of two types are:\n        // int256 : -(2**255) ~ (2**255 - 1)\n        // uint256:     0     ~ (2**256 - 1)\n        // So, add 2**255, INT256_MIN_ABS to the integer values.\n        //\n        // If the given integer value is -2**255, we cannot use `-uint256(-x)` because of the overflow.\n        // So, use `~uint256(x) + 1` instead.\n        uint256 _x = x < 0 ? (INT256_MIN_ABS - ~uint256(x) - 1) : (uint256(x) + INT256_MIN_ABS);\n        uint256 _min = min < 0 ? (INT256_MIN_ABS - ~uint256(min) - 1) : (uint256(min) + INT256_MIN_ABS);\n        uint256 _max = max < 0 ? (INT256_MIN_ABS - ~uint256(max) - 1) : (uint256(max) + INT256_MIN_ABS);\n\n        uint256 y = _bound(_x, _min, _max);\n\n        // To move it back to int256 value, subtract INT256_MIN_ABS at here.\n        result = y < INT256_MIN_ABS ? int256(~(INT256_MIN_ABS - y) + 1) : int256(y - INT256_MIN_ABS);\n    }\n\n    function bound(int256 x, int256 min, int256 max) internal pure virtual returns (int256 result) {\n        result = _bound(x, min, max);\n        console2_log_StdUtils(\"Bound result\", vm.toString(result));\n    }\n\n    function boundPrivateKey(uint256 privateKey) internal pure virtual returns (uint256 result) {\n        result = _bound(privateKey, 1, SECP256K1_ORDER - 1);\n    }\n\n    function bytesToUint(bytes memory b) internal pure virtual returns (uint256) {\n        require(b.length <= 32, \"StdUtils bytesToUint(bytes): Bytes length exceeds 32.\");\n        return abi.decode(abi.encodePacked(new bytes(32 - b.length), b), (uint256));\n    }\n\n    /// @dev Compute the address a contract will be deployed at for a given deployer address and nonce\n    /// @notice adapted from Solmate implementation (https://github.com/Rari-Capital/solmate/blob/main/src/utils/LibRLP.sol)\n    function computeCreateAddress(address deployer, uint256 nonce) internal pure virtual returns (address) {\n        console2_log_StdUtils(\"computeCreateAddress is deprecated. Please use vm.computeCreateAddress instead.\");\n        return vm.computeCreateAddress(deployer, nonce);\n    }\n\n    function computeCreate2Address(bytes32 salt, bytes32 initcodeHash, address deployer)\n        internal\n        pure\n        virtual\n        returns (address)\n    {\n        console2_log_StdUtils(\"computeCreate2Address is deprecated. Please use vm.computeCreate2Address instead.\");\n        return vm.computeCreate2Address(salt, initcodeHash, deployer);\n    }\n\n    /// @dev returns the address of a contract created with CREATE2 using the default CREATE2 deployer\n    function computeCreate2Address(bytes32 salt, bytes32 initCodeHash) internal pure returns (address) {\n        console2_log_StdUtils(\"computeCreate2Address is deprecated. Please use vm.computeCreate2Address instead.\");\n        return vm.computeCreate2Address(salt, initCodeHash);\n    }\n\n    /// @dev returns the hash of the init code (creation code + no args) used in CREATE2 with no constructor arguments\n    /// @param creationCode the creation code of a contract C, as returned by type(C).creationCode\n    function hashInitCode(bytes memory creationCode) internal pure returns (bytes32) {\n        return hashInitCode(creationCode, \"\");\n    }\n\n    /// @dev returns the hash of the init code (creation code + ABI-encoded args) used in CREATE2\n    /// @param creationCode the creation code of a contract C, as returned by type(C).creationCode\n    /// @param args the ABI-encoded arguments to the constructor of C\n    function hashInitCode(bytes memory creationCode, bytes memory args) internal pure returns (bytes32) {\n        return keccak256(abi.encodePacked(creationCode, args));\n    }\n\n    // Performs a single call with Multicall3 to query the ERC-20 token balances of the given addresses.\n    function getTokenBalances(address token, address[] memory addresses)\n        internal\n        virtual\n        returns (uint256[] memory balances)\n    {\n        uint256 tokenCodeSize;\n        assembly {\n            tokenCodeSize := extcodesize(token)\n        }\n        require(tokenCodeSize > 0, \"StdUtils getTokenBalances(address,address[]): Token address is not a contract.\");\n\n        // ABI encode the aggregate call to Multicall3.\n        uint256 length = addresses.length;\n        IMulticall3.Call[] memory calls = new IMulticall3.Call[](length);\n        for (uint256 i = 0; i < length; ++i) {\n            // 0x70a08231 = bytes4(\"balanceOf(address)\"))\n            calls[i] = IMulticall3.Call({target: token, callData: abi.encodeWithSelector(0x70a08231, (addresses[i]))});\n        }\n\n        // Make the aggregate call.\n        (, bytes[] memory returnData) = multicall.aggregate(calls);\n\n        // ABI decode the return data and return the balances.\n        balances = new uint256[](length);\n        for (uint256 i = 0; i < length; ++i) {\n            balances[i] = abi.decode(returnData[i], (uint256));\n        }\n    }\n\n    /*//////////////////////////////////////////////////////////////////////////\n                                 PRIVATE FUNCTIONS\n    //////////////////////////////////////////////////////////////////////////*/\n\n    function addressFromLast20Bytes(bytes32 bytesValue) private pure returns (address) {\n        return address(uint160(uint256(bytesValue)));\n    }\n\n    // This section is used to prevent the compilation of console, which shortens the compilation time when console is\n    // not used elsewhere. We also trick the compiler into letting us make the console log methods as `pure` to avoid\n    // any breaking changes to function signatures.\n    function _castLogPayloadViewToPure(function(bytes memory) internal view fnIn)\n        internal\n        pure\n        returns (function(bytes memory) internal pure fnOut)\n    {\n        assembly {\n            fnOut := fnIn\n        }\n    }\n\n    function _sendLogPayload(bytes memory payload) internal pure {\n        _castLogPayloadViewToPure(_sendLogPayloadView)(payload);\n    }\n\n    function _sendLogPayloadView(bytes memory payload) private view {\n        uint256 payloadLength = payload.length;\n        address consoleAddress = CONSOLE2_ADDRESS;\n        /// @solidity memory-safe-assembly\n        assembly {\n            let payloadStart := add(payload, 32)\n            let r := staticcall(gas(), consoleAddress, payloadStart, payloadLength, 0, 0)\n        }\n    }\n\n    function console2_log_StdUtils(string memory p0) private pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string)\", p0));\n    }\n\n    function console2_log_StdUtils(string memory p0, uint256 p1) private pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint256)\", p0, p1));\n    }\n\n    function console2_log_StdUtils(string memory p0, string memory p1) private pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string)\", p0, p1));\n    }\n}\n"},"lib/forge-std/src/Test.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity >=0.6.2 <0.9.0;\n\npragma experimental ABIEncoderV2;\n\n//  ABOUT\n// Forge Std's default Test.\n\n//  MODULES\nimport {console} from \"./console.sol\";\nimport {console2} from \"./console2.sol\";\nimport {safeconsole} from \"./safeconsole.sol\";\nimport {StdAssertions} from \"./StdAssertions.sol\";\nimport {StdChains} from \"./StdChains.sol\";\nimport {StdCheats} from \"./StdCheats.sol\";\nimport {stdError} from \"./StdError.sol\";\nimport {StdInvariant} from \"./StdInvariant.sol\";\nimport {stdJson} from \"./StdJson.sol\";\nimport {stdMath} from \"./StdMath.sol\";\nimport {StdStorage, stdStorage} from \"./StdStorage.sol\";\nimport {StdStyle} from \"./StdStyle.sol\";\nimport {stdToml} from \"./StdToml.sol\";\nimport {StdUtils} from \"./StdUtils.sol\";\nimport {Vm} from \"./Vm.sol\";\n\n//  BOILERPLATE\nimport {TestBase} from \"./Base.sol\";\n\n//  TEST\nabstract contract Test is TestBase, StdAssertions, StdChains, StdCheats, StdInvariant, StdUtils {\n    // Note: IS_TEST() must return true.\n    bool public IS_TEST = true;\n}\n"},"lib/forge-std/src/Vm.sol":{"content":"// Automatically @generated by scripts/vm.py. Do not modify manually.\n\n// SPDX-License-Identifier: MIT OR Apache-2.0\npragma solidity >=0.6.2 <0.9.0;\npragma experimental ABIEncoderV2;\n\n/// The `VmSafe` interface does not allow manipulation of the EVM state or other actions that may\n/// result in Script simulations differing from on-chain execution. It is recommended to only use\n/// these cheats in scripts.\ninterface VmSafe {\n    /// A modification applied to either `msg.sender` or `tx.origin`. Returned by `readCallers`.\n    enum CallerMode {\n        // No caller modification is currently active.\n        None,\n        // A one time broadcast triggered by a `vm.broadcast()` call is currently active.\n        Broadcast,\n        // A recurrent broadcast triggered by a `vm.startBroadcast()` call is currently active.\n        RecurrentBroadcast,\n        // A one time prank triggered by a `vm.prank()` call is currently active.\n        Prank,\n        // A recurrent prank triggered by a `vm.startPrank()` call is currently active.\n        RecurrentPrank\n    }\n\n    /// The kind of account access that occurred.\n    enum AccountAccessKind {\n        // The account was called.\n        Call,\n        // The account was called via delegatecall.\n        DelegateCall,\n        // The account was called via callcode.\n        CallCode,\n        // The account was called via staticcall.\n        StaticCall,\n        // The account was created.\n        Create,\n        // The account was selfdestructed.\n        SelfDestruct,\n        // Synthetic access indicating the current context has resumed after a previous sub-context (AccountAccess).\n        Resume,\n        // The account's balance was read.\n        Balance,\n        // The account's codesize was read.\n        Extcodesize,\n        // The account's codehash was read.\n        Extcodehash,\n        // The account's code was copied.\n        Extcodecopy\n    }\n\n    /// Forge execution contexts.\n    enum ForgeContext {\n        // Test group execution context (test, coverage or snapshot).\n        TestGroup,\n        // `forge test` execution context.\n        Test,\n        // `forge coverage` execution context.\n        Coverage,\n        // `forge snapshot` execution context.\n        Snapshot,\n        // Script group execution context (dry run, broadcast or resume).\n        ScriptGroup,\n        // `forge script` execution context.\n        ScriptDryRun,\n        // `forge script --broadcast` execution context.\n        ScriptBroadcast,\n        // `forge script --resume` execution context.\n        ScriptResume,\n        // Unknown `forge` execution context.\n        Unknown\n    }\n\n    /// The transaction type (`txType`) of the broadcast.\n    enum BroadcastTxType {\n        // Represents a CALL broadcast tx.\n        Call,\n        // Represents a CREATE broadcast tx.\n        Create,\n        // Represents a CREATE2 broadcast tx.\n        Create2\n    }\n\n    /// An Ethereum log. Returned by `getRecordedLogs`.\n    struct Log {\n        // The topics of the log, including the signature, if any.\n        bytes32[] topics;\n        // The raw data of the log.\n        bytes data;\n        // The address of the log's emitter.\n        address emitter;\n    }\n\n    /// An RPC URL and its alias. Returned by `rpcUrlStructs`.\n    struct Rpc {\n        // The alias of the RPC URL.\n        string key;\n        // The RPC URL.\n        string url;\n    }\n\n    /// An RPC log object. Returned by `eth_getLogs`.\n    struct EthGetLogs {\n        // The address of the log's emitter.\n        address emitter;\n        // The topics of the log, including the signature, if any.\n        bytes32[] topics;\n        // The raw data of the log.\n        bytes data;\n        // The block hash.\n        bytes32 blockHash;\n        // The block number.\n        uint64 blockNumber;\n        // The transaction hash.\n        bytes32 transactionHash;\n        // The transaction index in the block.\n        uint64 transactionIndex;\n        // The log index.\n        uint256 logIndex;\n        // Whether the log was removed.\n        bool removed;\n    }\n\n    /// A single entry in a directory listing. Returned by `readDir`.\n    struct DirEntry {\n        // The error message, if any.\n        string errorMessage;\n        // The path of the entry.\n        string path;\n        // The depth of the entry.\n        uint64 depth;\n        // Whether the entry is a directory.\n        bool isDir;\n        // Whether the entry is a symlink.\n        bool isSymlink;\n    }\n\n    /// Metadata information about a file.\n    /// This structure is returned from the `fsMetadata` function and represents known\n    /// metadata about a file such as its permissions, size, modification\n    /// times, etc.\n    struct FsMetadata {\n        // True if this metadata is for a directory.\n        bool isDir;\n        // True if this metadata is for a symlink.\n        bool isSymlink;\n        // The size of the file, in bytes, this metadata is for.\n        uint256 length;\n        // True if this metadata is for a readonly (unwritable) file.\n        bool readOnly;\n        // The last modification time listed in this metadata.\n        uint256 modified;\n        // The last access time of this metadata.\n        uint256 accessed;\n        // The creation time listed in this metadata.\n        uint256 created;\n    }\n\n    /// A wallet with a public and private key.\n    struct Wallet {\n        // The wallet's address.\n        address addr;\n        // The wallet's public key `X`.\n        uint256 publicKeyX;\n        // The wallet's public key `Y`.\n        uint256 publicKeyY;\n        // The wallet's private key.\n        uint256 privateKey;\n    }\n\n    /// The result of a `tryFfi` call.\n    struct FfiResult {\n        // The exit code of the call.\n        int32 exitCode;\n        // The optionally hex-decoded `stdout` data.\n        bytes stdout;\n        // The `stderr` data.\n        bytes stderr;\n    }\n\n    /// Information on the chain and fork.\n    struct ChainInfo {\n        // The fork identifier. Set to zero if no fork is active.\n        uint256 forkId;\n        // The chain ID of the current fork.\n        uint256 chainId;\n    }\n\n    /// The result of a `stopAndReturnStateDiff` call.\n    struct AccountAccess {\n        // The chain and fork the access occurred.\n        ChainInfo chainInfo;\n        // The kind of account access that determines what the account is.\n        // If kind is Call, DelegateCall, StaticCall or CallCode, then the account is the callee.\n        // If kind is Create, then the account is the newly created account.\n        // If kind is SelfDestruct, then the account is the selfdestruct recipient.\n        // If kind is a Resume, then account represents a account context that has resumed.\n        AccountAccessKind kind;\n        // The account that was accessed.\n        // It's either the account created, callee or a selfdestruct recipient for CREATE, CALL or SELFDESTRUCT.\n        address account;\n        // What accessed the account.\n        address accessor;\n        // If the account was initialized or empty prior to the access.\n        // An account is considered initialized if it has code, a\n        // non-zero nonce, or a non-zero balance.\n        bool initialized;\n        // The previous balance of the accessed account.\n        uint256 oldBalance;\n        // The potential new balance of the accessed account.\n        // That is, all balance changes are recorded here, even if reverts occurred.\n        uint256 newBalance;\n        // Code of the account deployed by CREATE.\n        bytes deployedCode;\n        // Value passed along with the account access\n        uint256 value;\n        // Input data provided to the CREATE or CALL\n        bytes data;\n        // If this access reverted in either the current or parent context.\n        bool reverted;\n        // An ordered list of storage accesses made during an account access operation.\n        StorageAccess[] storageAccesses;\n        // Call depth traversed during the recording of state differences\n        uint64 depth;\n    }\n\n    /// The storage accessed during an `AccountAccess`.\n    struct StorageAccess {\n        // The account whose storage was accessed.\n        address account;\n        // The slot that was accessed.\n        bytes32 slot;\n        // If the access was a write.\n        bool isWrite;\n        // The previous value of the slot.\n        bytes32 previousValue;\n        // The new value of the slot.\n        bytes32 newValue;\n        // If the access was reverted.\n        bool reverted;\n    }\n\n    /// Gas used. Returned by `lastCallGas`.\n    struct Gas {\n        // The gas limit of the call.\n        uint64 gasLimit;\n        // The total gas used.\n        uint64 gasTotalUsed;\n        // DEPRECATED: The amount of gas used for memory expansion. Ref: <https://github.com/foundry-rs/foundry/pull/7934#pullrequestreview-2069236939>\n        uint64 gasMemoryUsed;\n        // The amount of gas refunded.\n        int64 gasRefunded;\n        // The amount of gas remaining.\n        uint64 gasRemaining;\n    }\n\n    /// The result of the `stopDebugTraceRecording` call\n    struct DebugStep {\n        // The stack before executing the step of the run.\n        // stack\\[0\\] represents the top of the stack.\n        // and only stack data relevant to the opcode execution is contained.\n        uint256[] stack;\n        // The memory input data before executing the step of the run.\n        // only input data relevant to the opcode execution is contained.\n        // e.g. for MLOAD, it will have memory\\[offset:offset+32\\] copied here.\n        // the offset value can be get by the stack data.\n        bytes memoryInput;\n        // The opcode that was accessed.\n        uint8 opcode;\n        // The call depth of the step.\n        uint64 depth;\n        // Whether the call end up with out of gas error.\n        bool isOutOfGas;\n        // The contract address where the opcode is running\n        address contractAddr;\n    }\n\n    /// Represents a transaction's broadcast details.\n    struct BroadcastTxSummary {\n        // The hash of the transaction that was broadcasted\n        bytes32 txHash;\n        // Represent the type of transaction among CALL, CREATE, CREATE2\n        BroadcastTxType txType;\n        // The address of the contract that was called or created.\n        // This is address of the contract that is created if the txType is CREATE or CREATE2.\n        address contractAddress;\n        // The block number the transaction landed in.\n        uint64 blockNumber;\n        // Status of the transaction, retrieved from the transaction receipt.\n        bool success;\n    }\n\n    /// Holds a signed EIP-7702 authorization for an authority account to delegate to an implementation.\n    struct SignedDelegation {\n        // The y-parity of the recovered secp256k1 signature (0 or 1).\n        uint8 v;\n        // First 32 bytes of the signature.\n        bytes32 r;\n        // Second 32 bytes of the signature.\n        bytes32 s;\n        // The current nonce of the authority account at signing time.\n        // Used to ensure signature can't be replayed after account nonce changes.\n        uint64 nonce;\n        // Address of the contract implementation that will be delegated to.\n        // Gets encoded into delegation code: 0xef0100 || implementation.\n        address implementation;\n    }\n\n    /// Represents a \"potential\" revert reason from a single subsequent call when using `vm.assumeNoReverts`.\n    /// Reverts that match will result in a FOUNDRY::ASSUME rejection, whereas unmatched reverts will be surfaced\n    /// as normal.\n    struct PotentialRevert {\n        // The allowed origin of the revert opcode; address(0) allows reverts from any address\n        address reverter;\n        // When true, only matches on the beginning of the revert data, otherwise, matches on entire revert data\n        bool partialMatch;\n        // The data to use to match encountered reverts\n        bytes revertData;\n    }\n\n    // ======== Crypto ========\n\n    /// Derives a private key from the name, labels the account with that name, and returns the wallet.\n    function createWallet(string calldata walletLabel) external returns (Wallet memory wallet);\n\n    /// Generates a wallet from the private key and returns the wallet.\n    function createWallet(uint256 privateKey) external returns (Wallet memory wallet);\n\n    /// Generates a wallet from the private key, labels the account with that name, and returns the wallet.\n    function createWallet(uint256 privateKey, string calldata walletLabel) external returns (Wallet memory wallet);\n\n    /// Derive a private key from a provided mnenomic string (or mnenomic file path)\n    /// at the derivation path `m/44'/60'/0'/0/{index}`.\n    function deriveKey(string calldata mnemonic, uint32 index) external pure returns (uint256 privateKey);\n\n    /// Derive a private key from a provided mnenomic string (or mnenomic file path)\n    /// at `{derivationPath}{index}`.\n    function deriveKey(string calldata mnemonic, string calldata derivationPath, uint32 index)\n        external\n        pure\n        returns (uint256 privateKey);\n\n    /// Derive a private key from a provided mnenomic string (or mnenomic file path) in the specified language\n    /// at the derivation path `m/44'/60'/0'/0/{index}`.\n    function deriveKey(string calldata mnemonic, uint32 index, string calldata language)\n        external\n        pure\n        returns (uint256 privateKey);\n\n    /// Derive a private key from a provided mnenomic string (or mnenomic file path) in the specified language\n    /// at `{derivationPath}{index}`.\n    function deriveKey(string calldata mnemonic, string calldata derivationPath, uint32 index, string calldata language)\n        external\n        pure\n        returns (uint256 privateKey);\n\n    /// Derives secp256r1 public key from the provided `privateKey`.\n    function publicKeyP256(uint256 privateKey) external pure returns (uint256 publicKeyX, uint256 publicKeyY);\n\n    /// Adds a private key to the local forge wallet and returns the address.\n    function rememberKey(uint256 privateKey) external returns (address keyAddr);\n\n    /// Derive a set number of wallets from a mnemonic at the derivation path `m/44'/60'/0'/0/{0..count}`.\n    /// The respective private keys are saved to the local forge wallet for later use and their addresses are returned.\n    function rememberKeys(string calldata mnemonic, string calldata derivationPath, uint32 count)\n        external\n        returns (address[] memory keyAddrs);\n\n    /// Derive a set number of wallets from a mnemonic in the specified language at the derivation path `m/44'/60'/0'/0/{0..count}`.\n    /// The respective private keys are saved to the local forge wallet for later use and their addresses are returned.\n    function rememberKeys(\n        string calldata mnemonic,\n        string calldata derivationPath,\n        string calldata language,\n        uint32 count\n    ) external returns (address[] memory keyAddrs);\n\n    /// Signs data with a `Wallet`.\n    /// Returns a compact signature (`r`, `vs`) as per EIP-2098, where `vs` encodes both the\n    /// signature's `s` value, and the recovery id `v` in a single bytes32.\n    /// This format reduces the signature size from 65 to 64 bytes.\n    function signCompact(Wallet calldata wallet, bytes32 digest) external returns (bytes32 r, bytes32 vs);\n\n    /// Signs `digest` with `privateKey` using the secp256k1 curve.\n    /// Returns a compact signature (`r`, `vs`) as per EIP-2098, where `vs` encodes both the\n    /// signature's `s` value, and the recovery id `v` in a single bytes32.\n    /// This format reduces the signature size from 65 to 64 bytes.\n    function signCompact(uint256 privateKey, bytes32 digest) external pure returns (bytes32 r, bytes32 vs);\n\n    /// Signs `digest` with signer provided to script using the secp256k1 curve.\n    /// Returns a compact signature (`r`, `vs`) as per EIP-2098, where `vs` encodes both the\n    /// signature's `s` value, and the recovery id `v` in a single bytes32.\n    /// This format reduces the signature size from 65 to 64 bytes.\n    /// If `--sender` is provided, the signer with provided address is used, otherwise,\n    /// if exactly one signer is provided to the script, that signer is used.\n    /// Raises error if signer passed through `--sender` does not match any unlocked signers or\n    /// if `--sender` is not provided and not exactly one signer is passed to the script.\n    function signCompact(bytes32 digest) external pure returns (bytes32 r, bytes32 vs);\n\n    /// Signs `digest` with signer provided to script using the secp256k1 curve.\n    /// Returns a compact signature (`r`, `vs`) as per EIP-2098, where `vs` encodes both the\n    /// signature's `s` value, and the recovery id `v` in a single bytes32.\n    /// This format reduces the signature size from 65 to 64 bytes.\n    /// Raises error if none of the signers passed into the script have provided address.\n    function signCompact(address signer, bytes32 digest) external pure returns (bytes32 r, bytes32 vs);\n\n    /// Signs `digest` with `privateKey` using the secp256r1 curve.\n    function signP256(uint256 privateKey, bytes32 digest) external pure returns (bytes32 r, bytes32 s);\n\n    /// Signs data with a `Wallet`.\n    function sign(Wallet calldata wallet, bytes32 digest) external returns (uint8 v, bytes32 r, bytes32 s);\n\n    /// Signs `digest` with `privateKey` using the secp256k1 curve.\n    function sign(uint256 privateKey, bytes32 digest) external pure returns (uint8 v, bytes32 r, bytes32 s);\n\n    /// Signs `digest` with signer provided to script using the secp256k1 curve.\n    /// If `--sender` is provided, the signer with provided address is used, otherwise,\n    /// if exactly one signer is provided to the script, that signer is used.\n    /// Raises error if signer passed through `--sender` does not match any unlocked signers or\n    /// if `--sender` is not provided and not exactly one signer is passed to the script.\n    function sign(bytes32 digest) external pure returns (uint8 v, bytes32 r, bytes32 s);\n\n    /// Signs `digest` with signer provided to script using the secp256k1 curve.\n    /// Raises error if none of the signers passed into the script have provided address.\n    function sign(address signer, bytes32 digest) external pure returns (uint8 v, bytes32 r, bytes32 s);\n\n    // ======== Environment ========\n\n    /// Gets the environment variable `name` and parses it as `address`.\n    /// Reverts if the variable was not found or could not be parsed.\n    function envAddress(string calldata name) external view returns (address value);\n\n    /// Gets the environment variable `name` and parses it as an array of `address`, delimited by `delim`.\n    /// Reverts if the variable was not found or could not be parsed.\n    function envAddress(string calldata name, string calldata delim) external view returns (address[] memory value);\n\n    /// Gets the environment variable `name` and parses it as `bool`.\n    /// Reverts if the variable was not found or could not be parsed.\n    function envBool(string calldata name) external view returns (bool value);\n\n    /// Gets the environment variable `name` and parses it as an array of `bool`, delimited by `delim`.\n    /// Reverts if the variable was not found or could not be parsed.\n    function envBool(string calldata name, string calldata delim) external view returns (bool[] memory value);\n\n    /// Gets the environment variable `name` and parses it as `bytes32`.\n    /// Reverts if the variable was not found or could not be parsed.\n    function envBytes32(string calldata name) external view returns (bytes32 value);\n\n    /// Gets the environment variable `name` and parses it as an array of `bytes32`, delimited by `delim`.\n    /// Reverts if the variable was not found or could not be parsed.\n    function envBytes32(string calldata name, string calldata delim) external view returns (bytes32[] memory value);\n\n    /// Gets the environment variable `name` and parses it as `bytes`.\n    /// Reverts if the variable was not found or could not be parsed.\n    function envBytes(string calldata name) external view returns (bytes memory value);\n\n    /// Gets the environment variable `name` and parses it as an array of `bytes`, delimited by `delim`.\n    /// Reverts if the variable was not found or could not be parsed.\n    function envBytes(string calldata name, string calldata delim) external view returns (bytes[] memory value);\n\n    /// Gets the environment variable `name` and returns true if it exists, else returns false.\n    function envExists(string calldata name) external view returns (bool result);\n\n    /// Gets the environment variable `name` and parses it as `int256`.\n    /// Reverts if the variable was not found or could not be parsed.\n    function envInt(string calldata name) external view returns (int256 value);\n\n    /// Gets the environment variable `name` and parses it as an array of `int256`, delimited by `delim`.\n    /// Reverts if the variable was not found or could not be parsed.\n    function envInt(string calldata name, string calldata delim) external view returns (int256[] memory value);\n\n    /// Gets the environment variable `name` and parses it as `bool`.\n    /// Reverts if the variable could not be parsed.\n    /// Returns `defaultValue` if the variable was not found.\n    function envOr(string calldata name, bool defaultValue) external view returns (bool value);\n\n    /// Gets the environment variable `name` and parses it as `uint256`.\n    /// Reverts if the variable could not be parsed.\n    /// Returns `defaultValue` if the variable was not found.\n    function envOr(string calldata name, uint256 defaultValue) external view returns (uint256 value);\n\n    /// Gets the environment variable `name` and parses it as an array of `address`, delimited by `delim`.\n    /// Reverts if the variable could not be parsed.\n    /// Returns `defaultValue` if the variable was not found.\n    function envOr(string calldata name, string calldata delim, address[] calldata defaultValue)\n        external\n        view\n        returns (address[] memory value);\n\n    /// Gets the environment variable `name` and parses it as an array of `bytes32`, delimited by `delim`.\n    /// Reverts if the variable could not be parsed.\n    /// Returns `defaultValue` if the variable was not found.\n    function envOr(string calldata name, string calldata delim, bytes32[] calldata defaultValue)\n        external\n        view\n        returns (bytes32[] memory value);\n\n    /// Gets the environment variable `name` and parses it as an array of `string`, delimited by `delim`.\n    /// Reverts if the variable could not be parsed.\n    /// Returns `defaultValue` if the variable was not found.\n    function envOr(string calldata name, string calldata delim, string[] calldata defaultValue)\n        external\n        view\n        returns (string[] memory value);\n\n    /// Gets the environment variable `name` and parses it as an array of `bytes`, delimited by `delim`.\n    /// Reverts if the variable could not be parsed.\n    /// Returns `defaultValue` if the variable was not found.\n    function envOr(string calldata name, string calldata delim, bytes[] calldata defaultValue)\n        external\n        view\n        returns (bytes[] memory value);\n\n    /// Gets the environment variable `name` and parses it as `int256`.\n    /// Reverts if the variable could not be parsed.\n    /// Returns `defaultValue` if the variable was not found.\n    function envOr(string calldata name, int256 defaultValue) external view returns (int256 value);\n\n    /// Gets the environment variable `name` and parses it as `address`.\n    /// Reverts if the variable could not be parsed.\n    /// Returns `defaultValue` if the variable was not found.\n    function envOr(string calldata name, address defaultValue) external view returns (address value);\n\n    /// Gets the environment variable `name` and parses it as `bytes32`.\n    /// Reverts if the variable could not be parsed.\n    /// Returns `defaultValue` if the variable was not found.\n    function envOr(string calldata name, bytes32 defaultValue) external view returns (bytes32 value);\n\n    /// Gets the environment variable `name` and parses it as `string`.\n    /// Reverts if the variable could not be parsed.\n    /// Returns `defaultValue` if the variable was not found.\n    function envOr(string calldata name, string calldata defaultValue) external view returns (string memory value);\n\n    /// Gets the environment variable `name` and parses it as `bytes`.\n    /// Reverts if the variable could not be parsed.\n    /// Returns `defaultValue` if the variable was not found.\n    function envOr(string calldata name, bytes calldata defaultValue) external view returns (bytes memory value);\n\n    /// Gets the environment variable `name` and parses it as an array of `bool`, delimited by `delim`.\n    /// Reverts if the variable could not be parsed.\n    /// Returns `defaultValue` if the variable was not found.\n    function envOr(string calldata name, string calldata delim, bool[] calldata defaultValue)\n        external\n        view\n        returns (bool[] memory value);\n\n    /// Gets the environment variable `name` and parses it as an array of `uint256`, delimited by `delim`.\n    /// Reverts if the variable could not be parsed.\n    /// Returns `defaultValue` if the variable was not found.\n    function envOr(string calldata name, string calldata delim, uint256[] calldata defaultValue)\n        external\n        view\n        returns (uint256[] memory value);\n\n    /// Gets the environment variable `name` and parses it as an array of `int256`, delimited by `delim`.\n    /// Reverts if the variable could not be parsed.\n    /// Returns `defaultValue` if the variable was not found.\n    function envOr(string calldata name, string calldata delim, int256[] calldata defaultValue)\n        external\n        view\n        returns (int256[] memory value);\n\n    /// Gets the environment variable `name` and parses it as `string`.\n    /// Reverts if the variable was not found or could not be parsed.\n    function envString(string calldata name) external view returns (string memory value);\n\n    /// Gets the environment variable `name` and parses it as an array of `string`, delimited by `delim`.\n    /// Reverts if the variable was not found or could not be parsed.\n    function envString(string calldata name, string calldata delim) external view returns (string[] memory value);\n\n    /// Gets the environment variable `name` and parses it as `uint256`.\n    /// Reverts if the variable was not found or could not be parsed.\n    function envUint(string calldata name) external view returns (uint256 value);\n\n    /// Gets the environment variable `name` and parses it as an array of `uint256`, delimited by `delim`.\n    /// Reverts if the variable was not found or could not be parsed.\n    function envUint(string calldata name, string calldata delim) external view returns (uint256[] memory value);\n\n    /// Returns true if `forge` command was executed in given context.\n    function isContext(ForgeContext context) external view returns (bool result);\n\n    /// Sets environment variables.\n    function setEnv(string calldata name, string calldata value) external;\n\n    // ======== EVM ========\n\n    /// Gets all accessed reads and write slot from a `vm.record` session, for a given address.\n    function accesses(address target) external returns (bytes32[] memory readSlots, bytes32[] memory writeSlots);\n\n    /// Gets the address for a given private key.\n    function addr(uint256 privateKey) external pure returns (address keyAddr);\n\n    /// Gets all the logs according to specified filter.\n    function eth_getLogs(uint256 fromBlock, uint256 toBlock, address target, bytes32[] calldata topics)\n        external\n        returns (EthGetLogs[] memory logs);\n\n    /// Gets the current `block.blobbasefee`.\n    /// You should use this instead of `block.blobbasefee` if you use `vm.blobBaseFee`, as `block.blobbasefee` is assumed to be constant across a transaction,\n    /// and as a result will get optimized out by the compiler.\n    /// See https://github.com/foundry-rs/foundry/issues/6180\n    function getBlobBaseFee() external view returns (uint256 blobBaseFee);\n\n    /// Gets the current `block.number`.\n    /// You should use this instead of `block.number` if you use `vm.roll`, as `block.number` is assumed to be constant across a transaction,\n    /// and as a result will get optimized out by the compiler.\n    /// See https://github.com/foundry-rs/foundry/issues/6180\n    function getBlockNumber() external view returns (uint256 height);\n\n    /// Gets the current `block.timestamp`.\n    /// You should use this instead of `block.timestamp` if you use `vm.warp`, as `block.timestamp` is assumed to be constant across a transaction,\n    /// and as a result will get optimized out by the compiler.\n    /// See https://github.com/foundry-rs/foundry/issues/6180\n    function getBlockTimestamp() external view returns (uint256 timestamp);\n\n    /// Gets the map key and parent of a mapping at a given slot, for a given address.\n    function getMappingKeyAndParentOf(address target, bytes32 elementSlot)\n        external\n        returns (bool found, bytes32 key, bytes32 parent);\n\n    /// Gets the number of elements in the mapping at the given slot, for a given address.\n    function getMappingLength(address target, bytes32 mappingSlot) external returns (uint256 length);\n\n    /// Gets the elements at index idx of the mapping at the given slot, for a given address. The\n    /// index must be less than the length of the mapping (i.e. the number of keys in the mapping).\n    function getMappingSlotAt(address target, bytes32 mappingSlot, uint256 idx) external returns (bytes32 value);\n\n    /// Gets the nonce of an account.\n    function getNonce(address account) external view returns (uint64 nonce);\n\n    /// Get the nonce of a `Wallet`.\n    function getNonce(Wallet calldata wallet) external returns (uint64 nonce);\n\n    /// Gets all the recorded logs.\n    function getRecordedLogs() external returns (Log[] memory logs);\n\n    /// Returns state diffs from current `vm.startStateDiffRecording` session.\n    function getStateDiff() external view returns (string memory diff);\n\n    /// Returns state diffs from current `vm.startStateDiffRecording` session, in json format.\n    function getStateDiffJson() external view returns (string memory diff);\n\n    /// Gets the gas used in the last call from the callee perspective.\n    function lastCallGas() external view returns (Gas memory gas);\n\n    /// Loads a storage slot from an address.\n    function load(address target, bytes32 slot) external view returns (bytes32 data);\n\n    /// Pauses gas metering (i.e. gas usage is not counted). Noop if already paused.\n    function pauseGasMetering() external;\n\n    /// Records all storage reads and writes.\n    function record() external;\n\n    /// Record all the transaction logs.\n    function recordLogs() external;\n\n    /// Reset gas metering (i.e. gas usage is set to gas limit).\n    function resetGasMetering() external;\n\n    /// Resumes gas metering (i.e. gas usage is counted again). Noop if already on.\n    function resumeGasMetering() external;\n\n    /// Performs an Ethereum JSON-RPC request to the current fork URL.\n    function rpc(string calldata method, string calldata params) external returns (bytes memory data);\n\n    /// Performs an Ethereum JSON-RPC request to the given endpoint.\n    function rpc(string calldata urlOrAlias, string calldata method, string calldata params)\n        external\n        returns (bytes memory data);\n\n    /// Records the debug trace during the run.\n    function startDebugTraceRecording() external;\n\n    /// Starts recording all map SSTOREs for later retrieval.\n    function startMappingRecording() external;\n\n    /// Record all account accesses as part of CREATE, CALL or SELFDESTRUCT opcodes in order,\n    /// along with the context of the calls\n    function startStateDiffRecording() external;\n\n    /// Stop debug trace recording and returns the recorded debug trace.\n    function stopAndReturnDebugTraceRecording() external returns (DebugStep[] memory step);\n\n    /// Returns an ordered array of all account accesses from a `vm.startStateDiffRecording` session.\n    function stopAndReturnStateDiff() external returns (AccountAccess[] memory accountAccesses);\n\n    /// Stops recording all map SSTOREs for later retrieval and clears the recorded data.\n    function stopMappingRecording() external;\n\n    // ======== Filesystem ========\n\n    /// Closes file for reading, resetting the offset and allowing to read it from beginning with readLine.\n    /// `path` is relative to the project root.\n    function closeFile(string calldata path) external;\n\n    /// Copies the contents of one file to another. This function will **overwrite** the contents of `to`.\n    /// On success, the total number of bytes copied is returned and it is equal to the length of the `to` file as reported by `metadata`.\n    /// Both `from` and `to` are relative to the project root.\n    function copyFile(string calldata from, string calldata to) external returns (uint64 copied);\n\n    /// Creates a new, empty directory at the provided path.\n    /// This cheatcode will revert in the following situations, but is not limited to just these cases:\n    /// - User lacks permissions to modify `path`.\n    /// - A parent of the given path doesn't exist and `recursive` is false.\n    /// - `path` already exists and `recursive` is false.\n    /// `path` is relative to the project root.\n    function createDir(string calldata path, bool recursive) external;\n\n    /// Deploys a contract from an artifact file. Takes in the relative path to the json file or the path to the\n    /// artifact in the form of <path>:<contract>:<version> where <contract> and <version> parts are optional.\n    function deployCode(string calldata artifactPath) external returns (address deployedAddress);\n\n    /// Deploys a contract from an artifact file. Takes in the relative path to the json file or the path to the\n    /// artifact in the form of <path>:<contract>:<version> where <contract> and <version> parts are optional.\n    /// Additionally accepts abi-encoded constructor arguments.\n    function deployCode(string calldata artifactPath, bytes calldata constructorArgs)\n        external\n        returns (address deployedAddress);\n\n    /// Returns true if the given path points to an existing entity, else returns false.\n    function exists(string calldata path) external view returns (bool result);\n\n    /// Performs a foreign function call via the terminal.\n    function ffi(string[] calldata commandInput) external returns (bytes memory result);\n\n    /// Given a path, query the file system to get information about a file, directory, etc.\n    function fsMetadata(string calldata path) external view returns (FsMetadata memory metadata);\n\n    /// Gets the artifact path from code (aka. creation code).\n    function getArtifactPathByCode(bytes calldata code) external view returns (string memory path);\n\n    /// Gets the artifact path from deployed code (aka. runtime code).\n    function getArtifactPathByDeployedCode(bytes calldata deployedCode) external view returns (string memory path);\n\n    /// Returns the most recent broadcast for the given contract on `chainId` matching `txType`.\n    /// For example:\n    /// The most recent deployment can be fetched by passing `txType` as `CREATE` or `CREATE2`.\n    /// The most recent call can be fetched by passing `txType` as `CALL`.\n    function getBroadcast(string calldata contractName, uint64 chainId, BroadcastTxType txType)\n        external\n        view\n        returns (BroadcastTxSummary memory);\n\n    /// Returns all broadcasts for the given contract on `chainId` with the specified `txType`.\n    /// Sorted such that the most recent broadcast is the first element, and the oldest is the last. i.e descending order of BroadcastTxSummary.blockNumber.\n    function getBroadcasts(string calldata contractName, uint64 chainId, BroadcastTxType txType)\n        external\n        view\n        returns (BroadcastTxSummary[] memory);\n\n    /// Returns all broadcasts for the given contract on `chainId`.\n    /// Sorted such that the most recent broadcast is the first element, and the oldest is the last. i.e descending order of BroadcastTxSummary.blockNumber.\n    function getBroadcasts(string calldata contractName, uint64 chainId)\n        external\n        view\n        returns (BroadcastTxSummary[] memory);\n\n    /// Gets the creation bytecode from an artifact file. Takes in the relative path to the json file or the path to the\n    /// artifact in the form of <path>:<contract>:<version> where <contract> and <version> parts are optional.\n    function getCode(string calldata artifactPath) external view returns (bytes memory creationBytecode);\n\n    /// Gets the deployed bytecode from an artifact file. Takes in the relative path to the json file or the path to the\n    /// artifact in the form of <path>:<contract>:<version> where <contract> and <version> parts are optional.\n    function getDeployedCode(string calldata artifactPath) external view returns (bytes memory runtimeBytecode);\n\n    /// Returns the most recent deployment for the current `chainId`.\n    function getDeployment(string calldata contractName) external view returns (address deployedAddress);\n\n    /// Returns the most recent deployment for the given contract on `chainId`\n    function getDeployment(string calldata contractName, uint64 chainId)\n        external\n        view\n        returns (address deployedAddress);\n\n    /// Returns all deployments for the given contract on `chainId`\n    /// Sorted in descending order of deployment time i.e descending order of BroadcastTxSummary.blockNumber.\n    /// The most recent deployment is the first element, and the oldest is the last.\n    function getDeployments(string calldata contractName, uint64 chainId)\n        external\n        view\n        returns (address[] memory deployedAddresses);\n\n    /// Returns true if the path exists on disk and is pointing at a directory, else returns false.\n    function isDir(string calldata path) external view returns (bool result);\n\n    /// Returns true if the path exists on disk and is pointing at a regular file, else returns false.\n    function isFile(string calldata path) external view returns (bool result);\n\n    /// Get the path of the current project root.\n    function projectRoot() external view returns (string memory path);\n\n    /// Prompts the user for a string value in the terminal.\n    function prompt(string calldata promptText) external returns (string memory input);\n\n    /// Prompts the user for an address in the terminal.\n    function promptAddress(string calldata promptText) external returns (address);\n\n    /// Prompts the user for a hidden string value in the terminal.\n    function promptSecret(string calldata promptText) external returns (string memory input);\n\n    /// Prompts the user for hidden uint256 in the terminal (usually pk).\n    function promptSecretUint(string calldata promptText) external returns (uint256);\n\n    /// Prompts the user for uint256 in the terminal.\n    function promptUint(string calldata promptText) external returns (uint256);\n\n    /// Reads the directory at the given path recursively, up to `maxDepth`.\n    /// `maxDepth` defaults to 1, meaning only the direct children of the given directory will be returned.\n    /// Follows symbolic links if `followLinks` is true.\n    function readDir(string calldata path) external view returns (DirEntry[] memory entries);\n\n    /// See `readDir(string)`.\n    function readDir(string calldata path, uint64 maxDepth) external view returns (DirEntry[] memory entries);\n\n    /// See `readDir(string)`.\n    function readDir(string calldata path, uint64 maxDepth, bool followLinks)\n        external\n        view\n        returns (DirEntry[] memory entries);\n\n    /// Reads the entire content of file to string. `path` is relative to the project root.\n    function readFile(string calldata path) external view returns (string memory data);\n\n    /// Reads the entire content of file as binary. `path` is relative to the project root.\n    function readFileBinary(string calldata path) external view returns (bytes memory data);\n\n    /// Reads next line of file to string.\n    function readLine(string calldata path) external view returns (string memory line);\n\n    /// Reads a symbolic link, returning the path that the link points to.\n    /// This cheatcode will revert in the following situations, but is not limited to just these cases:\n    /// - `path` is not a symbolic link.\n    /// - `path` does not exist.\n    function readLink(string calldata linkPath) external view returns (string memory targetPath);\n\n    /// Removes a directory at the provided path.\n    /// This cheatcode will revert in the following situations, but is not limited to just these cases:\n    /// - `path` doesn't exist.\n    /// - `path` isn't a directory.\n    /// - User lacks permissions to modify `path`.\n    /// - The directory is not empty and `recursive` is false.\n    /// `path` is relative to the project root.\n    function removeDir(string calldata path, bool recursive) external;\n\n    /// Removes a file from the filesystem.\n    /// This cheatcode will revert in the following situations, but is not limited to just these cases:\n    /// - `path` points to a directory.\n    /// - The file doesn't exist.\n    /// - The user lacks permissions to remove the file.\n    /// `path` is relative to the project root.\n    function removeFile(string calldata path) external;\n\n    /// Performs a foreign function call via terminal and returns the exit code, stdout, and stderr.\n    function tryFfi(string[] calldata commandInput) external returns (FfiResult memory result);\n\n    /// Returns the time since unix epoch in milliseconds.\n    function unixTime() external view returns (uint256 milliseconds);\n\n    /// Writes data to file, creating a file if it does not exist, and entirely replacing its contents if it does.\n    /// `path` is relative to the project root.\n    function writeFile(string calldata path, string calldata data) external;\n\n    /// Writes binary data to a file, creating a file if it does not exist, and entirely replacing its contents if it does.\n    /// `path` is relative to the project root.\n    function writeFileBinary(string calldata path, bytes calldata data) external;\n\n    /// Writes line to file, creating a file if it does not exist.\n    /// `path` is relative to the project root.\n    function writeLine(string calldata path, string calldata data) external;\n\n    // ======== JSON ========\n\n    /// Checks if `key` exists in a JSON object.\n    function keyExistsJson(string calldata json, string calldata key) external view returns (bool);\n\n    /// Parses a string of JSON data at `key` and coerces it to `address`.\n    function parseJsonAddress(string calldata json, string calldata key) external pure returns (address);\n\n    /// Parses a string of JSON data at `key` and coerces it to `address[]`.\n    function parseJsonAddressArray(string calldata json, string calldata key)\n        external\n        pure\n        returns (address[] memory);\n\n    /// Parses a string of JSON data at `key` and coerces it to `bool`.\n    function parseJsonBool(string calldata json, string calldata key) external pure returns (bool);\n\n    /// Parses a string of JSON data at `key` and coerces it to `bool[]`.\n    function parseJsonBoolArray(string calldata json, string calldata key) external pure returns (bool[] memory);\n\n    /// Parses a string of JSON data at `key` and coerces it to `bytes`.\n    function parseJsonBytes(string calldata json, string calldata key) external pure returns (bytes memory);\n\n    /// Parses a string of JSON data at `key` and coerces it to `bytes32`.\n    function parseJsonBytes32(string calldata json, string calldata key) external pure returns (bytes32);\n\n    /// Parses a string of JSON data at `key` and coerces it to `bytes32[]`.\n    function parseJsonBytes32Array(string calldata json, string calldata key)\n        external\n        pure\n        returns (bytes32[] memory);\n\n    /// Parses a string of JSON data at `key` and coerces it to `bytes[]`.\n    function parseJsonBytesArray(string calldata json, string calldata key) external pure returns (bytes[] memory);\n\n    /// Parses a string of JSON data at `key` and coerces it to `int256`.\n    function parseJsonInt(string calldata json, string calldata key) external pure returns (int256);\n\n    /// Parses a string of JSON data at `key` and coerces it to `int256[]`.\n    function parseJsonIntArray(string calldata json, string calldata key) external pure returns (int256[] memory);\n\n    /// Returns an array of all the keys in a JSON object.\n    function parseJsonKeys(string calldata json, string calldata key) external pure returns (string[] memory keys);\n\n    /// Parses a string of JSON data at `key` and coerces it to `string`.\n    function parseJsonString(string calldata json, string calldata key) external pure returns (string memory);\n\n    /// Parses a string of JSON data at `key` and coerces it to `string[]`.\n    function parseJsonStringArray(string calldata json, string calldata key) external pure returns (string[] memory);\n\n    /// Parses a string of JSON data at `key` and coerces it to type array corresponding to `typeDescription`.\n    function parseJsonTypeArray(string calldata json, string calldata key, string calldata typeDescription)\n        external\n        pure\n        returns (bytes memory);\n\n    /// Parses a string of JSON data and coerces it to type corresponding to `typeDescription`.\n    function parseJsonType(string calldata json, string calldata typeDescription)\n        external\n        pure\n        returns (bytes memory);\n\n    /// Parses a string of JSON data at `key` and coerces it to type corresponding to `typeDescription`.\n    function parseJsonType(string calldata json, string calldata key, string calldata typeDescription)\n        external\n        pure\n        returns (bytes memory);\n\n    /// Parses a string of JSON data at `key` and coerces it to `uint256`.\n    function parseJsonUint(string calldata json, string calldata key) external pure returns (uint256);\n\n    /// Parses a string of JSON data at `key` and coerces it to `uint256[]`.\n    function parseJsonUintArray(string calldata json, string calldata key) external pure returns (uint256[] memory);\n\n    /// ABI-encodes a JSON object.\n    function parseJson(string calldata json) external pure returns (bytes memory abiEncodedData);\n\n    /// ABI-encodes a JSON object at `key`.\n    function parseJson(string calldata json, string calldata key) external pure returns (bytes memory abiEncodedData);\n\n    /// See `serializeJson`.\n    function serializeAddress(string calldata objectKey, string calldata valueKey, address value)\n        external\n        returns (string memory json);\n\n    /// See `serializeJson`.\n    function serializeAddress(string calldata objectKey, string calldata valueKey, address[] calldata values)\n        external\n        returns (string memory json);\n\n    /// See `serializeJson`.\n    function serializeBool(string calldata objectKey, string calldata valueKey, bool value)\n        external\n        returns (string memory json);\n\n    /// See `serializeJson`.\n    function serializeBool(string calldata objectKey, string calldata valueKey, bool[] calldata values)\n        external\n        returns (string memory json);\n\n    /// See `serializeJson`.\n    function serializeBytes32(string calldata objectKey, string calldata valueKey, bytes32 value)\n        external\n        returns (string memory json);\n\n    /// See `serializeJson`.\n    function serializeBytes32(string calldata objectKey, string calldata valueKey, bytes32[] calldata values)\n        external\n        returns (string memory json);\n\n    /// See `serializeJson`.\n    function serializeBytes(string calldata objectKey, string calldata valueKey, bytes calldata value)\n        external\n        returns (string memory json);\n\n    /// See `serializeJson`.\n    function serializeBytes(string calldata objectKey, string calldata valueKey, bytes[] calldata values)\n        external\n        returns (string memory json);\n\n    /// See `serializeJson`.\n    function serializeInt(string calldata objectKey, string calldata valueKey, int256 value)\n        external\n        returns (string memory json);\n\n    /// See `serializeJson`.\n    function serializeInt(string calldata objectKey, string calldata valueKey, int256[] calldata values)\n        external\n        returns (string memory json);\n\n    /// Serializes a key and value to a JSON object stored in-memory that can be later written to a file.\n    /// Returns the stringified version of the specific JSON file up to that moment.\n    function serializeJson(string calldata objectKey, string calldata value) external returns (string memory json);\n\n    /// See `serializeJson`.\n    function serializeJsonType(string calldata typeDescription, bytes calldata value)\n        external\n        pure\n        returns (string memory json);\n\n    /// See `serializeJson`.\n    function serializeJsonType(\n        string calldata objectKey,\n        string calldata valueKey,\n        string calldata typeDescription,\n        bytes calldata value\n    ) external returns (string memory json);\n\n    /// See `serializeJson`.\n    function serializeString(string calldata objectKey, string calldata valueKey, string calldata value)\n        external\n        returns (string memory json);\n\n    /// See `serializeJson`.\n    function serializeString(string calldata objectKey, string calldata valueKey, string[] calldata values)\n        external\n        returns (string memory json);\n\n    /// See `serializeJson`.\n    function serializeUintToHex(string calldata objectKey, string calldata valueKey, uint256 value)\n        external\n        returns (string memory json);\n\n    /// See `serializeJson`.\n    function serializeUint(string calldata objectKey, string calldata valueKey, uint256 value)\n        external\n        returns (string memory json);\n\n    /// See `serializeJson`.\n    function serializeUint(string calldata objectKey, string calldata valueKey, uint256[] calldata values)\n        external\n        returns (string memory json);\n\n    /// Write a serialized JSON object to a file. If the file exists, it will be overwritten.\n    function writeJson(string calldata json, string calldata path) external;\n\n    /// Write a serialized JSON object to an **existing** JSON file, replacing a value with key = <value_key.>\n    /// This is useful to replace a specific value of a JSON file, without having to parse the entire thing.\n    function writeJson(string calldata json, string calldata path, string calldata valueKey) external;\n\n    /// Checks if `key` exists in a JSON object\n    /// `keyExists` is being deprecated in favor of `keyExistsJson`. It will be removed in future versions.\n    function keyExists(string calldata json, string calldata key) external view returns (bool);\n\n    // ======== Scripting ========\n\n    /// Designate the next call as an EIP-7702 transaction\n    function attachDelegation(SignedDelegation calldata signedDelegation) external;\n\n    /// Takes a signed transaction and broadcasts it to the network.\n    function broadcastRawTransaction(bytes calldata data) external;\n\n    /// Has the next call (at this call depth only) create transactions that can later be signed and sent onchain.\n    /// Broadcasting address is determined by checking the following in order:\n    /// 1. If `--sender` argument was provided, that address is used.\n    /// 2. If exactly one signer (e.g. private key, hw wallet, keystore) is set when `forge broadcast` is invoked, that signer is used.\n    /// 3. Otherwise, default foundry sender (1804c8AB1F12E6bbf3894d4083f33e07309d1f38) is used.\n    function broadcast() external;\n\n    /// Has the next call (at this call depth only) create a transaction with the address provided\n    /// as the sender that can later be signed and sent onchain.\n    function broadcast(address signer) external;\n\n    /// Has the next call (at this call depth only) create a transaction with the private key\n    /// provided as the sender that can later be signed and sent onchain.\n    function broadcast(uint256 privateKey) external;\n\n    /// Returns addresses of available unlocked wallets in the script environment.\n    function getWallets() external returns (address[] memory wallets);\n\n    /// Sign an EIP-7702 authorization and designate the next call as an EIP-7702 transaction\n    function signAndAttachDelegation(address implementation, uint256 privateKey)\n        external\n        returns (SignedDelegation memory signedDelegation);\n\n    /// Sign an EIP-7702 authorization for delegation\n    function signDelegation(address implementation, uint256 privateKey)\n        external\n        returns (SignedDelegation memory signedDelegation);\n\n    /// Has all subsequent calls (at this call depth only) create transactions that can later be signed and sent onchain.\n    /// Broadcasting address is determined by checking the following in order:\n    /// 1. If `--sender` argument was provided, that address is used.\n    /// 2. If exactly one signer (e.g. private key, hw wallet, keystore) is set when `forge broadcast` is invoked, that signer is used.\n    /// 3. Otherwise, default foundry sender (1804c8AB1F12E6bbf3894d4083f33e07309d1f38) is used.\n    function startBroadcast() external;\n\n    /// Has all subsequent calls (at this call depth only) create transactions with the address\n    /// provided that can later be signed and sent onchain.\n    function startBroadcast(address signer) external;\n\n    /// Has all subsequent calls (at this call depth only) create transactions with the private key\n    /// provided that can later be signed and sent onchain.\n    function startBroadcast(uint256 privateKey) external;\n\n    /// Stops collecting onchain transactions.\n    function stopBroadcast() external;\n\n    // ======== String ========\n\n    /// Returns true if `search` is found in `subject`, false otherwise.\n    function contains(string calldata subject, string calldata search) external returns (bool result);\n\n    /// Returns the index of the first occurrence of a `key` in an `input` string.\n    /// Returns `NOT_FOUND` (i.e. `type(uint256).max`) if the `key` is not found.\n    /// Returns 0 in case of an empty `key`.\n    function indexOf(string calldata input, string calldata key) external pure returns (uint256);\n\n    /// Parses the given `string` into an `address`.\n    function parseAddress(string calldata stringifiedValue) external pure returns (address parsedValue);\n\n    /// Parses the given `string` into a `bool`.\n    function parseBool(string calldata stringifiedValue) external pure returns (bool parsedValue);\n\n    /// Parses the given `string` into `bytes`.\n    function parseBytes(string calldata stringifiedValue) external pure returns (bytes memory parsedValue);\n\n    /// Parses the given `string` into a `bytes32`.\n    function parseBytes32(string calldata stringifiedValue) external pure returns (bytes32 parsedValue);\n\n    /// Parses the given `string` into a `int256`.\n    function parseInt(string calldata stringifiedValue) external pure returns (int256 parsedValue);\n\n    /// Parses the given `string` into a `uint256`.\n    function parseUint(string calldata stringifiedValue) external pure returns (uint256 parsedValue);\n\n    /// Replaces occurrences of `from` in the given `string` with `to`.\n    function replace(string calldata input, string calldata from, string calldata to)\n        external\n        pure\n        returns (string memory output);\n\n    /// Splits the given `string` into an array of strings divided by the `delimiter`.\n    function split(string calldata input, string calldata delimiter) external pure returns (string[] memory outputs);\n\n    /// Converts the given `string` value to Lowercase.\n    function toLowercase(string calldata input) external pure returns (string memory output);\n\n    /// Converts the given value to a `string`.\n    function toString(address value) external pure returns (string memory stringifiedValue);\n\n    /// Converts the given value to a `string`.\n    function toString(bytes calldata value) external pure returns (string memory stringifiedValue);\n\n    /// Converts the given value to a `string`.\n    function toString(bytes32 value) external pure returns (string memory stringifiedValue);\n\n    /// Converts the given value to a `string`.\n    function toString(bool value) external pure returns (string memory stringifiedValue);\n\n    /// Converts the given value to a `string`.\n    function toString(uint256 value) external pure returns (string memory stringifiedValue);\n\n    /// Converts the given value to a `string`.\n    function toString(int256 value) external pure returns (string memory stringifiedValue);\n\n    /// Converts the given `string` value to Uppercase.\n    function toUppercase(string calldata input) external pure returns (string memory output);\n\n    /// Trims leading and trailing whitespace from the given `string` value.\n    function trim(string calldata input) external pure returns (string memory output);\n\n    // ======== Testing ========\n\n    /// Compares two `uint256` values. Expects difference to be less than or equal to `maxDelta`.\n    /// Formats values with decimals in failure message.\n    function assertApproxEqAbsDecimal(uint256 left, uint256 right, uint256 maxDelta, uint256 decimals) external pure;\n\n    /// Compares two `uint256` values. Expects difference to be less than or equal to `maxDelta`.\n    /// Formats values with decimals in failure message. Includes error message into revert string on failure.\n    function assertApproxEqAbsDecimal(\n        uint256 left,\n        uint256 right,\n        uint256 maxDelta,\n        uint256 decimals,\n        string calldata error\n    ) external pure;\n\n    /// Compares two `int256` values. Expects difference to be less than or equal to `maxDelta`.\n    /// Formats values with decimals in failure message.\n    function assertApproxEqAbsDecimal(int256 left, int256 right, uint256 maxDelta, uint256 decimals) external pure;\n\n    /// Compares two `int256` values. Expects difference to be less than or equal to `maxDelta`.\n    /// Formats values with decimals in failure message. Includes error message into revert string on failure.\n    function assertApproxEqAbsDecimal(\n        int256 left,\n        int256 right,\n        uint256 maxDelta,\n        uint256 decimals,\n        string calldata error\n    ) external pure;\n\n    /// Compares two `uint256` values. Expects difference to be less than or equal to `maxDelta`.\n    function assertApproxEqAbs(uint256 left, uint256 right, uint256 maxDelta) external pure;\n\n    /// Compares two `uint256` values. Expects difference to be less than or equal to `maxDelta`.\n    /// Includes error message into revert string on failure.\n    function assertApproxEqAbs(uint256 left, uint256 right, uint256 maxDelta, string calldata error) external pure;\n\n    /// Compares two `int256` values. Expects difference to be less than or equal to `maxDelta`.\n    function assertApproxEqAbs(int256 left, int256 right, uint256 maxDelta) external pure;\n\n    /// Compares two `int256` values. Expects difference to be less than or equal to `maxDelta`.\n    /// Includes error message into revert string on failure.\n    function assertApproxEqAbs(int256 left, int256 right, uint256 maxDelta, string calldata error) external pure;\n\n    /// Compares two `uint256` values. Expects relative difference in percents to be less than or equal to `maxPercentDelta`.\n    /// `maxPercentDelta` is an 18 decimal fixed point number, where 1e18 == 100%\n    /// Formats values with decimals in failure message.\n    function assertApproxEqRelDecimal(uint256 left, uint256 right, uint256 maxPercentDelta, uint256 decimals)\n        external\n        pure;\n\n    /// Compares two `uint256` values. Expects relative difference in percents to be less than or equal to `maxPercentDelta`.\n    /// `maxPercentDelta` is an 18 decimal fixed point number, where 1e18 == 100%\n    /// Formats values with decimals in failure message. Includes error message into revert string on failure.\n    function assertApproxEqRelDecimal(\n        uint256 left,\n        uint256 right,\n        uint256 maxPercentDelta,\n        uint256 decimals,\n        string calldata error\n    ) external pure;\n\n    /// Compares two `int256` values. Expects relative difference in percents to be less than or equal to `maxPercentDelta`.\n    /// `maxPercentDelta` is an 18 decimal fixed point number, where 1e18 == 100%\n    /// Formats values with decimals in failure message.\n    function assertApproxEqRelDecimal(int256 left, int256 right, uint256 maxPercentDelta, uint256 decimals)\n        external\n        pure;\n\n    /// Compares two `int256` values. Expects relative difference in percents to be less than or equal to `maxPercentDelta`.\n    /// `maxPercentDelta` is an 18 decimal fixed point number, where 1e18 == 100%\n    /// Formats values with decimals in failure message. Includes error message into revert string on failure.\n    function assertApproxEqRelDecimal(\n        int256 left,\n        int256 right,\n        uint256 maxPercentDelta,\n        uint256 decimals,\n        string calldata error\n    ) external pure;\n\n    /// Compares two `uint256` values. Expects relative difference in percents to be less than or equal to `maxPercentDelta`.\n    /// `maxPercentDelta` is an 18 decimal fixed point number, where 1e18 == 100%\n    function assertApproxEqRel(uint256 left, uint256 right, uint256 maxPercentDelta) external pure;\n\n    /// Compares two `uint256` values. Expects relative difference in percents to be less than or equal to `maxPercentDelta`.\n    /// `maxPercentDelta` is an 18 decimal fixed point number, where 1e18 == 100%\n    /// Includes error message into revert string on failure.\n    function assertApproxEqRel(uint256 left, uint256 right, uint256 maxPercentDelta, string calldata error)\n        external\n        pure;\n\n    /// Compares two `int256` values. Expects relative difference in percents to be less than or equal to `maxPercentDelta`.\n    /// `maxPercentDelta` is an 18 decimal fixed point number, where 1e18 == 100%\n    function assertApproxEqRel(int256 left, int256 right, uint256 maxPercentDelta) external pure;\n\n    /// Compares two `int256` values. Expects relative difference in percents to be less than or equal to `maxPercentDelta`.\n    /// `maxPercentDelta` is an 18 decimal fixed point number, where 1e18 == 100%\n    /// Includes error message into revert string on failure.\n    function assertApproxEqRel(int256 left, int256 right, uint256 maxPercentDelta, string calldata error)\n        external\n        pure;\n\n    /// Asserts that two `uint256` values are equal, formatting them with decimals in failure message.\n    function assertEqDecimal(uint256 left, uint256 right, uint256 decimals) external pure;\n\n    /// Asserts that two `uint256` values are equal, formatting them with decimals in failure message.\n    /// Includes error message into revert string on failure.\n    function assertEqDecimal(uint256 left, uint256 right, uint256 decimals, string calldata error) external pure;\n\n    /// Asserts that two `int256` values are equal, formatting them with decimals in failure message.\n    function assertEqDecimal(int256 left, int256 right, uint256 decimals) external pure;\n\n    /// Asserts that two `int256` values are equal, formatting them with decimals in failure message.\n    /// Includes error message into revert string on failure.\n    function assertEqDecimal(int256 left, int256 right, uint256 decimals, string calldata error) external pure;\n\n    /// Asserts that two `bool` values are equal.\n    function assertEq(bool left, bool right) external pure;\n\n    /// Asserts that two `bool` values are equal and includes error message into revert string on failure.\n    function assertEq(bool left, bool right, string calldata error) external pure;\n\n    /// Asserts that two `string` values are equal.\n    function assertEq(string calldata left, string calldata right) external pure;\n\n    /// Asserts that two `string` values are equal and includes error message into revert string on failure.\n    function assertEq(string calldata left, string calldata right, string calldata error) external pure;\n\n    /// Asserts that two `bytes` values are equal.\n    function assertEq(bytes calldata left, bytes calldata right) external pure;\n\n    /// Asserts that two `bytes` values are equal and includes error message into revert string on failure.\n    function assertEq(bytes calldata left, bytes calldata right, string calldata error) external pure;\n\n    /// Asserts that two arrays of `bool` values are equal.\n    function assertEq(bool[] calldata left, bool[] calldata right) external pure;\n\n    /// Asserts that two arrays of `bool` values are equal and includes error message into revert string on failure.\n    function assertEq(bool[] calldata left, bool[] calldata right, string calldata error) external pure;\n\n    /// Asserts that two arrays of `uint256 values are equal.\n    function assertEq(uint256[] calldata left, uint256[] calldata right) external pure;\n\n    /// Asserts that two arrays of `uint256` values are equal and includes error message into revert string on failure.\n    function assertEq(uint256[] calldata left, uint256[] calldata right, string calldata error) external pure;\n\n    /// Asserts that two arrays of `int256` values are equal.\n    function assertEq(int256[] calldata left, int256[] calldata right) external pure;\n\n    /// Asserts that two arrays of `int256` values are equal and includes error message into revert string on failure.\n    function assertEq(int256[] calldata left, int256[] calldata right, string calldata error) external pure;\n\n    /// Asserts that two `uint256` values are equal.\n    function assertEq(uint256 left, uint256 right) external pure;\n\n    /// Asserts that two arrays of `address` values are equal.\n    function assertEq(address[] calldata left, address[] calldata right) external pure;\n\n    /// Asserts that two arrays of `address` values are equal and includes error message into revert string on failure.\n    function assertEq(address[] calldata left, address[] calldata right, string calldata error) external pure;\n\n    /// Asserts that two arrays of `bytes32` values are equal.\n    function assertEq(bytes32[] calldata left, bytes32[] calldata right) external pure;\n\n    /// Asserts that two arrays of `bytes32` values are equal and includes error message into revert string on failure.\n    function assertEq(bytes32[] calldata left, bytes32[] calldata right, string calldata error) external pure;\n\n    /// Asserts that two arrays of `string` values are equal.\n    function assertEq(string[] calldata left, string[] calldata right) external pure;\n\n    /// Asserts that two arrays of `string` values are equal and includes error message into revert string on failure.\n    function assertEq(string[] calldata left, string[] calldata right, string calldata error) external pure;\n\n    /// Asserts that two arrays of `bytes` values are equal.\n    function assertEq(bytes[] calldata left, bytes[] calldata right) external pure;\n\n    /// Asserts that two arrays of `bytes` values are equal and includes error message into revert string on failure.\n    function assertEq(bytes[] calldata left, bytes[] calldata right, string calldata error) external pure;\n\n    /// Asserts that two `uint256` values are equal and includes error message into revert string on failure.\n    function assertEq(uint256 left, uint256 right, string calldata error) external pure;\n\n    /// Asserts that two `int256` values are equal.\n    function assertEq(int256 left, int256 right) external pure;\n\n    /// Asserts that two `int256` values are equal and includes error message into revert string on failure.\n    function assertEq(int256 left, int256 right, string calldata error) external pure;\n\n    /// Asserts that two `address` values are equal.\n    function assertEq(address left, address right) external pure;\n\n    /// Asserts that two `address` values are equal and includes error message into revert string on failure.\n    function assertEq(address left, address right, string calldata error) external pure;\n\n    /// Asserts that two `bytes32` values are equal.\n    function assertEq(bytes32 left, bytes32 right) external pure;\n\n    /// Asserts that two `bytes32` values are equal and includes error message into revert string on failure.\n    function assertEq(bytes32 left, bytes32 right, string calldata error) external pure;\n\n    /// Asserts that the given condition is false.\n    function assertFalse(bool condition) external pure;\n\n    /// Asserts that the given condition is false and includes error message into revert string on failure.\n    function assertFalse(bool condition, string calldata error) external pure;\n\n    /// Compares two `uint256` values. Expects first value to be greater than or equal to second.\n    /// Formats values with decimals in failure message.\n    function assertGeDecimal(uint256 left, uint256 right, uint256 decimals) external pure;\n\n    /// Compares two `uint256` values. Expects first value to be greater than or equal to second.\n    /// Formats values with decimals in failure message. Includes error message into revert string on failure.\n    function assertGeDecimal(uint256 left, uint256 right, uint256 decimals, string calldata error) external pure;\n\n    /// Compares two `int256` values. Expects first value to be greater than or equal to second.\n    /// Formats values with decimals in failure message.\n    function assertGeDecimal(int256 left, int256 right, uint256 decimals) external pure;\n\n    /// Compares two `int256` values. Expects first value to be greater than or equal to second.\n    /// Formats values with decimals in failure message. Includes error message into revert string on failure.\n    function assertGeDecimal(int256 left, int256 right, uint256 decimals, string calldata error) external pure;\n\n    /// Compares two `uint256` values. Expects first value to be greater than or equal to second.\n    function assertGe(uint256 left, uint256 right) external pure;\n\n    /// Compares two `uint256` values. Expects first value to be greater than or equal to second.\n    /// Includes error message into revert string on failure.\n    function assertGe(uint256 left, uint256 right, string calldata error) external pure;\n\n    /// Compares two `int256` values. Expects first value to be greater than or equal to second.\n    function assertGe(int256 left, int256 right) external pure;\n\n    /// Compares two `int256` values. Expects first value to be greater than or equal to second.\n    /// Includes error message into revert string on failure.\n    function assertGe(int256 left, int256 right, string calldata error) external pure;\n\n    /// Compares two `uint256` values. Expects first value to be greater than second.\n    /// Formats values with decimals in failure message.\n    function assertGtDecimal(uint256 left, uint256 right, uint256 decimals) external pure;\n\n    /// Compares two `uint256` values. Expects first value to be greater than second.\n    /// Formats values with decimals in failure message. Includes error message into revert string on failure.\n    function assertGtDecimal(uint256 left, uint256 right, uint256 decimals, string calldata error) external pure;\n\n    /// Compares two `int256` values. Expects first value to be greater than second.\n    /// Formats values with decimals in failure message.\n    function assertGtDecimal(int256 left, int256 right, uint256 decimals) external pure;\n\n    /// Compares two `int256` values. Expects first value to be greater than second.\n    /// Formats values with decimals in failure message. Includes error message into revert string on failure.\n    function assertGtDecimal(int256 left, int256 right, uint256 decimals, string calldata error) external pure;\n\n    /// Compares two `uint256` values. Expects first value to be greater than second.\n    function assertGt(uint256 left, uint256 right) external pure;\n\n    /// Compares two `uint256` values. Expects first value to be greater than second.\n    /// Includes error message into revert string on failure.\n    function assertGt(uint256 left, uint256 right, string calldata error) external pure;\n\n    /// Compares two `int256` values. Expects first value to be greater than second.\n    function assertGt(int256 left, int256 right) external pure;\n\n    /// Compares two `int256` values. Expects first value to be greater than second.\n    /// Includes error message into revert string on failure.\n    function assertGt(int256 left, int256 right, string calldata error) external pure;\n\n    /// Compares two `uint256` values. Expects first value to be less than or equal to second.\n    /// Formats values with decimals in failure message.\n    function assertLeDecimal(uint256 left, uint256 right, uint256 decimals) external pure;\n\n    /// Compares two `uint256` values. Expects first value to be less than or equal to second.\n    /// Formats values with decimals in failure message. Includes error message into revert string on failure.\n    function assertLeDecimal(uint256 left, uint256 right, uint256 decimals, string calldata error) external pure;\n\n    /// Compares two `int256` values. Expects first value to be less than or equal to second.\n    /// Formats values with decimals in failure message.\n    function assertLeDecimal(int256 left, int256 right, uint256 decimals) external pure;\n\n    /// Compares two `int256` values. Expects first value to be less than or equal to second.\n    /// Formats values with decimals in failure message. Includes error message into revert string on failure.\n    function assertLeDecimal(int256 left, int256 right, uint256 decimals, string calldata error) external pure;\n\n    /// Compares two `uint256` values. Expects first value to be less than or equal to second.\n    function assertLe(uint256 left, uint256 right) external pure;\n\n    /// Compares two `uint256` values. Expects first value to be less than or equal to second.\n    /// Includes error message into revert string on failure.\n    function assertLe(uint256 left, uint256 right, string calldata error) external pure;\n\n    /// Compares two `int256` values. Expects first value to be less than or equal to second.\n    function assertLe(int256 left, int256 right) external pure;\n\n    /// Compares two `int256` values. Expects first value to be less than or equal to second.\n    /// Includes error message into revert string on failure.\n    function assertLe(int256 left, int256 right, string calldata error) external pure;\n\n    /// Compares two `uint256` values. Expects first value to be less than second.\n    /// Formats values with decimals in failure message.\n    function assertLtDecimal(uint256 left, uint256 right, uint256 decimals) external pure;\n\n    /// Compares two `uint256` values. Expects first value to be less than second.\n    /// Formats values with decimals in failure message. Includes error message into revert string on failure.\n    function assertLtDecimal(uint256 left, uint256 right, uint256 decimals, string calldata error) external pure;\n\n    /// Compares two `int256` values. Expects first value to be less than second.\n    /// Formats values with decimals in failure message.\n    function assertLtDecimal(int256 left, int256 right, uint256 decimals) external pure;\n\n    /// Compares two `int256` values. Expects first value to be less than second.\n    /// Formats values with decimals in failure message. Includes error message into revert string on failure.\n    function assertLtDecimal(int256 left, int256 right, uint256 decimals, string calldata error) external pure;\n\n    /// Compares two `uint256` values. Expects first value to be less than second.\n    function assertLt(uint256 left, uint256 right) external pure;\n\n    /// Compares two `uint256` values. Expects first value to be less than second.\n    /// Includes error message into revert string on failure.\n    function assertLt(uint256 left, uint256 right, string calldata error) external pure;\n\n    /// Compares two `int256` values. Expects first value to be less than second.\n    function assertLt(int256 left, int256 right) external pure;\n\n    /// Compares two `int256` values. Expects first value to be less than second.\n    /// Includes error message into revert string on failure.\n    function assertLt(int256 left, int256 right, string calldata error) external pure;\n\n    /// Asserts that two `uint256` values are not equal, formatting them with decimals in failure message.\n    function assertNotEqDecimal(uint256 left, uint256 right, uint256 decimals) external pure;\n\n    /// Asserts that two `uint256` values are not equal, formatting them with decimals in failure message.\n    /// Includes error message into revert string on failure.\n    function assertNotEqDecimal(uint256 left, uint256 right, uint256 decimals, string calldata error) external pure;\n\n    /// Asserts that two `int256` values are not equal, formatting them with decimals in failure message.\n    function assertNotEqDecimal(int256 left, int256 right, uint256 decimals) external pure;\n\n    /// Asserts that two `int256` values are not equal, formatting them with decimals in failure message.\n    /// Includes error message into revert string on failure.\n    function assertNotEqDecimal(int256 left, int256 right, uint256 decimals, string calldata error) external pure;\n\n    /// Asserts that two `bool` values are not equal.\n    function assertNotEq(bool left, bool right) external pure;\n\n    /// Asserts that two `bool` values are not equal and includes error message into revert string on failure.\n    function assertNotEq(bool left, bool right, string calldata error) external pure;\n\n    /// Asserts that two `string` values are not equal.\n    function assertNotEq(string calldata left, string calldata right) external pure;\n\n    /// Asserts that two `string` values are not equal and includes error message into revert string on failure.\n    function assertNotEq(string calldata left, string calldata right, string calldata error) external pure;\n\n    /// Asserts that two `bytes` values are not equal.\n    function assertNotEq(bytes calldata left, bytes calldata right) external pure;\n\n    /// Asserts that two `bytes` values are not equal and includes error message into revert string on failure.\n    function assertNotEq(bytes calldata left, bytes calldata right, string calldata error) external pure;\n\n    /// Asserts that two arrays of `bool` values are not equal.\n    function assertNotEq(bool[] calldata left, bool[] calldata right) external pure;\n\n    /// Asserts that two arrays of `bool` values are not equal and includes error message into revert string on failure.\n    function assertNotEq(bool[] calldata left, bool[] calldata right, string calldata error) external pure;\n\n    /// Asserts that two arrays of `uint256` values are not equal.\n    function assertNotEq(uint256[] calldata left, uint256[] calldata right) external pure;\n\n    /// Asserts that two arrays of `uint256` values are not equal and includes error message into revert string on failure.\n    function assertNotEq(uint256[] calldata left, uint256[] calldata right, string calldata error) external pure;\n\n    /// Asserts that two arrays of `int256` values are not equal.\n    function assertNotEq(int256[] calldata left, int256[] calldata right) external pure;\n\n    /// Asserts that two arrays of `int256` values are not equal and includes error message into revert string on failure.\n    function assertNotEq(int256[] calldata left, int256[] calldata right, string calldata error) external pure;\n\n    /// Asserts that two `uint256` values are not equal.\n    function assertNotEq(uint256 left, uint256 right) external pure;\n\n    /// Asserts that two arrays of `address` values are not equal.\n    function assertNotEq(address[] calldata left, address[] calldata right) external pure;\n\n    /// Asserts that two arrays of `address` values are not equal and includes error message into revert string on failure.\n    function assertNotEq(address[] calldata left, address[] calldata right, string calldata error) external pure;\n\n    /// Asserts that two arrays of `bytes32` values are not equal.\n    function assertNotEq(bytes32[] calldata left, bytes32[] calldata right) external pure;\n\n    /// Asserts that two arrays of `bytes32` values are not equal and includes error message into revert string on failure.\n    function assertNotEq(bytes32[] calldata left, bytes32[] calldata right, string calldata error) external pure;\n\n    /// Asserts that two arrays of `string` values are not equal.\n    function assertNotEq(string[] calldata left, string[] calldata right) external pure;\n\n    /// Asserts that two arrays of `string` values are not equal and includes error message into revert string on failure.\n    function assertNotEq(string[] calldata left, string[] calldata right, string calldata error) external pure;\n\n    /// Asserts that two arrays of `bytes` values are not equal.\n    function assertNotEq(bytes[] calldata left, bytes[] calldata right) external pure;\n\n    /// Asserts that two arrays of `bytes` values are not equal and includes error message into revert string on failure.\n    function assertNotEq(bytes[] calldata left, bytes[] calldata right, string calldata error) external pure;\n\n    /// Asserts that two `uint256` values are not equal and includes error message into revert string on failure.\n    function assertNotEq(uint256 left, uint256 right, string calldata error) external pure;\n\n    /// Asserts that two `int256` values are not equal.\n    function assertNotEq(int256 left, int256 right) external pure;\n\n    /// Asserts that two `int256` values are not equal and includes error message into revert string on failure.\n    function assertNotEq(int256 left, int256 right, string calldata error) external pure;\n\n    /// Asserts that two `address` values are not equal.\n    function assertNotEq(address left, address right) external pure;\n\n    /// Asserts that two `address` values are not equal and includes error message into revert string on failure.\n    function assertNotEq(address left, address right, string calldata error) external pure;\n\n    /// Asserts that two `bytes32` values are not equal.\n    function assertNotEq(bytes32 left, bytes32 right) external pure;\n\n    /// Asserts that two `bytes32` values are not equal and includes error message into revert string on failure.\n    function assertNotEq(bytes32 left, bytes32 right, string calldata error) external pure;\n\n    /// Asserts that the given condition is true.\n    function assertTrue(bool condition) external pure;\n\n    /// Asserts that the given condition is true and includes error message into revert string on failure.\n    function assertTrue(bool condition, string calldata error) external pure;\n\n    /// If the condition is false, discard this run's fuzz inputs and generate new ones.\n    function assume(bool condition) external pure;\n\n    /// Discard this run's fuzz inputs and generate new ones if next call reverted.\n    function assumeNoRevert() external pure;\n\n    /// Discard this run's fuzz inputs and generate new ones if next call reverts with the potential revert parameters.\n    function assumeNoRevert(PotentialRevert calldata potentialRevert) external pure;\n\n    /// Discard this run's fuzz inputs and generate new ones if next call reverts with the any of the potential revert parameters.\n    function assumeNoRevert(PotentialRevert[] calldata potentialReverts) external pure;\n\n    /// Writes a breakpoint to jump to in the debugger.\n    function breakpoint(string calldata char) external pure;\n\n    /// Writes a conditional breakpoint to jump to in the debugger.\n    function breakpoint(string calldata char, bool value) external pure;\n\n    /// Returns the Foundry version.\n    /// Format: <cargo_version>-<tag>+<git_sha_short>.<unix_build_timestamp>.<profile>\n    /// Sample output: 0.3.0-nightly+3cb96bde9b.1737036656.debug\n    /// Note: Build timestamps may vary slightly across platforms due to separate CI jobs.\n    /// For reliable version comparisons, use UNIX format (e.g., >= 1700000000)\n    /// to compare timestamps while ignoring minor time differences.\n    function getFoundryVersion() external view returns (string memory version);\n\n    /// Returns the RPC url for the given alias.\n    function rpcUrl(string calldata rpcAlias) external view returns (string memory json);\n\n    /// Returns all rpc urls and their aliases as structs.\n    function rpcUrlStructs() external view returns (Rpc[] memory urls);\n\n    /// Returns all rpc urls and their aliases `[alias, url][]`.\n    function rpcUrls() external view returns (string[2][] memory urls);\n\n    /// Suspends execution of the main thread for `duration` milliseconds.\n    function sleep(uint256 duration) external;\n\n    // ======== Toml ========\n\n    /// Checks if `key` exists in a TOML table.\n    function keyExistsToml(string calldata toml, string calldata key) external view returns (bool);\n\n    /// Parses a string of TOML data at `key` and coerces it to `address`.\n    function parseTomlAddress(string calldata toml, string calldata key) external pure returns (address);\n\n    /// Parses a string of TOML data at `key` and coerces it to `address[]`.\n    function parseTomlAddressArray(string calldata toml, string calldata key)\n        external\n        pure\n        returns (address[] memory);\n\n    /// Parses a string of TOML data at `key` and coerces it to `bool`.\n    function parseTomlBool(string calldata toml, string calldata key) external pure returns (bool);\n\n    /// Parses a string of TOML data at `key` and coerces it to `bool[]`.\n    function parseTomlBoolArray(string calldata toml, string calldata key) external pure returns (bool[] memory);\n\n    /// Parses a string of TOML data at `key` and coerces it to `bytes`.\n    function parseTomlBytes(string calldata toml, string calldata key) external pure returns (bytes memory);\n\n    /// Parses a string of TOML data at `key` and coerces it to `bytes32`.\n    function parseTomlBytes32(string calldata toml, string calldata key) external pure returns (bytes32);\n\n    /// Parses a string of TOML data at `key` and coerces it to `bytes32[]`.\n    function parseTomlBytes32Array(string calldata toml, string calldata key)\n        external\n        pure\n        returns (bytes32[] memory);\n\n    /// Parses a string of TOML data at `key` and coerces it to `bytes[]`.\n    function parseTomlBytesArray(string calldata toml, string calldata key) external pure returns (bytes[] memory);\n\n    /// Parses a string of TOML data at `key` and coerces it to `int256`.\n    function parseTomlInt(string calldata toml, string calldata key) external pure returns (int256);\n\n    /// Parses a string of TOML data at `key` and coerces it to `int256[]`.\n    function parseTomlIntArray(string calldata toml, string calldata key) external pure returns (int256[] memory);\n\n    /// Returns an array of all the keys in a TOML table.\n    function parseTomlKeys(string calldata toml, string calldata key) external pure returns (string[] memory keys);\n\n    /// Parses a string of TOML data at `key` and coerces it to `string`.\n    function parseTomlString(string calldata toml, string calldata key) external pure returns (string memory);\n\n    /// Parses a string of TOML data at `key` and coerces it to `string[]`.\n    function parseTomlStringArray(string calldata toml, string calldata key) external pure returns (string[] memory);\n\n    /// Parses a string of TOML data at `key` and coerces it to type array corresponding to `typeDescription`.\n    function parseTomlTypeArray(string calldata toml, string calldata key, string calldata typeDescription)\n        external\n        pure\n        returns (bytes memory);\n\n    /// Parses a string of TOML data and coerces it to type corresponding to `typeDescription`.\n    function parseTomlType(string calldata toml, string calldata typeDescription)\n        external\n        pure\n        returns (bytes memory);\n\n    /// Parses a string of TOML data at `key` and coerces it to type corresponding to `typeDescription`.\n    function parseTomlType(string calldata toml, string calldata key, string calldata typeDescription)\n        external\n        pure\n        returns (bytes memory);\n\n    /// Parses a string of TOML data at `key` and coerces it to `uint256`.\n    function parseTomlUint(string calldata toml, string calldata key) external pure returns (uint256);\n\n    /// Parses a string of TOML data at `key` and coerces it to `uint256[]`.\n    function parseTomlUintArray(string calldata toml, string calldata key) external pure returns (uint256[] memory);\n\n    /// ABI-encodes a TOML table.\n    function parseToml(string calldata toml) external pure returns (bytes memory abiEncodedData);\n\n    /// ABI-encodes a TOML table at `key`.\n    function parseToml(string calldata toml, string calldata key) external pure returns (bytes memory abiEncodedData);\n\n    /// Takes serialized JSON, converts to TOML and write a serialized TOML to a file.\n    function writeToml(string calldata json, string calldata path) external;\n\n    /// Takes serialized JSON, converts to TOML and write a serialized TOML table to an **existing** TOML file, replacing a value with key = <value_key.>\n    /// This is useful to replace a specific value of a TOML file, without having to parse the entire thing.\n    function writeToml(string calldata json, string calldata path, string calldata valueKey) external;\n\n    // ======== Utilities ========\n\n    /// Compute the address of a contract created with CREATE2 using the given CREATE2 deployer.\n    function computeCreate2Address(bytes32 salt, bytes32 initCodeHash, address deployer)\n        external\n        pure\n        returns (address);\n\n    /// Compute the address of a contract created with CREATE2 using the default CREATE2 deployer.\n    function computeCreate2Address(bytes32 salt, bytes32 initCodeHash) external pure returns (address);\n\n    /// Compute the address a contract will be deployed at for a given deployer address and nonce.\n    function computeCreateAddress(address deployer, uint256 nonce) external pure returns (address);\n\n    /// Utility cheatcode to copy storage of `from` contract to another `to` contract.\n    function copyStorage(address from, address to) external;\n\n    /// Returns ENS namehash for provided string.\n    function ensNamehash(string calldata name) external pure returns (bytes32);\n\n    /// Gets the label for the specified address.\n    function getLabel(address account) external view returns (string memory currentLabel);\n\n    /// Labels an address in call traces.\n    function label(address account, string calldata newLabel) external;\n\n    /// Pauses collection of call traces. Useful in cases when you want to skip tracing of\n    /// complex calls which are not useful for debugging.\n    function pauseTracing() external view;\n\n    /// Returns a random `address`.\n    function randomAddress() external returns (address);\n\n    /// Returns a random `bool`.\n    function randomBool() external view returns (bool);\n\n    /// Returns a random byte array value of the given length.\n    function randomBytes(uint256 len) external view returns (bytes memory);\n\n    /// Returns a random fixed-size byte array of length 4.\n    function randomBytes4() external view returns (bytes4);\n\n    /// Returns a random fixed-size byte array of length 8.\n    function randomBytes8() external view returns (bytes8);\n\n    /// Returns a random `int256` value.\n    function randomInt() external view returns (int256);\n\n    /// Returns a random `int256` value of given bits.\n    function randomInt(uint256 bits) external view returns (int256);\n\n    /// Returns a random uint256 value.\n    function randomUint() external returns (uint256);\n\n    /// Returns random uint256 value between the provided range (=min..=max).\n    function randomUint(uint256 min, uint256 max) external returns (uint256);\n\n    /// Returns a random `uint256` value of given bits.\n    function randomUint(uint256 bits) external view returns (uint256);\n\n    /// Unpauses collection of call traces.\n    function resumeTracing() external view;\n\n    /// Utility cheatcode to set arbitrary storage for given target address.\n    function setArbitraryStorage(address target) external;\n\n    /// Encodes a `bytes` value to a base64url string.\n    function toBase64URL(bytes calldata data) external pure returns (string memory);\n\n    /// Encodes a `string` value to a base64url string.\n    function toBase64URL(string calldata data) external pure returns (string memory);\n\n    /// Encodes a `bytes` value to a base64 string.\n    function toBase64(bytes calldata data) external pure returns (string memory);\n\n    /// Encodes a `string` value to a base64 string.\n    function toBase64(string calldata data) external pure returns (string memory);\n}\n\n/// The `Vm` interface does allow manipulation of the EVM state. These are all intended to be used\n/// in tests, but it is not recommended to use these cheats in scripts.\ninterface Vm is VmSafe {\n    // ======== EVM ========\n\n    /// Returns the identifier of the currently active fork. Reverts if no fork is currently active.\n    function activeFork() external view returns (uint256 forkId);\n\n    /// In forking mode, explicitly grant the given address cheatcode access.\n    function allowCheatcodes(address account) external;\n\n    /// Sets `block.blobbasefee`\n    function blobBaseFee(uint256 newBlobBaseFee) external;\n\n    /// Sets the blobhashes in the transaction.\n    /// Not available on EVM versions before Cancun.\n    /// If used on unsupported EVM versions it will revert.\n    function blobhashes(bytes32[] calldata hashes) external;\n\n    /// Sets `block.chainid`.\n    function chainId(uint256 newChainId) external;\n\n    /// Clears all mocked calls.\n    function clearMockedCalls() external;\n\n    /// Clones a source account code, state, balance and nonce to a target account and updates in-memory EVM state.\n    function cloneAccount(address source, address target) external;\n\n    /// Sets `block.coinbase`.\n    function coinbase(address newCoinbase) external;\n\n    /// Creates a new fork with the given endpoint and the _latest_ block and returns the identifier of the fork.\n    function createFork(string calldata urlOrAlias) external returns (uint256 forkId);\n\n    /// Creates a new fork with the given endpoint and block and returns the identifier of the fork.\n    function createFork(string calldata urlOrAlias, uint256 blockNumber) external returns (uint256 forkId);\n\n    /// Creates a new fork with the given endpoint and at the block the given transaction was mined in,\n    /// replays all transaction mined in the block before the transaction, and returns the identifier of the fork.\n    function createFork(string calldata urlOrAlias, bytes32 txHash) external returns (uint256 forkId);\n\n    /// Creates and also selects a new fork with the given endpoint and the latest block and returns the identifier of the fork.\n    function createSelectFork(string calldata urlOrAlias) external returns (uint256 forkId);\n\n    /// Creates and also selects a new fork with the given endpoint and block and returns the identifier of the fork.\n    function createSelectFork(string calldata urlOrAlias, uint256 blockNumber) external returns (uint256 forkId);\n\n    /// Creates and also selects new fork with the given endpoint and at the block the given transaction was mined in,\n    /// replays all transaction mined in the block before the transaction, returns the identifier of the fork.\n    function createSelectFork(string calldata urlOrAlias, bytes32 txHash) external returns (uint256 forkId);\n\n    /// Sets an address' balance.\n    function deal(address account, uint256 newBalance) external;\n\n    /// Removes the snapshot with the given ID created by `snapshot`.\n    /// Takes the snapshot ID to delete.\n    /// Returns `true` if the snapshot was successfully deleted.\n    /// Returns `false` if the snapshot does not exist.\n    function deleteStateSnapshot(uint256 snapshotId) external returns (bool success);\n\n    /// Removes _all_ snapshots previously created by `snapshot`.\n    function deleteStateSnapshots() external;\n\n    /// Sets `block.difficulty`.\n    /// Not available on EVM versions from Paris onwards. Use `prevrandao` instead.\n    /// Reverts if used on unsupported EVM versions.\n    function difficulty(uint256 newDifficulty) external;\n\n    /// Dump a genesis JSON file's `allocs` to disk.\n    function dumpState(string calldata pathToStateJson) external;\n\n    /// Sets an address' code.\n    function etch(address target, bytes calldata newRuntimeBytecode) external;\n\n    /// Sets `block.basefee`.\n    function fee(uint256 newBasefee) external;\n\n    /// Gets the blockhashes from the current transaction.\n    /// Not available on EVM versions before Cancun.\n    /// If used on unsupported EVM versions it will revert.\n    function getBlobhashes() external view returns (bytes32[] memory hashes);\n\n    /// Returns true if the account is marked as persistent.\n    function isPersistent(address account) external view returns (bool persistent);\n\n    /// Load a genesis JSON file's `allocs` into the in-memory EVM state.\n    function loadAllocs(string calldata pathToAllocsJson) external;\n\n    /// Marks that the account(s) should use persistent storage across fork swaps in a multifork setup\n    /// Meaning, changes made to the state of this account will be kept when switching forks.\n    function makePersistent(address account) external;\n\n    /// See `makePersistent(address)`.\n    function makePersistent(address account0, address account1) external;\n\n    /// See `makePersistent(address)`.\n    function makePersistent(address account0, address account1, address account2) external;\n\n    /// See `makePersistent(address)`.\n    function makePersistent(address[] calldata accounts) external;\n\n    /// Reverts a call to an address with specified revert data.\n    function mockCallRevert(address callee, bytes calldata data, bytes calldata revertData) external;\n\n    /// Reverts a call to an address with a specific `msg.value`, with specified revert data.\n    function mockCallRevert(address callee, uint256 msgValue, bytes calldata data, bytes calldata revertData)\n        external;\n\n    /// Reverts a call to an address with specified revert data.\n    /// Overload to pass the function selector directly `token.approve.selector` instead of `abi.encodeWithSelector(token.approve.selector)`.\n    function mockCallRevert(address callee, bytes4 data, bytes calldata revertData) external;\n\n    /// Reverts a call to an address with a specific `msg.value`, with specified revert data.\n    /// Overload to pass the function selector directly `token.approve.selector` instead of `abi.encodeWithSelector(token.approve.selector)`.\n    function mockCallRevert(address callee, uint256 msgValue, bytes4 data, bytes calldata revertData) external;\n\n    /// Mocks a call to an address, returning specified data.\n    /// Calldata can either be strict or a partial match, e.g. if you only\n    /// pass a Solidity selector to the expected calldata, then the entire Solidity\n    /// function will be mocked.\n    function mockCall(address callee, bytes calldata data, bytes calldata returnData) external;\n\n    /// Mocks a call to an address with a specific `msg.value`, returning specified data.\n    /// Calldata match takes precedence over `msg.value` in case of ambiguity.\n    function mockCall(address callee, uint256 msgValue, bytes calldata data, bytes calldata returnData) external;\n\n    /// Mocks a call to an address, returning specified data.\n    /// Calldata can either be strict or a partial match, e.g. if you only\n    /// pass a Solidity selector to the expected calldata, then the entire Solidity\n    /// function will be mocked.\n    /// Overload to pass the function selector directly `token.approve.selector` instead of `abi.encodeWithSelector(token.approve.selector)`.\n    function mockCall(address callee, bytes4 data, bytes calldata returnData) external;\n\n    /// Mocks a call to an address with a specific `msg.value`, returning specified data.\n    /// Calldata match takes precedence over `msg.value` in case of ambiguity.\n    /// Overload to pass the function selector directly `token.approve.selector` instead of `abi.encodeWithSelector(token.approve.selector)`.\n    function mockCall(address callee, uint256 msgValue, bytes4 data, bytes calldata returnData) external;\n\n    /// Mocks multiple calls to an address, returning specified data for each call.\n    function mockCalls(address callee, bytes calldata data, bytes[] calldata returnData) external;\n\n    /// Mocks multiple calls to an address with a specific `msg.value`, returning specified data for each call.\n    function mockCalls(address callee, uint256 msgValue, bytes calldata data, bytes[] calldata returnData) external;\n\n    /// Whenever a call is made to `callee` with calldata `data`, this cheatcode instead calls\n    /// `target` with the same calldata. This functionality is similar to a delegate call made to\n    /// `target` contract from `callee`.\n    /// Can be used to substitute a call to a function with another implementation that captures\n    /// the primary logic of the original function but is easier to reason about.\n    /// If calldata is not a strict match then partial match by selector is attempted.\n    function mockFunction(address callee, address target, bytes calldata data) external;\n\n    /// Sets the *next* call's `msg.sender` to be the input address.\n    function prank(address msgSender) external;\n\n    /// Sets the *next* call's `msg.sender` to be the input address, and the `tx.origin` to be the second input.\n    function prank(address msgSender, address txOrigin) external;\n\n    /// Sets the *next* delegate call's `msg.sender` to be the input address.\n    function prank(address msgSender, bool delegateCall) external;\n\n    /// Sets the *next* delegate call's `msg.sender` to be the input address, and the `tx.origin` to be the second input.\n    function prank(address msgSender, address txOrigin, bool delegateCall) external;\n\n    /// Sets `block.prevrandao`.\n    /// Not available on EVM versions before Paris. Use `difficulty` instead.\n    /// If used on unsupported EVM versions it will revert.\n    function prevrandao(bytes32 newPrevrandao) external;\n\n    /// Sets `block.prevrandao`.\n    /// Not available on EVM versions before Paris. Use `difficulty` instead.\n    /// If used on unsupported EVM versions it will revert.\n    function prevrandao(uint256 newPrevrandao) external;\n\n    /// Reads the current `msg.sender` and `tx.origin` from state and reports if there is any active caller modification.\n    function readCallers() external returns (CallerMode callerMode, address msgSender, address txOrigin);\n\n    /// Resets the nonce of an account to 0 for EOAs and 1 for contract accounts.\n    function resetNonce(address account) external;\n\n    /// Revert the state of the EVM to a previous snapshot\n    /// Takes the snapshot ID to revert to.\n    /// Returns `true` if the snapshot was successfully reverted.\n    /// Returns `false` if the snapshot does not exist.\n    /// **Note:** This does not automatically delete the snapshot. To delete the snapshot use `deleteStateSnapshot`.\n    function revertToState(uint256 snapshotId) external returns (bool success);\n\n    /// Revert the state of the EVM to a previous snapshot and automatically deletes the snapshots\n    /// Takes the snapshot ID to revert to.\n    /// Returns `true` if the snapshot was successfully reverted and deleted.\n    /// Returns `false` if the snapshot does not exist.\n    function revertToStateAndDelete(uint256 snapshotId) external returns (bool success);\n\n    /// Revokes persistent status from the address, previously added via `makePersistent`.\n    function revokePersistent(address account) external;\n\n    /// See `revokePersistent(address)`.\n    function revokePersistent(address[] calldata accounts) external;\n\n    /// Sets `block.height`.\n    function roll(uint256 newHeight) external;\n\n    /// Updates the currently active fork to given block number\n    /// This is similar to `roll` but for the currently active fork.\n    function rollFork(uint256 blockNumber) external;\n\n    /// Updates the currently active fork to given transaction. This will `rollFork` with the number\n    /// of the block the transaction was mined in and replays all transaction mined before it in the block.\n    function rollFork(bytes32 txHash) external;\n\n    /// Updates the given fork to given block number.\n    function rollFork(uint256 forkId, uint256 blockNumber) external;\n\n    /// Updates the given fork to block number of the given transaction and replays all transaction mined before it in the block.\n    function rollFork(uint256 forkId, bytes32 txHash) external;\n\n    /// Takes a fork identifier created by `createFork` and sets the corresponding forked state as active.\n    function selectFork(uint256 forkId) external;\n\n    /// Set blockhash for the current block.\n    /// It only sets the blockhash for blocks where `block.number - 256 <= number < block.number`.\n    function setBlockhash(uint256 blockNumber, bytes32 blockHash) external;\n\n    /// Sets the nonce of an account. Must be higher than the current nonce of the account.\n    function setNonce(address account, uint64 newNonce) external;\n\n    /// Sets the nonce of an account to an arbitrary value.\n    function setNonceUnsafe(address account, uint64 newNonce) external;\n\n    /// Snapshot capture the gas usage of the last call by name from the callee perspective.\n    function snapshotGasLastCall(string calldata name) external returns (uint256 gasUsed);\n\n    /// Snapshot capture the gas usage of the last call by name in a group from the callee perspective.\n    function snapshotGasLastCall(string calldata group, string calldata name) external returns (uint256 gasUsed);\n\n    /// Snapshot the current state of the evm.\n    /// Returns the ID of the snapshot that was created.\n    /// To revert a snapshot use `revertToState`.\n    function snapshotState() external returns (uint256 snapshotId);\n\n    /// Snapshot capture an arbitrary numerical value by name.\n    /// The group name is derived from the contract name.\n    function snapshotValue(string calldata name, uint256 value) external;\n\n    /// Snapshot capture an arbitrary numerical value by name in a group.\n    function snapshotValue(string calldata group, string calldata name, uint256 value) external;\n\n    /// Sets all subsequent calls' `msg.sender` to be the input address until `stopPrank` is called.\n    function startPrank(address msgSender) external;\n\n    /// Sets all subsequent calls' `msg.sender` to be the input address until `stopPrank` is called, and the `tx.origin` to be the second input.\n    function startPrank(address msgSender, address txOrigin) external;\n\n    /// Sets all subsequent delegate calls' `msg.sender` to be the input address until `stopPrank` is called.\n    function startPrank(address msgSender, bool delegateCall) external;\n\n    /// Sets all subsequent delegate calls' `msg.sender` to be the input address until `stopPrank` is called, and the `tx.origin` to be the second input.\n    function startPrank(address msgSender, address txOrigin, bool delegateCall) external;\n\n    /// Start a snapshot capture of the current gas usage by name.\n    /// The group name is derived from the contract name.\n    function startSnapshotGas(string calldata name) external;\n\n    /// Start a snapshot capture of the current gas usage by name in a group.\n    function startSnapshotGas(string calldata group, string calldata name) external;\n\n    /// Resets subsequent calls' `msg.sender` to be `address(this)`.\n    function stopPrank() external;\n\n    /// Stop the snapshot capture of the current gas by latest snapshot name, capturing the gas used since the start.\n    function stopSnapshotGas() external returns (uint256 gasUsed);\n\n    /// Stop the snapshot capture of the current gas usage by name, capturing the gas used since the start.\n    /// The group name is derived from the contract name.\n    function stopSnapshotGas(string calldata name) external returns (uint256 gasUsed);\n\n    /// Stop the snapshot capture of the current gas usage by name in a group, capturing the gas used since the start.\n    function stopSnapshotGas(string calldata group, string calldata name) external returns (uint256 gasUsed);\n\n    /// Stores a value to an address' storage slot.\n    function store(address target, bytes32 slot, bytes32 value) external;\n\n    /// Fetches the given transaction from the active fork and executes it on the current state.\n    function transact(bytes32 txHash) external;\n\n    /// Fetches the given transaction from the given fork and executes it on the current state.\n    function transact(uint256 forkId, bytes32 txHash) external;\n\n    /// Sets `tx.gasprice`.\n    function txGasPrice(uint256 newGasPrice) external;\n\n    /// Sets `block.timestamp`.\n    function warp(uint256 newTimestamp) external;\n\n    /// `deleteSnapshot` is being deprecated in favor of `deleteStateSnapshot`. It will be removed in future versions.\n    function deleteSnapshot(uint256 snapshotId) external returns (bool success);\n\n    /// `deleteSnapshots` is being deprecated in favor of `deleteStateSnapshots`. It will be removed in future versions.\n    function deleteSnapshots() external;\n\n    /// `revertToAndDelete` is being deprecated in favor of `revertToStateAndDelete`. It will be removed in future versions.\n    function revertToAndDelete(uint256 snapshotId) external returns (bool success);\n\n    /// `revertTo` is being deprecated in favor of `revertToState`. It will be removed in future versions.\n    function revertTo(uint256 snapshotId) external returns (bool success);\n\n    /// `snapshot` is being deprecated in favor of `snapshotState`. It will be removed in future versions.\n    function snapshot() external returns (uint256 snapshotId);\n\n    // ======== Testing ========\n\n    /// Expect a call to an address with the specified `msg.value` and calldata, and a *minimum* amount of gas.\n    function expectCallMinGas(address callee, uint256 msgValue, uint64 minGas, bytes calldata data) external;\n\n    /// Expect given number of calls to an address with the specified `msg.value` and calldata, and a *minimum* amount of gas.\n    function expectCallMinGas(address callee, uint256 msgValue, uint64 minGas, bytes calldata data, uint64 count)\n        external;\n\n    /// Expects a call to an address with the specified calldata.\n    /// Calldata can either be a strict or a partial match.\n    function expectCall(address callee, bytes calldata data) external;\n\n    /// Expects given number of calls to an address with the specified calldata.\n    function expectCall(address callee, bytes calldata data, uint64 count) external;\n\n    /// Expects a call to an address with the specified `msg.value` and calldata.\n    function expectCall(address callee, uint256 msgValue, bytes calldata data) external;\n\n    /// Expects given number of calls to an address with the specified `msg.value` and calldata.\n    function expectCall(address callee, uint256 msgValue, bytes calldata data, uint64 count) external;\n\n    /// Expect a call to an address with the specified `msg.value`, gas, and calldata.\n    function expectCall(address callee, uint256 msgValue, uint64 gas, bytes calldata data) external;\n\n    /// Expects given number of calls to an address with the specified `msg.value`, gas, and calldata.\n    function expectCall(address callee, uint256 msgValue, uint64 gas, bytes calldata data, uint64 count) external;\n\n    /// Prepare an expected anonymous log with (bool checkTopic1, bool checkTopic2, bool checkTopic3, bool checkData.).\n    /// Call this function, then emit an anonymous event, then call a function. Internally after the call, we check if\n    /// logs were emitted in the expected order with the expected topics and data (as specified by the booleans).\n    function expectEmitAnonymous(bool checkTopic0, bool checkTopic1, bool checkTopic2, bool checkTopic3, bool checkData)\n        external;\n\n    /// Same as the previous method, but also checks supplied address against emitting contract.\n    function expectEmitAnonymous(\n        bool checkTopic0,\n        bool checkTopic1,\n        bool checkTopic2,\n        bool checkTopic3,\n        bool checkData,\n        address emitter\n    ) external;\n\n    /// Prepare an expected anonymous log with all topic and data checks enabled.\n    /// Call this function, then emit an anonymous event, then call a function. Internally after the call, we check if\n    /// logs were emitted in the expected order with the expected topics and data.\n    function expectEmitAnonymous() external;\n\n    /// Same as the previous method, but also checks supplied address against emitting contract.\n    function expectEmitAnonymous(address emitter) external;\n\n    /// Prepare an expected log with (bool checkTopic1, bool checkTopic2, bool checkTopic3, bool checkData.).\n    /// Call this function, then emit an event, then call a function. Internally after the call, we check if\n    /// logs were emitted in the expected order with the expected topics and data (as specified by the booleans).\n    function expectEmit(bool checkTopic1, bool checkTopic2, bool checkTopic3, bool checkData) external;\n\n    /// Same as the previous method, but also checks supplied address against emitting contract.\n    function expectEmit(bool checkTopic1, bool checkTopic2, bool checkTopic3, bool checkData, address emitter)\n        external;\n\n    /// Prepare an expected log with all topic and data checks enabled.\n    /// Call this function, then emit an event, then call a function. Internally after the call, we check if\n    /// logs were emitted in the expected order with the expected topics and data.\n    function expectEmit() external;\n\n    /// Same as the previous method, but also checks supplied address against emitting contract.\n    function expectEmit(address emitter) external;\n\n    /// Expect a given number of logs with the provided topics.\n    function expectEmit(bool checkTopic1, bool checkTopic2, bool checkTopic3, bool checkData, uint64 count) external;\n\n    /// Expect a given number of logs from a specific emitter with the provided topics.\n    function expectEmit(\n        bool checkTopic1,\n        bool checkTopic2,\n        bool checkTopic3,\n        bool checkData,\n        address emitter,\n        uint64 count\n    ) external;\n\n    /// Expect a given number of logs with all topic and data checks enabled.\n    function expectEmit(uint64 count) external;\n\n    /// Expect a given number of logs from a specific emitter with all topic and data checks enabled.\n    function expectEmit(address emitter, uint64 count) external;\n\n    /// Expects an error on next call that starts with the revert data.\n    function expectPartialRevert(bytes4 revertData) external;\n\n    /// Expects an error on next call to reverter address, that starts with the revert data.\n    function expectPartialRevert(bytes4 revertData, address reverter) external;\n\n    /// Expects an error on next call with any revert data.\n    function expectRevert() external;\n\n    /// Expects an error on next call that exactly matches the revert data.\n    function expectRevert(bytes4 revertData) external;\n\n    /// Expects a `count` number of reverts from the upcoming calls from the reverter address that match the revert data.\n    function expectRevert(bytes4 revertData, address reverter, uint64 count) external;\n\n    /// Expects a `count` number of reverts from the upcoming calls from the reverter address that exactly match the revert data.\n    function expectRevert(bytes calldata revertData, address reverter, uint64 count) external;\n\n    /// Expects an error on next call that exactly matches the revert data.\n    function expectRevert(bytes calldata revertData) external;\n\n    /// Expects an error with any revert data on next call to reverter address.\n    function expectRevert(address reverter) external;\n\n    /// Expects an error from reverter address on next call, with any revert data.\n    function expectRevert(bytes4 revertData, address reverter) external;\n\n    /// Expects an error from reverter address on next call, that exactly matches the revert data.\n    function expectRevert(bytes calldata revertData, address reverter) external;\n\n    /// Expects a `count` number of reverts from the upcoming calls with any revert data or reverter.\n    function expectRevert(uint64 count) external;\n\n    /// Expects a `count` number of reverts from the upcoming calls that match the revert data.\n    function expectRevert(bytes4 revertData, uint64 count) external;\n\n    /// Expects a `count` number of reverts from the upcoming calls that exactly match the revert data.\n    function expectRevert(bytes calldata revertData, uint64 count) external;\n\n    /// Expects a `count` number of reverts from the upcoming calls from the reverter address.\n    function expectRevert(address reverter, uint64 count) external;\n\n    /// Only allows memory writes to offsets [0x00, 0x60)  [min, max) in the current subcontext. If any other\n    /// memory is written to, the test will fail. Can be called multiple times to add more ranges to the set.\n    function expectSafeMemory(uint64 min, uint64 max) external;\n\n    /// Only allows memory writes to offsets [0x00, 0x60)  [min, max) in the next created subcontext.\n    /// If any other memory is written to, the test will fail. Can be called multiple times to add more ranges\n    /// to the set.\n    function expectSafeMemoryCall(uint64 min, uint64 max) external;\n\n    /// Marks a test as skipped. Must be called at the top level of a test.\n    function skip(bool skipTest) external;\n\n    /// Marks a test as skipped with a reason. Must be called at the top level of a test.\n    function skip(bool skipTest, string calldata reason) external;\n\n    /// Stops all safe memory expectation in the current subcontext.\n    function stopExpectSafeMemory() external;\n}\n"},"lib/forge-std/src/console.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity >=0.4.22 <0.9.0;\n\nlibrary console {\n    address constant CONSOLE_ADDRESS =\n        0x000000000000000000636F6e736F6c652e6c6f67;\n\n    function _sendLogPayloadImplementation(bytes memory payload) internal view {\n        address consoleAddress = CONSOLE_ADDRESS;\n        /// @solidity memory-safe-assembly\n        assembly {\n            pop(\n                staticcall(\n                    gas(),\n                    consoleAddress,\n                    add(payload, 32),\n                    mload(payload),\n                    0,\n                    0\n                )\n            )\n        }\n    }\n\n    function _castToPure(\n      function(bytes memory) internal view fnIn\n    ) internal pure returns (function(bytes memory) pure fnOut) {\n        assembly {\n            fnOut := fnIn\n        }\n    }\n\n    function _sendLogPayload(bytes memory payload) internal pure {\n        _castToPure(_sendLogPayloadImplementation)(payload);\n    }\n\n    function log() internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log()\"));\n    }\n\n    function logInt(int256 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(int256)\", p0));\n    }\n\n    function logUint(uint256 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256)\", p0));\n    }\n\n    function logString(string memory p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string)\", p0));\n    }\n\n    function logBool(bool p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool)\", p0));\n    }\n\n    function logAddress(address p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address)\", p0));\n    }\n\n    function logBytes(bytes memory p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes)\", p0));\n    }\n\n    function logBytes1(bytes1 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes1)\", p0));\n    }\n\n    function logBytes2(bytes2 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes2)\", p0));\n    }\n\n    function logBytes3(bytes3 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes3)\", p0));\n    }\n\n    function logBytes4(bytes4 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes4)\", p0));\n    }\n\n    function logBytes5(bytes5 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes5)\", p0));\n    }\n\n    function logBytes6(bytes6 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes6)\", p0));\n    }\n\n    function logBytes7(bytes7 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes7)\", p0));\n    }\n\n    function logBytes8(bytes8 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes8)\", p0));\n    }\n\n    function logBytes9(bytes9 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes9)\", p0));\n    }\n\n    function logBytes10(bytes10 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes10)\", p0));\n    }\n\n    function logBytes11(bytes11 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes11)\", p0));\n    }\n\n    function logBytes12(bytes12 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes12)\", p0));\n    }\n\n    function logBytes13(bytes13 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes13)\", p0));\n    }\n\n    function logBytes14(bytes14 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes14)\", p0));\n    }\n\n    function logBytes15(bytes15 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes15)\", p0));\n    }\n\n    function logBytes16(bytes16 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes16)\", p0));\n    }\n\n    function logBytes17(bytes17 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes17)\", p0));\n    }\n\n    function logBytes18(bytes18 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes18)\", p0));\n    }\n\n    function logBytes19(bytes19 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes19)\", p0));\n    }\n\n    function logBytes20(bytes20 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes20)\", p0));\n    }\n\n    function logBytes21(bytes21 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes21)\", p0));\n    }\n\n    function logBytes22(bytes22 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes22)\", p0));\n    }\n\n    function logBytes23(bytes23 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes23)\", p0));\n    }\n\n    function logBytes24(bytes24 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes24)\", p0));\n    }\n\n    function logBytes25(bytes25 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes25)\", p0));\n    }\n\n    function logBytes26(bytes26 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes26)\", p0));\n    }\n\n    function logBytes27(bytes27 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes27)\", p0));\n    }\n\n    function logBytes28(bytes28 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes28)\", p0));\n    }\n\n    function logBytes29(bytes29 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes29)\", p0));\n    }\n\n    function logBytes30(bytes30 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes30)\", p0));\n    }\n\n    function logBytes31(bytes31 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes31)\", p0));\n    }\n\n    function logBytes32(bytes32 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes32)\", p0));\n    }\n\n    function log(uint256 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256)\", p0));\n    }\n\n    function log(int256 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(int256)\", p0));\n    }\n\n    function log(string memory p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string)\", p0));\n    }\n\n    function log(bool p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool)\", p0));\n    }\n\n    function log(address p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address)\", p0));\n    }\n\n    function log(uint256 p0, uint256 p1) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256)\", p0, p1));\n    }\n\n    function log(uint256 p0, string memory p1) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,string)\", p0, p1));\n    }\n\n    function log(uint256 p0, bool p1) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool)\", p0, p1));\n    }\n\n    function log(uint256 p0, address p1) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,address)\", p0, p1));\n    }\n\n    function log(string memory p0, uint256 p1) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint256)\", p0, p1));\n    }\n\n    function log(string memory p0, int256 p1) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,int256)\", p0, p1));\n    }\n\n    function log(string memory p0, string memory p1) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string)\", p0, p1));\n    }\n\n    function log(string memory p0, bool p1) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool)\", p0, p1));\n    }\n\n    function log(string memory p0, address p1) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address)\", p0, p1));\n    }\n\n    function log(bool p0, uint256 p1) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256)\", p0, p1));\n    }\n\n    function log(bool p0, string memory p1) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string)\", p0, p1));\n    }\n\n    function log(bool p0, bool p1) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool)\", p0, p1));\n    }\n\n    function log(bool p0, address p1) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address)\", p0, p1));\n    }\n\n    function log(address p0, uint256 p1) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint256)\", p0, p1));\n    }\n\n    function log(address p0, string memory p1) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string)\", p0, p1));\n    }\n\n    function log(address p0, bool p1) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool)\", p0, p1));\n    }\n\n    function log(address p0, address p1) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address)\", p0, p1));\n    }\n\n    function log(uint256 p0, uint256 p1, uint256 p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,uint256)\", p0, p1, p2));\n    }\n\n    function log(uint256 p0, uint256 p1, string memory p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,string)\", p0, p1, p2));\n    }\n\n    function log(uint256 p0, uint256 p1, bool p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,bool)\", p0, p1, p2));\n    }\n\n    function log(uint256 p0, uint256 p1, address p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,address)\", p0, p1, p2));\n    }\n\n    function log(uint256 p0, string memory p1, uint256 p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,uint256)\", p0, p1, p2));\n    }\n\n    function log(uint256 p0, string memory p1, string memory p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,string)\", p0, p1, p2));\n    }\n\n    function log(uint256 p0, string memory p1, bool p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,bool)\", p0, p1, p2));\n    }\n\n    function log(uint256 p0, string memory p1, address p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,address)\", p0, p1, p2));\n    }\n\n    function log(uint256 p0, bool p1, uint256 p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,uint256)\", p0, p1, p2));\n    }\n\n    function log(uint256 p0, bool p1, string memory p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,string)\", p0, p1, p2));\n    }\n\n    function log(uint256 p0, bool p1, bool p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,bool)\", p0, p1, p2));\n    }\n\n    function log(uint256 p0, bool p1, address p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,address)\", p0, p1, p2));\n    }\n\n    function log(uint256 p0, address p1, uint256 p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,uint256)\", p0, p1, p2));\n    }\n\n    function log(uint256 p0, address p1, string memory p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,string)\", p0, p1, p2));\n    }\n\n    function log(uint256 p0, address p1, bool p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,bool)\", p0, p1, p2));\n    }\n\n    function log(uint256 p0, address p1, address p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,address)\", p0, p1, p2));\n    }\n\n    function log(string memory p0, uint256 p1, uint256 p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,uint256)\", p0, p1, p2));\n    }\n\n    function log(string memory p0, uint256 p1, string memory p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,string)\", p0, p1, p2));\n    }\n\n    function log(string memory p0, uint256 p1, bool p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,bool)\", p0, p1, p2));\n    }\n\n    function log(string memory p0, uint256 p1, address p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,address)\", p0, p1, p2));\n    }\n\n    function log(string memory p0, string memory p1, uint256 p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,uint256)\", p0, p1, p2));\n    }\n\n    function log(string memory p0, string memory p1, string memory p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,string)\", p0, p1, p2));\n    }\n\n    function log(string memory p0, string memory p1, bool p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,bool)\", p0, p1, p2));\n    }\n\n    function log(string memory p0, string memory p1, address p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,address)\", p0, p1, p2));\n    }\n\n    function log(string memory p0, bool p1, uint256 p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,uint256)\", p0, p1, p2));\n    }\n\n    function log(string memory p0, bool p1, string memory p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,string)\", p0, p1, p2));\n    }\n\n    function log(string memory p0, bool p1, bool p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,bool)\", p0, p1, p2));\n    }\n\n    function log(string memory p0, bool p1, address p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,address)\", p0, p1, p2));\n    }\n\n    function log(string memory p0, address p1, uint256 p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,uint256)\", p0, p1, p2));\n    }\n\n    function log(string memory p0, address p1, string memory p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,string)\", p0, p1, p2));\n    }\n\n    function log(string memory p0, address p1, bool p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,bool)\", p0, p1, p2));\n    }\n\n    function log(string memory p0, address p1, address p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,address)\", p0, p1, p2));\n    }\n\n    function log(bool p0, uint256 p1, uint256 p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,uint256)\", p0, p1, p2));\n    }\n\n    function log(bool p0, uint256 p1, string memory p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,string)\", p0, p1, p2));\n    }\n\n    function log(bool p0, uint256 p1, bool p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,bool)\", p0, p1, p2));\n    }\n\n    function log(bool p0, uint256 p1, address p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,address)\", p0, p1, p2));\n    }\n\n    function log(bool p0, string memory p1, uint256 p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,uint256)\", p0, p1, p2));\n    }\n\n    function log(bool p0, string memory p1, string memory p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,string)\", p0, p1, p2));\n    }\n\n    function log(bool p0, string memory p1, bool p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,bool)\", p0, p1, p2));\n    }\n\n    function log(bool p0, string memory p1, address p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,address)\", p0, p1, p2));\n    }\n\n    function log(bool p0, bool p1, uint256 p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,uint256)\", p0, p1, p2));\n    }\n\n    function log(bool p0, bool p1, string memory p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,string)\", p0, p1, p2));\n    }\n\n    function log(bool p0, bool p1, bool p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,bool)\", p0, p1, p2));\n    }\n\n    function log(bool p0, bool p1, address p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,address)\", p0, p1, p2));\n    }\n\n    function log(bool p0, address p1, uint256 p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,uint256)\", p0, p1, p2));\n    }\n\n    function log(bool p0, address p1, string memory p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,string)\", p0, p1, p2));\n    }\n\n    function log(bool p0, address p1, bool p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,bool)\", p0, p1, p2));\n    }\n\n    function log(bool p0, address p1, address p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,address)\", p0, p1, p2));\n    }\n\n    function log(address p0, uint256 p1, uint256 p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,uint256)\", p0, p1, p2));\n    }\n\n    function log(address p0, uint256 p1, string memory p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,string)\", p0, p1, p2));\n    }\n\n    function log(address p0, uint256 p1, bool p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,bool)\", p0, p1, p2));\n    }\n\n    function log(address p0, uint256 p1, address p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,address)\", p0, p1, p2));\n    }\n\n    function log(address p0, string memory p1, uint256 p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,uint256)\", p0, p1, p2));\n    }\n\n    function log(address p0, string memory p1, string memory p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,string)\", p0, p1, p2));\n    }\n\n    function log(address p0, string memory p1, bool p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,bool)\", p0, p1, p2));\n    }\n\n    function log(address p0, string memory p1, address p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,address)\", p0, p1, p2));\n    }\n\n    function log(address p0, bool p1, uint256 p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,uint256)\", p0, p1, p2));\n    }\n\n    function log(address p0, bool p1, string memory p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,string)\", p0, p1, p2));\n    }\n\n    function log(address p0, bool p1, bool p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,bool)\", p0, p1, p2));\n    }\n\n    function log(address p0, bool p1, address p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,address)\", p0, p1, p2));\n    }\n\n    function log(address p0, address p1, uint256 p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,uint256)\", p0, p1, p2));\n    }\n\n    function log(address p0, address p1, string memory p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,string)\", p0, p1, p2));\n    }\n\n    function log(address p0, address p1, bool p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,bool)\", p0, p1, p2));\n    }\n\n    function log(address p0, address p1, address p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,address)\", p0, p1, p2));\n    }\n\n    function log(uint256 p0, uint256 p1, uint256 p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,uint256,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, uint256 p1, uint256 p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,uint256,string)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, uint256 p1, uint256 p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,uint256,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, uint256 p1, uint256 p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,uint256,address)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, uint256 p1, string memory p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,string,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, uint256 p1, string memory p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,string,string)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, uint256 p1, string memory p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,string,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, uint256 p1, string memory p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,string,address)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, uint256 p1, bool p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,bool,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, uint256 p1, bool p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,bool,string)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, uint256 p1, bool p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,bool,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, uint256 p1, bool p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,bool,address)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, uint256 p1, address p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,address,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, uint256 p1, address p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,address,string)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, uint256 p1, address p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,address,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, uint256 p1, address p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,address,address)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, string memory p1, uint256 p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,uint256,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, string memory p1, uint256 p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,uint256,string)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, string memory p1, uint256 p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,uint256,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, string memory p1, uint256 p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,uint256,address)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, string memory p1, string memory p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,string,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, string memory p1, string memory p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,string,string)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, string memory p1, string memory p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,string,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, string memory p1, string memory p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,string,address)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, string memory p1, bool p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,bool,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, string memory p1, bool p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,bool,string)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, string memory p1, bool p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,bool,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, string memory p1, bool p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,bool,address)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, string memory p1, address p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,address,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, string memory p1, address p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,address,string)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, string memory p1, address p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,address,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, string memory p1, address p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,address,address)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, bool p1, uint256 p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,uint256,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, bool p1, uint256 p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,uint256,string)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, bool p1, uint256 p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,uint256,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, bool p1, uint256 p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,uint256,address)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, bool p1, string memory p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,string,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, bool p1, string memory p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,string,string)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, bool p1, string memory p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,string,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, bool p1, string memory p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,string,address)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, bool p1, bool p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,bool,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, bool p1, bool p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,bool,string)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, bool p1, bool p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,bool,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, bool p1, bool p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,bool,address)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, bool p1, address p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,address,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, bool p1, address p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,address,string)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, bool p1, address p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,address,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, bool p1, address p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,address,address)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, address p1, uint256 p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,uint256,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, address p1, uint256 p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,uint256,string)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, address p1, uint256 p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,uint256,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, address p1, uint256 p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,uint256,address)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, address p1, string memory p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,string,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, address p1, string memory p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,string,string)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, address p1, string memory p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,string,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, address p1, string memory p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,string,address)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, address p1, bool p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,bool,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, address p1, bool p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,bool,string)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, address p1, bool p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,bool,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, address p1, bool p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,bool,address)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, address p1, address p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,address,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, address p1, address p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,address,string)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, address p1, address p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,address,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, address p1, address p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,address,address)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, uint256 p1, uint256 p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,uint256,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, uint256 p1, uint256 p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,uint256,string)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, uint256 p1, uint256 p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,uint256,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, uint256 p1, uint256 p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,uint256,address)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, uint256 p1, string memory p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,string,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, uint256 p1, string memory p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,string,string)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, uint256 p1, string memory p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,string,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, uint256 p1, string memory p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,string,address)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, uint256 p1, bool p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,bool,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, uint256 p1, bool p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,bool,string)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, uint256 p1, bool p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,bool,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, uint256 p1, bool p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,bool,address)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, uint256 p1, address p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,address,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, uint256 p1, address p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,address,string)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, uint256 p1, address p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,address,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, uint256 p1, address p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,address,address)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, string memory p1, uint256 p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,uint256,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, string memory p1, uint256 p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,uint256,string)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, string memory p1, uint256 p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,uint256,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, string memory p1, uint256 p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,uint256,address)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, string memory p1, string memory p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,string,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, string memory p1, string memory p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,string,string)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, string memory p1, string memory p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,string,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, string memory p1, string memory p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,string,address)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, string memory p1, bool p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,bool,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, string memory p1, bool p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,bool,string)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, string memory p1, bool p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,bool,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, string memory p1, bool p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,bool,address)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, string memory p1, address p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,address,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, string memory p1, address p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,address,string)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, string memory p1, address p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,address,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, string memory p1, address p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,address,address)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, bool p1, uint256 p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,uint256,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, bool p1, uint256 p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,uint256,string)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, bool p1, uint256 p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,uint256,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, bool p1, uint256 p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,uint256,address)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, bool p1, string memory p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,string,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, bool p1, string memory p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,string,string)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, bool p1, string memory p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,string,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, bool p1, string memory p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,string,address)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, bool p1, bool p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,bool,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, bool p1, bool p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,bool,string)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, bool p1, bool p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,bool,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, bool p1, bool p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,bool,address)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, bool p1, address p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,address,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, bool p1, address p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,address,string)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, bool p1, address p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,address,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, bool p1, address p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,address,address)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, address p1, uint256 p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,uint256,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, address p1, uint256 p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,uint256,string)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, address p1, uint256 p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,uint256,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, address p1, uint256 p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,uint256,address)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, address p1, string memory p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,string,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, address p1, string memory p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,string,string)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, address p1, string memory p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,string,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, address p1, string memory p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,string,address)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, address p1, bool p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,bool,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, address p1, bool p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,bool,string)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, address p1, bool p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,bool,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, address p1, bool p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,bool,address)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, address p1, address p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,address,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, address p1, address p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,address,string)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, address p1, address p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,address,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, address p1, address p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,address,address)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, uint256 p1, uint256 p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,uint256,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, uint256 p1, uint256 p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,uint256,string)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, uint256 p1, uint256 p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,uint256,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, uint256 p1, uint256 p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,uint256,address)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, uint256 p1, string memory p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,string,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, uint256 p1, string memory p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,string,string)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, uint256 p1, string memory p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,string,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, uint256 p1, string memory p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,string,address)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, uint256 p1, bool p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,bool,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, uint256 p1, bool p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,bool,string)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, uint256 p1, bool p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,bool,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, uint256 p1, bool p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,bool,address)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, uint256 p1, address p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,address,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, uint256 p1, address p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,address,string)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, uint256 p1, address p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,address,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, uint256 p1, address p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,address,address)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, string memory p1, uint256 p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,uint256,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, string memory p1, uint256 p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,uint256,string)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, string memory p1, uint256 p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,uint256,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, string memory p1, uint256 p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,uint256,address)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, string memory p1, string memory p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,string,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, string memory p1, string memory p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,string,string)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, string memory p1, string memory p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,string,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, string memory p1, string memory p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,string,address)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, string memory p1, bool p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,bool,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, string memory p1, bool p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,bool,string)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, string memory p1, bool p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,bool,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, string memory p1, bool p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,bool,address)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, string memory p1, address p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,address,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, string memory p1, address p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,address,string)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, string memory p1, address p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,address,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, string memory p1, address p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,address,address)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, bool p1, uint256 p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,uint256,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, bool p1, uint256 p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,uint256,string)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, bool p1, uint256 p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,uint256,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, bool p1, uint256 p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,uint256,address)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, bool p1, string memory p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,string,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, bool p1, string memory p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,string,string)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, bool p1, string memory p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,string,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, bool p1, string memory p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,string,address)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, bool p1, bool p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,bool,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, bool p1, bool p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,bool,string)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, bool p1, bool p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,bool,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, bool p1, bool p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,bool,address)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, bool p1, address p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,address,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, bool p1, address p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,address,string)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, bool p1, address p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,address,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, bool p1, address p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,address,address)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, address p1, uint256 p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,uint256,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, address p1, uint256 p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,uint256,string)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, address p1, uint256 p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,uint256,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, address p1, uint256 p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,uint256,address)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, address p1, string memory p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,string,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, address p1, string memory p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,string,string)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, address p1, string memory p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,string,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, address p1, string memory p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,string,address)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, address p1, bool p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,bool,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, address p1, bool p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,bool,string)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, address p1, bool p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,bool,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, address p1, bool p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,bool,address)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, address p1, address p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,address,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, address p1, address p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,address,string)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, address p1, address p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,address,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, address p1, address p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,address,address)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, uint256 p1, uint256 p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,uint256,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, uint256 p1, uint256 p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,uint256,string)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, uint256 p1, uint256 p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,uint256,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, uint256 p1, uint256 p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,uint256,address)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, uint256 p1, string memory p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,string,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, uint256 p1, string memory p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,string,string)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, uint256 p1, string memory p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,string,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, uint256 p1, string memory p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,string,address)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, uint256 p1, bool p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,bool,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, uint256 p1, bool p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,bool,string)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, uint256 p1, bool p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,bool,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, uint256 p1, bool p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,bool,address)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, uint256 p1, address p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,address,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, uint256 p1, address p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,address,string)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, uint256 p1, address p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,address,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, uint256 p1, address p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,address,address)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, string memory p1, uint256 p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,uint256,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, string memory p1, uint256 p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,uint256,string)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, string memory p1, uint256 p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,uint256,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, string memory p1, uint256 p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,uint256,address)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, string memory p1, string memory p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,string,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, string memory p1, string memory p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,string,string)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, string memory p1, string memory p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,string,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, string memory p1, string memory p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,string,address)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, string memory p1, bool p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,bool,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, string memory p1, bool p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,bool,string)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, string memory p1, bool p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,bool,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, string memory p1, bool p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,bool,address)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, string memory p1, address p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,address,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, string memory p1, address p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,address,string)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, string memory p1, address p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,address,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, string memory p1, address p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,address,address)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, bool p1, uint256 p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,uint256,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, bool p1, uint256 p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,uint256,string)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, bool p1, uint256 p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,uint256,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, bool p1, uint256 p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,uint256,address)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, bool p1, string memory p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,string,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, bool p1, string memory p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,string,string)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, bool p1, string memory p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,string,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, bool p1, string memory p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,string,address)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, bool p1, bool p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,bool,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, bool p1, bool p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,bool,string)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, bool p1, bool p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,bool,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, bool p1, bool p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,bool,address)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, bool p1, address p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,address,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, bool p1, address p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,address,string)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, bool p1, address p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,address,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, bool p1, address p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,address,address)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, address p1, uint256 p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,uint256,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, address p1, uint256 p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,uint256,string)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, address p1, uint256 p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,uint256,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, address p1, uint256 p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,uint256,address)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, address p1, string memory p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,string,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, address p1, string memory p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,string,string)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, address p1, string memory p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,string,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, address p1, string memory p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,string,address)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, address p1, bool p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,bool,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, address p1, bool p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,bool,string)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, address p1, bool p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,bool,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, address p1, bool p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,bool,address)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, address p1, address p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,address,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, address p1, address p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,address,string)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, address p1, address p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,address,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, address p1, address p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,address,address)\", p0, p1, p2, p3));\n    }\n}\n"},"lib/forge-std/src/console2.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity >=0.4.22 <0.9.0;\n\nimport {console as console2} from \"./console.sol\";\n"},"lib/forge-std/src/interfaces/IMulticall3.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity >=0.6.2 <0.9.0;\n\npragma experimental ABIEncoderV2;\n\ninterface IMulticall3 {\n    struct Call {\n        address target;\n        bytes callData;\n    }\n\n    struct Call3 {\n        address target;\n        bool allowFailure;\n        bytes callData;\n    }\n\n    struct Call3Value {\n        address target;\n        bool allowFailure;\n        uint256 value;\n        bytes callData;\n    }\n\n    struct Result {\n        bool success;\n        bytes returnData;\n    }\n\n    function aggregate(Call[] calldata calls)\n        external\n        payable\n        returns (uint256 blockNumber, bytes[] memory returnData);\n\n    function aggregate3(Call3[] calldata calls) external payable returns (Result[] memory returnData);\n\n    function aggregate3Value(Call3Value[] calldata calls) external payable returns (Result[] memory returnData);\n\n    function blockAndAggregate(Call[] calldata calls)\n        external\n        payable\n        returns (uint256 blockNumber, bytes32 blockHash, Result[] memory returnData);\n\n    function getBasefee() external view returns (uint256 basefee);\n\n    function getBlockHash(uint256 blockNumber) external view returns (bytes32 blockHash);\n\n    function getBlockNumber() external view returns (uint256 blockNumber);\n\n    function getChainId() external view returns (uint256 chainid);\n\n    function getCurrentBlockCoinbase() external view returns (address coinbase);\n\n    function getCurrentBlockDifficulty() external view returns (uint256 difficulty);\n\n    function getCurrentBlockGasLimit() external view returns (uint256 gaslimit);\n\n    function getCurrentBlockTimestamp() external view returns (uint256 timestamp);\n\n    function getEthBalance(address addr) external view returns (uint256 balance);\n\n    function getLastBlockHash() external view returns (bytes32 blockHash);\n\n    function tryAggregate(bool requireSuccess, Call[] calldata calls)\n        external\n        payable\n        returns (Result[] memory returnData);\n\n    function tryBlockAndAggregate(bool requireSuccess, Call[] calldata calls)\n        external\n        payable\n        returns (uint256 blockNumber, bytes32 blockHash, Result[] memory returnData);\n}\n"},"lib/forge-std/src/safeconsole.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity >=0.6.2 <0.9.0;\n\n/// @author philogy <https://github.com/philogy>\n/// @dev Code generated automatically by script.\nlibrary safeconsole {\n    uint256 constant CONSOLE_ADDR = 0x000000000000000000000000000000000000000000636F6e736F6c652e6c6f67;\n\n    // Credit to [0age](https://twitter.com/z0age/status/1654922202930888704) and [0xdapper](https://github.com/foundry-rs/forge-std/pull/374)\n    // for the view-to-pure log trick.\n    function _sendLogPayload(uint256 offset, uint256 size) private pure {\n        function(uint256, uint256) internal view fnIn = _sendLogPayloadView;\n        function(uint256, uint256) internal pure pureSendLogPayload;\n        /// @solidity memory-safe-assembly\n        assembly {\n            pureSendLogPayload := fnIn\n        }\n        pureSendLogPayload(offset, size);\n    }\n\n    function _sendLogPayloadView(uint256 offset, uint256 size) private view {\n        /// @solidity memory-safe-assembly\n        assembly {\n            pop(staticcall(gas(), CONSOLE_ADDR, offset, size, 0x0, 0x0))\n        }\n    }\n\n    function _memcopy(uint256 fromOffset, uint256 toOffset, uint256 length) private pure {\n        function(uint256, uint256, uint256) internal view fnIn = _memcopyView;\n        function(uint256, uint256, uint256) internal pure pureMemcopy;\n        /// @solidity memory-safe-assembly\n        assembly {\n            pureMemcopy := fnIn\n        }\n        pureMemcopy(fromOffset, toOffset, length);\n    }\n\n    function _memcopyView(uint256 fromOffset, uint256 toOffset, uint256 length) private view {\n        /// @solidity memory-safe-assembly\n        assembly {\n            pop(staticcall(gas(), 0x4, fromOffset, length, toOffset, length))\n        }\n    }\n\n    function logMemory(uint256 offset, uint256 length) internal pure {\n        if (offset >= 0x60) {\n            // Sufficient memory before slice to prepare call header.\n            bytes32 m0;\n            bytes32 m1;\n            bytes32 m2;\n            /// @solidity memory-safe-assembly\n            assembly {\n                m0 := mload(sub(offset, 0x60))\n                m1 := mload(sub(offset, 0x40))\n                m2 := mload(sub(offset, 0x20))\n                // Selector of `log(bytes)`.\n                mstore(sub(offset, 0x60), 0x0be77f56)\n                mstore(sub(offset, 0x40), 0x20)\n                mstore(sub(offset, 0x20), length)\n            }\n            _sendLogPayload(offset - 0x44, length + 0x44);\n            /// @solidity memory-safe-assembly\n            assembly {\n                mstore(sub(offset, 0x60), m0)\n                mstore(sub(offset, 0x40), m1)\n                mstore(sub(offset, 0x20), m2)\n            }\n        } else {\n            // Insufficient space, so copy slice forward, add header and reverse.\n            bytes32 m0;\n            bytes32 m1;\n            bytes32 m2;\n            uint256 endOffset = offset + length;\n            /// @solidity memory-safe-assembly\n            assembly {\n                m0 := mload(add(endOffset, 0x00))\n                m1 := mload(add(endOffset, 0x20))\n                m2 := mload(add(endOffset, 0x40))\n            }\n            _memcopy(offset, offset + 0x60, length);\n            /// @solidity memory-safe-assembly\n            assembly {\n                // Selector of `log(bytes)`.\n                mstore(add(offset, 0x00), 0x0be77f56)\n                mstore(add(offset, 0x20), 0x20)\n                mstore(add(offset, 0x40), length)\n            }\n            _sendLogPayload(offset + 0x1c, length + 0x44);\n            _memcopy(offset + 0x60, offset, length);\n            /// @solidity memory-safe-assembly\n            assembly {\n                mstore(add(endOffset, 0x00), m0)\n                mstore(add(endOffset, 0x20), m1)\n                mstore(add(endOffset, 0x40), m2)\n            }\n        }\n    }\n\n    function log(address p0) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        /// @solidity memory-safe-assembly\n        assembly {\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            // Selector of `log(address)`.\n            mstore(0x00, 0x2c2ecbc2)\n            mstore(0x20, p0)\n        }\n        _sendLogPayload(0x1c, 0x24);\n        /// @solidity memory-safe-assembly\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n        }\n    }\n\n    function log(bool p0) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        /// @solidity memory-safe-assembly\n        assembly {\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            // Selector of `log(bool)`.\n            mstore(0x00, 0x32458eed)\n            mstore(0x20, p0)\n        }\n        _sendLogPayload(0x1c, 0x24);\n        /// @solidity memory-safe-assembly\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n        }\n    }\n\n    function log(uint256 p0) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        /// @solidity memory-safe-assembly\n        assembly {\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            // Selector of `log(uint256)`.\n            mstore(0x00, 0xf82c50f1)\n            mstore(0x20, p0)\n        }\n        _sendLogPayload(0x1c, 0x24);\n        /// @solidity memory-safe-assembly\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n        }\n    }\n\n    function log(bytes32 p0) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        /// @solidity memory-safe-assembly\n        assembly {\n            function writeString(pos, w) {\n                let length := 0\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\n                mstore(pos, length)\n                let shift := sub(256, shl(3, length))\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\n            }\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            // Selector of `log(string)`.\n            mstore(0x00, 0x41304fac)\n            mstore(0x20, 0x20)\n            writeString(0x40, p0)\n        }\n        _sendLogPayload(0x1c, 0x64);\n        /// @solidity memory-safe-assembly\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n        }\n    }\n\n    function log(address p0, address p1) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        /// @solidity memory-safe-assembly\n        assembly {\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            // Selector of `log(address,address)`.\n            mstore(0x00, 0xdaf0d4aa)\n            mstore(0x20, p0)\n            mstore(0x40, p1)\n        }\n        _sendLogPayload(0x1c, 0x44);\n        /// @solidity memory-safe-assembly\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n        }\n    }\n\n    function log(address p0, bool p1) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        /// @solidity memory-safe-assembly\n        assembly {\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            // Selector of `log(address,bool)`.\n            mstore(0x00, 0x75b605d3)\n            mstore(0x20, p0)\n            mstore(0x40, p1)\n        }\n        _sendLogPayload(0x1c, 0x44);\n        /// @solidity memory-safe-assembly\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n        }\n    }\n\n    function log(address p0, uint256 p1) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        /// @solidity memory-safe-assembly\n        assembly {\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            // Selector of `log(address,uint256)`.\n            mstore(0x00, 0x8309e8a8)\n            mstore(0x20, p0)\n            mstore(0x40, p1)\n        }\n        _sendLogPayload(0x1c, 0x44);\n        /// @solidity memory-safe-assembly\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n        }\n    }\n\n    function log(address p0, bytes32 p1) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        /// @solidity memory-safe-assembly\n        assembly {\n            function writeString(pos, w) {\n                let length := 0\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\n                mstore(pos, length)\n                let shift := sub(256, shl(3, length))\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\n            }\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            // Selector of `log(address,string)`.\n            mstore(0x00, 0x759f86bb)\n            mstore(0x20, p0)\n            mstore(0x40, 0x40)\n            writeString(0x60, p1)\n        }\n        _sendLogPayload(0x1c, 0x84);\n        /// @solidity memory-safe-assembly\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n        }\n    }\n\n    function log(bool p0, address p1) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        /// @solidity memory-safe-assembly\n        assembly {\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            // Selector of `log(bool,address)`.\n            mstore(0x00, 0x853c4849)\n            mstore(0x20, p0)\n            mstore(0x40, p1)\n        }\n        _sendLogPayload(0x1c, 0x44);\n        /// @solidity memory-safe-assembly\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n        }\n    }\n\n    function log(bool p0, bool p1) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        /// @solidity memory-safe-assembly\n        assembly {\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            // Selector of `log(bool,bool)`.\n            mstore(0x00, 0x2a110e83)\n            mstore(0x20, p0)\n            mstore(0x40, p1)\n        }\n        _sendLogPayload(0x1c, 0x44);\n        /// @solidity memory-safe-assembly\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n        }\n    }\n\n    function log(bool p0, uint256 p1) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        /// @solidity memory-safe-assembly\n        assembly {\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            // Selector of `log(bool,uint256)`.\n            mstore(0x00, 0x399174d3)\n            mstore(0x20, p0)\n            mstore(0x40, p1)\n        }\n        _sendLogPayload(0x1c, 0x44);\n        /// @solidity memory-safe-assembly\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n        }\n    }\n\n    function log(bool p0, bytes32 p1) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        /// @solidity memory-safe-assembly\n        assembly {\n            function writeString(pos, w) {\n                let length := 0\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\n                mstore(pos, length)\n                let shift := sub(256, shl(3, length))\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\n            }\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            // Selector of `log(bool,string)`.\n            mstore(0x00, 0x8feac525)\n            mstore(0x20, p0)\n            mstore(0x40, 0x40)\n            writeString(0x60, p1)\n        }\n        _sendLogPayload(0x1c, 0x84);\n        /// @solidity memory-safe-assembly\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n        }\n    }\n\n    function log(uint256 p0, address p1) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        /// @solidity memory-safe-assembly\n        assembly {\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            // Selector of `log(uint256,address)`.\n            mstore(0x00, 0x69276c86)\n            mstore(0x20, p0)\n            mstore(0x40, p1)\n        }\n        _sendLogPayload(0x1c, 0x44);\n        /// @solidity memory-safe-assembly\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n        }\n    }\n\n    function log(uint256 p0, bool p1) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        /// @solidity memory-safe-assembly\n        assembly {\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            // Selector of `log(uint256,bool)`.\n            mstore(0x00, 0x1c9d7eb3)\n            mstore(0x20, p0)\n            mstore(0x40, p1)\n        }\n        _sendLogPayload(0x1c, 0x44);\n        /// @solidity memory-safe-assembly\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n        }\n    }\n\n    function log(uint256 p0, uint256 p1) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        /// @solidity memory-safe-assembly\n        assembly {\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            // Selector of `log(uint256,uint256)`.\n            mstore(0x00, 0xf666715a)\n            mstore(0x20, p0)\n            mstore(0x40, p1)\n        }\n        _sendLogPayload(0x1c, 0x44);\n        /// @solidity memory-safe-assembly\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n        }\n    }\n\n    function log(uint256 p0, bytes32 p1) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        /// @solidity memory-safe-assembly\n        assembly {\n            function writeString(pos, w) {\n                let length := 0\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\n                mstore(pos, length)\n                let shift := sub(256, shl(3, length))\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\n            }\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            // Selector of `log(uint256,string)`.\n            mstore(0x00, 0x643fd0df)\n            mstore(0x20, p0)\n            mstore(0x40, 0x40)\n            writeString(0x60, p1)\n        }\n        _sendLogPayload(0x1c, 0x84);\n        /// @solidity memory-safe-assembly\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n        }\n    }\n\n    function log(bytes32 p0, address p1) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        /// @solidity memory-safe-assembly\n        assembly {\n            function writeString(pos, w) {\n                let length := 0\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\n                mstore(pos, length)\n                let shift := sub(256, shl(3, length))\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\n            }\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            // Selector of `log(string,address)`.\n            mstore(0x00, 0x319af333)\n            mstore(0x20, 0x40)\n            mstore(0x40, p1)\n            writeString(0x60, p0)\n        }\n        _sendLogPayload(0x1c, 0x84);\n        /// @solidity memory-safe-assembly\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n        }\n    }\n\n    function log(bytes32 p0, bool p1) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        /// @solidity memory-safe-assembly\n        assembly {\n            function writeString(pos, w) {\n                let length := 0\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\n                mstore(pos, length)\n                let shift := sub(256, shl(3, length))\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\n            }\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            // Selector of `log(string,bool)`.\n            mstore(0x00, 0xc3b55635)\n            mstore(0x20, 0x40)\n            mstore(0x40, p1)\n            writeString(0x60, p0)\n        }\n        _sendLogPayload(0x1c, 0x84);\n        /// @solidity memory-safe-assembly\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n        }\n    }\n\n    function log(bytes32 p0, uint256 p1) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        /// @solidity memory-safe-assembly\n        assembly {\n            function writeString(pos, w) {\n                let length := 0\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\n                mstore(pos, length)\n                let shift := sub(256, shl(3, length))\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\n            }\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            // Selector of `log(string,uint256)`.\n            mstore(0x00, 0xb60e72cc)\n            mstore(0x20, 0x40)\n            mstore(0x40, p1)\n            writeString(0x60, p0)\n        }\n        _sendLogPayload(0x1c, 0x84);\n        /// @solidity memory-safe-assembly\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n        }\n    }\n\n    function log(bytes32 p0, bytes32 p1) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        bytes32 m5;\n        bytes32 m6;\n        /// @solidity memory-safe-assembly\n        assembly {\n            function writeString(pos, w) {\n                let length := 0\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\n                mstore(pos, length)\n                let shift := sub(256, shl(3, length))\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\n            }\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            m5 := mload(0xa0)\n            m6 := mload(0xc0)\n            // Selector of `log(string,string)`.\n            mstore(0x00, 0x4b5c4277)\n            mstore(0x20, 0x40)\n            mstore(0x40, 0x80)\n            writeString(0x60, p0)\n            writeString(0xa0, p1)\n        }\n        _sendLogPayload(0x1c, 0xc4);\n        /// @solidity memory-safe-assembly\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n            mstore(0xa0, m5)\n            mstore(0xc0, m6)\n        }\n    }\n\n    function log(address p0, address p1, address p2) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        /// @solidity memory-safe-assembly\n        assembly {\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            // Selector of `log(address,address,address)`.\n            mstore(0x00, 0x018c84c2)\n            mstore(0x20, p0)\n            mstore(0x40, p1)\n            mstore(0x60, p2)\n        }\n        _sendLogPayload(0x1c, 0x64);\n        /// @solidity memory-safe-assembly\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n        }\n    }\n\n    function log(address p0, address p1, bool p2) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        /// @solidity memory-safe-assembly\n        assembly {\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            // Selector of `log(address,address,bool)`.\n            mstore(0x00, 0xf2a66286)\n            mstore(0x20, p0)\n            mstore(0x40, p1)\n            mstore(0x60, p2)\n        }\n        _sendLogPayload(0x1c, 0x64);\n        /// @solidity memory-safe-assembly\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n        }\n    }\n\n    function log(address p0, address p1, uint256 p2) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        /// @solidity memory-safe-assembly\n        assembly {\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            // Selector of `log(address,address,uint256)`.\n            mstore(0x00, 0x17fe6185)\n            mstore(0x20, p0)\n            mstore(0x40, p1)\n            mstore(0x60, p2)\n        }\n        _sendLogPayload(0x1c, 0x64);\n        /// @solidity memory-safe-assembly\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n        }\n    }\n\n    function log(address p0, address p1, bytes32 p2) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        bytes32 m5;\n        /// @solidity memory-safe-assembly\n        assembly {\n            function writeString(pos, w) {\n                let length := 0\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\n                mstore(pos, length)\n                let shift := sub(256, shl(3, length))\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\n            }\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            m5 := mload(0xa0)\n            // Selector of `log(address,address,string)`.\n            mstore(0x00, 0x007150be)\n            mstore(0x20, p0)\n            mstore(0x40, p1)\n            mstore(0x60, 0x60)\n            writeString(0x80, p2)\n        }\n        _sendLogPayload(0x1c, 0xa4);\n        /// @solidity memory-safe-assembly\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n            mstore(0xa0, m5)\n        }\n    }\n\n    function log(address p0, bool p1, address p2) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        /// @solidity memory-safe-assembly\n        assembly {\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            // Selector of `log(address,bool,address)`.\n            mstore(0x00, 0xf11699ed)\n            mstore(0x20, p0)\n            mstore(0x40, p1)\n            mstore(0x60, p2)\n        }\n        _sendLogPayload(0x1c, 0x64);\n        /// @solidity memory-safe-assembly\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n        }\n    }\n\n    function log(address p0, bool p1, bool p2) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        /// @solidity memory-safe-assembly\n        assembly {\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            // Selector of `log(address,bool,bool)`.\n            mstore(0x00, 0xeb830c92)\n            mstore(0x20, p0)\n            mstore(0x40, p1)\n            mstore(0x60, p2)\n        }\n        _sendLogPayload(0x1c, 0x64);\n        /// @solidity memory-safe-assembly\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n        }\n    }\n\n    function log(address p0, bool p1, uint256 p2) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        /// @solidity memory-safe-assembly\n        assembly {\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            // Selector of `log(address,bool,uint256)`.\n            mstore(0x00, 0x9c4f99fb)\n            mstore(0x20, p0)\n            mstore(0x40, p1)\n            mstore(0x60, p2)\n        }\n        _sendLogPayload(0x1c, 0x64);\n        /// @solidity memory-safe-assembly\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n        }\n    }\n\n    function log(address p0, bool p1, bytes32 p2) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        bytes32 m5;\n        /// @solidity memory-safe-assembly\n        assembly {\n            function writeString(pos, w) {\n                let length := 0\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\n                mstore(pos, length)\n                let shift := sub(256, shl(3, length))\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\n            }\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            m5 := mload(0xa0)\n            // Selector of `log(address,bool,string)`.\n            mstore(0x00, 0x212255cc)\n            mstore(0x20, p0)\n            mstore(0x40, p1)\n            mstore(0x60, 0x60)\n            writeString(0x80, p2)\n        }\n        _sendLogPayload(0x1c, 0xa4);\n        /// @solidity memory-safe-assembly\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n            mstore(0xa0, m5)\n        }\n    }\n\n    function log(address p0, uint256 p1, address p2) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        /// @solidity memory-safe-assembly\n        assembly {\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            // Selector of `log(address,uint256,address)`.\n            mstore(0x00, 0x7bc0d848)\n            mstore(0x20, p0)\n            mstore(0x40, p1)\n            mstore(0x60, p2)\n        }\n        _sendLogPayload(0x1c, 0x64);\n        /// @solidity memory-safe-assembly\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n        }\n    }\n\n    function log(address p0, uint256 p1, bool p2) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        /// @solidity memory-safe-assembly\n        assembly {\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            // Selector of `log(address,uint256,bool)`.\n            mstore(0x00, 0x678209a8)\n            mstore(0x20, p0)\n            mstore(0x40, p1)\n            mstore(0x60, p2)\n        }\n        _sendLogPayload(0x1c, 0x64);\n        /// @solidity memory-safe-assembly\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n        }\n    }\n\n    function log(address p0, uint256 p1, uint256 p2) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        /// @solidity memory-safe-assembly\n        assembly {\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            // Selector of `log(address,uint256,uint256)`.\n            mstore(0x00, 0xb69bcaf6)\n            mstore(0x20, p0)\n            mstore(0x40, p1)\n            mstore(0x60, p2)\n        }\n        _sendLogPayload(0x1c, 0x64);\n        /// @solidity memory-safe-assembly\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n        }\n    }\n\n    function log(address p0, uint256 p1, bytes32 p2) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        bytes32 m5;\n        /// @solidity memory-safe-assembly\n        assembly {\n            function writeString(pos, w) {\n                let length := 0\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\n                mstore(pos, length)\n                let shift := sub(256, shl(3, length))\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\n            }\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            m5 := mload(0xa0)\n            // Selector of `log(address,uint256,string)`.\n            mstore(0x00, 0xa1f2e8aa)\n            mstore(0x20, p0)\n            mstore(0x40, p1)\n            mstore(0x60, 0x60)\n            writeString(0x80, p2)\n        }\n        _sendLogPayload(0x1c, 0xa4);\n        /// @solidity memory-safe-assembly\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n            mstore(0xa0, m5)\n        }\n    }\n\n    function log(address p0, bytes32 p1, address p2) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        bytes32 m5;\n        /// @solidity memory-safe-assembly\n        assembly {\n            function writeString(pos, w) {\n                let length := 0\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\n                mstore(pos, length)\n                let shift := sub(256, shl(3, length))\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\n            }\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            m5 := mload(0xa0)\n            // Selector of `log(address,string,address)`.\n            mstore(0x00, 0xf08744e8)\n            mstore(0x20, p0)\n            mstore(0x40, 0x60)\n            mstore(0x60, p2)\n            writeString(0x80, p1)\n        }\n        _sendLogPayload(0x1c, 0xa4);\n        /// @solidity memory-safe-assembly\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n            mstore(0xa0, m5)\n        }\n    }\n\n    function log(address p0, bytes32 p1, bool p2) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        bytes32 m5;\n        /// @solidity memory-safe-assembly\n        assembly {\n            function writeString(pos, w) {\n                let length := 0\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\n                mstore(pos, length)\n                let shift := sub(256, shl(3, length))\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\n            }\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            m5 := mload(0xa0)\n            // Selector of `log(address,string,bool)`.\n            mstore(0x00, 0xcf020fb1)\n            mstore(0x20, p0)\n            mstore(0x40, 0x60)\n            mstore(0x60, p2)\n            writeString(0x80, p1)\n        }\n        _sendLogPayload(0x1c, 0xa4);\n        /// @solidity memory-safe-assembly\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n            mstore(0xa0, m5)\n        }\n    }\n\n    function log(address p0, bytes32 p1, uint256 p2) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        bytes32 m5;\n        /// @solidity memory-safe-assembly\n        assembly {\n            function writeString(pos, w) {\n                let length := 0\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\n                mstore(pos, length)\n                let shift := sub(256, shl(3, length))\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\n            }\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            m5 := mload(0xa0)\n            // Selector of `log(address,string,uint256)`.\n            mstore(0x00, 0x67dd6ff1)\n            mstore(0x20, p0)\n            mstore(0x40, 0x60)\n            mstore(0x60, p2)\n            writeString(0x80, p1)\n        }\n        _sendLogPayload(0x1c, 0xa4);\n        /// @solidity memory-safe-assembly\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n            mstore(0xa0, m5)\n        }\n    }\n\n    function log(address p0, bytes32 p1, bytes32 p2) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        bytes32 m5;\n        bytes32 m6;\n        bytes32 m7;\n        /// @solidity memory-safe-assembly\n        assembly {\n            function writeString(pos, w) {\n                let length := 0\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\n                mstore(pos, length)\n                let shift := sub(256, shl(3, length))\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\n            }\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            m5 := mload(0xa0)\n            m6 := mload(0xc0)\n            m7 := mload(0xe0)\n            // Selector of `log(address,string,string)`.\n            mstore(0x00, 0xfb772265)\n            mstore(0x20, p0)\n            mstore(0x40, 0x60)\n            mstore(0x60, 0xa0)\n            writeString(0x80, p1)\n            writeString(0xc0, p2)\n        }\n        _sendLogPayload(0x1c, 0xe4);\n        /// @solidity memory-safe-assembly\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n            mstore(0xa0, m5)\n            mstore(0xc0, m6)\n            mstore(0xe0, m7)\n        }\n    }\n\n    function log(bool p0, address p1, address p2) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        /// @solidity memory-safe-assembly\n        assembly {\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            // Selector of `log(bool,address,address)`.\n            mstore(0x00, 0xd2763667)\n            mstore(0x20, p0)\n            mstore(0x40, p1)\n            mstore(0x60, p2)\n        }\n        _sendLogPayload(0x1c, 0x64);\n        /// @solidity memory-safe-assembly\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n        }\n    }\n\n    function log(bool p0, address p1, bool p2) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        /// @solidity memory-safe-assembly\n        assembly {\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            // Selector of `log(bool,address,bool)`.\n            mstore(0x00, 0x18c9c746)\n            mstore(0x20, p0)\n            mstore(0x40, p1)\n            mstore(0x60, p2)\n        }\n        _sendLogPayload(0x1c, 0x64);\n        /// @solidity memory-safe-assembly\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n        }\n    }\n\n    function log(bool p0, address p1, uint256 p2) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        /// @solidity memory-safe-assembly\n        assembly {\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            // Selector of `log(bool,address,uint256)`.\n            mstore(0x00, 0x5f7b9afb)\n            mstore(0x20, p0)\n            mstore(0x40, p1)\n            mstore(0x60, p2)\n        }\n        _sendLogPayload(0x1c, 0x64);\n        /// @solidity memory-safe-assembly\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n        }\n    }\n\n    function log(bool p0, address p1, bytes32 p2) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        bytes32 m5;\n        /// @solidity memory-safe-assembly\n        assembly {\n            function writeString(pos, w) {\n                let length := 0\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\n                mstore(pos, length)\n                let shift := sub(256, shl(3, length))\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\n            }\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            m5 := mload(0xa0)\n            // Selector of `log(bool,address,string)`.\n            mstore(0x00, 0xde9a9270)\n            mstore(0x20, p0)\n            mstore(0x40, p1)\n            mstore(0x60, 0x60)\n            writeString(0x80, p2)\n        }\n        _sendLogPayload(0x1c, 0xa4);\n        /// @solidity memory-safe-assembly\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n            mstore(0xa0, m5)\n        }\n    }\n\n    function log(bool p0, bool p1, address p2) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        /// @solidity memory-safe-assembly\n        assembly {\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            // Selector of `log(bool,bool,address)`.\n            mstore(0x00, 0x1078f68d)\n            mstore(0x20, p0)\n            mstore(0x40, p1)\n            mstore(0x60, p2)\n        }\n        _sendLogPayload(0x1c, 0x64);\n        /// @solidity memory-safe-assembly\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n        }\n    }\n\n    function log(bool p0, bool p1, bool p2) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        /// @solidity memory-safe-assembly\n        assembly {\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            // Selector of `log(bool,bool,bool)`.\n            mstore(0x00, 0x50709698)\n            mstore(0x20, p0)\n            mstore(0x40, p1)\n            mstore(0x60, p2)\n        }\n        _sendLogPayload(0x1c, 0x64);\n        /// @solidity memory-safe-assembly\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n        }\n    }\n\n    function log(bool p0, bool p1, uint256 p2) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        /// @solidity memory-safe-assembly\n        assembly {\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            // Selector of `log(bool,bool,uint256)`.\n            mstore(0x00, 0x12f21602)\n            mstore(0x20, p0)\n            mstore(0x40, p1)\n            mstore(0x60, p2)\n        }\n        _sendLogPayload(0x1c, 0x64);\n        /// @solidity memory-safe-assembly\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n        }\n    }\n\n    function log(bool p0, bool p1, bytes32 p2) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        bytes32 m5;\n        /// @solidity memory-safe-assembly\n        assembly {\n            function writeString(pos, w) {\n                let length := 0\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\n                mstore(pos, length)\n                let shift := sub(256, shl(3, length))\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\n            }\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            m5 := mload(0xa0)\n            // Selector of `log(bool,bool,string)`.\n            mstore(0x00, 0x2555fa46)\n            mstore(0x20, p0)\n            mstore(0x40, p1)\n            mstore(0x60, 0x60)\n            writeString(0x80, p2)\n        }\n        _sendLogPayload(0x1c, 0xa4);\n        /// @solidity memory-safe-assembly\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n            mstore(0xa0, m5)\n        }\n    }\n\n    function log(bool p0, uint256 p1, address p2) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        /// @solidity memory-safe-assembly\n        assembly {\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            // Selector of `log(bool,uint256,address)`.\n            mstore(0x00, 0x088ef9d2)\n            mstore(0x20, p0)\n            mstore(0x40, p1)\n            mstore(0x60, p2)\n        }\n        _sendLogPayload(0x1c, 0x64);\n        /// @solidity memory-safe-assembly\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n        }\n    }\n\n    function log(bool p0, uint256 p1, bool p2) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        /// @solidity memory-safe-assembly\n        assembly {\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            // Selector of `log(bool,uint256,bool)`.\n            mstore(0x00, 0xe8defba9)\n            mstore(0x20, p0)\n            mstore(0x40, p1)\n            mstore(0x60, p2)\n        }\n        _sendLogPayload(0x1c, 0x64);\n        /// @solidity memory-safe-assembly\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n        }\n    }\n\n    function log(bool p0, uint256 p1, uint256 p2) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        /// @solidity memory-safe-assembly\n        assembly {\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            // Selector of `log(bool,uint256,uint256)`.\n            mstore(0x00, 0x37103367)\n            mstore(0x20, p0)\n            mstore(0x40, p1)\n            mstore(0x60, p2)\n        }\n        _sendLogPayload(0x1c, 0x64);\n        /// @solidity memory-safe-assembly\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n        }\n    }\n\n    function log(bool p0, uint256 p1, bytes32 p2) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        bytes32 m5;\n        /// @solidity memory-safe-assembly\n        assembly {\n            function writeString(pos, w) {\n                let length := 0\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\n                mstore(pos, length)\n                let shift := sub(256, shl(3, length))\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\n            }\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            m5 := mload(0xa0)\n            // Selector of `log(bool,uint256,string)`.\n            mstore(0x00, 0xc3fc3970)\n            mstore(0x20, p0)\n            mstore(0x40, p1)\n            mstore(0x60, 0x60)\n            writeString(0x80, p2)\n        }\n        _sendLogPayload(0x1c, 0xa4);\n        /// @solidity memory-safe-assembly\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n            mstore(0xa0, m5)\n        }\n    }\n\n    function log(bool p0, bytes32 p1, address p2) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        bytes32 m5;\n        /// @solidity memory-safe-assembly\n        assembly {\n            function writeString(pos, w) {\n                let length := 0\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\n                mstore(pos, length)\n                let shift := sub(256, shl(3, length))\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\n            }\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            m5 := mload(0xa0)\n            // Selector of `log(bool,string,address)`.\n            mstore(0x00, 0x9591b953)\n            mstore(0x20, p0)\n            mstore(0x40, 0x60)\n            mstore(0x60, p2)\n            writeString(0x80, p1)\n        }\n        _sendLogPayload(0x1c, 0xa4);\n        /// @solidity memory-safe-assembly\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n            mstore(0xa0, m5)\n        }\n    }\n\n    function log(bool p0, bytes32 p1, bool p2) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        bytes32 m5;\n        /// @solidity memory-safe-assembly\n        assembly {\n            function writeString(pos, w) {\n                let length := 0\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\n                mstore(pos, length)\n                let shift := sub(256, shl(3, length))\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\n            }\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            m5 := mload(0xa0)\n            // Selector of `log(bool,string,bool)`.\n            mstore(0x00, 0xdbb4c247)\n            mstore(0x20, p0)\n            mstore(0x40, 0x60)\n            mstore(0x60, p2)\n            writeString(0x80, p1)\n        }\n        _sendLogPayload(0x1c, 0xa4);\n        /// @solidity memory-safe-assembly\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n            mstore(0xa0, m5)\n        }\n    }\n\n    function log(bool p0, bytes32 p1, uint256 p2) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        bytes32 m5;\n        /// @solidity memory-safe-assembly\n        assembly {\n            function writeString(pos, w) {\n                let length := 0\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\n                mstore(pos, length)\n                let shift := sub(256, shl(3, length))\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\n            }\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            m5 := mload(0xa0)\n            // Selector of `log(bool,string,uint256)`.\n            mstore(0x00, 0x1093ee11)\n            mstore(0x20, p0)\n            mstore(0x40, 0x60)\n            mstore(0x60, p2)\n            writeString(0x80, p1)\n        }\n        _sendLogPayload(0x1c, 0xa4);\n        /// @solidity memory-safe-assembly\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n            mstore(0xa0, m5)\n        }\n    }\n\n    function log(bool p0, bytes32 p1, bytes32 p2) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        bytes32 m5;\n        bytes32 m6;\n        bytes32 m7;\n        /// @solidity memory-safe-assembly\n        assembly {\n            function writeString(pos, w) {\n                let length := 0\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\n                mstore(pos, length)\n                let shift := sub(256, shl(3, length))\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\n            }\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            m5 := mload(0xa0)\n            m6 := mload(0xc0)\n            m7 := mload(0xe0)\n            // Selector of `log(bool,string,string)`.\n            mstore(0x00, 0xb076847f)\n            mstore(0x20, p0)\n            mstore(0x40, 0x60)\n            mstore(0x60, 0xa0)\n            writeString(0x80, p1)\n            writeString(0xc0, p2)\n        }\n        _sendLogPayload(0x1c, 0xe4);\n        /// @solidity memory-safe-assembly\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n            mstore(0xa0, m5)\n            mstore(0xc0, m6)\n            mstore(0xe0, m7)\n        }\n    }\n\n    function log(uint256 p0, address p1, address p2) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        /// @solidity memory-safe-assembly\n        assembly {\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            // Selector of `log(uint256,address,address)`.\n            mstore(0x00, 0xbcfd9be0)\n            mstore(0x20, p0)\n            mstore(0x40, p1)\n            mstore(0x60, p2)\n        }\n        _sendLogPayload(0x1c, 0x64);\n        /// @solidity memory-safe-assembly\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n        }\n    }\n\n    function log(uint256 p0, address p1, bool p2) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        /// @solidity memory-safe-assembly\n        assembly {\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            // Selector of `log(uint256,address,bool)`.\n            mstore(0x00, 0x9b6ec042)\n            mstore(0x20, p0)\n            mstore(0x40, p1)\n            mstore(0x60, p2)\n        }\n        _sendLogPayload(0x1c, 0x64);\n        /// @solidity memory-safe-assembly\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n        }\n    }\n\n    function log(uint256 p0, address p1, uint256 p2) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        /// @solidity memory-safe-assembly\n        assembly {\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            // Selector of `log(uint256,address,uint256)`.\n            mstore(0x00, 0x5a9b5ed5)\n            mstore(0x20, p0)\n            mstore(0x40, p1)\n            mstore(0x60, p2)\n        }\n        _sendLogPayload(0x1c, 0x64);\n        /// @solidity memory-safe-assembly\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n        }\n    }\n\n    function log(uint256 p0, address p1, bytes32 p2) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        bytes32 m5;\n        /// @solidity memory-safe-assembly\n        assembly {\n            function writeString(pos, w) {\n                let length := 0\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\n                mstore(pos, length)\n                let shift := sub(256, shl(3, length))\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\n            }\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            m5 := mload(0xa0)\n            // Selector of `log(uint256,address,string)`.\n            mstore(0x00, 0x63cb41f9)\n            mstore(0x20, p0)\n            mstore(0x40, p1)\n            mstore(0x60, 0x60)\n            writeString(0x80, p2)\n        }\n        _sendLogPayload(0x1c, 0xa4);\n        /// @solidity memory-safe-assembly\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n            mstore(0xa0, m5)\n        }\n    }\n\n    function log(uint256 p0, bool p1, address p2) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        /// @solidity memory-safe-assembly\n        assembly {\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            // Selector of `log(uint256,bool,address)`.\n            mstore(0x00, 0x35085f7b)\n            mstore(0x20, p0)\n            mstore(0x40, p1)\n            mstore(0x60, p2)\n        }\n        _sendLogPayload(0x1c, 0x64);\n        /// @solidity memory-safe-assembly\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n        }\n    }\n\n    function log(uint256 p0, bool p1, bool p2) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        /// @solidity memory-safe-assembly\n        assembly {\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            // Selector of `log(uint256,bool,bool)`.\n            mstore(0x00, 0x20718650)\n            mstore(0x20, p0)\n            mstore(0x40, p1)\n            mstore(0x60, p2)\n        }\n        _sendLogPayload(0x1c, 0x64);\n        /// @solidity memory-safe-assembly\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n        }\n    }\n\n    function log(uint256 p0, bool p1, uint256 p2) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        /// @solidity memory-safe-assembly\n        assembly {\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            // Selector of `log(uint256,bool,uint256)`.\n            mstore(0x00, 0x20098014)\n            mstore(0x20, p0)\n            mstore(0x40, p1)\n            mstore(0x60, p2)\n        }\n        _sendLogPayload(0x1c, 0x64);\n        /// @solidity memory-safe-assembly\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n        }\n    }\n\n    function log(uint256 p0, bool p1, bytes32 p2) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        bytes32 m5;\n        /// @solidity memory-safe-assembly\n        assembly {\n            function writeString(pos, w) {\n                let length := 0\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\n                mstore(pos, length)\n                let shift := sub(256, shl(3, length))\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\n            }\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            m5 := mload(0xa0)\n            // Selector of `log(uint256,bool,string)`.\n            mstore(0x00, 0x85775021)\n            mstore(0x20, p0)\n            mstore(0x40, p1)\n            mstore(0x60, 0x60)\n            writeString(0x80, p2)\n        }\n        _sendLogPayload(0x1c, 0xa4);\n        /// @solidity memory-safe-assembly\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n            mstore(0xa0, m5)\n        }\n    }\n\n    function log(uint256 p0, uint256 p1, address p2) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        /// @solidity memory-safe-assembly\n        assembly {\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            // Selector of `log(uint256,uint256,address)`.\n            mstore(0x00, 0x5c96b331)\n            mstore(0x20, p0)\n            mstore(0x40, p1)\n            mstore(0x60, p2)\n        }\n        _sendLogPayload(0x1c, 0x64);\n        /// @solidity memory-safe-assembly\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n        }\n    }\n\n    function log(uint256 p0, uint256 p1, bool p2) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        /// @solidity memory-safe-assembly\n        assembly {\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            // Selector of `log(uint256,uint256,bool)`.\n            mstore(0x00, 0x4766da72)\n            mstore(0x20, p0)\n            mstore(0x40, p1)\n            mstore(0x60, p2)\n        }\n        _sendLogPayload(0x1c, 0x64);\n        /// @solidity memory-safe-assembly\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n        }\n    }\n\n    function log(uint256 p0, uint256 p1, uint256 p2) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        /// @solidity memory-safe-assembly\n        assembly {\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            // Selector of `log(uint256,uint256,uint256)`.\n            mstore(0x00, 0xd1ed7a3c)\n            mstore(0x20, p0)\n            mstore(0x40, p1)\n            mstore(0x60, p2)\n        }\n        _sendLogPayload(0x1c, 0x64);\n        /// @solidity memory-safe-assembly\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n        }\n    }\n\n    function log(uint256 p0, uint256 p1, bytes32 p2) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        bytes32 m5;\n        /// @solidity memory-safe-assembly\n        assembly {\n            function writeString(pos, w) {\n                let length := 0\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\n                mstore(pos, length)\n                let shift := sub(256, shl(3, length))\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\n            }\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            m5 := mload(0xa0)\n            // Selector of `log(uint256,uint256,string)`.\n            mstore(0x00, 0x71d04af2)\n            mstore(0x20, p0)\n            mstore(0x40, p1)\n            mstore(0x60, 0x60)\n            writeString(0x80, p2)\n        }\n        _sendLogPayload(0x1c, 0xa4);\n        /// @solidity memory-safe-assembly\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n            mstore(0xa0, m5)\n        }\n    }\n\n    function log(uint256 p0, bytes32 p1, address p2) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        bytes32 m5;\n        /// @solidity memory-safe-assembly\n        assembly {\n            function writeString(pos, w) {\n                let length := 0\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\n                mstore(pos, length)\n                let shift := sub(256, shl(3, length))\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\n            }\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            m5 := mload(0xa0)\n            // Selector of `log(uint256,string,address)`.\n            mstore(0x00, 0x7afac959)\n            mstore(0x20, p0)\n            mstore(0x40, 0x60)\n            mstore(0x60, p2)\n            writeString(0x80, p1)\n        }\n        _sendLogPayload(0x1c, 0xa4);\n        /// @solidity memory-safe-assembly\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n            mstore(0xa0, m5)\n        }\n    }\n\n    function log(uint256 p0, bytes32 p1, bool p2) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        bytes32 m5;\n        /// @solidity memory-safe-assembly\n        assembly {\n            function writeString(pos, w) {\n                let length := 0\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\n                mstore(pos, length)\n                let shift := sub(256, shl(3, length))\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\n            }\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            m5 := mload(0xa0)\n            // Selector of `log(uint256,string,bool)`.\n            mstore(0x00, 0x4ceda75a)\n            mstore(0x20, p0)\n            mstore(0x40, 0x60)\n            mstore(0x60, p2)\n            writeString(0x80, p1)\n        }\n        _sendLogPayload(0x1c, 0xa4);\n        /// @solidity memory-safe-assembly\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n            mstore(0xa0, m5)\n        }\n    }\n\n    function log(uint256 p0, bytes32 p1, uint256 p2) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        bytes32 m5;\n        /// @solidity memory-safe-assembly\n        assembly {\n            function writeString(pos, w) {\n                let length := 0\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\n                mstore(pos, length)\n                let shift := sub(256, shl(3, length))\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\n            }\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            m5 := mload(0xa0)\n            // Selector of `log(uint256,string,uint256)`.\n            mstore(0x00, 0x37aa7d4c)\n            mstore(0x20, p0)\n            mstore(0x40, 0x60)\n            mstore(0x60, p2)\n            writeString(0x80, p1)\n        }\n        _sendLogPayload(0x1c, 0xa4);\n        /// @solidity memory-safe-assembly\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n            mstore(0xa0, m5)\n        }\n    }\n\n    function log(uint256 p0, bytes32 p1, bytes32 p2) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        bytes32 m5;\n        bytes32 m6;\n        bytes32 m7;\n        /// @solidity memory-safe-assembly\n        assembly {\n            function writeString(pos, w) {\n                let length := 0\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\n                mstore(pos, length)\n                let shift := sub(256, shl(3, length))\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\n            }\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            m5 := mload(0xa0)\n            m6 := mload(0xc0)\n            m7 := mload(0xe0)\n            // Selector of `log(uint256,string,string)`.\n            mstore(0x00, 0xb115611f)\n            mstore(0x20, p0)\n            mstore(0x40, 0x60)\n            mstore(0x60, 0xa0)\n            writeString(0x80, p1)\n            writeString(0xc0, p2)\n        }\n        _sendLogPayload(0x1c, 0xe4);\n        /// @solidity memory-safe-assembly\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n            mstore(0xa0, m5)\n            mstore(0xc0, m6)\n            mstore(0xe0, m7)\n        }\n    }\n\n    function log(bytes32 p0, address p1, address p2) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        bytes32 m5;\n        /// @solidity memory-safe-assembly\n        assembly {\n            function writeString(pos, w) {\n                let length := 0\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\n                mstore(pos, length)\n                let shift := sub(256, shl(3, length))\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\n            }\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            m5 := mload(0xa0)\n            // Selector of `log(string,address,address)`.\n            mstore(0x00, 0xfcec75e0)\n            mstore(0x20, 0x60)\n            mstore(0x40, p1)\n            mstore(0x60, p2)\n            writeString(0x80, p0)\n        }\n        _sendLogPayload(0x1c, 0xa4);\n        /// @solidity memory-safe-assembly\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n            mstore(0xa0, m5)\n        }\n    }\n\n    function log(bytes32 p0, address p1, bool p2) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        bytes32 m5;\n        /// @solidity memory-safe-assembly\n        assembly {\n            function writeString(pos, w) {\n                let length := 0\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\n                mstore(pos, length)\n                let shift := sub(256, shl(3, length))\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\n            }\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            m5 := mload(0xa0)\n            // Selector of `log(string,address,bool)`.\n            mstore(0x00, 0xc91d5ed4)\n            mstore(0x20, 0x60)\n            mstore(0x40, p1)\n            mstore(0x60, p2)\n            writeString(0x80, p0)\n        }\n        _sendLogPayload(0x1c, 0xa4);\n        /// @solidity memory-safe-assembly\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n            mstore(0xa0, m5)\n        }\n    }\n\n    function log(bytes32 p0, address p1, uint256 p2) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        bytes32 m5;\n        /// @solidity memory-safe-assembly\n        assembly {\n            function writeString(pos, w) {\n                let length := 0\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\n                mstore(pos, length)\n                let shift := sub(256, shl(3, length))\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\n            }\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            m5 := mload(0xa0)\n            // Selector of `log(string,address,uint256)`.\n            mstore(0x00, 0x0d26b925)\n            mstore(0x20, 0x60)\n            mstore(0x40, p1)\n            mstore(0x60, p2)\n            writeString(0x80, p0)\n        }\n        _sendLogPayload(0x1c, 0xa4);\n        /// @solidity memory-safe-assembly\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n            mstore(0xa0, m5)\n        }\n    }\n\n    function log(bytes32 p0, address p1, bytes32 p2) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        bytes32 m5;\n        bytes32 m6;\n        bytes32 m7;\n        /// @solidity memory-safe-assembly\n        assembly {\n            function writeString(pos, w) {\n                let length := 0\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\n                mstore(pos, length)\n                let shift := sub(256, shl(3, length))\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\n            }\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            m5 := mload(0xa0)\n            m6 := mload(0xc0)\n            m7 := mload(0xe0)\n            // Selector of `log(string,address,string)`.\n            mstore(0x00, 0xe0e9ad4f)\n            mstore(0x20, 0x60)\n            mstore(0x40, p1)\n            mstore(0x60, 0xa0)\n            writeString(0x80, p0)\n            writeString(0xc0, p2)\n        }\n        _sendLogPayload(0x1c, 0xe4);\n        /// @solidity memory-safe-assembly\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n            mstore(0xa0, m5)\n            mstore(0xc0, m6)\n            mstore(0xe0, m7)\n        }\n    }\n\n    function log(bytes32 p0, bool p1, address p2) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        bytes32 m5;\n        /// @solidity memory-safe-assembly\n        assembly {\n            function writeString(pos, w) {\n                let length := 0\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\n                mstore(pos, length)\n                let shift := sub(256, shl(3, length))\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\n            }\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            m5 := mload(0xa0)\n            // Selector of `log(string,bool,address)`.\n            mstore(0x00, 0x932bbb38)\n            mstore(0x20, 0x60)\n            mstore(0x40, p1)\n            mstore(0x60, p2)\n            writeString(0x80, p0)\n        }\n        _sendLogPayload(0x1c, 0xa4);\n        /// @solidity memory-safe-assembly\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n            mstore(0xa0, m5)\n        }\n    }\n\n    function log(bytes32 p0, bool p1, bool p2) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        bytes32 m5;\n        /// @solidity memory-safe-assembly\n        assembly {\n            function writeString(pos, w) {\n                let length := 0\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\n                mstore(pos, length)\n                let shift := sub(256, shl(3, length))\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\n            }\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            m5 := mload(0xa0)\n            // Selector of `log(string,bool,bool)`.\n            mstore(0x00, 0x850b7ad6)\n            mstore(0x20, 0x60)\n            mstore(0x40, p1)\n            mstore(0x60, p2)\n            writeString(0x80, p0)\n        }\n        _sendLogPayload(0x1c, 0xa4);\n        /// @solidity memory-safe-assembly\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n            mstore(0xa0, m5)\n        }\n    }\n\n    function log(bytes32 p0, bool p1, uint256 p2) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        bytes32 m5;\n        /// @solidity memory-safe-assembly\n        assembly {\n            function writeString(pos, w) {\n                let length := 0\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\n                mstore(pos, length)\n                let shift := sub(256, shl(3, length))\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\n            }\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            m5 := mload(0xa0)\n            // Selector of `log(string,bool,uint256)`.\n            mstore(0x00, 0xc95958d6)\n            mstore(0x20, 0x60)\n            mstore(0x40, p1)\n            mstore(0x60, p2)\n            writeString(0x80, p0)\n        }\n        _sendLogPayload(0x1c, 0xa4);\n        /// @solidity memory-safe-assembly\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n            mstore(0xa0, m5)\n        }\n    }\n\n    function log(bytes32 p0, bool p1, bytes32 p2) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        bytes32 m5;\n        bytes32 m6;\n        bytes32 m7;\n        /// @solidity memory-safe-assembly\n        assembly {\n            function writeString(pos, w) {\n                let length := 0\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\n                mstore(pos, length)\n                let shift := sub(256, shl(3, length))\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\n            }\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            m5 := mload(0xa0)\n            m6 := mload(0xc0)\n            m7 := mload(0xe0)\n            // Selector of `log(string,bool,string)`.\n            mstore(0x00, 0xe298f47d)\n            mstore(0x20, 0x60)\n            mstore(0x40, p1)\n            mstore(0x60, 0xa0)\n            writeString(0x80, p0)\n            writeString(0xc0, p2)\n        }\n        _sendLogPayload(0x1c, 0xe4);\n        /// @solidity memory-safe-assembly\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n            mstore(0xa0, m5)\n            mstore(0xc0, m6)\n            mstore(0xe0, m7)\n        }\n    }\n\n    function log(bytes32 p0, uint256 p1, address p2) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        bytes32 m5;\n        /// @solidity memory-safe-assembly\n        assembly {\n            function writeString(pos, w) {\n                let length := 0\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\n                mstore(pos, length)\n                let shift := sub(256, shl(3, length))\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\n            }\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            m5 := mload(0xa0)\n            // Selector of `log(string,uint256,address)`.\n            mstore(0x00, 0x1c7ec448)\n            mstore(0x20, 0x60)\n            mstore(0x40, p1)\n            mstore(0x60, p2)\n            writeString(0x80, p0)\n        }\n        _sendLogPayload(0x1c, 0xa4);\n        /// @solidity memory-safe-assembly\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n            mstore(0xa0, m5)\n        }\n    }\n\n    function log(bytes32 p0, uint256 p1, bool p2) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        bytes32 m5;\n        /// @solidity memory-safe-assembly\n        assembly {\n            function writeString(pos, w) {\n                let length := 0\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\n                mstore(pos, length)\n                let shift := sub(256, shl(3, length))\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\n            }\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            m5 := mload(0xa0)\n            // Selector of `log(string,uint256,bool)`.\n            mstore(0x00, 0xca7733b1)\n            mstore(0x20, 0x60)\n            mstore(0x40, p1)\n            mstore(0x60, p2)\n            writeString(0x80, p0)\n        }\n        _sendLogPayload(0x1c, 0xa4);\n        /// @solidity memory-safe-assembly\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n            mstore(0xa0, m5)\n        }\n    }\n\n    function log(bytes32 p0, uint256 p1, uint256 p2) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        bytes32 m5;\n        /// @solidity memory-safe-assembly\n        assembly {\n            function writeString(pos, w) {\n                let length := 0\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\n                mstore(pos, length)\n                let shift := sub(256, shl(3, length))\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\n            }\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            m5 := mload(0xa0)\n            // Selector of `log(string,uint256,uint256)`.\n            mstore(0x00, 0xca47c4eb)\n            mstore(0x20, 0x60)\n            mstore(0x40, p1)\n            mstore(0x60, p2)\n            writeString(0x80, p0)\n        }\n        _sendLogPayload(0x1c, 0xa4);\n        /// @solidity memory-safe-assembly\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n            mstore(0xa0, m5)\n        }\n    }\n\n    function log(bytes32 p0, uint256 p1, bytes32 p2) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        bytes32 m5;\n        bytes32 m6;\n        bytes32 m7;\n        /// @solidity memory-safe-assembly\n        assembly {\n            function writeString(pos, w) {\n                let length := 0\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\n                mstore(pos, length)\n                let shift := sub(256, shl(3, length))\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\n            }\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            m5 := mload(0xa0)\n            m6 := mload(0xc0)\n            m7 := mload(0xe0)\n            // Selector of `log(string,uint256,string)`.\n            mstore(0x00, 0x5970e089)\n            mstore(0x20, 0x60)\n            mstore(0x40, p1)\n            mstore(0x60, 0xa0)\n            writeString(0x80, p0)\n            writeString(0xc0, p2)\n        }\n        _sendLogPayload(0x1c, 0xe4);\n        /// @solidity memory-safe-assembly\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n            mstore(0xa0, m5)\n            mstore(0xc0, m6)\n            mstore(0xe0, m7)\n        }\n    }\n\n    function log(bytes32 p0, bytes32 p1, address p2) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        bytes32 m5;\n        bytes32 m6;\n        bytes32 m7;\n        /// @solidity memory-safe-assembly\n        assembly {\n            function writeString(pos, w) {\n                let length := 0\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\n                mstore(pos, length)\n                let shift := sub(256, shl(3, length))\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\n            }\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            m5 := mload(0xa0)\n            m6 := mload(0xc0)\n            m7 := mload(0xe0)\n            // Selector of `log(string,string,address)`.\n            mstore(0x00, 0x95ed0195)\n            mstore(0x20, 0x60)\n            mstore(0x40, 0xa0)\n            mstore(0x60, p2)\n            writeString(0x80, p0)\n            writeString(0xc0, p1)\n        }\n        _sendLogPayload(0x1c, 0xe4);\n        /// @solidity memory-safe-assembly\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n            mstore(0xa0, m5)\n            mstore(0xc0, m6)\n            mstore(0xe0, m7)\n        }\n    }\n\n    function log(bytes32 p0, bytes32 p1, bool p2) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        bytes32 m5;\n        bytes32 m6;\n        bytes32 m7;\n        /// @solidity memory-safe-assembly\n        assembly {\n            function writeString(pos, w) {\n                let length := 0\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\n                mstore(pos, length)\n                let shift := sub(256, shl(3, length))\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\n            }\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            m5 := mload(0xa0)\n            m6 := mload(0xc0)\n            m7 := mload(0xe0)\n            // Selector of `log(string,string,bool)`.\n            mstore(0x00, 0xb0e0f9b5)\n            mstore(0x20, 0x60)\n            mstore(0x40, 0xa0)\n            mstore(0x60, p2)\n            writeString(0x80, p0)\n            writeString(0xc0, p1)\n        }\n        _sendLogPayload(0x1c, 0xe4);\n        /// @solidity memory-safe-assembly\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n            mstore(0xa0, m5)\n            mstore(0xc0, m6)\n            mstore(0xe0, m7)\n        }\n    }\n\n    function log(bytes32 p0, bytes32 p1, uint256 p2) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        bytes32 m5;\n        bytes32 m6;\n        bytes32 m7;\n        /// @solidity memory-safe-assembly\n        assembly {\n            function writeString(pos, w) {\n                let length := 0\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\n                mstore(pos, length)\n                let shift := sub(256, shl(3, length))\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\n            }\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            m5 := mload(0xa0)\n            m6 := mload(0xc0)\n            m7 := mload(0xe0)\n            // Selector of `log(string,string,uint256)`.\n            mstore(0x00, 0x5821efa1)\n            mstore(0x20, 0x60)\n            mstore(0x40, 0xa0)\n            mstore(0x60, p2)\n            writeString(0x80, p0)\n            writeString(0xc0, p1)\n        }\n        _sendLogPayload(0x1c, 0xe4);\n        /// @solidity memory-safe-assembly\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n            mstore(0xa0, m5)\n            mstore(0xc0, m6)\n            mstore(0xe0, m7)\n        }\n    }\n\n    function log(bytes32 p0, bytes32 p1, bytes32 p2) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        bytes32 m5;\n        bytes32 m6;\n        bytes32 m7;\n        bytes32 m8;\n        bytes32 m9;\n        /// @solidity memory-safe-assembly\n        assembly {\n            function writeString(pos, w) {\n                let length := 0\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\n                mstore(pos, length)\n                let shift := sub(256, shl(3, length))\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\n            }\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            m5 := mload(0xa0)\n            m6 := mload(0xc0)\n            m7 := mload(0xe0)\n            m8 := mload(0x100)\n            m9 := mload(0x120)\n            // Selector of `log(string,string,string)`.\n            mstore(0x00, 0x2ced7cef)\n            mstore(0x20, 0x60)\n            mstore(0x40, 0xa0)\n            mstore(0x60, 0xe0)\n            writeString(0x80, p0)\n            writeString(0xc0, p1)\n            writeString(0x100, p2)\n        }\n        _sendLogPayload(0x1c, 0x124);\n        /// @solidity memory-safe-assembly\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n            mstore(0xa0, m5)\n            mstore(0xc0, m6)\n            mstore(0xe0, m7)\n            mstore(0x100, m8)\n            mstore(0x120, m9)\n        }\n    }\n\n    function log(address p0, address p1, address p2, address p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        /// @solidity memory-safe-assembly\n        assembly {\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            // Selector of `log(address,address,address,address)`.\n            mstore(0x00, 0x665bf134)\n            mstore(0x20, p0)\n            mstore(0x40, p1)\n            mstore(0x60, p2)\n            mstore(0x80, p3)\n        }\n        _sendLogPayload(0x1c, 0x84);\n        /// @solidity memory-safe-assembly\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n        }\n    }\n\n    function log(address p0, address p1, address p2, bool p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        /// @solidity memory-safe-assembly\n        assembly {\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            // Selector of `log(address,address,address,bool)`.\n            mstore(0x00, 0x0e378994)\n            mstore(0x20, p0)\n            mstore(0x40, p1)\n            mstore(0x60, p2)\n            mstore(0x80, p3)\n        }\n        _sendLogPayload(0x1c, 0x84);\n        /// @solidity memory-safe-assembly\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n        }\n    }\n\n    function log(address p0, address p1, address p2, uint256 p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        /// @solidity memory-safe-assembly\n        assembly {\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            // Selector of `log(address,address,address,uint256)`.\n            mstore(0x00, 0x94250d77)\n            mstore(0x20, p0)\n            mstore(0x40, p1)\n            mstore(0x60, p2)\n            mstore(0x80, p3)\n        }\n        _sendLogPayload(0x1c, 0x84);\n        /// @solidity memory-safe-assembly\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n        }\n    }\n\n    function log(address p0, address p1, address p2, bytes32 p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        bytes32 m5;\n        bytes32 m6;\n        /// @solidity memory-safe-assembly\n        assembly {\n            function writeString(pos, w) {\n                let length := 0\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\n                mstore(pos, length)\n                let shift := sub(256, shl(3, length))\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\n            }\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            m5 := mload(0xa0)\n            m6 := mload(0xc0)\n            // Selector of `log(address,address,address,string)`.\n            mstore(0x00, 0xf808da20)\n            mstore(0x20, p0)\n            mstore(0x40, p1)\n            mstore(0x60, p2)\n            mstore(0x80, 0x80)\n            writeString(0xa0, p3)\n        }\n        _sendLogPayload(0x1c, 0xc4);\n        /// @solidity memory-safe-assembly\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n            mstore(0xa0, m5)\n            mstore(0xc0, m6)\n        }\n    }\n\n    function log(address p0, address p1, bool p2, address p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        /// @solidity memory-safe-assembly\n        assembly {\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            // Selector of `log(address,address,bool,address)`.\n            mstore(0x00, 0x9f1bc36e)\n            mstore(0x20, p0)\n            mstore(0x40, p1)\n            mstore(0x60, p2)\n            mstore(0x80, p3)\n        }\n        _sendLogPayload(0x1c, 0x84);\n        /// @solidity memory-safe-assembly\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n        }\n    }\n\n    function log(address p0, address p1, bool p2, bool p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        /// @solidity memory-safe-assembly\n        assembly {\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            // Selector of `log(address,address,bool,bool)`.\n            mstore(0x00, 0x2cd4134a)\n            mstore(0x20, p0)\n            mstore(0x40, p1)\n            mstore(0x60, p2)\n            mstore(0x80, p3)\n        }\n        _sendLogPayload(0x1c, 0x84);\n        /// @solidity memory-safe-assembly\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n        }\n    }\n\n    function log(address p0, address p1, bool p2, uint256 p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        /// @solidity memory-safe-assembly\n        assembly {\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            // Selector of `log(address,address,bool,uint256)`.\n            mstore(0x00, 0x3971e78c)\n            mstore(0x20, p0)\n            mstore(0x40, p1)\n            mstore(0x60, p2)\n            mstore(0x80, p3)\n        }\n        _sendLogPayload(0x1c, 0x84);\n        /// @solidity memory-safe-assembly\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n        }\n    }\n\n    function log(address p0, address p1, bool p2, bytes32 p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        bytes32 m5;\n        bytes32 m6;\n        /// @solidity memory-safe-assembly\n        assembly {\n            function writeString(pos, w) {\n                let length := 0\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\n                mstore(pos, length)\n                let shift := sub(256, shl(3, length))\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\n            }\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            m5 := mload(0xa0)\n            m6 := mload(0xc0)\n            // Selector of `log(address,address,bool,string)`.\n            mstore(0x00, 0xaa6540c8)\n            mstore(0x20, p0)\n            mstore(0x40, p1)\n            mstore(0x60, p2)\n            mstore(0x80, 0x80)\n            writeString(0xa0, p3)\n        }\n        _sendLogPayload(0x1c, 0xc4);\n        /// @solidity memory-safe-assembly\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n            mstore(0xa0, m5)\n            mstore(0xc0, m6)\n        }\n    }\n\n    function log(address p0, address p1, uint256 p2, address p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        /// @solidity memory-safe-assembly\n        assembly {\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            // Selector of `log(address,address,uint256,address)`.\n            mstore(0x00, 0x8da6def5)\n            mstore(0x20, p0)\n            mstore(0x40, p1)\n            mstore(0x60, p2)\n            mstore(0x80, p3)\n        }\n        _sendLogPayload(0x1c, 0x84);\n        /// @solidity memory-safe-assembly\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n        }\n    }\n\n    function log(address p0, address p1, uint256 p2, bool p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        /// @solidity memory-safe-assembly\n        assembly {\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            // Selector of `log(address,address,uint256,bool)`.\n            mstore(0x00, 0x9b4254e2)\n            mstore(0x20, p0)\n            mstore(0x40, p1)\n            mstore(0x60, p2)\n            mstore(0x80, p3)\n        }\n        _sendLogPayload(0x1c, 0x84);\n        /// @solidity memory-safe-assembly\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n        }\n    }\n\n    function log(address p0, address p1, uint256 p2, uint256 p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        /// @solidity memory-safe-assembly\n        assembly {\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            // Selector of `log(address,address,uint256,uint256)`.\n            mstore(0x00, 0xbe553481)\n            mstore(0x20, p0)\n            mstore(0x40, p1)\n            mstore(0x60, p2)\n            mstore(0x80, p3)\n        }\n        _sendLogPayload(0x1c, 0x84);\n        /// @solidity memory-safe-assembly\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n        }\n    }\n\n    function log(address p0, address p1, uint256 p2, bytes32 p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        bytes32 m5;\n        bytes32 m6;\n        /// @solidity memory-safe-assembly\n        assembly {\n            function writeString(pos, w) {\n                let length := 0\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\n                mstore(pos, length)\n                let shift := sub(256, shl(3, length))\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\n            }\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            m5 := mload(0xa0)\n            m6 := mload(0xc0)\n            // Selector of `log(address,address,uint256,string)`.\n            mstore(0x00, 0xfdb4f990)\n            mstore(0x20, p0)\n            mstore(0x40, p1)\n            mstore(0x60, p2)\n            mstore(0x80, 0x80)\n            writeString(0xa0, p3)\n        }\n        _sendLogPayload(0x1c, 0xc4);\n        /// @solidity memory-safe-assembly\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n            mstore(0xa0, m5)\n            mstore(0xc0, m6)\n        }\n    }\n\n    function log(address p0, address p1, bytes32 p2, address p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        bytes32 m5;\n        bytes32 m6;\n        /// @solidity memory-safe-assembly\n        assembly {\n            function writeString(pos, w) {\n                let length := 0\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\n                mstore(pos, length)\n                let shift := sub(256, shl(3, length))\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\n            }\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            m5 := mload(0xa0)\n            m6 := mload(0xc0)\n            // Selector of `log(address,address,string,address)`.\n            mstore(0x00, 0x8f736d16)\n            mstore(0x20, p0)\n            mstore(0x40, p1)\n            mstore(0x60, 0x80)\n            mstore(0x80, p3)\n            writeString(0xa0, p2)\n        }\n        _sendLogPayload(0x1c, 0xc4);\n        /// @solidity memory-safe-assembly\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n            mstore(0xa0, m5)\n            mstore(0xc0, m6)\n        }\n    }\n\n    function log(address p0, address p1, bytes32 p2, bool p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        bytes32 m5;\n        bytes32 m6;\n        /// @solidity memory-safe-assembly\n        assembly {\n            function writeString(pos, w) {\n                let length := 0\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\n                mstore(pos, length)\n                let shift := sub(256, shl(3, length))\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\n            }\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            m5 := mload(0xa0)\n            m6 := mload(0xc0)\n            // Selector of `log(address,address,string,bool)`.\n            mstore(0x00, 0x6f1a594e)\n            mstore(0x20, p0)\n            mstore(0x40, p1)\n            mstore(0x60, 0x80)\n            mstore(0x80, p3)\n            writeString(0xa0, p2)\n        }\n        _sendLogPayload(0x1c, 0xc4);\n        /// @solidity memory-safe-assembly\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n            mstore(0xa0, m5)\n            mstore(0xc0, m6)\n        }\n    }\n\n    function log(address p0, address p1, bytes32 p2, uint256 p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        bytes32 m5;\n        bytes32 m6;\n        /// @solidity memory-safe-assembly\n        assembly {\n            function writeString(pos, w) {\n                let length := 0\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\n                mstore(pos, length)\n                let shift := sub(256, shl(3, length))\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\n            }\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            m5 := mload(0xa0)\n            m6 := mload(0xc0)\n            // Selector of `log(address,address,string,uint256)`.\n            mstore(0x00, 0xef1cefe7)\n            mstore(0x20, p0)\n            mstore(0x40, p1)\n            mstore(0x60, 0x80)\n            mstore(0x80, p3)\n            writeString(0xa0, p2)\n        }\n        _sendLogPayload(0x1c, 0xc4);\n        /// @solidity memory-safe-assembly\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n            mstore(0xa0, m5)\n            mstore(0xc0, m6)\n        }\n    }\n\n    function log(address p0, address p1, bytes32 p2, bytes32 p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        bytes32 m5;\n        bytes32 m6;\n        bytes32 m7;\n        bytes32 m8;\n        /// @solidity memory-safe-assembly\n        assembly {\n            function writeString(pos, w) {\n                let length := 0\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\n                mstore(pos, length)\n                let shift := sub(256, shl(3, length))\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\n            }\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            m5 := mload(0xa0)\n            m6 := mload(0xc0)\n            m7 := mload(0xe0)\n            m8 := mload(0x100)\n            // Selector of `log(address,address,string,string)`.\n            mstore(0x00, 0x21bdaf25)\n            mstore(0x20, p0)\n            mstore(0x40, p1)\n            mstore(0x60, 0x80)\n            mstore(0x80, 0xc0)\n            writeString(0xa0, p2)\n            writeString(0xe0, p3)\n        }\n        _sendLogPayload(0x1c, 0x104);\n        /// @solidity memory-safe-assembly\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n            mstore(0xa0, m5)\n            mstore(0xc0, m6)\n            mstore(0xe0, m7)\n            mstore(0x100, m8)\n        }\n    }\n\n    function log(address p0, bool p1, address p2, address p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        /// @solidity memory-safe-assembly\n        assembly {\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            // Selector of `log(address,bool,address,address)`.\n            mstore(0x00, 0x660375dd)\n            mstore(0x20, p0)\n            mstore(0x40, p1)\n            mstore(0x60, p2)\n            mstore(0x80, p3)\n        }\n        _sendLogPayload(0x1c, 0x84);\n        /// @solidity memory-safe-assembly\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n        }\n    }\n\n    function log(address p0, bool p1, address p2, bool p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        /// @solidity memory-safe-assembly\n        assembly {\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            // Selector of `log(address,bool,address,bool)`.\n            mstore(0x00, 0xa6f50b0f)\n            mstore(0x20, p0)\n            mstore(0x40, p1)\n            mstore(0x60, p2)\n            mstore(0x80, p3)\n        }\n        _sendLogPayload(0x1c, 0x84);\n        /// @solidity memory-safe-assembly\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n        }\n    }\n\n    function log(address p0, bool p1, address p2, uint256 p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        /// @solidity memory-safe-assembly\n        assembly {\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            // Selector of `log(address,bool,address,uint256)`.\n            mstore(0x00, 0xa75c59de)\n            mstore(0x20, p0)\n            mstore(0x40, p1)\n            mstore(0x60, p2)\n            mstore(0x80, p3)\n        }\n        _sendLogPayload(0x1c, 0x84);\n        /// @solidity memory-safe-assembly\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n        }\n    }\n\n    function log(address p0, bool p1, address p2, bytes32 p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        bytes32 m5;\n        bytes32 m6;\n        /// @solidity memory-safe-assembly\n        assembly {\n            function writeString(pos, w) {\n                let length := 0\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\n                mstore(pos, length)\n                let shift := sub(256, shl(3, length))\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\n            }\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            m5 := mload(0xa0)\n            m6 := mload(0xc0)\n            // Selector of `log(address,bool,address,string)`.\n            mstore(0x00, 0x2dd778e6)\n            mstore(0x20, p0)\n            mstore(0x40, p1)\n            mstore(0x60, p2)\n            mstore(0x80, 0x80)\n            writeString(0xa0, p3)\n        }\n        _sendLogPayload(0x1c, 0xc4);\n        /// @solidity memory-safe-assembly\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n            mstore(0xa0, m5)\n            mstore(0xc0, m6)\n        }\n    }\n\n    function log(address p0, bool p1, bool p2, address p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        /// @solidity memory-safe-assembly\n        assembly {\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            // Selector of `log(address,bool,bool,address)`.\n            mstore(0x00, 0xcf394485)\n            mstore(0x20, p0)\n            mstore(0x40, p1)\n            mstore(0x60, p2)\n            mstore(0x80, p3)\n        }\n        _sendLogPayload(0x1c, 0x84);\n        /// @solidity memory-safe-assembly\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n        }\n    }\n\n    function log(address p0, bool p1, bool p2, bool p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        /// @solidity memory-safe-assembly\n        assembly {\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            // Selector of `log(address,bool,bool,bool)`.\n            mstore(0x00, 0xcac43479)\n            mstore(0x20, p0)\n            mstore(0x40, p1)\n            mstore(0x60, p2)\n            mstore(0x80, p3)\n        }\n        _sendLogPayload(0x1c, 0x84);\n        /// @solidity memory-safe-assembly\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n        }\n    }\n\n    function log(address p0, bool p1, bool p2, uint256 p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        /// @solidity memory-safe-assembly\n        assembly {\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            // Selector of `log(address,bool,bool,uint256)`.\n            mstore(0x00, 0x8c4e5de6)\n            mstore(0x20, p0)\n            mstore(0x40, p1)\n            mstore(0x60, p2)\n            mstore(0x80, p3)\n        }\n        _sendLogPayload(0x1c, 0x84);\n        /// @solidity memory-safe-assembly\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n        }\n    }\n\n    function log(address p0, bool p1, bool p2, bytes32 p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        bytes32 m5;\n        bytes32 m6;\n        /// @solidity memory-safe-assembly\n        assembly {\n            function writeString(pos, w) {\n                let length := 0\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\n                mstore(pos, length)\n                let shift := sub(256, shl(3, length))\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\n            }\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            m5 := mload(0xa0)\n            m6 := mload(0xc0)\n            // Selector of `log(address,bool,bool,string)`.\n            mstore(0x00, 0xdfc4a2e8)\n            mstore(0x20, p0)\n            mstore(0x40, p1)\n            mstore(0x60, p2)\n            mstore(0x80, 0x80)\n            writeString(0xa0, p3)\n        }\n        _sendLogPayload(0x1c, 0xc4);\n        /// @solidity memory-safe-assembly\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n            mstore(0xa0, m5)\n            mstore(0xc0, m6)\n        }\n    }\n\n    function log(address p0, bool p1, uint256 p2, address p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        /// @solidity memory-safe-assembly\n        assembly {\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            // Selector of `log(address,bool,uint256,address)`.\n            mstore(0x00, 0xccf790a1)\n            mstore(0x20, p0)\n            mstore(0x40, p1)\n            mstore(0x60, p2)\n            mstore(0x80, p3)\n        }\n        _sendLogPayload(0x1c, 0x84);\n        /// @solidity memory-safe-assembly\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n        }\n    }\n\n    function log(address p0, bool p1, uint256 p2, bool p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        /// @solidity memory-safe-assembly\n        assembly {\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            // Selector of `log(address,bool,uint256,bool)`.\n            mstore(0x00, 0xc4643e20)\n            mstore(0x20, p0)\n            mstore(0x40, p1)\n            mstore(0x60, p2)\n            mstore(0x80, p3)\n        }\n        _sendLogPayload(0x1c, 0x84);\n        /// @solidity memory-safe-assembly\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n        }\n    }\n\n    function log(address p0, bool p1, uint256 p2, uint256 p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        /// @solidity memory-safe-assembly\n        assembly {\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            // Selector of `log(address,bool,uint256,uint256)`.\n            mstore(0x00, 0x386ff5f4)\n            mstore(0x20, p0)\n            mstore(0x40, p1)\n            mstore(0x60, p2)\n            mstore(0x80, p3)\n        }\n        _sendLogPayload(0x1c, 0x84);\n        /// @solidity memory-safe-assembly\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n        }\n    }\n\n    function log(address p0, bool p1, uint256 p2, bytes32 p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        bytes32 m5;\n        bytes32 m6;\n        /// @solidity memory-safe-assembly\n        assembly {\n            function writeString(pos, w) {\n                let length := 0\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\n                mstore(pos, length)\n                let shift := sub(256, shl(3, length))\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\n            }\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            m5 := mload(0xa0)\n            m6 := mload(0xc0)\n            // Selector of `log(address,bool,uint256,string)`.\n            mstore(0x00, 0x0aa6cfad)\n            mstore(0x20, p0)\n            mstore(0x40, p1)\n            mstore(0x60, p2)\n            mstore(0x80, 0x80)\n            writeString(0xa0, p3)\n        }\n        _sendLogPayload(0x1c, 0xc4);\n        /// @solidity memory-safe-assembly\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n            mstore(0xa0, m5)\n            mstore(0xc0, m6)\n        }\n    }\n\n    function log(address p0, bool p1, bytes32 p2, address p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        bytes32 m5;\n        bytes32 m6;\n        /// @solidity memory-safe-assembly\n        assembly {\n            function writeString(pos, w) {\n                let length := 0\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\n                mstore(pos, length)\n                let shift := sub(256, shl(3, length))\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\n            }\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            m5 := mload(0xa0)\n            m6 := mload(0xc0)\n            // Selector of `log(address,bool,string,address)`.\n            mstore(0x00, 0x19fd4956)\n            mstore(0x20, p0)\n            mstore(0x40, p1)\n            mstore(0x60, 0x80)\n            mstore(0x80, p3)\n            writeString(0xa0, p2)\n        }\n        _sendLogPayload(0x1c, 0xc4);\n        /// @solidity memory-safe-assembly\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n            mstore(0xa0, m5)\n            mstore(0xc0, m6)\n        }\n    }\n\n    function log(address p0, bool p1, bytes32 p2, bool p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        bytes32 m5;\n        bytes32 m6;\n        /// @solidity memory-safe-assembly\n        assembly {\n            function writeString(pos, w) {\n                let length := 0\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\n                mstore(pos, length)\n                let shift := sub(256, shl(3, length))\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\n            }\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            m5 := mload(0xa0)\n            m6 := mload(0xc0)\n            // Selector of `log(address,bool,string,bool)`.\n            mstore(0x00, 0x50ad461d)\n            mstore(0x20, p0)\n            mstore(0x40, p1)\n            mstore(0x60, 0x80)\n            mstore(0x80, p3)\n            writeString(0xa0, p2)\n        }\n        _sendLogPayload(0x1c, 0xc4);\n        /// @solidity memory-safe-assembly\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n            mstore(0xa0, m5)\n            mstore(0xc0, m6)\n        }\n    }\n\n    function log(address p0, bool p1, bytes32 p2, uint256 p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        bytes32 m5;\n        bytes32 m6;\n        /// @solidity memory-safe-assembly\n        assembly {\n            function writeString(pos, w) {\n                let length := 0\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\n                mstore(pos, length)\n                let shift := sub(256, shl(3, length))\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\n            }\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            m5 := mload(0xa0)\n            m6 := mload(0xc0)\n            // Selector of `log(address,bool,string,uint256)`.\n            mstore(0x00, 0x80e6a20b)\n            mstore(0x20, p0)\n            mstore(0x40, p1)\n            mstore(0x60, 0x80)\n            mstore(0x80, p3)\n            writeString(0xa0, p2)\n        }\n        _sendLogPayload(0x1c, 0xc4);\n        /// @solidity memory-safe-assembly\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n            mstore(0xa0, m5)\n            mstore(0xc0, m6)\n        }\n    }\n\n    function log(address p0, bool p1, bytes32 p2, bytes32 p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        bytes32 m5;\n        bytes32 m6;\n        bytes32 m7;\n        bytes32 m8;\n        /// @solidity memory-safe-assembly\n        assembly {\n            function writeString(pos, w) {\n                let length := 0\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\n                mstore(pos, length)\n                let shift := sub(256, shl(3, length))\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\n            }\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            m5 := mload(0xa0)\n            m6 := mload(0xc0)\n            m7 := mload(0xe0)\n            m8 := mload(0x100)\n            // Selector of `log(address,bool,string,string)`.\n            mstore(0x00, 0x475c5c33)\n            mstore(0x20, p0)\n            mstore(0x40, p1)\n            mstore(0x60, 0x80)\n            mstore(0x80, 0xc0)\n            writeString(0xa0, p2)\n            writeString(0xe0, p3)\n        }\n        _sendLogPayload(0x1c, 0x104);\n        /// @solidity memory-safe-assembly\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n            mstore(0xa0, m5)\n            mstore(0xc0, m6)\n            mstore(0xe0, m7)\n            mstore(0x100, m8)\n        }\n    }\n\n    function log(address p0, uint256 p1, address p2, address p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        /// @solidity memory-safe-assembly\n        assembly {\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            // Selector of `log(address,uint256,address,address)`.\n            mstore(0x00, 0x478d1c62)\n            mstore(0x20, p0)\n            mstore(0x40, p1)\n            mstore(0x60, p2)\n            mstore(0x80, p3)\n        }\n        _sendLogPayload(0x1c, 0x84);\n        /// @solidity memory-safe-assembly\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n        }\n    }\n\n    function log(address p0, uint256 p1, address p2, bool p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        /// @solidity memory-safe-assembly\n        assembly {\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            // Selector of `log(address,uint256,address,bool)`.\n            mstore(0x00, 0xa1bcc9b3)\n            mstore(0x20, p0)\n            mstore(0x40, p1)\n            mstore(0x60, p2)\n            mstore(0x80, p3)\n        }\n        _sendLogPayload(0x1c, 0x84);\n        /// @solidity memory-safe-assembly\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n        }\n    }\n\n    function log(address p0, uint256 p1, address p2, uint256 p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        /// @solidity memory-safe-assembly\n        assembly {\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            // Selector of `log(address,uint256,address,uint256)`.\n            mstore(0x00, 0x100f650e)\n            mstore(0x20, p0)\n            mstore(0x40, p1)\n            mstore(0x60, p2)\n            mstore(0x80, p3)\n        }\n        _sendLogPayload(0x1c, 0x84);\n        /// @solidity memory-safe-assembly\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n        }\n    }\n\n    function log(address p0, uint256 p1, address p2, bytes32 p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        bytes32 m5;\n        bytes32 m6;\n        /// @solidity memory-safe-assembly\n        assembly {\n            function writeString(pos, w) {\n                let length := 0\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\n                mstore(pos, length)\n                let shift := sub(256, shl(3, length))\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\n            }\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            m5 := mload(0xa0)\n            m6 := mload(0xc0)\n            // Selector of `log(address,uint256,address,string)`.\n            mstore(0x00, 0x1da986ea)\n            mstore(0x20, p0)\n            mstore(0x40, p1)\n            mstore(0x60, p2)\n            mstore(0x80, 0x80)\n            writeString(0xa0, p3)\n        }\n        _sendLogPayload(0x1c, 0xc4);\n        /// @solidity memory-safe-assembly\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n            mstore(0xa0, m5)\n            mstore(0xc0, m6)\n        }\n    }\n\n    function log(address p0, uint256 p1, bool p2, address p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        /// @solidity memory-safe-assembly\n        assembly {\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            // Selector of `log(address,uint256,bool,address)`.\n            mstore(0x00, 0xa31bfdcc)\n            mstore(0x20, p0)\n            mstore(0x40, p1)\n            mstore(0x60, p2)\n            mstore(0x80, p3)\n        }\n        _sendLogPayload(0x1c, 0x84);\n        /// @solidity memory-safe-assembly\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n        }\n    }\n\n    function log(address p0, uint256 p1, bool p2, bool p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        /// @solidity memory-safe-assembly\n        assembly {\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            // Selector of `log(address,uint256,bool,bool)`.\n            mstore(0x00, 0x3bf5e537)\n            mstore(0x20, p0)\n            mstore(0x40, p1)\n            mstore(0x60, p2)\n            mstore(0x80, p3)\n        }\n        _sendLogPayload(0x1c, 0x84);\n        /// @solidity memory-safe-assembly\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n        }\n    }\n\n    function log(address p0, uint256 p1, bool p2, uint256 p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        /// @solidity memory-safe-assembly\n        assembly {\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            // Selector of `log(address,uint256,bool,uint256)`.\n            mstore(0x00, 0x22f6b999)\n            mstore(0x20, p0)\n            mstore(0x40, p1)\n            mstore(0x60, p2)\n            mstore(0x80, p3)\n        }\n        _sendLogPayload(0x1c, 0x84);\n        /// @solidity memory-safe-assembly\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n        }\n    }\n\n    function log(address p0, uint256 p1, bool p2, bytes32 p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        bytes32 m5;\n        bytes32 m6;\n        /// @solidity memory-safe-assembly\n        assembly {\n            function writeString(pos, w) {\n                let length := 0\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\n                mstore(pos, length)\n                let shift := sub(256, shl(3, length))\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\n            }\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            m5 := mload(0xa0)\n            m6 := mload(0xc0)\n            // Selector of `log(address,uint256,bool,string)`.\n            mstore(0x00, 0xc5ad85f9)\n            mstore(0x20, p0)\n            mstore(0x40, p1)\n            mstore(0x60, p2)\n            mstore(0x80, 0x80)\n            writeString(0xa0, p3)\n        }\n        _sendLogPayload(0x1c, 0xc4);\n        /// @solidity memory-safe-assembly\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n            mstore(0xa0, m5)\n            mstore(0xc0, m6)\n        }\n    }\n\n    function log(address p0, uint256 p1, uint256 p2, address p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        /// @solidity memory-safe-assembly\n        assembly {\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            // Selector of `log(address,uint256,uint256,address)`.\n            mstore(0x00, 0x20e3984d)\n            mstore(0x20, p0)\n            mstore(0x40, p1)\n            mstore(0x60, p2)\n            mstore(0x80, p3)\n        }\n        _sendLogPayload(0x1c, 0x84);\n        /// @solidity memory-safe-assembly\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n        }\n    }\n\n    function log(address p0, uint256 p1, uint256 p2, bool p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        /// @solidity memory-safe-assembly\n        assembly {\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            // Selector of `log(address,uint256,uint256,bool)`.\n            mstore(0x00, 0x66f1bc67)\n            mstore(0x20, p0)\n            mstore(0x40, p1)\n            mstore(0x60, p2)\n            mstore(0x80, p3)\n        }\n        _sendLogPayload(0x1c, 0x84);\n        /// @solidity memory-safe-assembly\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n        }\n    }\n\n    function log(address p0, uint256 p1, uint256 p2, uint256 p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        /// @solidity memory-safe-assembly\n        assembly {\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            // Selector of `log(address,uint256,uint256,uint256)`.\n            mstore(0x00, 0x34f0e636)\n            mstore(0x20, p0)\n            mstore(0x40, p1)\n            mstore(0x60, p2)\n            mstore(0x80, p3)\n        }\n        _sendLogPayload(0x1c, 0x84);\n        /// @solidity memory-safe-assembly\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n        }\n    }\n\n    function log(address p0, uint256 p1, uint256 p2, bytes32 p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        bytes32 m5;\n        bytes32 m6;\n        /// @solidity memory-safe-assembly\n        assembly {\n            function writeString(pos, w) {\n                let length := 0\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\n                mstore(pos, length)\n                let shift := sub(256, shl(3, length))\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\n            }\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            m5 := mload(0xa0)\n            m6 := mload(0xc0)\n            // Selector of `log(address,uint256,uint256,string)`.\n            mstore(0x00, 0x4a28c017)\n            mstore(0x20, p0)\n            mstore(0x40, p1)\n            mstore(0x60, p2)\n            mstore(0x80, 0x80)\n            writeString(0xa0, p3)\n        }\n        _sendLogPayload(0x1c, 0xc4);\n        /// @solidity memory-safe-assembly\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n            mstore(0xa0, m5)\n            mstore(0xc0, m6)\n        }\n    }\n\n    function log(address p0, uint256 p1, bytes32 p2, address p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        bytes32 m5;\n        bytes32 m6;\n        /// @solidity memory-safe-assembly\n        assembly {\n            function writeString(pos, w) {\n                let length := 0\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\n                mstore(pos, length)\n                let shift := sub(256, shl(3, length))\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\n            }\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            m5 := mload(0xa0)\n            m6 := mload(0xc0)\n            // Selector of `log(address,uint256,string,address)`.\n            mstore(0x00, 0x5c430d47)\n            mstore(0x20, p0)\n            mstore(0x40, p1)\n            mstore(0x60, 0x80)\n            mstore(0x80, p3)\n            writeString(0xa0, p2)\n        }\n        _sendLogPayload(0x1c, 0xc4);\n        /// @solidity memory-safe-assembly\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n            mstore(0xa0, m5)\n            mstore(0xc0, m6)\n        }\n    }\n\n    function log(address p0, uint256 p1, bytes32 p2, bool p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        bytes32 m5;\n        bytes32 m6;\n        /// @solidity memory-safe-assembly\n        assembly {\n            function writeString(pos, w) {\n                let length := 0\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\n                mstore(pos, length)\n                let shift := sub(256, shl(3, length))\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\n            }\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            m5 := mload(0xa0)\n            m6 := mload(0xc0)\n            // Selector of `log(address,uint256,string,bool)`.\n            mstore(0x00, 0xcf18105c)\n            mstore(0x20, p0)\n            mstore(0x40, p1)\n            mstore(0x60, 0x80)\n            mstore(0x80, p3)\n            writeString(0xa0, p2)\n        }\n        _sendLogPayload(0x1c, 0xc4);\n        /// @solidity memory-safe-assembly\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n            mstore(0xa0, m5)\n            mstore(0xc0, m6)\n        }\n    }\n\n    function log(address p0, uint256 p1, bytes32 p2, uint256 p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        bytes32 m5;\n        bytes32 m6;\n        /// @solidity memory-safe-assembly\n        assembly {\n            function writeString(pos, w) {\n                let length := 0\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\n                mstore(pos, length)\n                let shift := sub(256, shl(3, length))\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\n            }\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            m5 := mload(0xa0)\n            m6 := mload(0xc0)\n            // Selector of `log(address,uint256,string,uint256)`.\n            mstore(0x00, 0xbf01f891)\n            mstore(0x20, p0)\n            mstore(0x40, p1)\n            mstore(0x60, 0x80)\n            mstore(0x80, p3)\n            writeString(0xa0, p2)\n        }\n        _sendLogPayload(0x1c, 0xc4);\n        /// @solidity memory-safe-assembly\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n            mstore(0xa0, m5)\n            mstore(0xc0, m6)\n        }\n    }\n\n    function log(address p0, uint256 p1, bytes32 p2, bytes32 p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        bytes32 m5;\n        bytes32 m6;\n        bytes32 m7;\n        bytes32 m8;\n        /// @solidity memory-safe-assembly\n        assembly {\n            function writeString(pos, w) {\n                let length := 0\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\n                mstore(pos, length)\n                let shift := sub(256, shl(3, length))\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\n            }\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            m5 := mload(0xa0)\n            m6 := mload(0xc0)\n            m7 := mload(0xe0)\n            m8 := mload(0x100)\n            // Selector of `log(address,uint256,string,string)`.\n            mstore(0x00, 0x88a8c406)\n            mstore(0x20, p0)\n            mstore(0x40, p1)\n            mstore(0x60, 0x80)\n            mstore(0x80, 0xc0)\n            writeString(0xa0, p2)\n            writeString(0xe0, p3)\n        }\n        _sendLogPayload(0x1c, 0x104);\n        /// @solidity memory-safe-assembly\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n            mstore(0xa0, m5)\n            mstore(0xc0, m6)\n            mstore(0xe0, m7)\n            mstore(0x100, m8)\n        }\n    }\n\n    function log(address p0, bytes32 p1, address p2, address p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        bytes32 m5;\n        bytes32 m6;\n        /// @solidity memory-safe-assembly\n        assembly {\n            function writeString(pos, w) {\n                let length := 0\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\n                mstore(pos, length)\n                let shift := sub(256, shl(3, length))\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\n            }\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            m5 := mload(0xa0)\n            m6 := mload(0xc0)\n            // Selector of `log(address,string,address,address)`.\n            mstore(0x00, 0x0d36fa20)\n            mstore(0x20, p0)\n            mstore(0x40, 0x80)\n            mstore(0x60, p2)\n            mstore(0x80, p3)\n            writeString(0xa0, p1)\n        }\n        _sendLogPayload(0x1c, 0xc4);\n        /// @solidity memory-safe-assembly\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n            mstore(0xa0, m5)\n            mstore(0xc0, m6)\n        }\n    }\n\n    function log(address p0, bytes32 p1, address p2, bool p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        bytes32 m5;\n        bytes32 m6;\n        /// @solidity memory-safe-assembly\n        assembly {\n            function writeString(pos, w) {\n                let length := 0\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\n                mstore(pos, length)\n                let shift := sub(256, shl(3, length))\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\n            }\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            m5 := mload(0xa0)\n            m6 := mload(0xc0)\n            // Selector of `log(address,string,address,bool)`.\n            mstore(0x00, 0x0df12b76)\n            mstore(0x20, p0)\n            mstore(0x40, 0x80)\n            mstore(0x60, p2)\n            mstore(0x80, p3)\n            writeString(0xa0, p1)\n        }\n        _sendLogPayload(0x1c, 0xc4);\n        /// @solidity memory-safe-assembly\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n            mstore(0xa0, m5)\n            mstore(0xc0, m6)\n        }\n    }\n\n    function log(address p0, bytes32 p1, address p2, uint256 p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        bytes32 m5;\n        bytes32 m6;\n        /// @solidity memory-safe-assembly\n        assembly {\n            function writeString(pos, w) {\n                let length := 0\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\n                mstore(pos, length)\n                let shift := sub(256, shl(3, length))\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\n            }\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            m5 := mload(0xa0)\n            m6 := mload(0xc0)\n            // Selector of `log(address,string,address,uint256)`.\n            mstore(0x00, 0x457fe3cf)\n            mstore(0x20, p0)\n            mstore(0x40, 0x80)\n            mstore(0x60, p2)\n            mstore(0x80, p3)\n            writeString(0xa0, p1)\n        }\n        _sendLogPayload(0x1c, 0xc4);\n        /// @solidity memory-safe-assembly\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n            mstore(0xa0, m5)\n            mstore(0xc0, m6)\n        }\n    }\n\n    function log(address p0, bytes32 p1, address p2, bytes32 p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        bytes32 m5;\n        bytes32 m6;\n        bytes32 m7;\n        bytes32 m8;\n        /// @solidity memory-safe-assembly\n        assembly {\n            function writeString(pos, w) {\n                let length := 0\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\n                mstore(pos, length)\n                let shift := sub(256, shl(3, length))\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\n            }\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            m5 := mload(0xa0)\n            m6 := mload(0xc0)\n            m7 := mload(0xe0)\n            m8 := mload(0x100)\n            // Selector of `log(address,string,address,string)`.\n            mstore(0x00, 0xf7e36245)\n            mstore(0x20, p0)\n            mstore(0x40, 0x80)\n            mstore(0x60, p2)\n            mstore(0x80, 0xc0)\n            writeString(0xa0, p1)\n            writeString(0xe0, p3)\n        }\n        _sendLogPayload(0x1c, 0x104);\n        /// @solidity memory-safe-assembly\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n            mstore(0xa0, m5)\n            mstore(0xc0, m6)\n            mstore(0xe0, m7)\n            mstore(0x100, m8)\n        }\n    }\n\n    function log(address p0, bytes32 p1, bool p2, address p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        bytes32 m5;\n        bytes32 m6;\n        /// @solidity memory-safe-assembly\n        assembly {\n            function writeString(pos, w) {\n                let length := 0\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\n                mstore(pos, length)\n                let shift := sub(256, shl(3, length))\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\n            }\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            m5 := mload(0xa0)\n            m6 := mload(0xc0)\n            // Selector of `log(address,string,bool,address)`.\n            mstore(0x00, 0x205871c2)\n            mstore(0x20, p0)\n            mstore(0x40, 0x80)\n            mstore(0x60, p2)\n            mstore(0x80, p3)\n            writeString(0xa0, p1)\n        }\n        _sendLogPayload(0x1c, 0xc4);\n        /// @solidity memory-safe-assembly\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n            mstore(0xa0, m5)\n            mstore(0xc0, m6)\n        }\n    }\n\n    function log(address p0, bytes32 p1, bool p2, bool p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        bytes32 m5;\n        bytes32 m6;\n        /// @solidity memory-safe-assembly\n        assembly {\n            function writeString(pos, w) {\n                let length := 0\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\n                mstore(pos, length)\n                let shift := sub(256, shl(3, length))\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\n            }\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            m5 := mload(0xa0)\n            m6 := mload(0xc0)\n            // Selector of `log(address,string,bool,bool)`.\n            mstore(0x00, 0x5f1d5c9f)\n            mstore(0x20, p0)\n            mstore(0x40, 0x80)\n            mstore(0x60, p2)\n            mstore(0x80, p3)\n            writeString(0xa0, p1)\n        }\n        _sendLogPayload(0x1c, 0xc4);\n        /// @solidity memory-safe-assembly\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n            mstore(0xa0, m5)\n            mstore(0xc0, m6)\n        }\n    }\n\n    function log(address p0, bytes32 p1, bool p2, uint256 p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        bytes32 m5;\n        bytes32 m6;\n        /// @solidity memory-safe-assembly\n        assembly {\n            function writeString(pos, w) {\n                let length := 0\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\n                mstore(pos, length)\n                let shift := sub(256, shl(3, length))\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\n            }\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            m5 := mload(0xa0)\n            m6 := mload(0xc0)\n            // Selector of `log(address,string,bool,uint256)`.\n            mstore(0x00, 0x515e38b6)\n            mstore(0x20, p0)\n            mstore(0x40, 0x80)\n            mstore(0x60, p2)\n            mstore(0x80, p3)\n            writeString(0xa0, p1)\n        }\n        _sendLogPayload(0x1c, 0xc4);\n        /// @solidity memory-safe-assembly\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n            mstore(0xa0, m5)\n            mstore(0xc0, m6)\n        }\n    }\n\n    function log(address p0, bytes32 p1, bool p2, bytes32 p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        bytes32 m5;\n        bytes32 m6;\n        bytes32 m7;\n        bytes32 m8;\n        /// @solidity memory-safe-assembly\n        assembly {\n            function writeString(pos, w) {\n                let length := 0\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\n                mstore(pos, length)\n                let shift := sub(256, shl(3, length))\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\n            }\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            m5 := mload(0xa0)\n            m6 := mload(0xc0)\n            m7 := mload(0xe0)\n            m8 := mload(0x100)\n            // Selector of `log(address,string,bool,string)`.\n            mstore(0x00, 0xbc0b61fe)\n            mstore(0x20, p0)\n            mstore(0x40, 0x80)\n            mstore(0x60, p2)\n            mstore(0x80, 0xc0)\n            writeString(0xa0, p1)\n            writeString(0xe0, p3)\n        }\n        _sendLogPayload(0x1c, 0x104);\n        /// @solidity memory-safe-assembly\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n            mstore(0xa0, m5)\n            mstore(0xc0, m6)\n            mstore(0xe0, m7)\n            mstore(0x100, m8)\n        }\n    }\n\n    function log(address p0, bytes32 p1, uint256 p2, address p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        bytes32 m5;\n        bytes32 m6;\n        /// @solidity memory-safe-assembly\n        assembly {\n            function writeString(pos, w) {\n                let length := 0\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\n                mstore(pos, length)\n                let shift := sub(256, shl(3, length))\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\n            }\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            m5 := mload(0xa0)\n            m6 := mload(0xc0)\n            // Selector of `log(address,string,uint256,address)`.\n            mstore(0x00, 0x63183678)\n            mstore(0x20, p0)\n            mstore(0x40, 0x80)\n            mstore(0x60, p2)\n            mstore(0x80, p3)\n            writeString(0xa0, p1)\n        }\n        _sendLogPayload(0x1c, 0xc4);\n        /// @solidity memory-safe-assembly\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n            mstore(0xa0, m5)\n            mstore(0xc0, m6)\n        }\n    }\n\n    function log(address p0, bytes32 p1, uint256 p2, bool p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        bytes32 m5;\n        bytes32 m6;\n        /// @solidity memory-safe-assembly\n        assembly {\n            function writeString(pos, w) {\n                let length := 0\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\n                mstore(pos, length)\n                let shift := sub(256, shl(3, length))\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\n            }\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            m5 := mload(0xa0)\n            m6 := mload(0xc0)\n            // Selector of `log(address,string,uint256,bool)`.\n            mstore(0x00, 0x0ef7e050)\n            mstore(0x20, p0)\n            mstore(0x40, 0x80)\n            mstore(0x60, p2)\n            mstore(0x80, p3)\n            writeString(0xa0, p1)\n        }\n        _sendLogPayload(0x1c, 0xc4);\n        /// @solidity memory-safe-assembly\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n            mstore(0xa0, m5)\n            mstore(0xc0, m6)\n        }\n    }\n\n    function log(address p0, bytes32 p1, uint256 p2, uint256 p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        bytes32 m5;\n        bytes32 m6;\n        /// @solidity memory-safe-assembly\n        assembly {\n            function writeString(pos, w) {\n                let length := 0\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\n                mstore(pos, length)\n                let shift := sub(256, shl(3, length))\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\n            }\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            m5 := mload(0xa0)\n            m6 := mload(0xc0)\n            // Selector of `log(address,string,uint256,uint256)`.\n            mstore(0x00, 0x1dc8e1b8)\n            mstore(0x20, p0)\n            mstore(0x40, 0x80)\n            mstore(0x60, p2)\n            mstore(0x80, p3)\n            writeString(0xa0, p1)\n        }\n        _sendLogPayload(0x1c, 0xc4);\n        /// @solidity memory-safe-assembly\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n            mstore(0xa0, m5)\n            mstore(0xc0, m6)\n        }\n    }\n\n    function log(address p0, bytes32 p1, uint256 p2, bytes32 p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        bytes32 m5;\n        bytes32 m6;\n        bytes32 m7;\n        bytes32 m8;\n        /// @solidity memory-safe-assembly\n        assembly {\n            function writeString(pos, w) {\n                let length := 0\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\n                mstore(pos, length)\n                let shift := sub(256, shl(3, length))\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\n            }\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            m5 := mload(0xa0)\n            m6 := mload(0xc0)\n            m7 := mload(0xe0)\n            m8 := mload(0x100)\n            // Selector of `log(address,string,uint256,string)`.\n            mstore(0x00, 0x448830a8)\n            mstore(0x20, p0)\n            mstore(0x40, 0x80)\n            mstore(0x60, p2)\n            mstore(0x80, 0xc0)\n            writeString(0xa0, p1)\n            writeString(0xe0, p3)\n        }\n        _sendLogPayload(0x1c, 0x104);\n        /// @solidity memory-safe-assembly\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n            mstore(0xa0, m5)\n            mstore(0xc0, m6)\n            mstore(0xe0, m7)\n            mstore(0x100, m8)\n        }\n    }\n\n    function log(address p0, bytes32 p1, bytes32 p2, address p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        bytes32 m5;\n        bytes32 m6;\n        bytes32 m7;\n        bytes32 m8;\n        /// @solidity memory-safe-assembly\n        assembly {\n            function writeString(pos, w) {\n                let length := 0\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\n                mstore(pos, length)\n                let shift := sub(256, shl(3, length))\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\n            }\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            m5 := mload(0xa0)\n            m6 := mload(0xc0)\n            m7 := mload(0xe0)\n            m8 := mload(0x100)\n            // Selector of `log(address,string,string,address)`.\n            mstore(0x00, 0xa04e2f87)\n            mstore(0x20, p0)\n            mstore(0x40, 0x80)\n            mstore(0x60, 0xc0)\n            mstore(0x80, p3)\n            writeString(0xa0, p1)\n            writeString(0xe0, p2)\n        }\n        _sendLogPayload(0x1c, 0x104);\n        /// @solidity memory-safe-assembly\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n            mstore(0xa0, m5)\n            mstore(0xc0, m6)\n            mstore(0xe0, m7)\n            mstore(0x100, m8)\n        }\n    }\n\n    function log(address p0, bytes32 p1, bytes32 p2, bool p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        bytes32 m5;\n        bytes32 m6;\n        bytes32 m7;\n        bytes32 m8;\n        /// @solidity memory-safe-assembly\n        assembly {\n            function writeString(pos, w) {\n                let length := 0\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\n                mstore(pos, length)\n                let shift := sub(256, shl(3, length))\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\n            }\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            m5 := mload(0xa0)\n            m6 := mload(0xc0)\n            m7 := mload(0xe0)\n            m8 := mload(0x100)\n            // Selector of `log(address,string,string,bool)`.\n            mstore(0x00, 0x35a5071f)\n            mstore(0x20, p0)\n            mstore(0x40, 0x80)\n            mstore(0x60, 0xc0)\n            mstore(0x80, p3)\n            writeString(0xa0, p1)\n            writeString(0xe0, p2)\n        }\n        _sendLogPayload(0x1c, 0x104);\n        /// @solidity memory-safe-assembly\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n            mstore(0xa0, m5)\n            mstore(0xc0, m6)\n            mstore(0xe0, m7)\n            mstore(0x100, m8)\n        }\n    }\n\n    function log(address p0, bytes32 p1, bytes32 p2, uint256 p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        bytes32 m5;\n        bytes32 m6;\n        bytes32 m7;\n        bytes32 m8;\n        /// @solidity memory-safe-assembly\n        assembly {\n            function writeString(pos, w) {\n                let length := 0\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\n                mstore(pos, length)\n                let shift := sub(256, shl(3, length))\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\n            }\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            m5 := mload(0xa0)\n            m6 := mload(0xc0)\n            m7 := mload(0xe0)\n            m8 := mload(0x100)\n            // Selector of `log(address,string,string,uint256)`.\n            mstore(0x00, 0x159f8927)\n            mstore(0x20, p0)\n            mstore(0x40, 0x80)\n            mstore(0x60, 0xc0)\n            mstore(0x80, p3)\n            writeString(0xa0, p1)\n            writeString(0xe0, p2)\n        }\n        _sendLogPayload(0x1c, 0x104);\n        /// @solidity memory-safe-assembly\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n            mstore(0xa0, m5)\n            mstore(0xc0, m6)\n            mstore(0xe0, m7)\n            mstore(0x100, m8)\n        }\n    }\n\n    function log(address p0, bytes32 p1, bytes32 p2, bytes32 p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        bytes32 m5;\n        bytes32 m6;\n        bytes32 m7;\n        bytes32 m8;\n        bytes32 m9;\n        bytes32 m10;\n        /// @solidity memory-safe-assembly\n        assembly {\n            function writeString(pos, w) {\n                let length := 0\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\n                mstore(pos, length)\n                let shift := sub(256, shl(3, length))\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\n            }\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            m5 := mload(0xa0)\n            m6 := mload(0xc0)\n            m7 := mload(0xe0)\n            m8 := mload(0x100)\n            m9 := mload(0x120)\n            m10 := mload(0x140)\n            // Selector of `log(address,string,string,string)`.\n            mstore(0x00, 0x5d02c50b)\n            mstore(0x20, p0)\n            mstore(0x40, 0x80)\n            mstore(0x60, 0xc0)\n            mstore(0x80, 0x100)\n            writeString(0xa0, p1)\n            writeString(0xe0, p2)\n            writeString(0x120, p3)\n        }\n        _sendLogPayload(0x1c, 0x144);\n        /// @solidity memory-safe-assembly\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n            mstore(0xa0, m5)\n            mstore(0xc0, m6)\n            mstore(0xe0, m7)\n            mstore(0x100, m8)\n            mstore(0x120, m9)\n            mstore(0x140, m10)\n        }\n    }\n\n    function log(bool p0, address p1, address p2, address p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        /// @solidity memory-safe-assembly\n        assembly {\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            // Selector of `log(bool,address,address,address)`.\n            mstore(0x00, 0x1d14d001)\n            mstore(0x20, p0)\n            mstore(0x40, p1)\n            mstore(0x60, p2)\n            mstore(0x80, p3)\n        }\n        _sendLogPayload(0x1c, 0x84);\n        /// @solidity memory-safe-assembly\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n        }\n    }\n\n    function log(bool p0, address p1, address p2, bool p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        /// @solidity memory-safe-assembly\n        assembly {\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            // Selector of `log(bool,address,address,bool)`.\n            mstore(0x00, 0x46600be0)\n            mstore(0x20, p0)\n            mstore(0x40, p1)\n            mstore(0x60, p2)\n            mstore(0x80, p3)\n        }\n        _sendLogPayload(0x1c, 0x84);\n        /// @solidity memory-safe-assembly\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n        }\n    }\n\n    function log(bool p0, address p1, address p2, uint256 p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        /// @solidity memory-safe-assembly\n        assembly {\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            // Selector of `log(bool,address,address,uint256)`.\n            mstore(0x00, 0x0c66d1be)\n            mstore(0x20, p0)\n            mstore(0x40, p1)\n            mstore(0x60, p2)\n            mstore(0x80, p3)\n        }\n        _sendLogPayload(0x1c, 0x84);\n        /// @solidity memory-safe-assembly\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n        }\n    }\n\n    function log(bool p0, address p1, address p2, bytes32 p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        bytes32 m5;\n        bytes32 m6;\n        /// @solidity memory-safe-assembly\n        assembly {\n            function writeString(pos, w) {\n                let length := 0\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\n                mstore(pos, length)\n                let shift := sub(256, shl(3, length))\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\n            }\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            m5 := mload(0xa0)\n            m6 := mload(0xc0)\n            // Selector of `log(bool,address,address,string)`.\n            mstore(0x00, 0xd812a167)\n            mstore(0x20, p0)\n            mstore(0x40, p1)\n            mstore(0x60, p2)\n            mstore(0x80, 0x80)\n            writeString(0xa0, p3)\n        }\n        _sendLogPayload(0x1c, 0xc4);\n        /// @solidity memory-safe-assembly\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n            mstore(0xa0, m5)\n            mstore(0xc0, m6)\n        }\n    }\n\n    function log(bool p0, address p1, bool p2, address p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        /// @solidity memory-safe-assembly\n        assembly {\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            // Selector of `log(bool,address,bool,address)`.\n            mstore(0x00, 0x1c41a336)\n            mstore(0x20, p0)\n            mstore(0x40, p1)\n            mstore(0x60, p2)\n            mstore(0x80, p3)\n        }\n        _sendLogPayload(0x1c, 0x84);\n        /// @solidity memory-safe-assembly\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n        }\n    }\n\n    function log(bool p0, address p1, bool p2, bool p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        /// @solidity memory-safe-assembly\n        assembly {\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            // Selector of `log(bool,address,bool,bool)`.\n            mstore(0x00, 0x6a9c478b)\n            mstore(0x20, p0)\n            mstore(0x40, p1)\n            mstore(0x60, p2)\n            mstore(0x80, p3)\n        }\n        _sendLogPayload(0x1c, 0x84);\n        /// @solidity memory-safe-assembly\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n        }\n    }\n\n    function log(bool p0, address p1, bool p2, uint256 p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        /// @solidity memory-safe-assembly\n        assembly {\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            // Selector of `log(bool,address,bool,uint256)`.\n            mstore(0x00, 0x07831502)\n            mstore(0x20, p0)\n            mstore(0x40, p1)\n            mstore(0x60, p2)\n            mstore(0x80, p3)\n        }\n        _sendLogPayload(0x1c, 0x84);\n        /// @solidity memory-safe-assembly\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n        }\n    }\n\n    function log(bool p0, address p1, bool p2, bytes32 p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        bytes32 m5;\n        bytes32 m6;\n        /// @solidity memory-safe-assembly\n        assembly {\n            function writeString(pos, w) {\n                let length := 0\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\n                mstore(pos, length)\n                let shift := sub(256, shl(3, length))\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\n            }\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            m5 := mload(0xa0)\n            m6 := mload(0xc0)\n            // Selector of `log(bool,address,bool,string)`.\n            mstore(0x00, 0x4a66cb34)\n            mstore(0x20, p0)\n            mstore(0x40, p1)\n            mstore(0x60, p2)\n            mstore(0x80, 0x80)\n            writeString(0xa0, p3)\n        }\n        _sendLogPayload(0x1c, 0xc4);\n        /// @solidity memory-safe-assembly\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n            mstore(0xa0, m5)\n            mstore(0xc0, m6)\n        }\n    }\n\n    function log(bool p0, address p1, uint256 p2, address p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        /// @solidity memory-safe-assembly\n        assembly {\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            // Selector of `log(bool,address,uint256,address)`.\n            mstore(0x00, 0x136b05dd)\n            mstore(0x20, p0)\n            mstore(0x40, p1)\n            mstore(0x60, p2)\n            mstore(0x80, p3)\n        }\n        _sendLogPayload(0x1c, 0x84);\n        /// @solidity memory-safe-assembly\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n        }\n    }\n\n    function log(bool p0, address p1, uint256 p2, bool p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        /// @solidity memory-safe-assembly\n        assembly {\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            // Selector of `log(bool,address,uint256,bool)`.\n            mstore(0x00, 0xd6019f1c)\n            mstore(0x20, p0)\n            mstore(0x40, p1)\n            mstore(0x60, p2)\n            mstore(0x80, p3)\n        }\n        _sendLogPayload(0x1c, 0x84);\n        /// @solidity memory-safe-assembly\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n        }\n    }\n\n    function log(bool p0, address p1, uint256 p2, uint256 p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        /// @solidity memory-safe-assembly\n        assembly {\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            // Selector of `log(bool,address,uint256,uint256)`.\n            mstore(0x00, 0x7bf181a1)\n            mstore(0x20, p0)\n            mstore(0x40, p1)\n            mstore(0x60, p2)\n            mstore(0x80, p3)\n        }\n        _sendLogPayload(0x1c, 0x84);\n        /// @solidity memory-safe-assembly\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n        }\n    }\n\n    function log(bool p0, address p1, uint256 p2, bytes32 p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        bytes32 m5;\n        bytes32 m6;\n        /// @solidity memory-safe-assembly\n        assembly {\n            function writeString(pos, w) {\n                let length := 0\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\n                mstore(pos, length)\n                let shift := sub(256, shl(3, length))\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\n            }\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            m5 := mload(0xa0)\n            m6 := mload(0xc0)\n            // Selector of `log(bool,address,uint256,string)`.\n            mstore(0x00, 0x51f09ff8)\n            mstore(0x20, p0)\n            mstore(0x40, p1)\n            mstore(0x60, p2)\n            mstore(0x80, 0x80)\n            writeString(0xa0, p3)\n        }\n        _sendLogPayload(0x1c, 0xc4);\n        /// @solidity memory-safe-assembly\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n            mstore(0xa0, m5)\n            mstore(0xc0, m6)\n        }\n    }\n\n    function log(bool p0, address p1, bytes32 p2, address p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        bytes32 m5;\n        bytes32 m6;\n        /// @solidity memory-safe-assembly\n        assembly {\n            function writeString(pos, w) {\n                let length := 0\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\n                mstore(pos, length)\n                let shift := sub(256, shl(3, length))\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\n            }\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            m5 := mload(0xa0)\n            m6 := mload(0xc0)\n            // Selector of `log(bool,address,string,address)`.\n            mstore(0x00, 0x6f7c603e)\n            mstore(0x20, p0)\n            mstore(0x40, p1)\n            mstore(0x60, 0x80)\n            mstore(0x80, p3)\n            writeString(0xa0, p2)\n        }\n        _sendLogPayload(0x1c, 0xc4);\n        /// @solidity memory-safe-assembly\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n            mstore(0xa0, m5)\n            mstore(0xc0, m6)\n        }\n    }\n\n    function log(bool p0, address p1, bytes32 p2, bool p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        bytes32 m5;\n        bytes32 m6;\n        /// @solidity memory-safe-assembly\n        assembly {\n            function writeString(pos, w) {\n                let length := 0\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\n                mstore(pos, length)\n                let shift := sub(256, shl(3, length))\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\n            }\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            m5 := mload(0xa0)\n            m6 := mload(0xc0)\n            // Selector of `log(bool,address,string,bool)`.\n            mstore(0x00, 0xe2bfd60b)\n            mstore(0x20, p0)\n            mstore(0x40, p1)\n            mstore(0x60, 0x80)\n            mstore(0x80, p3)\n            writeString(0xa0, p2)\n        }\n        _sendLogPayload(0x1c, 0xc4);\n        /// @solidity memory-safe-assembly\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n            mstore(0xa0, m5)\n            mstore(0xc0, m6)\n        }\n    }\n\n    function log(bool p0, address p1, bytes32 p2, uint256 p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        bytes32 m5;\n        bytes32 m6;\n        /// @solidity memory-safe-assembly\n        assembly {\n            function writeString(pos, w) {\n                let length := 0\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\n                mstore(pos, length)\n                let shift := sub(256, shl(3, length))\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\n            }\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            m5 := mload(0xa0)\n            m6 := mload(0xc0)\n            // Selector of `log(bool,address,string,uint256)`.\n            mstore(0x00, 0xc21f64c7)\n            mstore(0x20, p0)\n            mstore(0x40, p1)\n            mstore(0x60, 0x80)\n            mstore(0x80, p3)\n            writeString(0xa0, p2)\n        }\n        _sendLogPayload(0x1c, 0xc4);\n        /// @solidity memory-safe-assembly\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n            mstore(0xa0, m5)\n            mstore(0xc0, m6)\n        }\n    }\n\n    function log(bool p0, address p1, bytes32 p2, bytes32 p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        bytes32 m5;\n        bytes32 m6;\n        bytes32 m7;\n        bytes32 m8;\n        /// @solidity memory-safe-assembly\n        assembly {\n            function writeString(pos, w) {\n                let length := 0\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\n                mstore(pos, length)\n                let shift := sub(256, shl(3, length))\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\n            }\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            m5 := mload(0xa0)\n            m6 := mload(0xc0)\n            m7 := mload(0xe0)\n            m8 := mload(0x100)\n            // Selector of `log(bool,address,string,string)`.\n            mstore(0x00, 0xa73c1db6)\n            mstore(0x20, p0)\n            mstore(0x40, p1)\n            mstore(0x60, 0x80)\n            mstore(0x80, 0xc0)\n            writeString(0xa0, p2)\n            writeString(0xe0, p3)\n        }\n        _sendLogPayload(0x1c, 0x104);\n        /// @solidity memory-safe-assembly\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n            mstore(0xa0, m5)\n            mstore(0xc0, m6)\n            mstore(0xe0, m7)\n            mstore(0x100, m8)\n        }\n    }\n\n    function log(bool p0, bool p1, address p2, address p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        /// @solidity memory-safe-assembly\n        assembly {\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            // Selector of `log(bool,bool,address,address)`.\n            mstore(0x00, 0xf4880ea4)\n            mstore(0x20, p0)\n            mstore(0x40, p1)\n            mstore(0x60, p2)\n            mstore(0x80, p3)\n        }\n        _sendLogPayload(0x1c, 0x84);\n        /// @solidity memory-safe-assembly\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n        }\n    }\n\n    function log(bool p0, bool p1, address p2, bool p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        /// @solidity memory-safe-assembly\n        assembly {\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            // Selector of `log(bool,bool,address,bool)`.\n            mstore(0x00, 0xc0a302d8)\n            mstore(0x20, p0)\n            mstore(0x40, p1)\n            mstore(0x60, p2)\n            mstore(0x80, p3)\n        }\n        _sendLogPayload(0x1c, 0x84);\n        /// @solidity memory-safe-assembly\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n        }\n    }\n\n    function log(bool p0, bool p1, address p2, uint256 p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        /// @solidity memory-safe-assembly\n        assembly {\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            // Selector of `log(bool,bool,address,uint256)`.\n            mstore(0x00, 0x4c123d57)\n            mstore(0x20, p0)\n            mstore(0x40, p1)\n            mstore(0x60, p2)\n            mstore(0x80, p3)\n        }\n        _sendLogPayload(0x1c, 0x84);\n        /// @solidity memory-safe-assembly\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n        }\n    }\n\n    function log(bool p0, bool p1, address p2, bytes32 p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        bytes32 m5;\n        bytes32 m6;\n        /// @solidity memory-safe-assembly\n        assembly {\n            function writeString(pos, w) {\n                let length := 0\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\n                mstore(pos, length)\n                let shift := sub(256, shl(3, length))\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\n            }\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            m5 := mload(0xa0)\n            m6 := mload(0xc0)\n            // Selector of `log(bool,bool,address,string)`.\n            mstore(0x00, 0xa0a47963)\n            mstore(0x20, p0)\n            mstore(0x40, p1)\n            mstore(0x60, p2)\n            mstore(0x80, 0x80)\n            writeString(0xa0, p3)\n        }\n        _sendLogPayload(0x1c, 0xc4);\n        /// @solidity memory-safe-assembly\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n            mstore(0xa0, m5)\n            mstore(0xc0, m6)\n        }\n    }\n\n    function log(bool p0, bool p1, bool p2, address p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        /// @solidity memory-safe-assembly\n        assembly {\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            // Selector of `log(bool,bool,bool,address)`.\n            mstore(0x00, 0x8c329b1a)\n            mstore(0x20, p0)\n            mstore(0x40, p1)\n            mstore(0x60, p2)\n            mstore(0x80, p3)\n        }\n        _sendLogPayload(0x1c, 0x84);\n        /// @solidity memory-safe-assembly\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n        }\n    }\n\n    function log(bool p0, bool p1, bool p2, bool p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        /// @solidity memory-safe-assembly\n        assembly {\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            // Selector of `log(bool,bool,bool,bool)`.\n            mstore(0x00, 0x3b2a5ce0)\n            mstore(0x20, p0)\n            mstore(0x40, p1)\n            mstore(0x60, p2)\n            mstore(0x80, p3)\n        }\n        _sendLogPayload(0x1c, 0x84);\n        /// @solidity memory-safe-assembly\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n        }\n    }\n\n    function log(bool p0, bool p1, bool p2, uint256 p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        /// @solidity memory-safe-assembly\n        assembly {\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            // Selector of `log(bool,bool,bool,uint256)`.\n            mstore(0x00, 0x6d7045c1)\n            mstore(0x20, p0)\n            mstore(0x40, p1)\n            mstore(0x60, p2)\n            mstore(0x80, p3)\n        }\n        _sendLogPayload(0x1c, 0x84);\n        /// @solidity memory-safe-assembly\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n        }\n    }\n\n    function log(bool p0, bool p1, bool p2, bytes32 p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        bytes32 m5;\n        bytes32 m6;\n        /// @solidity memory-safe-assembly\n        assembly {\n            function writeString(pos, w) {\n                let length := 0\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\n                mstore(pos, length)\n                let shift := sub(256, shl(3, length))\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\n            }\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            m5 := mload(0xa0)\n            m6 := mload(0xc0)\n            // Selector of `log(bool,bool,bool,string)`.\n            mstore(0x00, 0x2ae408d4)\n            mstore(0x20, p0)\n            mstore(0x40, p1)\n            mstore(0x60, p2)\n            mstore(0x80, 0x80)\n            writeString(0xa0, p3)\n        }\n        _sendLogPayload(0x1c, 0xc4);\n        /// @solidity memory-safe-assembly\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n            mstore(0xa0, m5)\n            mstore(0xc0, m6)\n        }\n    }\n\n    function log(bool p0, bool p1, uint256 p2, address p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        /// @solidity memory-safe-assembly\n        assembly {\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            // Selector of `log(bool,bool,uint256,address)`.\n            mstore(0x00, 0x54a7a9a0)\n            mstore(0x20, p0)\n            mstore(0x40, p1)\n            mstore(0x60, p2)\n            mstore(0x80, p3)\n        }\n        _sendLogPayload(0x1c, 0x84);\n        /// @solidity memory-safe-assembly\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n        }\n    }\n\n    function log(bool p0, bool p1, uint256 p2, bool p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        /// @solidity memory-safe-assembly\n        assembly {\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            // Selector of `log(bool,bool,uint256,bool)`.\n            mstore(0x00, 0x619e4d0e)\n            mstore(0x20, p0)\n            mstore(0x40, p1)\n            mstore(0x60, p2)\n            mstore(0x80, p3)\n        }\n        _sendLogPayload(0x1c, 0x84);\n        /// @solidity memory-safe-assembly\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n        }\n    }\n\n    function log(bool p0, bool p1, uint256 p2, uint256 p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        /// @solidity memory-safe-assembly\n        assembly {\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            // Selector of `log(bool,bool,uint256,uint256)`.\n            mstore(0x00, 0x0bb00eab)\n            mstore(0x20, p0)\n            mstore(0x40, p1)\n            mstore(0x60, p2)\n            mstore(0x80, p3)\n        }\n        _sendLogPayload(0x1c, 0x84);\n        /// @solidity memory-safe-assembly\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n        }\n    }\n\n    function log(bool p0, bool p1, uint256 p2, bytes32 p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        bytes32 m5;\n        bytes32 m6;\n        /// @solidity memory-safe-assembly\n        assembly {\n            function writeString(pos, w) {\n                let length := 0\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\n                mstore(pos, length)\n                let shift := sub(256, shl(3, length))\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\n            }\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            m5 := mload(0xa0)\n            m6 := mload(0xc0)\n            // Selector of `log(bool,bool,uint256,string)`.\n            mstore(0x00, 0x7dd4d0e0)\n            mstore(0x20, p0)\n            mstore(0x40, p1)\n            mstore(0x60, p2)\n            mstore(0x80, 0x80)\n            writeString(0xa0, p3)\n        }\n        _sendLogPayload(0x1c, 0xc4);\n        /// @solidity memory-safe-assembly\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n            mstore(0xa0, m5)\n            mstore(0xc0, m6)\n        }\n    }\n\n    function log(bool p0, bool p1, bytes32 p2, address p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        bytes32 m5;\n        bytes32 m6;\n        /// @solidity memory-safe-assembly\n        assembly {\n            function writeString(pos, w) {\n                let length := 0\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\n                mstore(pos, length)\n                let shift := sub(256, shl(3, length))\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\n            }\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            m5 := mload(0xa0)\n            m6 := mload(0xc0)\n            // Selector of `log(bool,bool,string,address)`.\n            mstore(0x00, 0xf9ad2b89)\n            mstore(0x20, p0)\n            mstore(0x40, p1)\n            mstore(0x60, 0x80)\n            mstore(0x80, p3)\n            writeString(0xa0, p2)\n        }\n        _sendLogPayload(0x1c, 0xc4);\n        /// @solidity memory-safe-assembly\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n            mstore(0xa0, m5)\n            mstore(0xc0, m6)\n        }\n    }\n\n    function log(bool p0, bool p1, bytes32 p2, bool p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        bytes32 m5;\n        bytes32 m6;\n        /// @solidity memory-safe-assembly\n        assembly {\n            function writeString(pos, w) {\n                let length := 0\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\n                mstore(pos, length)\n                let shift := sub(256, shl(3, length))\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\n            }\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            m5 := mload(0xa0)\n            m6 := mload(0xc0)\n            // Selector of `log(bool,bool,string,bool)`.\n            mstore(0x00, 0xb857163a)\n            mstore(0x20, p0)\n            mstore(0x40, p1)\n            mstore(0x60, 0x80)\n            mstore(0x80, p3)\n            writeString(0xa0, p2)\n        }\n        _sendLogPayload(0x1c, 0xc4);\n        /// @solidity memory-safe-assembly\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n            mstore(0xa0, m5)\n            mstore(0xc0, m6)\n        }\n    }\n\n    function log(bool p0, bool p1, bytes32 p2, uint256 p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        bytes32 m5;\n        bytes32 m6;\n        /// @solidity memory-safe-assembly\n        assembly {\n            function writeString(pos, w) {\n                let length := 0\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\n                mstore(pos, length)\n                let shift := sub(256, shl(3, length))\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\n            }\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            m5 := mload(0xa0)\n            m6 := mload(0xc0)\n            // Selector of `log(bool,bool,string,uint256)`.\n            mstore(0x00, 0xe3a9ca2f)\n            mstore(0x20, p0)\n            mstore(0x40, p1)\n            mstore(0x60, 0x80)\n            mstore(0x80, p3)\n            writeString(0xa0, p2)\n        }\n        _sendLogPayload(0x1c, 0xc4);\n        /// @solidity memory-safe-assembly\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n            mstore(0xa0, m5)\n            mstore(0xc0, m6)\n        }\n    }\n\n    function log(bool p0, bool p1, bytes32 p2, bytes32 p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        bytes32 m5;\n        bytes32 m6;\n        bytes32 m7;\n        bytes32 m8;\n        /// @solidity memory-safe-assembly\n        assembly {\n            function writeString(pos, w) {\n                let length := 0\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\n                mstore(pos, length)\n                let shift := sub(256, shl(3, length))\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\n            }\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            m5 := mload(0xa0)\n            m6 := mload(0xc0)\n            m7 := mload(0xe0)\n            m8 := mload(0x100)\n            // Selector of `log(bool,bool,string,string)`.\n            mstore(0x00, 0x6d1e8751)\n            mstore(0x20, p0)\n            mstore(0x40, p1)\n            mstore(0x60, 0x80)\n            mstore(0x80, 0xc0)\n            writeString(0xa0, p2)\n            writeString(0xe0, p3)\n        }\n        _sendLogPayload(0x1c, 0x104);\n        /// @solidity memory-safe-assembly\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n            mstore(0xa0, m5)\n            mstore(0xc0, m6)\n            mstore(0xe0, m7)\n            mstore(0x100, m8)\n        }\n    }\n\n    function log(bool p0, uint256 p1, address p2, address p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        /// @solidity memory-safe-assembly\n        assembly {\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            // Selector of `log(bool,uint256,address,address)`.\n            mstore(0x00, 0x26f560a8)\n            mstore(0x20, p0)\n            mstore(0x40, p1)\n            mstore(0x60, p2)\n            mstore(0x80, p3)\n        }\n        _sendLogPayload(0x1c, 0x84);\n        /// @solidity memory-safe-assembly\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n        }\n    }\n\n    function log(bool p0, uint256 p1, address p2, bool p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        /// @solidity memory-safe-assembly\n        assembly {\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            // Selector of `log(bool,uint256,address,bool)`.\n            mstore(0x00, 0xb4c314ff)\n            mstore(0x20, p0)\n            mstore(0x40, p1)\n            mstore(0x60, p2)\n            mstore(0x80, p3)\n        }\n        _sendLogPayload(0x1c, 0x84);\n        /// @solidity memory-safe-assembly\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n        }\n    }\n\n    function log(bool p0, uint256 p1, address p2, uint256 p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        /// @solidity memory-safe-assembly\n        assembly {\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            // Selector of `log(bool,uint256,address,uint256)`.\n            mstore(0x00, 0x1537dc87)\n            mstore(0x20, p0)\n            mstore(0x40, p1)\n            mstore(0x60, p2)\n            mstore(0x80, p3)\n        }\n        _sendLogPayload(0x1c, 0x84);\n        /// @solidity memory-safe-assembly\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n        }\n    }\n\n    function log(bool p0, uint256 p1, address p2, bytes32 p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        bytes32 m5;\n        bytes32 m6;\n        /// @solidity memory-safe-assembly\n        assembly {\n            function writeString(pos, w) {\n                let length := 0\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\n                mstore(pos, length)\n                let shift := sub(256, shl(3, length))\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\n            }\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            m5 := mload(0xa0)\n            m6 := mload(0xc0)\n            // Selector of `log(bool,uint256,address,string)`.\n            mstore(0x00, 0x1bb3b09a)\n            mstore(0x20, p0)\n            mstore(0x40, p1)\n            mstore(0x60, p2)\n            mstore(0x80, 0x80)\n            writeString(0xa0, p3)\n        }\n        _sendLogPayload(0x1c, 0xc4);\n        /// @solidity memory-safe-assembly\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n            mstore(0xa0, m5)\n            mstore(0xc0, m6)\n        }\n    }\n\n    function log(bool p0, uint256 p1, bool p2, address p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        /// @solidity memory-safe-assembly\n        assembly {\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            // Selector of `log(bool,uint256,bool,address)`.\n            mstore(0x00, 0x9acd3616)\n            mstore(0x20, p0)\n            mstore(0x40, p1)\n            mstore(0x60, p2)\n            mstore(0x80, p3)\n        }\n        _sendLogPayload(0x1c, 0x84);\n        /// @solidity memory-safe-assembly\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n        }\n    }\n\n    function log(bool p0, uint256 p1, bool p2, bool p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        /// @solidity memory-safe-assembly\n        assembly {\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            // Selector of `log(bool,uint256,bool,bool)`.\n            mstore(0x00, 0xceb5f4d7)\n            mstore(0x20, p0)\n            mstore(0x40, p1)\n            mstore(0x60, p2)\n            mstore(0x80, p3)\n        }\n        _sendLogPayload(0x1c, 0x84);\n        /// @solidity memory-safe-assembly\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n        }\n    }\n\n    function log(bool p0, uint256 p1, bool p2, uint256 p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        /// @solidity memory-safe-assembly\n        assembly {\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            // Selector of `log(bool,uint256,bool,uint256)`.\n            mstore(0x00, 0x7f9bbca2)\n            mstore(0x20, p0)\n            mstore(0x40, p1)\n            mstore(0x60, p2)\n            mstore(0x80, p3)\n        }\n        _sendLogPayload(0x1c, 0x84);\n        /// @solidity memory-safe-assembly\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n        }\n    }\n\n    function log(bool p0, uint256 p1, bool p2, bytes32 p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        bytes32 m5;\n        bytes32 m6;\n        /// @solidity memory-safe-assembly\n        assembly {\n            function writeString(pos, w) {\n                let length := 0\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\n                mstore(pos, length)\n                let shift := sub(256, shl(3, length))\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\n            }\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            m5 := mload(0xa0)\n            m6 := mload(0xc0)\n            // Selector of `log(bool,uint256,bool,string)`.\n            mstore(0x00, 0x9143dbb1)\n            mstore(0x20, p0)\n            mstore(0x40, p1)\n            mstore(0x60, p2)\n            mstore(0x80, 0x80)\n            writeString(0xa0, p3)\n        }\n        _sendLogPayload(0x1c, 0xc4);\n        /// @solidity memory-safe-assembly\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n            mstore(0xa0, m5)\n            mstore(0xc0, m6)\n        }\n    }\n\n    function log(bool p0, uint256 p1, uint256 p2, address p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        /// @solidity memory-safe-assembly\n        assembly {\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            // Selector of `log(bool,uint256,uint256,address)`.\n            mstore(0x00, 0x00dd87b9)\n            mstore(0x20, p0)\n            mstore(0x40, p1)\n            mstore(0x60, p2)\n            mstore(0x80, p3)\n        }\n        _sendLogPayload(0x1c, 0x84);\n        /// @solidity memory-safe-assembly\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n        }\n    }\n\n    function log(bool p0, uint256 p1, uint256 p2, bool p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        /// @solidity memory-safe-assembly\n        assembly {\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            // Selector of `log(bool,uint256,uint256,bool)`.\n            mstore(0x00, 0xbe984353)\n            mstore(0x20, p0)\n            mstore(0x40, p1)\n            mstore(0x60, p2)\n            mstore(0x80, p3)\n        }\n        _sendLogPayload(0x1c, 0x84);\n        /// @solidity memory-safe-assembly\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n        }\n    }\n\n    function log(bool p0, uint256 p1, uint256 p2, uint256 p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        /// @solidity memory-safe-assembly\n        assembly {\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            // Selector of `log(bool,uint256,uint256,uint256)`.\n            mstore(0x00, 0x374bb4b2)\n            mstore(0x20, p0)\n            mstore(0x40, p1)\n            mstore(0x60, p2)\n            mstore(0x80, p3)\n        }\n        _sendLogPayload(0x1c, 0x84);\n        /// @solidity memory-safe-assembly\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n        }\n    }\n\n    function log(bool p0, uint256 p1, uint256 p2, bytes32 p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        bytes32 m5;\n        bytes32 m6;\n        /// @solidity memory-safe-assembly\n        assembly {\n            function writeString(pos, w) {\n                let length := 0\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\n                mstore(pos, length)\n                let shift := sub(256, shl(3, length))\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\n            }\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            m5 := mload(0xa0)\n            m6 := mload(0xc0)\n            // Selector of `log(bool,uint256,uint256,string)`.\n            mstore(0x00, 0x8e69fb5d)\n            mstore(0x20, p0)\n            mstore(0x40, p1)\n            mstore(0x60, p2)\n            mstore(0x80, 0x80)\n            writeString(0xa0, p3)\n        }\n        _sendLogPayload(0x1c, 0xc4);\n        /// @solidity memory-safe-assembly\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n            mstore(0xa0, m5)\n            mstore(0xc0, m6)\n        }\n    }\n\n    function log(bool p0, uint256 p1, bytes32 p2, address p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        bytes32 m5;\n        bytes32 m6;\n        /// @solidity memory-safe-assembly\n        assembly {\n            function writeString(pos, w) {\n                let length := 0\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\n                mstore(pos, length)\n                let shift := sub(256, shl(3, length))\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\n            }\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            m5 := mload(0xa0)\n            m6 := mload(0xc0)\n            // Selector of `log(bool,uint256,string,address)`.\n            mstore(0x00, 0xfedd1fff)\n            mstore(0x20, p0)\n            mstore(0x40, p1)\n            mstore(0x60, 0x80)\n            mstore(0x80, p3)\n            writeString(0xa0, p2)\n        }\n        _sendLogPayload(0x1c, 0xc4);\n        /// @solidity memory-safe-assembly\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n            mstore(0xa0, m5)\n            mstore(0xc0, m6)\n        }\n    }\n\n    function log(bool p0, uint256 p1, bytes32 p2, bool p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        bytes32 m5;\n        bytes32 m6;\n        /// @solidity memory-safe-assembly\n        assembly {\n            function writeString(pos, w) {\n                let length := 0\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\n                mstore(pos, length)\n                let shift := sub(256, shl(3, length))\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\n            }\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            m5 := mload(0xa0)\n            m6 := mload(0xc0)\n            // Selector of `log(bool,uint256,string,bool)`.\n            mstore(0x00, 0xe5e70b2b)\n            mstore(0x20, p0)\n            mstore(0x40, p1)\n            mstore(0x60, 0x80)\n            mstore(0x80, p3)\n            writeString(0xa0, p2)\n        }\n        _sendLogPayload(0x1c, 0xc4);\n        /// @solidity memory-safe-assembly\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n            mstore(0xa0, m5)\n            mstore(0xc0, m6)\n        }\n    }\n\n    function log(bool p0, uint256 p1, bytes32 p2, uint256 p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        bytes32 m5;\n        bytes32 m6;\n        /// @solidity memory-safe-assembly\n        assembly {\n            function writeString(pos, w) {\n                let length := 0\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\n                mstore(pos, length)\n                let shift := sub(256, shl(3, length))\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\n            }\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            m5 := mload(0xa0)\n            m6 := mload(0xc0)\n            // Selector of `log(bool,uint256,string,uint256)`.\n            mstore(0x00, 0x6a1199e2)\n            mstore(0x20, p0)\n            mstore(0x40, p1)\n            mstore(0x60, 0x80)\n            mstore(0x80, p3)\n            writeString(0xa0, p2)\n        }\n        _sendLogPayload(0x1c, 0xc4);\n        /// @solidity memory-safe-assembly\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n            mstore(0xa0, m5)\n            mstore(0xc0, m6)\n        }\n    }\n\n    function log(bool p0, uint256 p1, bytes32 p2, bytes32 p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        bytes32 m5;\n        bytes32 m6;\n        bytes32 m7;\n        bytes32 m8;\n        /// @solidity memory-safe-assembly\n        assembly {\n            function writeString(pos, w) {\n                let length := 0\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\n                mstore(pos, length)\n                let shift := sub(256, shl(3, length))\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\n            }\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            m5 := mload(0xa0)\n            m6 := mload(0xc0)\n            m7 := mload(0xe0)\n            m8 := mload(0x100)\n            // Selector of `log(bool,uint256,string,string)`.\n            mstore(0x00, 0xf5bc2249)\n            mstore(0x20, p0)\n            mstore(0x40, p1)\n            mstore(0x60, 0x80)\n            mstore(0x80, 0xc0)\n            writeString(0xa0, p2)\n            writeString(0xe0, p3)\n        }\n        _sendLogPayload(0x1c, 0x104);\n        /// @solidity memory-safe-assembly\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n            mstore(0xa0, m5)\n            mstore(0xc0, m6)\n            mstore(0xe0, m7)\n            mstore(0x100, m8)\n        }\n    }\n\n    function log(bool p0, bytes32 p1, address p2, address p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        bytes32 m5;\n        bytes32 m6;\n        /// @solidity memory-safe-assembly\n        assembly {\n            function writeString(pos, w) {\n                let length := 0\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\n                mstore(pos, length)\n                let shift := sub(256, shl(3, length))\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\n            }\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            m5 := mload(0xa0)\n            m6 := mload(0xc0)\n            // Selector of `log(bool,string,address,address)`.\n            mstore(0x00, 0x2b2b18dc)\n            mstore(0x20, p0)\n            mstore(0x40, 0x80)\n            mstore(0x60, p2)\n            mstore(0x80, p3)\n            writeString(0xa0, p1)\n        }\n        _sendLogPayload(0x1c, 0xc4);\n        /// @solidity memory-safe-assembly\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n            mstore(0xa0, m5)\n            mstore(0xc0, m6)\n        }\n    }\n\n    function log(bool p0, bytes32 p1, address p2, bool p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        bytes32 m5;\n        bytes32 m6;\n        /// @solidity memory-safe-assembly\n        assembly {\n            function writeString(pos, w) {\n                let length := 0\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\n                mstore(pos, length)\n                let shift := sub(256, shl(3, length))\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\n            }\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            m5 := mload(0xa0)\n            m6 := mload(0xc0)\n            // Selector of `log(bool,string,address,bool)`.\n            mstore(0x00, 0x6dd434ca)\n            mstore(0x20, p0)\n            mstore(0x40, 0x80)\n            mstore(0x60, p2)\n            mstore(0x80, p3)\n            writeString(0xa0, p1)\n        }\n        _sendLogPayload(0x1c, 0xc4);\n        /// @solidity memory-safe-assembly\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n            mstore(0xa0, m5)\n            mstore(0xc0, m6)\n        }\n    }\n\n    function log(bool p0, bytes32 p1, address p2, uint256 p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        bytes32 m5;\n        bytes32 m6;\n        /// @solidity memory-safe-assembly\n        assembly {\n            function writeString(pos, w) {\n                let length := 0\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\n                mstore(pos, length)\n                let shift := sub(256, shl(3, length))\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\n            }\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            m5 := mload(0xa0)\n            m6 := mload(0xc0)\n            // Selector of `log(bool,string,address,uint256)`.\n            mstore(0x00, 0xa5cada94)\n            mstore(0x20, p0)\n            mstore(0x40, 0x80)\n            mstore(0x60, p2)\n            mstore(0x80, p3)\n            writeString(0xa0, p1)\n        }\n        _sendLogPayload(0x1c, 0xc4);\n        /// @solidity memory-safe-assembly\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n            mstore(0xa0, m5)\n            mstore(0xc0, m6)\n        }\n    }\n\n    function log(bool p0, bytes32 p1, address p2, bytes32 p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        bytes32 m5;\n        bytes32 m6;\n        bytes32 m7;\n        bytes32 m8;\n        /// @solidity memory-safe-assembly\n        assembly {\n            function writeString(pos, w) {\n                let length := 0\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\n                mstore(pos, length)\n                let shift := sub(256, shl(3, length))\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\n            }\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            m5 := mload(0xa0)\n            m6 := mload(0xc0)\n            m7 := mload(0xe0)\n            m8 := mload(0x100)\n            // Selector of `log(bool,string,address,string)`.\n            mstore(0x00, 0x12d6c788)\n            mstore(0x20, p0)\n            mstore(0x40, 0x80)\n            mstore(0x60, p2)\n            mstore(0x80, 0xc0)\n            writeString(0xa0, p1)\n            writeString(0xe0, p3)\n        }\n        _sendLogPayload(0x1c, 0x104);\n        /// @solidity memory-safe-assembly\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n            mstore(0xa0, m5)\n            mstore(0xc0, m6)\n            mstore(0xe0, m7)\n            mstore(0x100, m8)\n        }\n    }\n\n    function log(bool p0, bytes32 p1, bool p2, address p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        bytes32 m5;\n        bytes32 m6;\n        /// @solidity memory-safe-assembly\n        assembly {\n            function writeString(pos, w) {\n                let length := 0\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\n                mstore(pos, length)\n                let shift := sub(256, shl(3, length))\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\n            }\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            m5 := mload(0xa0)\n            m6 := mload(0xc0)\n            // Selector of `log(bool,string,bool,address)`.\n            mstore(0x00, 0x538e06ab)\n            mstore(0x20, p0)\n            mstore(0x40, 0x80)\n            mstore(0x60, p2)\n            mstore(0x80, p3)\n            writeString(0xa0, p1)\n        }\n        _sendLogPayload(0x1c, 0xc4);\n        /// @solidity memory-safe-assembly\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n            mstore(0xa0, m5)\n            mstore(0xc0, m6)\n        }\n    }\n\n    function log(bool p0, bytes32 p1, bool p2, bool p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        bytes32 m5;\n        bytes32 m6;\n        /// @solidity memory-safe-assembly\n        assembly {\n            function writeString(pos, w) {\n                let length := 0\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\n                mstore(pos, length)\n                let shift := sub(256, shl(3, length))\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\n            }\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            m5 := mload(0xa0)\n            m6 := mload(0xc0)\n            // Selector of `log(bool,string,bool,bool)`.\n            mstore(0x00, 0xdc5e935b)\n            mstore(0x20, p0)\n            mstore(0x40, 0x80)\n            mstore(0x60, p2)\n            mstore(0x80, p3)\n            writeString(0xa0, p1)\n        }\n        _sendLogPayload(0x1c, 0xc4);\n        /// @solidity memory-safe-assembly\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n            mstore(0xa0, m5)\n            mstore(0xc0, m6)\n        }\n    }\n\n    function log(bool p0, bytes32 p1, bool p2, uint256 p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        bytes32 m5;\n        bytes32 m6;\n        /// @solidity memory-safe-assembly\n        assembly {\n            function writeString(pos, w) {\n                let length := 0\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\n                mstore(pos, length)\n                let shift := sub(256, shl(3, length))\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\n            }\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            m5 := mload(0xa0)\n            m6 := mload(0xc0)\n            // Selector of `log(bool,string,bool,uint256)`.\n            mstore(0x00, 0x1606a393)\n            mstore(0x20, p0)\n            mstore(0x40, 0x80)\n            mstore(0x60, p2)\n            mstore(0x80, p3)\n            writeString(0xa0, p1)\n        }\n        _sendLogPayload(0x1c, 0xc4);\n        /// @solidity memory-safe-assembly\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n            mstore(0xa0, m5)\n            mstore(0xc0, m6)\n        }\n    }\n\n    function log(bool p0, bytes32 p1, bool p2, bytes32 p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        bytes32 m5;\n        bytes32 m6;\n        bytes32 m7;\n        bytes32 m8;\n        /// @solidity memory-safe-assembly\n        assembly {\n            function writeString(pos, w) {\n                let length := 0\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\n                mstore(pos, length)\n                let shift := sub(256, shl(3, length))\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\n            }\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            m5 := mload(0xa0)\n            m6 := mload(0xc0)\n            m7 := mload(0xe0)\n            m8 := mload(0x100)\n            // Selector of `log(bool,string,bool,string)`.\n            mstore(0x00, 0x483d0416)\n            mstore(0x20, p0)\n            mstore(0x40, 0x80)\n            mstore(0x60, p2)\n            mstore(0x80, 0xc0)\n            writeString(0xa0, p1)\n            writeString(0xe0, p3)\n        }\n        _sendLogPayload(0x1c, 0x104);\n        /// @solidity memory-safe-assembly\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n            mstore(0xa0, m5)\n            mstore(0xc0, m6)\n            mstore(0xe0, m7)\n            mstore(0x100, m8)\n        }\n    }\n\n    function log(bool p0, bytes32 p1, uint256 p2, address p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        bytes32 m5;\n        bytes32 m6;\n        /// @solidity memory-safe-assembly\n        assembly {\n            function writeString(pos, w) {\n                let length := 0\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\n                mstore(pos, length)\n                let shift := sub(256, shl(3, length))\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\n            }\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            m5 := mload(0xa0)\n            m6 := mload(0xc0)\n            // Selector of `log(bool,string,uint256,address)`.\n            mstore(0x00, 0x1596a1ce)\n            mstore(0x20, p0)\n            mstore(0x40, 0x80)\n            mstore(0x60, p2)\n            mstore(0x80, p3)\n            writeString(0xa0, p1)\n        }\n        _sendLogPayload(0x1c, 0xc4);\n        /// @solidity memory-safe-assembly\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n            mstore(0xa0, m5)\n            mstore(0xc0, m6)\n        }\n    }\n\n    function log(bool p0, bytes32 p1, uint256 p2, bool p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        bytes32 m5;\n        bytes32 m6;\n        /// @solidity memory-safe-assembly\n        assembly {\n            function writeString(pos, w) {\n                let length := 0\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\n                mstore(pos, length)\n                let shift := sub(256, shl(3, length))\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\n            }\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            m5 := mload(0xa0)\n            m6 := mload(0xc0)\n            // Selector of `log(bool,string,uint256,bool)`.\n            mstore(0x00, 0x6b0e5d53)\n            mstore(0x20, p0)\n            mstore(0x40, 0x80)\n            mstore(0x60, p2)\n            mstore(0x80, p3)\n            writeString(0xa0, p1)\n        }\n        _sendLogPayload(0x1c, 0xc4);\n        /// @solidity memory-safe-assembly\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n            mstore(0xa0, m5)\n            mstore(0xc0, m6)\n        }\n    }\n\n    function log(bool p0, bytes32 p1, uint256 p2, uint256 p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        bytes32 m5;\n        bytes32 m6;\n        /// @solidity memory-safe-assembly\n        assembly {\n            function writeString(pos, w) {\n                let length := 0\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\n                mstore(pos, length)\n                let shift := sub(256, shl(3, length))\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\n            }\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            m5 := mload(0xa0)\n            m6 := mload(0xc0)\n            // Selector of `log(bool,string,uint256,uint256)`.\n            mstore(0x00, 0x28863fcb)\n            mstore(0x20, p0)\n            mstore(0x40, 0x80)\n            mstore(0x60, p2)\n            mstore(0x80, p3)\n            writeString(0xa0, p1)\n        }\n        _sendLogPayload(0x1c, 0xc4);\n        /// @solidity memory-safe-assembly\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n            mstore(0xa0, m5)\n            mstore(0xc0, m6)\n        }\n    }\n\n    function log(bool p0, bytes32 p1, uint256 p2, bytes32 p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        bytes32 m5;\n        bytes32 m6;\n        bytes32 m7;\n        bytes32 m8;\n        /// @solidity memory-safe-assembly\n        assembly {\n            function writeString(pos, w) {\n                let length := 0\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\n                mstore(pos, length)\n                let shift := sub(256, shl(3, length))\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\n            }\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            m5 := mload(0xa0)\n            m6 := mload(0xc0)\n            m7 := mload(0xe0)\n            m8 := mload(0x100)\n            // Selector of `log(bool,string,uint256,string)`.\n            mstore(0x00, 0x1ad96de6)\n            mstore(0x20, p0)\n            mstore(0x40, 0x80)\n            mstore(0x60, p2)\n            mstore(0x80, 0xc0)\n            writeString(0xa0, p1)\n            writeString(0xe0, p3)\n        }\n        _sendLogPayload(0x1c, 0x104);\n        /// @solidity memory-safe-assembly\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n            mstore(0xa0, m5)\n            mstore(0xc0, m6)\n            mstore(0xe0, m7)\n            mstore(0x100, m8)\n        }\n    }\n\n    function log(bool p0, bytes32 p1, bytes32 p2, address p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        bytes32 m5;\n        bytes32 m6;\n        bytes32 m7;\n        bytes32 m8;\n        /// @solidity memory-safe-assembly\n        assembly {\n            function writeString(pos, w) {\n                let length := 0\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\n                mstore(pos, length)\n                let shift := sub(256, shl(3, length))\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\n            }\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            m5 := mload(0xa0)\n            m6 := mload(0xc0)\n            m7 := mload(0xe0)\n            m8 := mload(0x100)\n            // Selector of `log(bool,string,string,address)`.\n            mstore(0x00, 0x97d394d8)\n            mstore(0x20, p0)\n            mstore(0x40, 0x80)\n            mstore(0x60, 0xc0)\n            mstore(0x80, p3)\n            writeString(0xa0, p1)\n            writeString(0xe0, p2)\n        }\n        _sendLogPayload(0x1c, 0x104);\n        /// @solidity memory-safe-assembly\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n            mstore(0xa0, m5)\n            mstore(0xc0, m6)\n            mstore(0xe0, m7)\n            mstore(0x100, m8)\n        }\n    }\n\n    function log(bool p0, bytes32 p1, bytes32 p2, bool p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        bytes32 m5;\n        bytes32 m6;\n        bytes32 m7;\n        bytes32 m8;\n        /// @solidity memory-safe-assembly\n        assembly {\n            function writeString(pos, w) {\n                let length := 0\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\n                mstore(pos, length)\n                let shift := sub(256, shl(3, length))\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\n            }\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            m5 := mload(0xa0)\n            m6 := mload(0xc0)\n            m7 := mload(0xe0)\n            m8 := mload(0x100)\n            // Selector of `log(bool,string,string,bool)`.\n            mstore(0x00, 0x1e4b87e5)\n            mstore(0x20, p0)\n            mstore(0x40, 0x80)\n            mstore(0x60, 0xc0)\n            mstore(0x80, p3)\n            writeString(0xa0, p1)\n            writeString(0xe0, p2)\n        }\n        _sendLogPayload(0x1c, 0x104);\n        /// @solidity memory-safe-assembly\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n            mstore(0xa0, m5)\n            mstore(0xc0, m6)\n            mstore(0xe0, m7)\n            mstore(0x100, m8)\n        }\n    }\n\n    function log(bool p0, bytes32 p1, bytes32 p2, uint256 p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        bytes32 m5;\n        bytes32 m6;\n        bytes32 m7;\n        bytes32 m8;\n        /// @solidity memory-safe-assembly\n        assembly {\n            function writeString(pos, w) {\n                let length := 0\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\n                mstore(pos, length)\n                let shift := sub(256, shl(3, length))\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\n            }\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            m5 := mload(0xa0)\n            m6 := mload(0xc0)\n            m7 := mload(0xe0)\n            m8 := mload(0x100)\n            // Selector of `log(bool,string,string,uint256)`.\n            mstore(0x00, 0x7be0c3eb)\n            mstore(0x20, p0)\n            mstore(0x40, 0x80)\n            mstore(0x60, 0xc0)\n            mstore(0x80, p3)\n            writeString(0xa0, p1)\n            writeString(0xe0, p2)\n        }\n        _sendLogPayload(0x1c, 0x104);\n        /// @solidity memory-safe-assembly\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n            mstore(0xa0, m5)\n            mstore(0xc0, m6)\n            mstore(0xe0, m7)\n            mstore(0x100, m8)\n        }\n    }\n\n    function log(bool p0, bytes32 p1, bytes32 p2, bytes32 p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        bytes32 m5;\n        bytes32 m6;\n        bytes32 m7;\n        bytes32 m8;\n        bytes32 m9;\n        bytes32 m10;\n        /// @solidity memory-safe-assembly\n        assembly {\n            function writeString(pos, w) {\n                let length := 0\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\n                mstore(pos, length)\n                let shift := sub(256, shl(3, length))\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\n            }\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            m5 := mload(0xa0)\n            m6 := mload(0xc0)\n            m7 := mload(0xe0)\n            m8 := mload(0x100)\n            m9 := mload(0x120)\n            m10 := mload(0x140)\n            // Selector of `log(bool,string,string,string)`.\n            mstore(0x00, 0x1762e32a)\n            mstore(0x20, p0)\n            mstore(0x40, 0x80)\n            mstore(0x60, 0xc0)\n            mstore(0x80, 0x100)\n            writeString(0xa0, p1)\n            writeString(0xe0, p2)\n            writeString(0x120, p3)\n        }\n        _sendLogPayload(0x1c, 0x144);\n        /// @solidity memory-safe-assembly\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n            mstore(0xa0, m5)\n            mstore(0xc0, m6)\n            mstore(0xe0, m7)\n            mstore(0x100, m8)\n            mstore(0x120, m9)\n            mstore(0x140, m10)\n        }\n    }\n\n    function log(uint256 p0, address p1, address p2, address p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        /// @solidity memory-safe-assembly\n        assembly {\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            // Selector of `log(uint256,address,address,address)`.\n            mstore(0x00, 0x2488b414)\n            mstore(0x20, p0)\n            mstore(0x40, p1)\n            mstore(0x60, p2)\n            mstore(0x80, p3)\n        }\n        _sendLogPayload(0x1c, 0x84);\n        /// @solidity memory-safe-assembly\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n        }\n    }\n\n    function log(uint256 p0, address p1, address p2, bool p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        /// @solidity memory-safe-assembly\n        assembly {\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            // Selector of `log(uint256,address,address,bool)`.\n            mstore(0x00, 0x091ffaf5)\n            mstore(0x20, p0)\n            mstore(0x40, p1)\n            mstore(0x60, p2)\n            mstore(0x80, p3)\n        }\n        _sendLogPayload(0x1c, 0x84);\n        /// @solidity memory-safe-assembly\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n        }\n    }\n\n    function log(uint256 p0, address p1, address p2, uint256 p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        /// @solidity memory-safe-assembly\n        assembly {\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            // Selector of `log(uint256,address,address,uint256)`.\n            mstore(0x00, 0x736efbb6)\n            mstore(0x20, p0)\n            mstore(0x40, p1)\n            mstore(0x60, p2)\n            mstore(0x80, p3)\n        }\n        _sendLogPayload(0x1c, 0x84);\n        /// @solidity memory-safe-assembly\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n        }\n    }\n\n    function log(uint256 p0, address p1, address p2, bytes32 p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        bytes32 m5;\n        bytes32 m6;\n        /// @solidity memory-safe-assembly\n        assembly {\n            function writeString(pos, w) {\n                let length := 0\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\n                mstore(pos, length)\n                let shift := sub(256, shl(3, length))\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\n            }\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            m5 := mload(0xa0)\n            m6 := mload(0xc0)\n            // Selector of `log(uint256,address,address,string)`.\n            mstore(0x00, 0x031c6f73)\n            mstore(0x20, p0)\n            mstore(0x40, p1)\n            mstore(0x60, p2)\n            mstore(0x80, 0x80)\n            writeString(0xa0, p3)\n        }\n        _sendLogPayload(0x1c, 0xc4);\n        /// @solidity memory-safe-assembly\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n            mstore(0xa0, m5)\n            mstore(0xc0, m6)\n        }\n    }\n\n    function log(uint256 p0, address p1, bool p2, address p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        /// @solidity memory-safe-assembly\n        assembly {\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            // Selector of `log(uint256,address,bool,address)`.\n            mstore(0x00, 0xef72c513)\n            mstore(0x20, p0)\n            mstore(0x40, p1)\n            mstore(0x60, p2)\n            mstore(0x80, p3)\n        }\n        _sendLogPayload(0x1c, 0x84);\n        /// @solidity memory-safe-assembly\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n        }\n    }\n\n    function log(uint256 p0, address p1, bool p2, bool p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        /// @solidity memory-safe-assembly\n        assembly {\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            // Selector of `log(uint256,address,bool,bool)`.\n            mstore(0x00, 0xe351140f)\n            mstore(0x20, p0)\n            mstore(0x40, p1)\n            mstore(0x60, p2)\n            mstore(0x80, p3)\n        }\n        _sendLogPayload(0x1c, 0x84);\n        /// @solidity memory-safe-assembly\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n        }\n    }\n\n    function log(uint256 p0, address p1, bool p2, uint256 p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        /// @solidity memory-safe-assembly\n        assembly {\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            // Selector of `log(uint256,address,bool,uint256)`.\n            mstore(0x00, 0x5abd992a)\n            mstore(0x20, p0)\n            mstore(0x40, p1)\n            mstore(0x60, p2)\n            mstore(0x80, p3)\n        }\n        _sendLogPayload(0x1c, 0x84);\n        /// @solidity memory-safe-assembly\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n        }\n    }\n\n    function log(uint256 p0, address p1, bool p2, bytes32 p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        bytes32 m5;\n        bytes32 m6;\n        /// @solidity memory-safe-assembly\n        assembly {\n            function writeString(pos, w) {\n                let length := 0\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\n                mstore(pos, length)\n                let shift := sub(256, shl(3, length))\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\n            }\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            m5 := mload(0xa0)\n            m6 := mload(0xc0)\n            // Selector of `log(uint256,address,bool,string)`.\n            mstore(0x00, 0x90fb06aa)\n            mstore(0x20, p0)\n            mstore(0x40, p1)\n            mstore(0x60, p2)\n            mstore(0x80, 0x80)\n            writeString(0xa0, p3)\n        }\n        _sendLogPayload(0x1c, 0xc4);\n        /// @solidity memory-safe-assembly\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n            mstore(0xa0, m5)\n            mstore(0xc0, m6)\n        }\n    }\n\n    function log(uint256 p0, address p1, uint256 p2, address p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        /// @solidity memory-safe-assembly\n        assembly {\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            // Selector of `log(uint256,address,uint256,address)`.\n            mstore(0x00, 0x15c127b5)\n            mstore(0x20, p0)\n            mstore(0x40, p1)\n            mstore(0x60, p2)\n            mstore(0x80, p3)\n        }\n        _sendLogPayload(0x1c, 0x84);\n        /// @solidity memory-safe-assembly\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n        }\n    }\n\n    function log(uint256 p0, address p1, uint256 p2, bool p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        /// @solidity memory-safe-assembly\n        assembly {\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            // Selector of `log(uint256,address,uint256,bool)`.\n            mstore(0x00, 0x5f743a7c)\n            mstore(0x20, p0)\n            mstore(0x40, p1)\n            mstore(0x60, p2)\n            mstore(0x80, p3)\n        }\n        _sendLogPayload(0x1c, 0x84);\n        /// @solidity memory-safe-assembly\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n        }\n    }\n\n    function log(uint256 p0, address p1, uint256 p2, uint256 p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        /// @solidity memory-safe-assembly\n        assembly {\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            // Selector of `log(uint256,address,uint256,uint256)`.\n            mstore(0x00, 0x0c9cd9c1)\n            mstore(0x20, p0)\n            mstore(0x40, p1)\n            mstore(0x60, p2)\n            mstore(0x80, p3)\n        }\n        _sendLogPayload(0x1c, 0x84);\n        /// @solidity memory-safe-assembly\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n        }\n    }\n\n    function log(uint256 p0, address p1, uint256 p2, bytes32 p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        bytes32 m5;\n        bytes32 m6;\n        /// @solidity memory-safe-assembly\n        assembly {\n            function writeString(pos, w) {\n                let length := 0\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\n                mstore(pos, length)\n                let shift := sub(256, shl(3, length))\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\n            }\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            m5 := mload(0xa0)\n            m6 := mload(0xc0)\n            // Selector of `log(uint256,address,uint256,string)`.\n            mstore(0x00, 0xddb06521)\n            mstore(0x20, p0)\n            mstore(0x40, p1)\n            mstore(0x60, p2)\n            mstore(0x80, 0x80)\n            writeString(0xa0, p3)\n        }\n        _sendLogPayload(0x1c, 0xc4);\n        /// @solidity memory-safe-assembly\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n            mstore(0xa0, m5)\n            mstore(0xc0, m6)\n        }\n    }\n\n    function log(uint256 p0, address p1, bytes32 p2, address p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        bytes32 m5;\n        bytes32 m6;\n        /// @solidity memory-safe-assembly\n        assembly {\n            function writeString(pos, w) {\n                let length := 0\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\n                mstore(pos, length)\n                let shift := sub(256, shl(3, length))\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\n            }\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            m5 := mload(0xa0)\n            m6 := mload(0xc0)\n            // Selector of `log(uint256,address,string,address)`.\n            mstore(0x00, 0x9cba8fff)\n            mstore(0x20, p0)\n            mstore(0x40, p1)\n            mstore(0x60, 0x80)\n            mstore(0x80, p3)\n            writeString(0xa0, p2)\n        }\n        _sendLogPayload(0x1c, 0xc4);\n        /// @solidity memory-safe-assembly\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n            mstore(0xa0, m5)\n            mstore(0xc0, m6)\n        }\n    }\n\n    function log(uint256 p0, address p1, bytes32 p2, bool p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        bytes32 m5;\n        bytes32 m6;\n        /// @solidity memory-safe-assembly\n        assembly {\n            function writeString(pos, w) {\n                let length := 0\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\n                mstore(pos, length)\n                let shift := sub(256, shl(3, length))\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\n            }\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            m5 := mload(0xa0)\n            m6 := mload(0xc0)\n            // Selector of `log(uint256,address,string,bool)`.\n            mstore(0x00, 0xcc32ab07)\n            mstore(0x20, p0)\n            mstore(0x40, p1)\n            mstore(0x60, 0x80)\n            mstore(0x80, p3)\n            writeString(0xa0, p2)\n        }\n        _sendLogPayload(0x1c, 0xc4);\n        /// @solidity memory-safe-assembly\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n            mstore(0xa0, m5)\n            mstore(0xc0, m6)\n        }\n    }\n\n    function log(uint256 p0, address p1, bytes32 p2, uint256 p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        bytes32 m5;\n        bytes32 m6;\n        /// @solidity memory-safe-assembly\n        assembly {\n            function writeString(pos, w) {\n                let length := 0\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\n                mstore(pos, length)\n                let shift := sub(256, shl(3, length))\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\n            }\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            m5 := mload(0xa0)\n            m6 := mload(0xc0)\n            // Selector of `log(uint256,address,string,uint256)`.\n            mstore(0x00, 0x46826b5d)\n            mstore(0x20, p0)\n            mstore(0x40, p1)\n            mstore(0x60, 0x80)\n            mstore(0x80, p3)\n            writeString(0xa0, p2)\n        }\n        _sendLogPayload(0x1c, 0xc4);\n        /// @solidity memory-safe-assembly\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n            mstore(0xa0, m5)\n            mstore(0xc0, m6)\n        }\n    }\n\n    function log(uint256 p0, address p1, bytes32 p2, bytes32 p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        bytes32 m5;\n        bytes32 m6;\n        bytes32 m7;\n        bytes32 m8;\n        /// @solidity memory-safe-assembly\n        assembly {\n            function writeString(pos, w) {\n                let length := 0\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\n                mstore(pos, length)\n                let shift := sub(256, shl(3, length))\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\n            }\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            m5 := mload(0xa0)\n            m6 := mload(0xc0)\n            m7 := mload(0xe0)\n            m8 := mload(0x100)\n            // Selector of `log(uint256,address,string,string)`.\n            mstore(0x00, 0x3e128ca3)\n            mstore(0x20, p0)\n            mstore(0x40, p1)\n            mstore(0x60, 0x80)\n            mstore(0x80, 0xc0)\n            writeString(0xa0, p2)\n            writeString(0xe0, p3)\n        }\n        _sendLogPayload(0x1c, 0x104);\n        /// @solidity memory-safe-assembly\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n            mstore(0xa0, m5)\n            mstore(0xc0, m6)\n            mstore(0xe0, m7)\n            mstore(0x100, m8)\n        }\n    }\n\n    function log(uint256 p0, bool p1, address p2, address p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        /// @solidity memory-safe-assembly\n        assembly {\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            // Selector of `log(uint256,bool,address,address)`.\n            mstore(0x00, 0xa1ef4cbb)\n            mstore(0x20, p0)\n            mstore(0x40, p1)\n            mstore(0x60, p2)\n            mstore(0x80, p3)\n        }\n        _sendLogPayload(0x1c, 0x84);\n        /// @solidity memory-safe-assembly\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n        }\n    }\n\n    function log(uint256 p0, bool p1, address p2, bool p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        /// @solidity memory-safe-assembly\n        assembly {\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            // Selector of `log(uint256,bool,address,bool)`.\n            mstore(0x00, 0x454d54a5)\n            mstore(0x20, p0)\n            mstore(0x40, p1)\n            mstore(0x60, p2)\n            mstore(0x80, p3)\n        }\n        _sendLogPayload(0x1c, 0x84);\n        /// @solidity memory-safe-assembly\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n        }\n    }\n\n    function log(uint256 p0, bool p1, address p2, uint256 p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        /// @solidity memory-safe-assembly\n        assembly {\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            // Selector of `log(uint256,bool,address,uint256)`.\n            mstore(0x00, 0x078287f5)\n            mstore(0x20, p0)\n            mstore(0x40, p1)\n            mstore(0x60, p2)\n            mstore(0x80, p3)\n        }\n        _sendLogPayload(0x1c, 0x84);\n        /// @solidity memory-safe-assembly\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n        }\n    }\n\n    function log(uint256 p0, bool p1, address p2, bytes32 p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        bytes32 m5;\n        bytes32 m6;\n        /// @solidity memory-safe-assembly\n        assembly {\n            function writeString(pos, w) {\n                let length := 0\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\n                mstore(pos, length)\n                let shift := sub(256, shl(3, length))\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\n            }\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            m5 := mload(0xa0)\n            m6 := mload(0xc0)\n            // Selector of `log(uint256,bool,address,string)`.\n            mstore(0x00, 0xade052c7)\n            mstore(0x20, p0)\n            mstore(0x40, p1)\n            mstore(0x60, p2)\n            mstore(0x80, 0x80)\n            writeString(0xa0, p3)\n        }\n        _sendLogPayload(0x1c, 0xc4);\n        /// @solidity memory-safe-assembly\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n            mstore(0xa0, m5)\n            mstore(0xc0, m6)\n        }\n    }\n\n    function log(uint256 p0, bool p1, bool p2, address p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        /// @solidity memory-safe-assembly\n        assembly {\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            // Selector of `log(uint256,bool,bool,address)`.\n            mstore(0x00, 0x69640b59)\n            mstore(0x20, p0)\n            mstore(0x40, p1)\n            mstore(0x60, p2)\n            mstore(0x80, p3)\n        }\n        _sendLogPayload(0x1c, 0x84);\n        /// @solidity memory-safe-assembly\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n        }\n    }\n\n    function log(uint256 p0, bool p1, bool p2, bool p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        /// @solidity memory-safe-assembly\n        assembly {\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            // Selector of `log(uint256,bool,bool,bool)`.\n            mstore(0x00, 0xb6f577a1)\n            mstore(0x20, p0)\n            mstore(0x40, p1)\n            mstore(0x60, p2)\n            mstore(0x80, p3)\n        }\n        _sendLogPayload(0x1c, 0x84);\n        /// @solidity memory-safe-assembly\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n        }\n    }\n\n    function log(uint256 p0, bool p1, bool p2, uint256 p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        /// @solidity memory-safe-assembly\n        assembly {\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            // Selector of `log(uint256,bool,bool,uint256)`.\n            mstore(0x00, 0x7464ce23)\n            mstore(0x20, p0)\n            mstore(0x40, p1)\n            mstore(0x60, p2)\n            mstore(0x80, p3)\n        }\n        _sendLogPayload(0x1c, 0x84);\n        /// @solidity memory-safe-assembly\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n        }\n    }\n\n    function log(uint256 p0, bool p1, bool p2, bytes32 p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        bytes32 m5;\n        bytes32 m6;\n        /// @solidity memory-safe-assembly\n        assembly {\n            function writeString(pos, w) {\n                let length := 0\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\n                mstore(pos, length)\n                let shift := sub(256, shl(3, length))\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\n            }\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            m5 := mload(0xa0)\n            m6 := mload(0xc0)\n            // Selector of `log(uint256,bool,bool,string)`.\n            mstore(0x00, 0xdddb9561)\n            mstore(0x20, p0)\n            mstore(0x40, p1)\n            mstore(0x60, p2)\n            mstore(0x80, 0x80)\n            writeString(0xa0, p3)\n        }\n        _sendLogPayload(0x1c, 0xc4);\n        /// @solidity memory-safe-assembly\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n            mstore(0xa0, m5)\n            mstore(0xc0, m6)\n        }\n    }\n\n    function log(uint256 p0, bool p1, uint256 p2, address p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        /// @solidity memory-safe-assembly\n        assembly {\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            // Selector of `log(uint256,bool,uint256,address)`.\n            mstore(0x00, 0x88cb6041)\n            mstore(0x20, p0)\n            mstore(0x40, p1)\n            mstore(0x60, p2)\n            mstore(0x80, p3)\n        }\n        _sendLogPayload(0x1c, 0x84);\n        /// @solidity memory-safe-assembly\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n        }\n    }\n\n    function log(uint256 p0, bool p1, uint256 p2, bool p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        /// @solidity memory-safe-assembly\n        assembly {\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            // Selector of `log(uint256,bool,uint256,bool)`.\n            mstore(0x00, 0x91a02e2a)\n            mstore(0x20, p0)\n            mstore(0x40, p1)\n            mstore(0x60, p2)\n            mstore(0x80, p3)\n        }\n        _sendLogPayload(0x1c, 0x84);\n        /// @solidity memory-safe-assembly\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n        }\n    }\n\n    function log(uint256 p0, bool p1, uint256 p2, uint256 p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        /// @solidity memory-safe-assembly\n        assembly {\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            // Selector of `log(uint256,bool,uint256,uint256)`.\n            mstore(0x00, 0xc6acc7a8)\n            mstore(0x20, p0)\n            mstore(0x40, p1)\n            mstore(0x60, p2)\n            mstore(0x80, p3)\n        }\n        _sendLogPayload(0x1c, 0x84);\n        /// @solidity memory-safe-assembly\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n        }\n    }\n\n    function log(uint256 p0, bool p1, uint256 p2, bytes32 p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        bytes32 m5;\n        bytes32 m6;\n        /// @solidity memory-safe-assembly\n        assembly {\n            function writeString(pos, w) {\n                let length := 0\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\n                mstore(pos, length)\n                let shift := sub(256, shl(3, length))\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\n            }\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            m5 := mload(0xa0)\n            m6 := mload(0xc0)\n            // Selector of `log(uint256,bool,uint256,string)`.\n            mstore(0x00, 0xde03e774)\n            mstore(0x20, p0)\n            mstore(0x40, p1)\n            mstore(0x60, p2)\n            mstore(0x80, 0x80)\n            writeString(0xa0, p3)\n        }\n        _sendLogPayload(0x1c, 0xc4);\n        /// @solidity memory-safe-assembly\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n            mstore(0xa0, m5)\n            mstore(0xc0, m6)\n        }\n    }\n\n    function log(uint256 p0, bool p1, bytes32 p2, address p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        bytes32 m5;\n        bytes32 m6;\n        /// @solidity memory-safe-assembly\n        assembly {\n            function writeString(pos, w) {\n                let length := 0\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\n                mstore(pos, length)\n                let shift := sub(256, shl(3, length))\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\n            }\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            m5 := mload(0xa0)\n            m6 := mload(0xc0)\n            // Selector of `log(uint256,bool,string,address)`.\n            mstore(0x00, 0xef529018)\n            mstore(0x20, p0)\n            mstore(0x40, p1)\n            mstore(0x60, 0x80)\n            mstore(0x80, p3)\n            writeString(0xa0, p2)\n        }\n        _sendLogPayload(0x1c, 0xc4);\n        /// @solidity memory-safe-assembly\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n            mstore(0xa0, m5)\n            mstore(0xc0, m6)\n        }\n    }\n\n    function log(uint256 p0, bool p1, bytes32 p2, bool p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        bytes32 m5;\n        bytes32 m6;\n        /// @solidity memory-safe-assembly\n        assembly {\n            function writeString(pos, w) {\n                let length := 0\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\n                mstore(pos, length)\n                let shift := sub(256, shl(3, length))\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\n            }\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            m5 := mload(0xa0)\n            m6 := mload(0xc0)\n            // Selector of `log(uint256,bool,string,bool)`.\n            mstore(0x00, 0xeb928d7f)\n            mstore(0x20, p0)\n            mstore(0x40, p1)\n            mstore(0x60, 0x80)\n            mstore(0x80, p3)\n            writeString(0xa0, p2)\n        }\n        _sendLogPayload(0x1c, 0xc4);\n        /// @solidity memory-safe-assembly\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n            mstore(0xa0, m5)\n            mstore(0xc0, m6)\n        }\n    }\n\n    function log(uint256 p0, bool p1, bytes32 p2, uint256 p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        bytes32 m5;\n        bytes32 m6;\n        /// @solidity memory-safe-assembly\n        assembly {\n            function writeString(pos, w) {\n                let length := 0\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\n                mstore(pos, length)\n                let shift := sub(256, shl(3, length))\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\n            }\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            m5 := mload(0xa0)\n            m6 := mload(0xc0)\n            // Selector of `log(uint256,bool,string,uint256)`.\n            mstore(0x00, 0x2c1d0746)\n            mstore(0x20, p0)\n            mstore(0x40, p1)\n            mstore(0x60, 0x80)\n            mstore(0x80, p3)\n            writeString(0xa0, p2)\n        }\n        _sendLogPayload(0x1c, 0xc4);\n        /// @solidity memory-safe-assembly\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n            mstore(0xa0, m5)\n            mstore(0xc0, m6)\n        }\n    }\n\n    function log(uint256 p0, bool p1, bytes32 p2, bytes32 p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        bytes32 m5;\n        bytes32 m6;\n        bytes32 m7;\n        bytes32 m8;\n        /// @solidity memory-safe-assembly\n        assembly {\n            function writeString(pos, w) {\n                let length := 0\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\n                mstore(pos, length)\n                let shift := sub(256, shl(3, length))\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\n            }\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            m5 := mload(0xa0)\n            m6 := mload(0xc0)\n            m7 := mload(0xe0)\n            m8 := mload(0x100)\n            // Selector of `log(uint256,bool,string,string)`.\n            mstore(0x00, 0x68c8b8bd)\n            mstore(0x20, p0)\n            mstore(0x40, p1)\n            mstore(0x60, 0x80)\n            mstore(0x80, 0xc0)\n            writeString(0xa0, p2)\n            writeString(0xe0, p3)\n        }\n        _sendLogPayload(0x1c, 0x104);\n        /// @solidity memory-safe-assembly\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n            mstore(0xa0, m5)\n            mstore(0xc0, m6)\n            mstore(0xe0, m7)\n            mstore(0x100, m8)\n        }\n    }\n\n    function log(uint256 p0, uint256 p1, address p2, address p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        /// @solidity memory-safe-assembly\n        assembly {\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            // Selector of `log(uint256,uint256,address,address)`.\n            mstore(0x00, 0x56a5d1b1)\n            mstore(0x20, p0)\n            mstore(0x40, p1)\n            mstore(0x60, p2)\n            mstore(0x80, p3)\n        }\n        _sendLogPayload(0x1c, 0x84);\n        /// @solidity memory-safe-assembly\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n        }\n    }\n\n    function log(uint256 p0, uint256 p1, address p2, bool p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        /// @solidity memory-safe-assembly\n        assembly {\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            // Selector of `log(uint256,uint256,address,bool)`.\n            mstore(0x00, 0x15cac476)\n            mstore(0x20, p0)\n            mstore(0x40, p1)\n            mstore(0x60, p2)\n            mstore(0x80, p3)\n        }\n        _sendLogPayload(0x1c, 0x84);\n        /// @solidity memory-safe-assembly\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n        }\n    }\n\n    function log(uint256 p0, uint256 p1, address p2, uint256 p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        /// @solidity memory-safe-assembly\n        assembly {\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            // Selector of `log(uint256,uint256,address,uint256)`.\n            mstore(0x00, 0x88f6e4b2)\n            mstore(0x20, p0)\n            mstore(0x40, p1)\n            mstore(0x60, p2)\n            mstore(0x80, p3)\n        }\n        _sendLogPayload(0x1c, 0x84);\n        /// @solidity memory-safe-assembly\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n        }\n    }\n\n    function log(uint256 p0, uint256 p1, address p2, bytes32 p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        bytes32 m5;\n        bytes32 m6;\n        /// @solidity memory-safe-assembly\n        assembly {\n            function writeString(pos, w) {\n                let length := 0\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\n                mstore(pos, length)\n                let shift := sub(256, shl(3, length))\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\n            }\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            m5 := mload(0xa0)\n            m6 := mload(0xc0)\n            // Selector of `log(uint256,uint256,address,string)`.\n            mstore(0x00, 0x6cde40b8)\n            mstore(0x20, p0)\n            mstore(0x40, p1)\n            mstore(0x60, p2)\n            mstore(0x80, 0x80)\n            writeString(0xa0, p3)\n        }\n        _sendLogPayload(0x1c, 0xc4);\n        /// @solidity memory-safe-assembly\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n            mstore(0xa0, m5)\n            mstore(0xc0, m6)\n        }\n    }\n\n    function log(uint256 p0, uint256 p1, bool p2, address p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        /// @solidity memory-safe-assembly\n        assembly {\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            // Selector of `log(uint256,uint256,bool,address)`.\n            mstore(0x00, 0x9a816a83)\n            mstore(0x20, p0)\n            mstore(0x40, p1)\n            mstore(0x60, p2)\n            mstore(0x80, p3)\n        }\n        _sendLogPayload(0x1c, 0x84);\n        /// @solidity memory-safe-assembly\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n        }\n    }\n\n    function log(uint256 p0, uint256 p1, bool p2, bool p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        /// @solidity memory-safe-assembly\n        assembly {\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            // Selector of `log(uint256,uint256,bool,bool)`.\n            mstore(0x00, 0xab085ae6)\n            mstore(0x20, p0)\n            mstore(0x40, p1)\n            mstore(0x60, p2)\n            mstore(0x80, p3)\n        }\n        _sendLogPayload(0x1c, 0x84);\n        /// @solidity memory-safe-assembly\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n        }\n    }\n\n    function log(uint256 p0, uint256 p1, bool p2, uint256 p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        /// @solidity memory-safe-assembly\n        assembly {\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            // Selector of `log(uint256,uint256,bool,uint256)`.\n            mstore(0x00, 0xeb7f6fd2)\n            mstore(0x20, p0)\n            mstore(0x40, p1)\n            mstore(0x60, p2)\n            mstore(0x80, p3)\n        }\n        _sendLogPayload(0x1c, 0x84);\n        /// @solidity memory-safe-assembly\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n        }\n    }\n\n    function log(uint256 p0, uint256 p1, bool p2, bytes32 p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        bytes32 m5;\n        bytes32 m6;\n        /// @solidity memory-safe-assembly\n        assembly {\n            function writeString(pos, w) {\n                let length := 0\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\n                mstore(pos, length)\n                let shift := sub(256, shl(3, length))\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\n            }\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            m5 := mload(0xa0)\n            m6 := mload(0xc0)\n            // Selector of `log(uint256,uint256,bool,string)`.\n            mstore(0x00, 0xa5b4fc99)\n            mstore(0x20, p0)\n            mstore(0x40, p1)\n            mstore(0x60, p2)\n            mstore(0x80, 0x80)\n            writeString(0xa0, p3)\n        }\n        _sendLogPayload(0x1c, 0xc4);\n        /// @solidity memory-safe-assembly\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n            mstore(0xa0, m5)\n            mstore(0xc0, m6)\n        }\n    }\n\n    function log(uint256 p0, uint256 p1, uint256 p2, address p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        /// @solidity memory-safe-assembly\n        assembly {\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            // Selector of `log(uint256,uint256,uint256,address)`.\n            mstore(0x00, 0xfa8185af)\n            mstore(0x20, p0)\n            mstore(0x40, p1)\n            mstore(0x60, p2)\n            mstore(0x80, p3)\n        }\n        _sendLogPayload(0x1c, 0x84);\n        /// @solidity memory-safe-assembly\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n        }\n    }\n\n    function log(uint256 p0, uint256 p1, uint256 p2, bool p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        /// @solidity memory-safe-assembly\n        assembly {\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            // Selector of `log(uint256,uint256,uint256,bool)`.\n            mstore(0x00, 0xc598d185)\n            mstore(0x20, p0)\n            mstore(0x40, p1)\n            mstore(0x60, p2)\n            mstore(0x80, p3)\n        }\n        _sendLogPayload(0x1c, 0x84);\n        /// @solidity memory-safe-assembly\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n        }\n    }\n\n    function log(uint256 p0, uint256 p1, uint256 p2, uint256 p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        /// @solidity memory-safe-assembly\n        assembly {\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            // Selector of `log(uint256,uint256,uint256,uint256)`.\n            mstore(0x00, 0x193fb800)\n            mstore(0x20, p0)\n            mstore(0x40, p1)\n            mstore(0x60, p2)\n            mstore(0x80, p3)\n        }\n        _sendLogPayload(0x1c, 0x84);\n        /// @solidity memory-safe-assembly\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n        }\n    }\n\n    function log(uint256 p0, uint256 p1, uint256 p2, bytes32 p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        bytes32 m5;\n        bytes32 m6;\n        /// @solidity memory-safe-assembly\n        assembly {\n            function writeString(pos, w) {\n                let length := 0\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\n                mstore(pos, length)\n                let shift := sub(256, shl(3, length))\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\n            }\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            m5 := mload(0xa0)\n            m6 := mload(0xc0)\n            // Selector of `log(uint256,uint256,uint256,string)`.\n            mstore(0x00, 0x59cfcbe3)\n            mstore(0x20, p0)\n            mstore(0x40, p1)\n            mstore(0x60, p2)\n            mstore(0x80, 0x80)\n            writeString(0xa0, p3)\n        }\n        _sendLogPayload(0x1c, 0xc4);\n        /// @solidity memory-safe-assembly\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n            mstore(0xa0, m5)\n            mstore(0xc0, m6)\n        }\n    }\n\n    function log(uint256 p0, uint256 p1, bytes32 p2, address p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        bytes32 m5;\n        bytes32 m6;\n        /// @solidity memory-safe-assembly\n        assembly {\n            function writeString(pos, w) {\n                let length := 0\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\n                mstore(pos, length)\n                let shift := sub(256, shl(3, length))\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\n            }\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            m5 := mload(0xa0)\n            m6 := mload(0xc0)\n            // Selector of `log(uint256,uint256,string,address)`.\n            mstore(0x00, 0x42d21db7)\n            mstore(0x20, p0)\n            mstore(0x40, p1)\n            mstore(0x60, 0x80)\n            mstore(0x80, p3)\n            writeString(0xa0, p2)\n        }\n        _sendLogPayload(0x1c, 0xc4);\n        /// @solidity memory-safe-assembly\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n            mstore(0xa0, m5)\n            mstore(0xc0, m6)\n        }\n    }\n\n    function log(uint256 p0, uint256 p1, bytes32 p2, bool p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        bytes32 m5;\n        bytes32 m6;\n        /// @solidity memory-safe-assembly\n        assembly {\n            function writeString(pos, w) {\n                let length := 0\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\n                mstore(pos, length)\n                let shift := sub(256, shl(3, length))\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\n            }\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            m5 := mload(0xa0)\n            m6 := mload(0xc0)\n            // Selector of `log(uint256,uint256,string,bool)`.\n            mstore(0x00, 0x7af6ab25)\n            mstore(0x20, p0)\n            mstore(0x40, p1)\n            mstore(0x60, 0x80)\n            mstore(0x80, p3)\n            writeString(0xa0, p2)\n        }\n        _sendLogPayload(0x1c, 0xc4);\n        /// @solidity memory-safe-assembly\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n            mstore(0xa0, m5)\n            mstore(0xc0, m6)\n        }\n    }\n\n    function log(uint256 p0, uint256 p1, bytes32 p2, uint256 p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        bytes32 m5;\n        bytes32 m6;\n        /// @solidity memory-safe-assembly\n        assembly {\n            function writeString(pos, w) {\n                let length := 0\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\n                mstore(pos, length)\n                let shift := sub(256, shl(3, length))\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\n            }\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            m5 := mload(0xa0)\n            m6 := mload(0xc0)\n            // Selector of `log(uint256,uint256,string,uint256)`.\n            mstore(0x00, 0x5da297eb)\n            mstore(0x20, p0)\n            mstore(0x40, p1)\n            mstore(0x60, 0x80)\n            mstore(0x80, p3)\n            writeString(0xa0, p2)\n        }\n        _sendLogPayload(0x1c, 0xc4);\n        /// @solidity memory-safe-assembly\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n            mstore(0xa0, m5)\n            mstore(0xc0, m6)\n        }\n    }\n\n    function log(uint256 p0, uint256 p1, bytes32 p2, bytes32 p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        bytes32 m5;\n        bytes32 m6;\n        bytes32 m7;\n        bytes32 m8;\n        /// @solidity memory-safe-assembly\n        assembly {\n            function writeString(pos, w) {\n                let length := 0\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\n                mstore(pos, length)\n                let shift := sub(256, shl(3, length))\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\n            }\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            m5 := mload(0xa0)\n            m6 := mload(0xc0)\n            m7 := mload(0xe0)\n            m8 := mload(0x100)\n            // Selector of `log(uint256,uint256,string,string)`.\n            mstore(0x00, 0x27d8afd2)\n            mstore(0x20, p0)\n            mstore(0x40, p1)\n            mstore(0x60, 0x80)\n            mstore(0x80, 0xc0)\n            writeString(0xa0, p2)\n            writeString(0xe0, p3)\n        }\n        _sendLogPayload(0x1c, 0x104);\n        /// @solidity memory-safe-assembly\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n            mstore(0xa0, m5)\n            mstore(0xc0, m6)\n            mstore(0xe0, m7)\n            mstore(0x100, m8)\n        }\n    }\n\n    function log(uint256 p0, bytes32 p1, address p2, address p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        bytes32 m5;\n        bytes32 m6;\n        /// @solidity memory-safe-assembly\n        assembly {\n            function writeString(pos, w) {\n                let length := 0\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\n                mstore(pos, length)\n                let shift := sub(256, shl(3, length))\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\n            }\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            m5 := mload(0xa0)\n            m6 := mload(0xc0)\n            // Selector of `log(uint256,string,address,address)`.\n            mstore(0x00, 0x6168ed61)\n            mstore(0x20, p0)\n            mstore(0x40, 0x80)\n            mstore(0x60, p2)\n            mstore(0x80, p3)\n            writeString(0xa0, p1)\n        }\n        _sendLogPayload(0x1c, 0xc4);\n        /// @solidity memory-safe-assembly\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n            mstore(0xa0, m5)\n            mstore(0xc0, m6)\n        }\n    }\n\n    function log(uint256 p0, bytes32 p1, address p2, bool p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        bytes32 m5;\n        bytes32 m6;\n        /// @solidity memory-safe-assembly\n        assembly {\n            function writeString(pos, w) {\n                let length := 0\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\n                mstore(pos, length)\n                let shift := sub(256, shl(3, length))\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\n            }\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            m5 := mload(0xa0)\n            m6 := mload(0xc0)\n            // Selector of `log(uint256,string,address,bool)`.\n            mstore(0x00, 0x90c30a56)\n            mstore(0x20, p0)\n            mstore(0x40, 0x80)\n            mstore(0x60, p2)\n            mstore(0x80, p3)\n            writeString(0xa0, p1)\n        }\n        _sendLogPayload(0x1c, 0xc4);\n        /// @solidity memory-safe-assembly\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n            mstore(0xa0, m5)\n            mstore(0xc0, m6)\n        }\n    }\n\n    function log(uint256 p0, bytes32 p1, address p2, uint256 p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        bytes32 m5;\n        bytes32 m6;\n        /// @solidity memory-safe-assembly\n        assembly {\n            function writeString(pos, w) {\n                let length := 0\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\n                mstore(pos, length)\n                let shift := sub(256, shl(3, length))\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\n            }\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            m5 := mload(0xa0)\n            m6 := mload(0xc0)\n            // Selector of `log(uint256,string,address,uint256)`.\n            mstore(0x00, 0xe8d3018d)\n            mstore(0x20, p0)\n            mstore(0x40, 0x80)\n            mstore(0x60, p2)\n            mstore(0x80, p3)\n            writeString(0xa0, p1)\n        }\n        _sendLogPayload(0x1c, 0xc4);\n        /// @solidity memory-safe-assembly\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n            mstore(0xa0, m5)\n            mstore(0xc0, m6)\n        }\n    }\n\n    function log(uint256 p0, bytes32 p1, address p2, bytes32 p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        bytes32 m5;\n        bytes32 m6;\n        bytes32 m7;\n        bytes32 m8;\n        /// @solidity memory-safe-assembly\n        assembly {\n            function writeString(pos, w) {\n                let length := 0\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\n                mstore(pos, length)\n                let shift := sub(256, shl(3, length))\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\n            }\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            m5 := mload(0xa0)\n            m6 := mload(0xc0)\n            m7 := mload(0xe0)\n            m8 := mload(0x100)\n            // Selector of `log(uint256,string,address,string)`.\n            mstore(0x00, 0x9c3adfa1)\n            mstore(0x20, p0)\n            mstore(0x40, 0x80)\n            mstore(0x60, p2)\n            mstore(0x80, 0xc0)\n            writeString(0xa0, p1)\n            writeString(0xe0, p3)\n        }\n        _sendLogPayload(0x1c, 0x104);\n        /// @solidity memory-safe-assembly\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n            mstore(0xa0, m5)\n            mstore(0xc0, m6)\n            mstore(0xe0, m7)\n            mstore(0x100, m8)\n        }\n    }\n\n    function log(uint256 p0, bytes32 p1, bool p2, address p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        bytes32 m5;\n        bytes32 m6;\n        /// @solidity memory-safe-assembly\n        assembly {\n            function writeString(pos, w) {\n                let length := 0\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\n                mstore(pos, length)\n                let shift := sub(256, shl(3, length))\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\n            }\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            m5 := mload(0xa0)\n            m6 := mload(0xc0)\n            // Selector of `log(uint256,string,bool,address)`.\n            mstore(0x00, 0xae2ec581)\n            mstore(0x20, p0)\n            mstore(0x40, 0x80)\n            mstore(0x60, p2)\n            mstore(0x80, p3)\n            writeString(0xa0, p1)\n        }\n        _sendLogPayload(0x1c, 0xc4);\n        /// @solidity memory-safe-assembly\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n            mstore(0xa0, m5)\n            mstore(0xc0, m6)\n        }\n    }\n\n    function log(uint256 p0, bytes32 p1, bool p2, bool p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        bytes32 m5;\n        bytes32 m6;\n        /// @solidity memory-safe-assembly\n        assembly {\n            function writeString(pos, w) {\n                let length := 0\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\n                mstore(pos, length)\n                let shift := sub(256, shl(3, length))\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\n            }\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            m5 := mload(0xa0)\n            m6 := mload(0xc0)\n            // Selector of `log(uint256,string,bool,bool)`.\n            mstore(0x00, 0xba535d9c)\n            mstore(0x20, p0)\n            mstore(0x40, 0x80)\n            mstore(0x60, p2)\n            mstore(0x80, p3)\n            writeString(0xa0, p1)\n        }\n        _sendLogPayload(0x1c, 0xc4);\n        /// @solidity memory-safe-assembly\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n            mstore(0xa0, m5)\n            mstore(0xc0, m6)\n        }\n    }\n\n    function log(uint256 p0, bytes32 p1, bool p2, uint256 p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        bytes32 m5;\n        bytes32 m6;\n        /// @solidity memory-safe-assembly\n        assembly {\n            function writeString(pos, w) {\n                let length := 0\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\n                mstore(pos, length)\n                let shift := sub(256, shl(3, length))\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\n            }\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            m5 := mload(0xa0)\n            m6 := mload(0xc0)\n            // Selector of `log(uint256,string,bool,uint256)`.\n            mstore(0x00, 0xcf009880)\n            mstore(0x20, p0)\n            mstore(0x40, 0x80)\n            mstore(0x60, p2)\n            mstore(0x80, p3)\n            writeString(0xa0, p1)\n        }\n        _sendLogPayload(0x1c, 0xc4);\n        /// @solidity memory-safe-assembly\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n            mstore(0xa0, m5)\n            mstore(0xc0, m6)\n        }\n    }\n\n    function log(uint256 p0, bytes32 p1, bool p2, bytes32 p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        bytes32 m5;\n        bytes32 m6;\n        bytes32 m7;\n        bytes32 m8;\n        /// @solidity memory-safe-assembly\n        assembly {\n            function writeString(pos, w) {\n                let length := 0\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\n                mstore(pos, length)\n                let shift := sub(256, shl(3, length))\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\n            }\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            m5 := mload(0xa0)\n            m6 := mload(0xc0)\n            m7 := mload(0xe0)\n            m8 := mload(0x100)\n            // Selector of `log(uint256,string,bool,string)`.\n            mstore(0x00, 0xd2d423cd)\n            mstore(0x20, p0)\n            mstore(0x40, 0x80)\n            mstore(0x60, p2)\n            mstore(0x80, 0xc0)\n            writeString(0xa0, p1)\n            writeString(0xe0, p3)\n        }\n        _sendLogPayload(0x1c, 0x104);\n        /// @solidity memory-safe-assembly\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n            mstore(0xa0, m5)\n            mstore(0xc0, m6)\n            mstore(0xe0, m7)\n            mstore(0x100, m8)\n        }\n    }\n\n    function log(uint256 p0, bytes32 p1, uint256 p2, address p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        bytes32 m5;\n        bytes32 m6;\n        /// @solidity memory-safe-assembly\n        assembly {\n            function writeString(pos, w) {\n                let length := 0\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\n                mstore(pos, length)\n                let shift := sub(256, shl(3, length))\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\n            }\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            m5 := mload(0xa0)\n            m6 := mload(0xc0)\n            // Selector of `log(uint256,string,uint256,address)`.\n            mstore(0x00, 0x3b2279b4)\n            mstore(0x20, p0)\n            mstore(0x40, 0x80)\n            mstore(0x60, p2)\n            mstore(0x80, p3)\n            writeString(0xa0, p1)\n        }\n        _sendLogPayload(0x1c, 0xc4);\n        /// @solidity memory-safe-assembly\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n            mstore(0xa0, m5)\n            mstore(0xc0, m6)\n        }\n    }\n\n    function log(uint256 p0, bytes32 p1, uint256 p2, bool p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        bytes32 m5;\n        bytes32 m6;\n        /// @solidity memory-safe-assembly\n        assembly {\n            function writeString(pos, w) {\n                let length := 0\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\n                mstore(pos, length)\n                let shift := sub(256, shl(3, length))\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\n            }\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            m5 := mload(0xa0)\n            m6 := mload(0xc0)\n            // Selector of `log(uint256,string,uint256,bool)`.\n            mstore(0x00, 0x691a8f74)\n            mstore(0x20, p0)\n            mstore(0x40, 0x80)\n            mstore(0x60, p2)\n            mstore(0x80, p3)\n            writeString(0xa0, p1)\n        }\n        _sendLogPayload(0x1c, 0xc4);\n        /// @solidity memory-safe-assembly\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n            mstore(0xa0, m5)\n            mstore(0xc0, m6)\n        }\n    }\n\n    function log(uint256 p0, bytes32 p1, uint256 p2, uint256 p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        bytes32 m5;\n        bytes32 m6;\n        /// @solidity memory-safe-assembly\n        assembly {\n            function writeString(pos, w) {\n                let length := 0\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\n                mstore(pos, length)\n                let shift := sub(256, shl(3, length))\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\n            }\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            m5 := mload(0xa0)\n            m6 := mload(0xc0)\n            // Selector of `log(uint256,string,uint256,uint256)`.\n            mstore(0x00, 0x82c25b74)\n            mstore(0x20, p0)\n            mstore(0x40, 0x80)\n            mstore(0x60, p2)\n            mstore(0x80, p3)\n            writeString(0xa0, p1)\n        }\n        _sendLogPayload(0x1c, 0xc4);\n        /// @solidity memory-safe-assembly\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n            mstore(0xa0, m5)\n            mstore(0xc0, m6)\n        }\n    }\n\n    function log(uint256 p0, bytes32 p1, uint256 p2, bytes32 p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        bytes32 m5;\n        bytes32 m6;\n        bytes32 m7;\n        bytes32 m8;\n        /// @solidity memory-safe-assembly\n        assembly {\n            function writeString(pos, w) {\n                let length := 0\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\n                mstore(pos, length)\n                let shift := sub(256, shl(3, length))\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\n            }\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            m5 := mload(0xa0)\n            m6 := mload(0xc0)\n            m7 := mload(0xe0)\n            m8 := mload(0x100)\n            // Selector of `log(uint256,string,uint256,string)`.\n            mstore(0x00, 0xb7b914ca)\n            mstore(0x20, p0)\n            mstore(0x40, 0x80)\n            mstore(0x60, p2)\n            mstore(0x80, 0xc0)\n            writeString(0xa0, p1)\n            writeString(0xe0, p3)\n        }\n        _sendLogPayload(0x1c, 0x104);\n        /// @solidity memory-safe-assembly\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n            mstore(0xa0, m5)\n            mstore(0xc0, m6)\n            mstore(0xe0, m7)\n            mstore(0x100, m8)\n        }\n    }\n\n    function log(uint256 p0, bytes32 p1, bytes32 p2, address p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        bytes32 m5;\n        bytes32 m6;\n        bytes32 m7;\n        bytes32 m8;\n        /// @solidity memory-safe-assembly\n        assembly {\n            function writeString(pos, w) {\n                let length := 0\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\n                mstore(pos, length)\n                let shift := sub(256, shl(3, length))\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\n            }\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            m5 := mload(0xa0)\n            m6 := mload(0xc0)\n            m7 := mload(0xe0)\n            m8 := mload(0x100)\n            // Selector of `log(uint256,string,string,address)`.\n            mstore(0x00, 0xd583c602)\n            mstore(0x20, p0)\n            mstore(0x40, 0x80)\n            mstore(0x60, 0xc0)\n            mstore(0x80, p3)\n            writeString(0xa0, p1)\n            writeString(0xe0, p2)\n        }\n        _sendLogPayload(0x1c, 0x104);\n        /// @solidity memory-safe-assembly\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n            mstore(0xa0, m5)\n            mstore(0xc0, m6)\n            mstore(0xe0, m7)\n            mstore(0x100, m8)\n        }\n    }\n\n    function log(uint256 p0, bytes32 p1, bytes32 p2, bool p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        bytes32 m5;\n        bytes32 m6;\n        bytes32 m7;\n        bytes32 m8;\n        /// @solidity memory-safe-assembly\n        assembly {\n            function writeString(pos, w) {\n                let length := 0\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\n                mstore(pos, length)\n                let shift := sub(256, shl(3, length))\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\n            }\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            m5 := mload(0xa0)\n            m6 := mload(0xc0)\n            m7 := mload(0xe0)\n            m8 := mload(0x100)\n            // Selector of `log(uint256,string,string,bool)`.\n            mstore(0x00, 0xb3a6b6bd)\n            mstore(0x20, p0)\n            mstore(0x40, 0x80)\n            mstore(0x60, 0xc0)\n            mstore(0x80, p3)\n            writeString(0xa0, p1)\n            writeString(0xe0, p2)\n        }\n        _sendLogPayload(0x1c, 0x104);\n        /// @solidity memory-safe-assembly\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n            mstore(0xa0, m5)\n            mstore(0xc0, m6)\n            mstore(0xe0, m7)\n            mstore(0x100, m8)\n        }\n    }\n\n    function log(uint256 p0, bytes32 p1, bytes32 p2, uint256 p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        bytes32 m5;\n        bytes32 m6;\n        bytes32 m7;\n        bytes32 m8;\n        /// @solidity memory-safe-assembly\n        assembly {\n            function writeString(pos, w) {\n                let length := 0\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\n                mstore(pos, length)\n                let shift := sub(256, shl(3, length))\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\n            }\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            m5 := mload(0xa0)\n            m6 := mload(0xc0)\n            m7 := mload(0xe0)\n            m8 := mload(0x100)\n            // Selector of `log(uint256,string,string,uint256)`.\n            mstore(0x00, 0xb028c9bd)\n            mstore(0x20, p0)\n            mstore(0x40, 0x80)\n            mstore(0x60, 0xc0)\n            mstore(0x80, p3)\n            writeString(0xa0, p1)\n            writeString(0xe0, p2)\n        }\n        _sendLogPayload(0x1c, 0x104);\n        /// @solidity memory-safe-assembly\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n            mstore(0xa0, m5)\n            mstore(0xc0, m6)\n            mstore(0xe0, m7)\n            mstore(0x100, m8)\n        }\n    }\n\n    function log(uint256 p0, bytes32 p1, bytes32 p2, bytes32 p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        bytes32 m5;\n        bytes32 m6;\n        bytes32 m7;\n        bytes32 m8;\n        bytes32 m9;\n        bytes32 m10;\n        /// @solidity memory-safe-assembly\n        assembly {\n            function writeString(pos, w) {\n                let length := 0\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\n                mstore(pos, length)\n                let shift := sub(256, shl(3, length))\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\n            }\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            m5 := mload(0xa0)\n            m6 := mload(0xc0)\n            m7 := mload(0xe0)\n            m8 := mload(0x100)\n            m9 := mload(0x120)\n            m10 := mload(0x140)\n            // Selector of `log(uint256,string,string,string)`.\n            mstore(0x00, 0x21ad0683)\n            mstore(0x20, p0)\n            mstore(0x40, 0x80)\n            mstore(0x60, 0xc0)\n            mstore(0x80, 0x100)\n            writeString(0xa0, p1)\n            writeString(0xe0, p2)\n            writeString(0x120, p3)\n        }\n        _sendLogPayload(0x1c, 0x144);\n        /// @solidity memory-safe-assembly\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n            mstore(0xa0, m5)\n            mstore(0xc0, m6)\n            mstore(0xe0, m7)\n            mstore(0x100, m8)\n            mstore(0x120, m9)\n            mstore(0x140, m10)\n        }\n    }\n\n    function log(bytes32 p0, address p1, address p2, address p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        bytes32 m5;\n        bytes32 m6;\n        /// @solidity memory-safe-assembly\n        assembly {\n            function writeString(pos, w) {\n                let length := 0\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\n                mstore(pos, length)\n                let shift := sub(256, shl(3, length))\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\n            }\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            m5 := mload(0xa0)\n            m6 := mload(0xc0)\n            // Selector of `log(string,address,address,address)`.\n            mstore(0x00, 0xed8f28f6)\n            mstore(0x20, 0x80)\n            mstore(0x40, p1)\n            mstore(0x60, p2)\n            mstore(0x80, p3)\n            writeString(0xa0, p0)\n        }\n        _sendLogPayload(0x1c, 0xc4);\n        /// @solidity memory-safe-assembly\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n            mstore(0xa0, m5)\n            mstore(0xc0, m6)\n        }\n    }\n\n    function log(bytes32 p0, address p1, address p2, bool p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        bytes32 m5;\n        bytes32 m6;\n        /// @solidity memory-safe-assembly\n        assembly {\n            function writeString(pos, w) {\n                let length := 0\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\n                mstore(pos, length)\n                let shift := sub(256, shl(3, length))\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\n            }\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            m5 := mload(0xa0)\n            m6 := mload(0xc0)\n            // Selector of `log(string,address,address,bool)`.\n            mstore(0x00, 0xb59dbd60)\n            mstore(0x20, 0x80)\n            mstore(0x40, p1)\n            mstore(0x60, p2)\n            mstore(0x80, p3)\n            writeString(0xa0, p0)\n        }\n        _sendLogPayload(0x1c, 0xc4);\n        /// @solidity memory-safe-assembly\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n            mstore(0xa0, m5)\n            mstore(0xc0, m6)\n        }\n    }\n\n    function log(bytes32 p0, address p1, address p2, uint256 p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        bytes32 m5;\n        bytes32 m6;\n        /// @solidity memory-safe-assembly\n        assembly {\n            function writeString(pos, w) {\n                let length := 0\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\n                mstore(pos, length)\n                let shift := sub(256, shl(3, length))\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\n            }\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            m5 := mload(0xa0)\n            m6 := mload(0xc0)\n            // Selector of `log(string,address,address,uint256)`.\n            mstore(0x00, 0x8ef3f399)\n            mstore(0x20, 0x80)\n            mstore(0x40, p1)\n            mstore(0x60, p2)\n            mstore(0x80, p3)\n            writeString(0xa0, p0)\n        }\n        _sendLogPayload(0x1c, 0xc4);\n        /// @solidity memory-safe-assembly\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n            mstore(0xa0, m5)\n            mstore(0xc0, m6)\n        }\n    }\n\n    function log(bytes32 p0, address p1, address p2, bytes32 p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        bytes32 m5;\n        bytes32 m6;\n        bytes32 m7;\n        bytes32 m8;\n        /// @solidity memory-safe-assembly\n        assembly {\n            function writeString(pos, w) {\n                let length := 0\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\n                mstore(pos, length)\n                let shift := sub(256, shl(3, length))\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\n            }\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            m5 := mload(0xa0)\n            m6 := mload(0xc0)\n            m7 := mload(0xe0)\n            m8 := mload(0x100)\n            // Selector of `log(string,address,address,string)`.\n            mstore(0x00, 0x800a1c67)\n            mstore(0x20, 0x80)\n            mstore(0x40, p1)\n            mstore(0x60, p2)\n            mstore(0x80, 0xc0)\n            writeString(0xa0, p0)\n            writeString(0xe0, p3)\n        }\n        _sendLogPayload(0x1c, 0x104);\n        /// @solidity memory-safe-assembly\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n            mstore(0xa0, m5)\n            mstore(0xc0, m6)\n            mstore(0xe0, m7)\n            mstore(0x100, m8)\n        }\n    }\n\n    function log(bytes32 p0, address p1, bool p2, address p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        bytes32 m5;\n        bytes32 m6;\n        /// @solidity memory-safe-assembly\n        assembly {\n            function writeString(pos, w) {\n                let length := 0\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\n                mstore(pos, length)\n                let shift := sub(256, shl(3, length))\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\n            }\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            m5 := mload(0xa0)\n            m6 := mload(0xc0)\n            // Selector of `log(string,address,bool,address)`.\n            mstore(0x00, 0x223603bd)\n            mstore(0x20, 0x80)\n            mstore(0x40, p1)\n            mstore(0x60, p2)\n            mstore(0x80, p3)\n            writeString(0xa0, p0)\n        }\n        _sendLogPayload(0x1c, 0xc4);\n        /// @solidity memory-safe-assembly\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n            mstore(0xa0, m5)\n            mstore(0xc0, m6)\n        }\n    }\n\n    function log(bytes32 p0, address p1, bool p2, bool p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        bytes32 m5;\n        bytes32 m6;\n        /// @solidity memory-safe-assembly\n        assembly {\n            function writeString(pos, w) {\n                let length := 0\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\n                mstore(pos, length)\n                let shift := sub(256, shl(3, length))\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\n            }\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            m5 := mload(0xa0)\n            m6 := mload(0xc0)\n            // Selector of `log(string,address,bool,bool)`.\n            mstore(0x00, 0x79884c2b)\n            mstore(0x20, 0x80)\n            mstore(0x40, p1)\n            mstore(0x60, p2)\n            mstore(0x80, p3)\n            writeString(0xa0, p0)\n        }\n        _sendLogPayload(0x1c, 0xc4);\n        /// @solidity memory-safe-assembly\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n            mstore(0xa0, m5)\n            mstore(0xc0, m6)\n        }\n    }\n\n    function log(bytes32 p0, address p1, bool p2, uint256 p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        bytes32 m5;\n        bytes32 m6;\n        /// @solidity memory-safe-assembly\n        assembly {\n            function writeString(pos, w) {\n                let length := 0\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\n                mstore(pos, length)\n                let shift := sub(256, shl(3, length))\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\n            }\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            m5 := mload(0xa0)\n            m6 := mload(0xc0)\n            // Selector of `log(string,address,bool,uint256)`.\n            mstore(0x00, 0x3e9f866a)\n            mstore(0x20, 0x80)\n            mstore(0x40, p1)\n            mstore(0x60, p2)\n            mstore(0x80, p3)\n            writeString(0xa0, p0)\n        }\n        _sendLogPayload(0x1c, 0xc4);\n        /// @solidity memory-safe-assembly\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n            mstore(0xa0, m5)\n            mstore(0xc0, m6)\n        }\n    }\n\n    function log(bytes32 p0, address p1, bool p2, bytes32 p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        bytes32 m5;\n        bytes32 m6;\n        bytes32 m7;\n        bytes32 m8;\n        /// @solidity memory-safe-assembly\n        assembly {\n            function writeString(pos, w) {\n                let length := 0\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\n                mstore(pos, length)\n                let shift := sub(256, shl(3, length))\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\n            }\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            m5 := mload(0xa0)\n            m6 := mload(0xc0)\n            m7 := mload(0xe0)\n            m8 := mload(0x100)\n            // Selector of `log(string,address,bool,string)`.\n            mstore(0x00, 0x0454c079)\n            mstore(0x20, 0x80)\n            mstore(0x40, p1)\n            mstore(0x60, p2)\n            mstore(0x80, 0xc0)\n            writeString(0xa0, p0)\n            writeString(0xe0, p3)\n        }\n        _sendLogPayload(0x1c, 0x104);\n        /// @solidity memory-safe-assembly\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n            mstore(0xa0, m5)\n            mstore(0xc0, m6)\n            mstore(0xe0, m7)\n            mstore(0x100, m8)\n        }\n    }\n\n    function log(bytes32 p0, address p1, uint256 p2, address p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        bytes32 m5;\n        bytes32 m6;\n        /// @solidity memory-safe-assembly\n        assembly {\n            function writeString(pos, w) {\n                let length := 0\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\n                mstore(pos, length)\n                let shift := sub(256, shl(3, length))\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\n            }\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            m5 := mload(0xa0)\n            m6 := mload(0xc0)\n            // Selector of `log(string,address,uint256,address)`.\n            mstore(0x00, 0x63fb8bc5)\n            mstore(0x20, 0x80)\n            mstore(0x40, p1)\n            mstore(0x60, p2)\n            mstore(0x80, p3)\n            writeString(0xa0, p0)\n        }\n        _sendLogPayload(0x1c, 0xc4);\n        /// @solidity memory-safe-assembly\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n            mstore(0xa0, m5)\n            mstore(0xc0, m6)\n        }\n    }\n\n    function log(bytes32 p0, address p1, uint256 p2, bool p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        bytes32 m5;\n        bytes32 m6;\n        /// @solidity memory-safe-assembly\n        assembly {\n            function writeString(pos, w) {\n                let length := 0\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\n                mstore(pos, length)\n                let shift := sub(256, shl(3, length))\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\n            }\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            m5 := mload(0xa0)\n            m6 := mload(0xc0)\n            // Selector of `log(string,address,uint256,bool)`.\n            mstore(0x00, 0xfc4845f0)\n            mstore(0x20, 0x80)\n            mstore(0x40, p1)\n            mstore(0x60, p2)\n            mstore(0x80, p3)\n            writeString(0xa0, p0)\n        }\n        _sendLogPayload(0x1c, 0xc4);\n        /// @solidity memory-safe-assembly\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n            mstore(0xa0, m5)\n            mstore(0xc0, m6)\n        }\n    }\n\n    function log(bytes32 p0, address p1, uint256 p2, uint256 p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        bytes32 m5;\n        bytes32 m6;\n        /// @solidity memory-safe-assembly\n        assembly {\n            function writeString(pos, w) {\n                let length := 0\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\n                mstore(pos, length)\n                let shift := sub(256, shl(3, length))\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\n            }\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            m5 := mload(0xa0)\n            m6 := mload(0xc0)\n            // Selector of `log(string,address,uint256,uint256)`.\n            mstore(0x00, 0xf8f51b1e)\n            mstore(0x20, 0x80)\n            mstore(0x40, p1)\n            mstore(0x60, p2)\n            mstore(0x80, p3)\n            writeString(0xa0, p0)\n        }\n        _sendLogPayload(0x1c, 0xc4);\n        /// @solidity memory-safe-assembly\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n            mstore(0xa0, m5)\n            mstore(0xc0, m6)\n        }\n    }\n\n    function log(bytes32 p0, address p1, uint256 p2, bytes32 p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        bytes32 m5;\n        bytes32 m6;\n        bytes32 m7;\n        bytes32 m8;\n        /// @solidity memory-safe-assembly\n        assembly {\n            function writeString(pos, w) {\n                let length := 0\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\n                mstore(pos, length)\n                let shift := sub(256, shl(3, length))\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\n            }\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            m5 := mload(0xa0)\n            m6 := mload(0xc0)\n            m7 := mload(0xe0)\n            m8 := mload(0x100)\n            // Selector of `log(string,address,uint256,string)`.\n            mstore(0x00, 0x5a477632)\n            mstore(0x20, 0x80)\n            mstore(0x40, p1)\n            mstore(0x60, p2)\n            mstore(0x80, 0xc0)\n            writeString(0xa0, p0)\n            writeString(0xe0, p3)\n        }\n        _sendLogPayload(0x1c, 0x104);\n        /// @solidity memory-safe-assembly\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n            mstore(0xa0, m5)\n            mstore(0xc0, m6)\n            mstore(0xe0, m7)\n            mstore(0x100, m8)\n        }\n    }\n\n    function log(bytes32 p0, address p1, bytes32 p2, address p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        bytes32 m5;\n        bytes32 m6;\n        bytes32 m7;\n        bytes32 m8;\n        /// @solidity memory-safe-assembly\n        assembly {\n            function writeString(pos, w) {\n                let length := 0\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\n                mstore(pos, length)\n                let shift := sub(256, shl(3, length))\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\n            }\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            m5 := mload(0xa0)\n            m6 := mload(0xc0)\n            m7 := mload(0xe0)\n            m8 := mload(0x100)\n            // Selector of `log(string,address,string,address)`.\n            mstore(0x00, 0xaabc9a31)\n            mstore(0x20, 0x80)\n            mstore(0x40, p1)\n            mstore(0x60, 0xc0)\n            mstore(0x80, p3)\n            writeString(0xa0, p0)\n            writeString(0xe0, p2)\n        }\n        _sendLogPayload(0x1c, 0x104);\n        /// @solidity memory-safe-assembly\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n            mstore(0xa0, m5)\n            mstore(0xc0, m6)\n            mstore(0xe0, m7)\n            mstore(0x100, m8)\n        }\n    }\n\n    function log(bytes32 p0, address p1, bytes32 p2, bool p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        bytes32 m5;\n        bytes32 m6;\n        bytes32 m7;\n        bytes32 m8;\n        /// @solidity memory-safe-assembly\n        assembly {\n            function writeString(pos, w) {\n                let length := 0\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\n                mstore(pos, length)\n                let shift := sub(256, shl(3, length))\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\n            }\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            m5 := mload(0xa0)\n            m6 := mload(0xc0)\n            m7 := mload(0xe0)\n            m8 := mload(0x100)\n            // Selector of `log(string,address,string,bool)`.\n            mstore(0x00, 0x5f15d28c)\n            mstore(0x20, 0x80)\n            mstore(0x40, p1)\n            mstore(0x60, 0xc0)\n            mstore(0x80, p3)\n            writeString(0xa0, p0)\n            writeString(0xe0, p2)\n        }\n        _sendLogPayload(0x1c, 0x104);\n        /// @solidity memory-safe-assembly\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n            mstore(0xa0, m5)\n            mstore(0xc0, m6)\n            mstore(0xe0, m7)\n            mstore(0x100, m8)\n        }\n    }\n\n    function log(bytes32 p0, address p1, bytes32 p2, uint256 p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        bytes32 m5;\n        bytes32 m6;\n        bytes32 m7;\n        bytes32 m8;\n        /// @solidity memory-safe-assembly\n        assembly {\n            function writeString(pos, w) {\n                let length := 0\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\n                mstore(pos, length)\n                let shift := sub(256, shl(3, length))\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\n            }\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            m5 := mload(0xa0)\n            m6 := mload(0xc0)\n            m7 := mload(0xe0)\n            m8 := mload(0x100)\n            // Selector of `log(string,address,string,uint256)`.\n            mstore(0x00, 0x91d1112e)\n            mstore(0x20, 0x80)\n            mstore(0x40, p1)\n            mstore(0x60, 0xc0)\n            mstore(0x80, p3)\n            writeString(0xa0, p0)\n            writeString(0xe0, p2)\n        }\n        _sendLogPayload(0x1c, 0x104);\n        /// @solidity memory-safe-assembly\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n            mstore(0xa0, m5)\n            mstore(0xc0, m6)\n            mstore(0xe0, m7)\n            mstore(0x100, m8)\n        }\n    }\n\n    function log(bytes32 p0, address p1, bytes32 p2, bytes32 p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        bytes32 m5;\n        bytes32 m6;\n        bytes32 m7;\n        bytes32 m8;\n        bytes32 m9;\n        bytes32 m10;\n        /// @solidity memory-safe-assembly\n        assembly {\n            function writeString(pos, w) {\n                let length := 0\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\n                mstore(pos, length)\n                let shift := sub(256, shl(3, length))\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\n            }\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            m5 := mload(0xa0)\n            m6 := mload(0xc0)\n            m7 := mload(0xe0)\n            m8 := mload(0x100)\n            m9 := mload(0x120)\n            m10 := mload(0x140)\n            // Selector of `log(string,address,string,string)`.\n            mstore(0x00, 0x245986f2)\n            mstore(0x20, 0x80)\n            mstore(0x40, p1)\n            mstore(0x60, 0xc0)\n            mstore(0x80, 0x100)\n            writeString(0xa0, p0)\n            writeString(0xe0, p2)\n            writeString(0x120, p3)\n        }\n        _sendLogPayload(0x1c, 0x144);\n        /// @solidity memory-safe-assembly\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n            mstore(0xa0, m5)\n            mstore(0xc0, m6)\n            mstore(0xe0, m7)\n            mstore(0x100, m8)\n            mstore(0x120, m9)\n            mstore(0x140, m10)\n        }\n    }\n\n    function log(bytes32 p0, bool p1, address p2, address p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        bytes32 m5;\n        bytes32 m6;\n        /// @solidity memory-safe-assembly\n        assembly {\n            function writeString(pos, w) {\n                let length := 0\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\n                mstore(pos, length)\n                let shift := sub(256, shl(3, length))\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\n            }\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            m5 := mload(0xa0)\n            m6 := mload(0xc0)\n            // Selector of `log(string,bool,address,address)`.\n            mstore(0x00, 0x33e9dd1d)\n            mstore(0x20, 0x80)\n            mstore(0x40, p1)\n            mstore(0x60, p2)\n            mstore(0x80, p3)\n            writeString(0xa0, p0)\n        }\n        _sendLogPayload(0x1c, 0xc4);\n        /// @solidity memory-safe-assembly\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n            mstore(0xa0, m5)\n            mstore(0xc0, m6)\n        }\n    }\n\n    function log(bytes32 p0, bool p1, address p2, bool p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        bytes32 m5;\n        bytes32 m6;\n        /// @solidity memory-safe-assembly\n        assembly {\n            function writeString(pos, w) {\n                let length := 0\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\n                mstore(pos, length)\n                let shift := sub(256, shl(3, length))\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\n            }\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            m5 := mload(0xa0)\n            m6 := mload(0xc0)\n            // Selector of `log(string,bool,address,bool)`.\n            mstore(0x00, 0x958c28c6)\n            mstore(0x20, 0x80)\n            mstore(0x40, p1)\n            mstore(0x60, p2)\n            mstore(0x80, p3)\n            writeString(0xa0, p0)\n        }\n        _sendLogPayload(0x1c, 0xc4);\n        /// @solidity memory-safe-assembly\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n            mstore(0xa0, m5)\n            mstore(0xc0, m6)\n        }\n    }\n\n    function log(bytes32 p0, bool p1, address p2, uint256 p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        bytes32 m5;\n        bytes32 m6;\n        /// @solidity memory-safe-assembly\n        assembly {\n            function writeString(pos, w) {\n                let length := 0\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\n                mstore(pos, length)\n                let shift := sub(256, shl(3, length))\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\n            }\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            m5 := mload(0xa0)\n            m6 := mload(0xc0)\n            // Selector of `log(string,bool,address,uint256)`.\n            mstore(0x00, 0x5d08bb05)\n            mstore(0x20, 0x80)\n            mstore(0x40, p1)\n            mstore(0x60, p2)\n            mstore(0x80, p3)\n            writeString(0xa0, p0)\n        }\n        _sendLogPayload(0x1c, 0xc4);\n        /// @solidity memory-safe-assembly\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n            mstore(0xa0, m5)\n            mstore(0xc0, m6)\n        }\n    }\n\n    function log(bytes32 p0, bool p1, address p2, bytes32 p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        bytes32 m5;\n        bytes32 m6;\n        bytes32 m7;\n        bytes32 m8;\n        /// @solidity memory-safe-assembly\n        assembly {\n            function writeString(pos, w) {\n                let length := 0\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\n                mstore(pos, length)\n                let shift := sub(256, shl(3, length))\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\n            }\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            m5 := mload(0xa0)\n            m6 := mload(0xc0)\n            m7 := mload(0xe0)\n            m8 := mload(0x100)\n            // Selector of `log(string,bool,address,string)`.\n            mstore(0x00, 0x2d8e33a4)\n            mstore(0x20, 0x80)\n            mstore(0x40, p1)\n            mstore(0x60, p2)\n            mstore(0x80, 0xc0)\n            writeString(0xa0, p0)\n            writeString(0xe0, p3)\n        }\n        _sendLogPayload(0x1c, 0x104);\n        /// @solidity memory-safe-assembly\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n            mstore(0xa0, m5)\n            mstore(0xc0, m6)\n            mstore(0xe0, m7)\n            mstore(0x100, m8)\n        }\n    }\n\n    function log(bytes32 p0, bool p1, bool p2, address p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        bytes32 m5;\n        bytes32 m6;\n        /// @solidity memory-safe-assembly\n        assembly {\n            function writeString(pos, w) {\n                let length := 0\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\n                mstore(pos, length)\n                let shift := sub(256, shl(3, length))\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\n            }\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            m5 := mload(0xa0)\n            m6 := mload(0xc0)\n            // Selector of `log(string,bool,bool,address)`.\n            mstore(0x00, 0x7190a529)\n            mstore(0x20, 0x80)\n            mstore(0x40, p1)\n            mstore(0x60, p2)\n            mstore(0x80, p3)\n            writeString(0xa0, p0)\n        }\n        _sendLogPayload(0x1c, 0xc4);\n        /// @solidity memory-safe-assembly\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n            mstore(0xa0, m5)\n            mstore(0xc0, m6)\n        }\n    }\n\n    function log(bytes32 p0, bool p1, bool p2, bool p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        bytes32 m5;\n        bytes32 m6;\n        /// @solidity memory-safe-assembly\n        assembly {\n            function writeString(pos, w) {\n                let length := 0\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\n                mstore(pos, length)\n                let shift := sub(256, shl(3, length))\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\n            }\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            m5 := mload(0xa0)\n            m6 := mload(0xc0)\n            // Selector of `log(string,bool,bool,bool)`.\n            mstore(0x00, 0x895af8c5)\n            mstore(0x20, 0x80)\n            mstore(0x40, p1)\n            mstore(0x60, p2)\n            mstore(0x80, p3)\n            writeString(0xa0, p0)\n        }\n        _sendLogPayload(0x1c, 0xc4);\n        /// @solidity memory-safe-assembly\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n            mstore(0xa0, m5)\n            mstore(0xc0, m6)\n        }\n    }\n\n    function log(bytes32 p0, bool p1, bool p2, uint256 p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        bytes32 m5;\n        bytes32 m6;\n        /// @solidity memory-safe-assembly\n        assembly {\n            function writeString(pos, w) {\n                let length := 0\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\n                mstore(pos, length)\n                let shift := sub(256, shl(3, length))\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\n            }\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            m5 := mload(0xa0)\n            m6 := mload(0xc0)\n            // Selector of `log(string,bool,bool,uint256)`.\n            mstore(0x00, 0x8e3f78a9)\n            mstore(0x20, 0x80)\n            mstore(0x40, p1)\n            mstore(0x60, p2)\n            mstore(0x80, p3)\n            writeString(0xa0, p0)\n        }\n        _sendLogPayload(0x1c, 0xc4);\n        /// @solidity memory-safe-assembly\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n            mstore(0xa0, m5)\n            mstore(0xc0, m6)\n        }\n    }\n\n    function log(bytes32 p0, bool p1, bool p2, bytes32 p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        bytes32 m5;\n        bytes32 m6;\n        bytes32 m7;\n        bytes32 m8;\n        /// @solidity memory-safe-assembly\n        assembly {\n            function writeString(pos, w) {\n                let length := 0\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\n                mstore(pos, length)\n                let shift := sub(256, shl(3, length))\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\n            }\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            m5 := mload(0xa0)\n            m6 := mload(0xc0)\n            m7 := mload(0xe0)\n            m8 := mload(0x100)\n            // Selector of `log(string,bool,bool,string)`.\n            mstore(0x00, 0x9d22d5dd)\n            mstore(0x20, 0x80)\n            mstore(0x40, p1)\n            mstore(0x60, p2)\n            mstore(0x80, 0xc0)\n            writeString(0xa0, p0)\n            writeString(0xe0, p3)\n        }\n        _sendLogPayload(0x1c, 0x104);\n        /// @solidity memory-safe-assembly\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n            mstore(0xa0, m5)\n            mstore(0xc0, m6)\n            mstore(0xe0, m7)\n            mstore(0x100, m8)\n        }\n    }\n\n    function log(bytes32 p0, bool p1, uint256 p2, address p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        bytes32 m5;\n        bytes32 m6;\n        /// @solidity memory-safe-assembly\n        assembly {\n            function writeString(pos, w) {\n                let length := 0\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\n                mstore(pos, length)\n                let shift := sub(256, shl(3, length))\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\n            }\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            m5 := mload(0xa0)\n            m6 := mload(0xc0)\n            // Selector of `log(string,bool,uint256,address)`.\n            mstore(0x00, 0x935e09bf)\n            mstore(0x20, 0x80)\n            mstore(0x40, p1)\n            mstore(0x60, p2)\n            mstore(0x80, p3)\n            writeString(0xa0, p0)\n        }\n        _sendLogPayload(0x1c, 0xc4);\n        /// @solidity memory-safe-assembly\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n            mstore(0xa0, m5)\n            mstore(0xc0, m6)\n        }\n    }\n\n    function log(bytes32 p0, bool p1, uint256 p2, bool p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        bytes32 m5;\n        bytes32 m6;\n        /// @solidity memory-safe-assembly\n        assembly {\n            function writeString(pos, w) {\n                let length := 0\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\n                mstore(pos, length)\n                let shift := sub(256, shl(3, length))\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\n            }\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            m5 := mload(0xa0)\n            m6 := mload(0xc0)\n            // Selector of `log(string,bool,uint256,bool)`.\n            mstore(0x00, 0x8af7cf8a)\n            mstore(0x20, 0x80)\n            mstore(0x40, p1)\n            mstore(0x60, p2)\n            mstore(0x80, p3)\n            writeString(0xa0, p0)\n        }\n        _sendLogPayload(0x1c, 0xc4);\n        /// @solidity memory-safe-assembly\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n            mstore(0xa0, m5)\n            mstore(0xc0, m6)\n        }\n    }\n\n    function log(bytes32 p0, bool p1, uint256 p2, uint256 p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        bytes32 m5;\n        bytes32 m6;\n        /// @solidity memory-safe-assembly\n        assembly {\n            function writeString(pos, w) {\n                let length := 0\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\n                mstore(pos, length)\n                let shift := sub(256, shl(3, length))\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\n            }\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            m5 := mload(0xa0)\n            m6 := mload(0xc0)\n            // Selector of `log(string,bool,uint256,uint256)`.\n            mstore(0x00, 0x64b5bb67)\n            mstore(0x20, 0x80)\n            mstore(0x40, p1)\n            mstore(0x60, p2)\n            mstore(0x80, p3)\n            writeString(0xa0, p0)\n        }\n        _sendLogPayload(0x1c, 0xc4);\n        /// @solidity memory-safe-assembly\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n            mstore(0xa0, m5)\n            mstore(0xc0, m6)\n        }\n    }\n\n    function log(bytes32 p0, bool p1, uint256 p2, bytes32 p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        bytes32 m5;\n        bytes32 m6;\n        bytes32 m7;\n        bytes32 m8;\n        /// @solidity memory-safe-assembly\n        assembly {\n            function writeString(pos, w) {\n                let length := 0\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\n                mstore(pos, length)\n                let shift := sub(256, shl(3, length))\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\n            }\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            m5 := mload(0xa0)\n            m6 := mload(0xc0)\n            m7 := mload(0xe0)\n            m8 := mload(0x100)\n            // Selector of `log(string,bool,uint256,string)`.\n            mstore(0x00, 0x742d6ee7)\n            mstore(0x20, 0x80)\n            mstore(0x40, p1)\n            mstore(0x60, p2)\n            mstore(0x80, 0xc0)\n            writeString(0xa0, p0)\n            writeString(0xe0, p3)\n        }\n        _sendLogPayload(0x1c, 0x104);\n        /// @solidity memory-safe-assembly\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n            mstore(0xa0, m5)\n            mstore(0xc0, m6)\n            mstore(0xe0, m7)\n            mstore(0x100, m8)\n        }\n    }\n\n    function log(bytes32 p0, bool p1, bytes32 p2, address p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        bytes32 m5;\n        bytes32 m6;\n        bytes32 m7;\n        bytes32 m8;\n        /// @solidity memory-safe-assembly\n        assembly {\n            function writeString(pos, w) {\n                let length := 0\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\n                mstore(pos, length)\n                let shift := sub(256, shl(3, length))\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\n            }\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            m5 := mload(0xa0)\n            m6 := mload(0xc0)\n            m7 := mload(0xe0)\n            m8 := mload(0x100)\n            // Selector of `log(string,bool,string,address)`.\n            mstore(0x00, 0xe0625b29)\n            mstore(0x20, 0x80)\n            mstore(0x40, p1)\n            mstore(0x60, 0xc0)\n            mstore(0x80, p3)\n            writeString(0xa0, p0)\n            writeString(0xe0, p2)\n        }\n        _sendLogPayload(0x1c, 0x104);\n        /// @solidity memory-safe-assembly\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n            mstore(0xa0, m5)\n            mstore(0xc0, m6)\n            mstore(0xe0, m7)\n            mstore(0x100, m8)\n        }\n    }\n\n    function log(bytes32 p0, bool p1, bytes32 p2, bool p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        bytes32 m5;\n        bytes32 m6;\n        bytes32 m7;\n        bytes32 m8;\n        /// @solidity memory-safe-assembly\n        assembly {\n            function writeString(pos, w) {\n                let length := 0\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\n                mstore(pos, length)\n                let shift := sub(256, shl(3, length))\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\n            }\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            m5 := mload(0xa0)\n            m6 := mload(0xc0)\n            m7 := mload(0xe0)\n            m8 := mload(0x100)\n            // Selector of `log(string,bool,string,bool)`.\n            mstore(0x00, 0x3f8a701d)\n            mstore(0x20, 0x80)\n            mstore(0x40, p1)\n            mstore(0x60, 0xc0)\n            mstore(0x80, p3)\n            writeString(0xa0, p0)\n            writeString(0xe0, p2)\n        }\n        _sendLogPayload(0x1c, 0x104);\n        /// @solidity memory-safe-assembly\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n            mstore(0xa0, m5)\n            mstore(0xc0, m6)\n            mstore(0xe0, m7)\n            mstore(0x100, m8)\n        }\n    }\n\n    function log(bytes32 p0, bool p1, bytes32 p2, uint256 p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        bytes32 m5;\n        bytes32 m6;\n        bytes32 m7;\n        bytes32 m8;\n        /// @solidity memory-safe-assembly\n        assembly {\n            function writeString(pos, w) {\n                let length := 0\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\n                mstore(pos, length)\n                let shift := sub(256, shl(3, length))\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\n            }\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            m5 := mload(0xa0)\n            m6 := mload(0xc0)\n            m7 := mload(0xe0)\n            m8 := mload(0x100)\n            // Selector of `log(string,bool,string,uint256)`.\n            mstore(0x00, 0x24f91465)\n            mstore(0x20, 0x80)\n            mstore(0x40, p1)\n            mstore(0x60, 0xc0)\n            mstore(0x80, p3)\n            writeString(0xa0, p0)\n            writeString(0xe0, p2)\n        }\n        _sendLogPayload(0x1c, 0x104);\n        /// @solidity memory-safe-assembly\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n            mstore(0xa0, m5)\n            mstore(0xc0, m6)\n            mstore(0xe0, m7)\n            mstore(0x100, m8)\n        }\n    }\n\n    function log(bytes32 p0, bool p1, bytes32 p2, bytes32 p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        bytes32 m5;\n        bytes32 m6;\n        bytes32 m7;\n        bytes32 m8;\n        bytes32 m9;\n        bytes32 m10;\n        /// @solidity memory-safe-assembly\n        assembly {\n            function writeString(pos, w) {\n                let length := 0\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\n                mstore(pos, length)\n                let shift := sub(256, shl(3, length))\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\n            }\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            m5 := mload(0xa0)\n            m6 := mload(0xc0)\n            m7 := mload(0xe0)\n            m8 := mload(0x100)\n            m9 := mload(0x120)\n            m10 := mload(0x140)\n            // Selector of `log(string,bool,string,string)`.\n            mstore(0x00, 0xa826caeb)\n            mstore(0x20, 0x80)\n            mstore(0x40, p1)\n            mstore(0x60, 0xc0)\n            mstore(0x80, 0x100)\n            writeString(0xa0, p0)\n            writeString(0xe0, p2)\n            writeString(0x120, p3)\n        }\n        _sendLogPayload(0x1c, 0x144);\n        /// @solidity memory-safe-assembly\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n            mstore(0xa0, m5)\n            mstore(0xc0, m6)\n            mstore(0xe0, m7)\n            mstore(0x100, m8)\n            mstore(0x120, m9)\n            mstore(0x140, m10)\n        }\n    }\n\n    function log(bytes32 p0, uint256 p1, address p2, address p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        bytes32 m5;\n        bytes32 m6;\n        /// @solidity memory-safe-assembly\n        assembly {\n            function writeString(pos, w) {\n                let length := 0\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\n                mstore(pos, length)\n                let shift := sub(256, shl(3, length))\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\n            }\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            m5 := mload(0xa0)\n            m6 := mload(0xc0)\n            // Selector of `log(string,uint256,address,address)`.\n            mstore(0x00, 0x5ea2b7ae)\n            mstore(0x20, 0x80)\n            mstore(0x40, p1)\n            mstore(0x60, p2)\n            mstore(0x80, p3)\n            writeString(0xa0, p0)\n        }\n        _sendLogPayload(0x1c, 0xc4);\n        /// @solidity memory-safe-assembly\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n            mstore(0xa0, m5)\n            mstore(0xc0, m6)\n        }\n    }\n\n    function log(bytes32 p0, uint256 p1, address p2, bool p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        bytes32 m5;\n        bytes32 m6;\n        /// @solidity memory-safe-assembly\n        assembly {\n            function writeString(pos, w) {\n                let length := 0\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\n                mstore(pos, length)\n                let shift := sub(256, shl(3, length))\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\n            }\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            m5 := mload(0xa0)\n            m6 := mload(0xc0)\n            // Selector of `log(string,uint256,address,bool)`.\n            mstore(0x00, 0x82112a42)\n            mstore(0x20, 0x80)\n            mstore(0x40, p1)\n            mstore(0x60, p2)\n            mstore(0x80, p3)\n            writeString(0xa0, p0)\n        }\n        _sendLogPayload(0x1c, 0xc4);\n        /// @solidity memory-safe-assembly\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n            mstore(0xa0, m5)\n            mstore(0xc0, m6)\n        }\n    }\n\n    function log(bytes32 p0, uint256 p1, address p2, uint256 p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        bytes32 m5;\n        bytes32 m6;\n        /// @solidity memory-safe-assembly\n        assembly {\n            function writeString(pos, w) {\n                let length := 0\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\n                mstore(pos, length)\n                let shift := sub(256, shl(3, length))\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\n            }\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            m5 := mload(0xa0)\n            m6 := mload(0xc0)\n            // Selector of `log(string,uint256,address,uint256)`.\n            mstore(0x00, 0x4f04fdc6)\n            mstore(0x20, 0x80)\n            mstore(0x40, p1)\n            mstore(0x60, p2)\n            mstore(0x80, p3)\n            writeString(0xa0, p0)\n        }\n        _sendLogPayload(0x1c, 0xc4);\n        /// @solidity memory-safe-assembly\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n            mstore(0xa0, m5)\n            mstore(0xc0, m6)\n        }\n    }\n\n    function log(bytes32 p0, uint256 p1, address p2, bytes32 p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        bytes32 m5;\n        bytes32 m6;\n        bytes32 m7;\n        bytes32 m8;\n        /// @solidity memory-safe-assembly\n        assembly {\n            function writeString(pos, w) {\n                let length := 0\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\n                mstore(pos, length)\n                let shift := sub(256, shl(3, length))\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\n            }\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            m5 := mload(0xa0)\n            m6 := mload(0xc0)\n            m7 := mload(0xe0)\n            m8 := mload(0x100)\n            // Selector of `log(string,uint256,address,string)`.\n            mstore(0x00, 0x9ffb2f93)\n            mstore(0x20, 0x80)\n            mstore(0x40, p1)\n            mstore(0x60, p2)\n            mstore(0x80, 0xc0)\n            writeString(0xa0, p0)\n            writeString(0xe0, p3)\n        }\n        _sendLogPayload(0x1c, 0x104);\n        /// @solidity memory-safe-assembly\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n            mstore(0xa0, m5)\n            mstore(0xc0, m6)\n            mstore(0xe0, m7)\n            mstore(0x100, m8)\n        }\n    }\n\n    function log(bytes32 p0, uint256 p1, bool p2, address p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        bytes32 m5;\n        bytes32 m6;\n        /// @solidity memory-safe-assembly\n        assembly {\n            function writeString(pos, w) {\n                let length := 0\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\n                mstore(pos, length)\n                let shift := sub(256, shl(3, length))\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\n            }\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            m5 := mload(0xa0)\n            m6 := mload(0xc0)\n            // Selector of `log(string,uint256,bool,address)`.\n            mstore(0x00, 0xe0e95b98)\n            mstore(0x20, 0x80)\n            mstore(0x40, p1)\n            mstore(0x60, p2)\n            mstore(0x80, p3)\n            writeString(0xa0, p0)\n        }\n        _sendLogPayload(0x1c, 0xc4);\n        /// @solidity memory-safe-assembly\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n            mstore(0xa0, m5)\n            mstore(0xc0, m6)\n        }\n    }\n\n    function log(bytes32 p0, uint256 p1, bool p2, bool p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        bytes32 m5;\n        bytes32 m6;\n        /// @solidity memory-safe-assembly\n        assembly {\n            function writeString(pos, w) {\n                let length := 0\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\n                mstore(pos, length)\n                let shift := sub(256, shl(3, length))\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\n            }\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            m5 := mload(0xa0)\n            m6 := mload(0xc0)\n            // Selector of `log(string,uint256,bool,bool)`.\n            mstore(0x00, 0x354c36d6)\n            mstore(0x20, 0x80)\n            mstore(0x40, p1)\n            mstore(0x60, p2)\n            mstore(0x80, p3)\n            writeString(0xa0, p0)\n        }\n        _sendLogPayload(0x1c, 0xc4);\n        /// @solidity memory-safe-assembly\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n            mstore(0xa0, m5)\n            mstore(0xc0, m6)\n        }\n    }\n\n    function log(bytes32 p0, uint256 p1, bool p2, uint256 p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        bytes32 m5;\n        bytes32 m6;\n        /// @solidity memory-safe-assembly\n        assembly {\n            function writeString(pos, w) {\n                let length := 0\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\n                mstore(pos, length)\n                let shift := sub(256, shl(3, length))\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\n            }\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            m5 := mload(0xa0)\n            m6 := mload(0xc0)\n            // Selector of `log(string,uint256,bool,uint256)`.\n            mstore(0x00, 0xe41b6f6f)\n            mstore(0x20, 0x80)\n            mstore(0x40, p1)\n            mstore(0x60, p2)\n            mstore(0x80, p3)\n            writeString(0xa0, p0)\n        }\n        _sendLogPayload(0x1c, 0xc4);\n        /// @solidity memory-safe-assembly\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n            mstore(0xa0, m5)\n            mstore(0xc0, m6)\n        }\n    }\n\n    function log(bytes32 p0, uint256 p1, bool p2, bytes32 p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        bytes32 m5;\n        bytes32 m6;\n        bytes32 m7;\n        bytes32 m8;\n        /// @solidity memory-safe-assembly\n        assembly {\n            function writeString(pos, w) {\n                let length := 0\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\n                mstore(pos, length)\n                let shift := sub(256, shl(3, length))\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\n            }\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            m5 := mload(0xa0)\n            m6 := mload(0xc0)\n            m7 := mload(0xe0)\n            m8 := mload(0x100)\n            // Selector of `log(string,uint256,bool,string)`.\n            mstore(0x00, 0xabf73a98)\n            mstore(0x20, 0x80)\n            mstore(0x40, p1)\n            mstore(0x60, p2)\n            mstore(0x80, 0xc0)\n            writeString(0xa0, p0)\n            writeString(0xe0, p3)\n        }\n        _sendLogPayload(0x1c, 0x104);\n        /// @solidity memory-safe-assembly\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n            mstore(0xa0, m5)\n            mstore(0xc0, m6)\n            mstore(0xe0, m7)\n            mstore(0x100, m8)\n        }\n    }\n\n    function log(bytes32 p0, uint256 p1, uint256 p2, address p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        bytes32 m5;\n        bytes32 m6;\n        /// @solidity memory-safe-assembly\n        assembly {\n            function writeString(pos, w) {\n                let length := 0\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\n                mstore(pos, length)\n                let shift := sub(256, shl(3, length))\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\n            }\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            m5 := mload(0xa0)\n            m6 := mload(0xc0)\n            // Selector of `log(string,uint256,uint256,address)`.\n            mstore(0x00, 0xe21de278)\n            mstore(0x20, 0x80)\n            mstore(0x40, p1)\n            mstore(0x60, p2)\n            mstore(0x80, p3)\n            writeString(0xa0, p0)\n        }\n        _sendLogPayload(0x1c, 0xc4);\n        /// @solidity memory-safe-assembly\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n            mstore(0xa0, m5)\n            mstore(0xc0, m6)\n        }\n    }\n\n    function log(bytes32 p0, uint256 p1, uint256 p2, bool p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        bytes32 m5;\n        bytes32 m6;\n        /// @solidity memory-safe-assembly\n        assembly {\n            function writeString(pos, w) {\n                let length := 0\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\n                mstore(pos, length)\n                let shift := sub(256, shl(3, length))\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\n            }\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            m5 := mload(0xa0)\n            m6 := mload(0xc0)\n            // Selector of `log(string,uint256,uint256,bool)`.\n            mstore(0x00, 0x7626db92)\n            mstore(0x20, 0x80)\n            mstore(0x40, p1)\n            mstore(0x60, p2)\n            mstore(0x80, p3)\n            writeString(0xa0, p0)\n        }\n        _sendLogPayload(0x1c, 0xc4);\n        /// @solidity memory-safe-assembly\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n            mstore(0xa0, m5)\n            mstore(0xc0, m6)\n        }\n    }\n\n    function log(bytes32 p0, uint256 p1, uint256 p2, uint256 p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        bytes32 m5;\n        bytes32 m6;\n        /// @solidity memory-safe-assembly\n        assembly {\n            function writeString(pos, w) {\n                let length := 0\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\n                mstore(pos, length)\n                let shift := sub(256, shl(3, length))\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\n            }\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            m5 := mload(0xa0)\n            m6 := mload(0xc0)\n            // Selector of `log(string,uint256,uint256,uint256)`.\n            mstore(0x00, 0xa7a87853)\n            mstore(0x20, 0x80)\n            mstore(0x40, p1)\n            mstore(0x60, p2)\n            mstore(0x80, p3)\n            writeString(0xa0, p0)\n        }\n        _sendLogPayload(0x1c, 0xc4);\n        /// @solidity memory-safe-assembly\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n            mstore(0xa0, m5)\n            mstore(0xc0, m6)\n        }\n    }\n\n    function log(bytes32 p0, uint256 p1, uint256 p2, bytes32 p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        bytes32 m5;\n        bytes32 m6;\n        bytes32 m7;\n        bytes32 m8;\n        /// @solidity memory-safe-assembly\n        assembly {\n            function writeString(pos, w) {\n                let length := 0\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\n                mstore(pos, length)\n                let shift := sub(256, shl(3, length))\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\n            }\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            m5 := mload(0xa0)\n            m6 := mload(0xc0)\n            m7 := mload(0xe0)\n            m8 := mload(0x100)\n            // Selector of `log(string,uint256,uint256,string)`.\n            mstore(0x00, 0x854b3496)\n            mstore(0x20, 0x80)\n            mstore(0x40, p1)\n            mstore(0x60, p2)\n            mstore(0x80, 0xc0)\n            writeString(0xa0, p0)\n            writeString(0xe0, p3)\n        }\n        _sendLogPayload(0x1c, 0x104);\n        /// @solidity memory-safe-assembly\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n            mstore(0xa0, m5)\n            mstore(0xc0, m6)\n            mstore(0xe0, m7)\n            mstore(0x100, m8)\n        }\n    }\n\n    function log(bytes32 p0, uint256 p1, bytes32 p2, address p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        bytes32 m5;\n        bytes32 m6;\n        bytes32 m7;\n        bytes32 m8;\n        /// @solidity memory-safe-assembly\n        assembly {\n            function writeString(pos, w) {\n                let length := 0\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\n                mstore(pos, length)\n                let shift := sub(256, shl(3, length))\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\n            }\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            m5 := mload(0xa0)\n            m6 := mload(0xc0)\n            m7 := mload(0xe0)\n            m8 := mload(0x100)\n            // Selector of `log(string,uint256,string,address)`.\n            mstore(0x00, 0x7c4632a4)\n            mstore(0x20, 0x80)\n            mstore(0x40, p1)\n            mstore(0x60, 0xc0)\n            mstore(0x80, p3)\n            writeString(0xa0, p0)\n            writeString(0xe0, p2)\n        }\n        _sendLogPayload(0x1c, 0x104);\n        /// @solidity memory-safe-assembly\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n            mstore(0xa0, m5)\n            mstore(0xc0, m6)\n            mstore(0xe0, m7)\n            mstore(0x100, m8)\n        }\n    }\n\n    function log(bytes32 p0, uint256 p1, bytes32 p2, bool p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        bytes32 m5;\n        bytes32 m6;\n        bytes32 m7;\n        bytes32 m8;\n        /// @solidity memory-safe-assembly\n        assembly {\n            function writeString(pos, w) {\n                let length := 0\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\n                mstore(pos, length)\n                let shift := sub(256, shl(3, length))\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\n            }\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            m5 := mload(0xa0)\n            m6 := mload(0xc0)\n            m7 := mload(0xe0)\n            m8 := mload(0x100)\n            // Selector of `log(string,uint256,string,bool)`.\n            mstore(0x00, 0x7d24491d)\n            mstore(0x20, 0x80)\n            mstore(0x40, p1)\n            mstore(0x60, 0xc0)\n            mstore(0x80, p3)\n            writeString(0xa0, p0)\n            writeString(0xe0, p2)\n        }\n        _sendLogPayload(0x1c, 0x104);\n        /// @solidity memory-safe-assembly\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n            mstore(0xa0, m5)\n            mstore(0xc0, m6)\n            mstore(0xe0, m7)\n            mstore(0x100, m8)\n        }\n    }\n\n    function log(bytes32 p0, uint256 p1, bytes32 p2, uint256 p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        bytes32 m5;\n        bytes32 m6;\n        bytes32 m7;\n        bytes32 m8;\n        /// @solidity memory-safe-assembly\n        assembly {\n            function writeString(pos, w) {\n                let length := 0\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\n                mstore(pos, length)\n                let shift := sub(256, shl(3, length))\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\n            }\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            m5 := mload(0xa0)\n            m6 := mload(0xc0)\n            m7 := mload(0xe0)\n            m8 := mload(0x100)\n            // Selector of `log(string,uint256,string,uint256)`.\n            mstore(0x00, 0xc67ea9d1)\n            mstore(0x20, 0x80)\n            mstore(0x40, p1)\n            mstore(0x60, 0xc0)\n            mstore(0x80, p3)\n            writeString(0xa0, p0)\n            writeString(0xe0, p2)\n        }\n        _sendLogPayload(0x1c, 0x104);\n        /// @solidity memory-safe-assembly\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n            mstore(0xa0, m5)\n            mstore(0xc0, m6)\n            mstore(0xe0, m7)\n            mstore(0x100, m8)\n        }\n    }\n\n    function log(bytes32 p0, uint256 p1, bytes32 p2, bytes32 p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        bytes32 m5;\n        bytes32 m6;\n        bytes32 m7;\n        bytes32 m8;\n        bytes32 m9;\n        bytes32 m10;\n        /// @solidity memory-safe-assembly\n        assembly {\n            function writeString(pos, w) {\n                let length := 0\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\n                mstore(pos, length)\n                let shift := sub(256, shl(3, length))\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\n            }\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            m5 := mload(0xa0)\n            m6 := mload(0xc0)\n            m7 := mload(0xe0)\n            m8 := mload(0x100)\n            m9 := mload(0x120)\n            m10 := mload(0x140)\n            // Selector of `log(string,uint256,string,string)`.\n            mstore(0x00, 0x5ab84e1f)\n            mstore(0x20, 0x80)\n            mstore(0x40, p1)\n            mstore(0x60, 0xc0)\n            mstore(0x80, 0x100)\n            writeString(0xa0, p0)\n            writeString(0xe0, p2)\n            writeString(0x120, p3)\n        }\n        _sendLogPayload(0x1c, 0x144);\n        /// @solidity memory-safe-assembly\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n            mstore(0xa0, m5)\n            mstore(0xc0, m6)\n            mstore(0xe0, m7)\n            mstore(0x100, m8)\n            mstore(0x120, m9)\n            mstore(0x140, m10)\n        }\n    }\n\n    function log(bytes32 p0, bytes32 p1, address p2, address p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        bytes32 m5;\n        bytes32 m6;\n        bytes32 m7;\n        bytes32 m8;\n        /// @solidity memory-safe-assembly\n        assembly {\n            function writeString(pos, w) {\n                let length := 0\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\n                mstore(pos, length)\n                let shift := sub(256, shl(3, length))\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\n            }\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            m5 := mload(0xa0)\n            m6 := mload(0xc0)\n            m7 := mload(0xe0)\n            m8 := mload(0x100)\n            // Selector of `log(string,string,address,address)`.\n            mstore(0x00, 0x439c7bef)\n            mstore(0x20, 0x80)\n            mstore(0x40, 0xc0)\n            mstore(0x60, p2)\n            mstore(0x80, p3)\n            writeString(0xa0, p0)\n            writeString(0xe0, p1)\n        }\n        _sendLogPayload(0x1c, 0x104);\n        /// @solidity memory-safe-assembly\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n            mstore(0xa0, m5)\n            mstore(0xc0, m6)\n            mstore(0xe0, m7)\n            mstore(0x100, m8)\n        }\n    }\n\n    function log(bytes32 p0, bytes32 p1, address p2, bool p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        bytes32 m5;\n        bytes32 m6;\n        bytes32 m7;\n        bytes32 m8;\n        /// @solidity memory-safe-assembly\n        assembly {\n            function writeString(pos, w) {\n                let length := 0\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\n                mstore(pos, length)\n                let shift := sub(256, shl(3, length))\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\n            }\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            m5 := mload(0xa0)\n            m6 := mload(0xc0)\n            m7 := mload(0xe0)\n            m8 := mload(0x100)\n            // Selector of `log(string,string,address,bool)`.\n            mstore(0x00, 0x5ccd4e37)\n            mstore(0x20, 0x80)\n            mstore(0x40, 0xc0)\n            mstore(0x60, p2)\n            mstore(0x80, p3)\n            writeString(0xa0, p0)\n            writeString(0xe0, p1)\n        }\n        _sendLogPayload(0x1c, 0x104);\n        /// @solidity memory-safe-assembly\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n            mstore(0xa0, m5)\n            mstore(0xc0, m6)\n            mstore(0xe0, m7)\n            mstore(0x100, m8)\n        }\n    }\n\n    function log(bytes32 p0, bytes32 p1, address p2, uint256 p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        bytes32 m5;\n        bytes32 m6;\n        bytes32 m7;\n        bytes32 m8;\n        /// @solidity memory-safe-assembly\n        assembly {\n            function writeString(pos, w) {\n                let length := 0\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\n                mstore(pos, length)\n                let shift := sub(256, shl(3, length))\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\n            }\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            m5 := mload(0xa0)\n            m6 := mload(0xc0)\n            m7 := mload(0xe0)\n            m8 := mload(0x100)\n            // Selector of `log(string,string,address,uint256)`.\n            mstore(0x00, 0x7cc3c607)\n            mstore(0x20, 0x80)\n            mstore(0x40, 0xc0)\n            mstore(0x60, p2)\n            mstore(0x80, p3)\n            writeString(0xa0, p0)\n            writeString(0xe0, p1)\n        }\n        _sendLogPayload(0x1c, 0x104);\n        /// @solidity memory-safe-assembly\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n            mstore(0xa0, m5)\n            mstore(0xc0, m6)\n            mstore(0xe0, m7)\n            mstore(0x100, m8)\n        }\n    }\n\n    function log(bytes32 p0, bytes32 p1, address p2, bytes32 p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        bytes32 m5;\n        bytes32 m6;\n        bytes32 m7;\n        bytes32 m8;\n        bytes32 m9;\n        bytes32 m10;\n        /// @solidity memory-safe-assembly\n        assembly {\n            function writeString(pos, w) {\n                let length := 0\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\n                mstore(pos, length)\n                let shift := sub(256, shl(3, length))\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\n            }\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            m5 := mload(0xa0)\n            m6 := mload(0xc0)\n            m7 := mload(0xe0)\n            m8 := mload(0x100)\n            m9 := mload(0x120)\n            m10 := mload(0x140)\n            // Selector of `log(string,string,address,string)`.\n            mstore(0x00, 0xeb1bff80)\n            mstore(0x20, 0x80)\n            mstore(0x40, 0xc0)\n            mstore(0x60, p2)\n            mstore(0x80, 0x100)\n            writeString(0xa0, p0)\n            writeString(0xe0, p1)\n            writeString(0x120, p3)\n        }\n        _sendLogPayload(0x1c, 0x144);\n        /// @solidity memory-safe-assembly\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n            mstore(0xa0, m5)\n            mstore(0xc0, m6)\n            mstore(0xe0, m7)\n            mstore(0x100, m8)\n            mstore(0x120, m9)\n            mstore(0x140, m10)\n        }\n    }\n\n    function log(bytes32 p0, bytes32 p1, bool p2, address p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        bytes32 m5;\n        bytes32 m6;\n        bytes32 m7;\n        bytes32 m8;\n        /// @solidity memory-safe-assembly\n        assembly {\n            function writeString(pos, w) {\n                let length := 0\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\n                mstore(pos, length)\n                let shift := sub(256, shl(3, length))\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\n            }\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            m5 := mload(0xa0)\n            m6 := mload(0xc0)\n            m7 := mload(0xe0)\n            m8 := mload(0x100)\n            // Selector of `log(string,string,bool,address)`.\n            mstore(0x00, 0xc371c7db)\n            mstore(0x20, 0x80)\n            mstore(0x40, 0xc0)\n            mstore(0x60, p2)\n            mstore(0x80, p3)\n            writeString(0xa0, p0)\n            writeString(0xe0, p1)\n        }\n        _sendLogPayload(0x1c, 0x104);\n        /// @solidity memory-safe-assembly\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n            mstore(0xa0, m5)\n            mstore(0xc0, m6)\n            mstore(0xe0, m7)\n            mstore(0x100, m8)\n        }\n    }\n\n    function log(bytes32 p0, bytes32 p1, bool p2, bool p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        bytes32 m5;\n        bytes32 m6;\n        bytes32 m7;\n        bytes32 m8;\n        /// @solidity memory-safe-assembly\n        assembly {\n            function writeString(pos, w) {\n                let length := 0\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\n                mstore(pos, length)\n                let shift := sub(256, shl(3, length))\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\n            }\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            m5 := mload(0xa0)\n            m6 := mload(0xc0)\n            m7 := mload(0xe0)\n            m8 := mload(0x100)\n            // Selector of `log(string,string,bool,bool)`.\n            mstore(0x00, 0x40785869)\n            mstore(0x20, 0x80)\n            mstore(0x40, 0xc0)\n            mstore(0x60, p2)\n            mstore(0x80, p3)\n            writeString(0xa0, p0)\n            writeString(0xe0, p1)\n        }\n        _sendLogPayload(0x1c, 0x104);\n        /// @solidity memory-safe-assembly\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n            mstore(0xa0, m5)\n            mstore(0xc0, m6)\n            mstore(0xe0, m7)\n            mstore(0x100, m8)\n        }\n    }\n\n    function log(bytes32 p0, bytes32 p1, bool p2, uint256 p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        bytes32 m5;\n        bytes32 m6;\n        bytes32 m7;\n        bytes32 m8;\n        /// @solidity memory-safe-assembly\n        assembly {\n            function writeString(pos, w) {\n                let length := 0\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\n                mstore(pos, length)\n                let shift := sub(256, shl(3, length))\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\n            }\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            m5 := mload(0xa0)\n            m6 := mload(0xc0)\n            m7 := mload(0xe0)\n            m8 := mload(0x100)\n            // Selector of `log(string,string,bool,uint256)`.\n            mstore(0x00, 0xd6aefad2)\n            mstore(0x20, 0x80)\n            mstore(0x40, 0xc0)\n            mstore(0x60, p2)\n            mstore(0x80, p3)\n            writeString(0xa0, p0)\n            writeString(0xe0, p1)\n        }\n        _sendLogPayload(0x1c, 0x104);\n        /// @solidity memory-safe-assembly\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n            mstore(0xa0, m5)\n            mstore(0xc0, m6)\n            mstore(0xe0, m7)\n            mstore(0x100, m8)\n        }\n    }\n\n    function log(bytes32 p0, bytes32 p1, bool p2, bytes32 p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        bytes32 m5;\n        bytes32 m6;\n        bytes32 m7;\n        bytes32 m8;\n        bytes32 m9;\n        bytes32 m10;\n        /// @solidity memory-safe-assembly\n        assembly {\n            function writeString(pos, w) {\n                let length := 0\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\n                mstore(pos, length)\n                let shift := sub(256, shl(3, length))\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\n            }\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            m5 := mload(0xa0)\n            m6 := mload(0xc0)\n            m7 := mload(0xe0)\n            m8 := mload(0x100)\n            m9 := mload(0x120)\n            m10 := mload(0x140)\n            // Selector of `log(string,string,bool,string)`.\n            mstore(0x00, 0x5e84b0ea)\n            mstore(0x20, 0x80)\n            mstore(0x40, 0xc0)\n            mstore(0x60, p2)\n            mstore(0x80, 0x100)\n            writeString(0xa0, p0)\n            writeString(0xe0, p1)\n            writeString(0x120, p3)\n        }\n        _sendLogPayload(0x1c, 0x144);\n        /// @solidity memory-safe-assembly\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n            mstore(0xa0, m5)\n            mstore(0xc0, m6)\n            mstore(0xe0, m7)\n            mstore(0x100, m8)\n            mstore(0x120, m9)\n            mstore(0x140, m10)\n        }\n    }\n\n    function log(bytes32 p0, bytes32 p1, uint256 p2, address p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        bytes32 m5;\n        bytes32 m6;\n        bytes32 m7;\n        bytes32 m8;\n        /// @solidity memory-safe-assembly\n        assembly {\n            function writeString(pos, w) {\n                let length := 0\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\n                mstore(pos, length)\n                let shift := sub(256, shl(3, length))\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\n            }\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            m5 := mload(0xa0)\n            m6 := mload(0xc0)\n            m7 := mload(0xe0)\n            m8 := mload(0x100)\n            // Selector of `log(string,string,uint256,address)`.\n            mstore(0x00, 0x1023f7b2)\n            mstore(0x20, 0x80)\n            mstore(0x40, 0xc0)\n            mstore(0x60, p2)\n            mstore(0x80, p3)\n            writeString(0xa0, p0)\n            writeString(0xe0, p1)\n        }\n        _sendLogPayload(0x1c, 0x104);\n        /// @solidity memory-safe-assembly\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n            mstore(0xa0, m5)\n            mstore(0xc0, m6)\n            mstore(0xe0, m7)\n            mstore(0x100, m8)\n        }\n    }\n\n    function log(bytes32 p0, bytes32 p1, uint256 p2, bool p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        bytes32 m5;\n        bytes32 m6;\n        bytes32 m7;\n        bytes32 m8;\n        /// @solidity memory-safe-assembly\n        assembly {\n            function writeString(pos, w) {\n                let length := 0\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\n                mstore(pos, length)\n                let shift := sub(256, shl(3, length))\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\n            }\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            m5 := mload(0xa0)\n            m6 := mload(0xc0)\n            m7 := mload(0xe0)\n            m8 := mload(0x100)\n            // Selector of `log(string,string,uint256,bool)`.\n            mstore(0x00, 0xc3a8a654)\n            mstore(0x20, 0x80)\n            mstore(0x40, 0xc0)\n            mstore(0x60, p2)\n            mstore(0x80, p3)\n            writeString(0xa0, p0)\n            writeString(0xe0, p1)\n        }\n        _sendLogPayload(0x1c, 0x104);\n        /// @solidity memory-safe-assembly\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n            mstore(0xa0, m5)\n            mstore(0xc0, m6)\n            mstore(0xe0, m7)\n            mstore(0x100, m8)\n        }\n    }\n\n    function log(bytes32 p0, bytes32 p1, uint256 p2, uint256 p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        bytes32 m5;\n        bytes32 m6;\n        bytes32 m7;\n        bytes32 m8;\n        /// @solidity memory-safe-assembly\n        assembly {\n            function writeString(pos, w) {\n                let length := 0\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\n                mstore(pos, length)\n                let shift := sub(256, shl(3, length))\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\n            }\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            m5 := mload(0xa0)\n            m6 := mload(0xc0)\n            m7 := mload(0xe0)\n            m8 := mload(0x100)\n            // Selector of `log(string,string,uint256,uint256)`.\n            mstore(0x00, 0xf45d7d2c)\n            mstore(0x20, 0x80)\n            mstore(0x40, 0xc0)\n            mstore(0x60, p2)\n            mstore(0x80, p3)\n            writeString(0xa0, p0)\n            writeString(0xe0, p1)\n        }\n        _sendLogPayload(0x1c, 0x104);\n        /// @solidity memory-safe-assembly\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n            mstore(0xa0, m5)\n            mstore(0xc0, m6)\n            mstore(0xe0, m7)\n            mstore(0x100, m8)\n        }\n    }\n\n    function log(bytes32 p0, bytes32 p1, uint256 p2, bytes32 p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        bytes32 m5;\n        bytes32 m6;\n        bytes32 m7;\n        bytes32 m8;\n        bytes32 m9;\n        bytes32 m10;\n        /// @solidity memory-safe-assembly\n        assembly {\n            function writeString(pos, w) {\n                let length := 0\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\n                mstore(pos, length)\n                let shift := sub(256, shl(3, length))\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\n            }\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            m5 := mload(0xa0)\n            m6 := mload(0xc0)\n            m7 := mload(0xe0)\n            m8 := mload(0x100)\n            m9 := mload(0x120)\n            m10 := mload(0x140)\n            // Selector of `log(string,string,uint256,string)`.\n            mstore(0x00, 0x5d1a971a)\n            mstore(0x20, 0x80)\n            mstore(0x40, 0xc0)\n            mstore(0x60, p2)\n            mstore(0x80, 0x100)\n            writeString(0xa0, p0)\n            writeString(0xe0, p1)\n            writeString(0x120, p3)\n        }\n        _sendLogPayload(0x1c, 0x144);\n        /// @solidity memory-safe-assembly\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n            mstore(0xa0, m5)\n            mstore(0xc0, m6)\n            mstore(0xe0, m7)\n            mstore(0x100, m8)\n            mstore(0x120, m9)\n            mstore(0x140, m10)\n        }\n    }\n\n    function log(bytes32 p0, bytes32 p1, bytes32 p2, address p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        bytes32 m5;\n        bytes32 m6;\n        bytes32 m7;\n        bytes32 m8;\n        bytes32 m9;\n        bytes32 m10;\n        /// @solidity memory-safe-assembly\n        assembly {\n            function writeString(pos, w) {\n                let length := 0\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\n                mstore(pos, length)\n                let shift := sub(256, shl(3, length))\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\n            }\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            m5 := mload(0xa0)\n            m6 := mload(0xc0)\n            m7 := mload(0xe0)\n            m8 := mload(0x100)\n            m9 := mload(0x120)\n            m10 := mload(0x140)\n            // Selector of `log(string,string,string,address)`.\n            mstore(0x00, 0x6d572f44)\n            mstore(0x20, 0x80)\n            mstore(0x40, 0xc0)\n            mstore(0x60, 0x100)\n            mstore(0x80, p3)\n            writeString(0xa0, p0)\n            writeString(0xe0, p1)\n            writeString(0x120, p2)\n        }\n        _sendLogPayload(0x1c, 0x144);\n        /// @solidity memory-safe-assembly\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n            mstore(0xa0, m5)\n            mstore(0xc0, m6)\n            mstore(0xe0, m7)\n            mstore(0x100, m8)\n            mstore(0x120, m9)\n            mstore(0x140, m10)\n        }\n    }\n\n    function log(bytes32 p0, bytes32 p1, bytes32 p2, bool p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        bytes32 m5;\n        bytes32 m6;\n        bytes32 m7;\n        bytes32 m8;\n        bytes32 m9;\n        bytes32 m10;\n        /// @solidity memory-safe-assembly\n        assembly {\n            function writeString(pos, w) {\n                let length := 0\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\n                mstore(pos, length)\n                let shift := sub(256, shl(3, length))\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\n            }\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            m5 := mload(0xa0)\n            m6 := mload(0xc0)\n            m7 := mload(0xe0)\n            m8 := mload(0x100)\n            m9 := mload(0x120)\n            m10 := mload(0x140)\n            // Selector of `log(string,string,string,bool)`.\n            mstore(0x00, 0x2c1754ed)\n            mstore(0x20, 0x80)\n            mstore(0x40, 0xc0)\n            mstore(0x60, 0x100)\n            mstore(0x80, p3)\n            writeString(0xa0, p0)\n            writeString(0xe0, p1)\n            writeString(0x120, p2)\n        }\n        _sendLogPayload(0x1c, 0x144);\n        /// @solidity memory-safe-assembly\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n            mstore(0xa0, m5)\n            mstore(0xc0, m6)\n            mstore(0xe0, m7)\n            mstore(0x100, m8)\n            mstore(0x120, m9)\n            mstore(0x140, m10)\n        }\n    }\n\n    function log(bytes32 p0, bytes32 p1, bytes32 p2, uint256 p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        bytes32 m5;\n        bytes32 m6;\n        bytes32 m7;\n        bytes32 m8;\n        bytes32 m9;\n        bytes32 m10;\n        /// @solidity memory-safe-assembly\n        assembly {\n            function writeString(pos, w) {\n                let length := 0\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\n                mstore(pos, length)\n                let shift := sub(256, shl(3, length))\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\n            }\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            m5 := mload(0xa0)\n            m6 := mload(0xc0)\n            m7 := mload(0xe0)\n            m8 := mload(0x100)\n            m9 := mload(0x120)\n            m10 := mload(0x140)\n            // Selector of `log(string,string,string,uint256)`.\n            mstore(0x00, 0x8eafb02b)\n            mstore(0x20, 0x80)\n            mstore(0x40, 0xc0)\n            mstore(0x60, 0x100)\n            mstore(0x80, p3)\n            writeString(0xa0, p0)\n            writeString(0xe0, p1)\n            writeString(0x120, p2)\n        }\n        _sendLogPayload(0x1c, 0x144);\n        /// @solidity memory-safe-assembly\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n            mstore(0xa0, m5)\n            mstore(0xc0, m6)\n            mstore(0xe0, m7)\n            mstore(0x100, m8)\n            mstore(0x120, m9)\n            mstore(0x140, m10)\n        }\n    }\n\n    function log(bytes32 p0, bytes32 p1, bytes32 p2, bytes32 p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        bytes32 m5;\n        bytes32 m6;\n        bytes32 m7;\n        bytes32 m8;\n        bytes32 m9;\n        bytes32 m10;\n        bytes32 m11;\n        bytes32 m12;\n        /// @solidity memory-safe-assembly\n        assembly {\n            function writeString(pos, w) {\n                let length := 0\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\n                mstore(pos, length)\n                let shift := sub(256, shl(3, length))\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\n            }\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            m5 := mload(0xa0)\n            m6 := mload(0xc0)\n            m7 := mload(0xe0)\n            m8 := mload(0x100)\n            m9 := mload(0x120)\n            m10 := mload(0x140)\n            m11 := mload(0x160)\n            m12 := mload(0x180)\n            // Selector of `log(string,string,string,string)`.\n            mstore(0x00, 0xde68f20a)\n            mstore(0x20, 0x80)\n            mstore(0x40, 0xc0)\n            mstore(0x60, 0x100)\n            mstore(0x80, 0x140)\n            writeString(0xa0, p0)\n            writeString(0xe0, p1)\n            writeString(0x120, p2)\n            writeString(0x160, p3)\n        }\n        _sendLogPayload(0x1c, 0x184);\n        /// @solidity memory-safe-assembly\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n            mstore(0xa0, m5)\n            mstore(0xc0, m6)\n            mstore(0xe0, m7)\n            mstore(0x100, m8)\n            mstore(0x120, m9)\n            mstore(0x140, m10)\n            mstore(0x160, m11)\n            mstore(0x180, m12)\n        }\n    }\n}\n"},"lib/openzeppelin-contracts/contracts/access/AccessControl.sol":{"content":"// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (access/AccessControl.sol)\n\npragma solidity ^0.8.20;\n\nimport {IAccessControl} from \"./IAccessControl.sol\";\nimport {Context} from \"../utils/Context.sol\";\nimport {ERC165} from \"../utils/introspection/ERC165.sol\";\n\n/**\n * @dev Contract module that allows children to implement role-based access\n * control mechanisms. This is a lightweight version that doesn't allow enumerating role\n * members except through off-chain means by accessing the contract event logs. Some\n * applications may benefit from on-chain enumerability, for those cases see\n * {AccessControlEnumerable}.\n *\n * Roles are referred to by their `bytes32` identifier. These should be exposed\n * in the external API and be unique. The best way to achieve this is by\n * using `public constant` hash digests:\n *\n * ```solidity\n * bytes32 public constant MY_ROLE = keccak256(\"MY_ROLE\");\n * ```\n *\n * Roles can be used to represent a set of permissions. To restrict access to a\n * function call, use {hasRole}:\n *\n * ```solidity\n * function foo() public {\n *     require(hasRole(MY_ROLE, msg.sender));\n *     ...\n * }\n * ```\n *\n * Roles can be granted and revoked dynamically via the {grantRole} and\n * {revokeRole} functions. Each role has an associated admin role, and only\n * accounts that have a role's admin role can call {grantRole} and {revokeRole}.\n *\n * By default, the admin role for all roles is `DEFAULT_ADMIN_ROLE`, which means\n * that only accounts with this role will be able to grant or revoke other\n * roles. More complex role relationships can be created by using\n * {_setRoleAdmin}.\n *\n * WARNING: The `DEFAULT_ADMIN_ROLE` is also its own admin: it has permission to\n * grant and revoke this role. Extra precautions should be taken to secure\n * accounts that have been granted it. We recommend using {AccessControlDefaultAdminRules}\n * to enforce additional security measures for this role.\n */\nabstract contract AccessControl is Context, IAccessControl, ERC165 {\n    struct RoleData {\n        mapping(address account => bool) hasRole;\n        bytes32 adminRole;\n    }\n\n    mapping(bytes32 role => RoleData) private _roles;\n\n    bytes32 public constant DEFAULT_ADMIN_ROLE = 0x00;\n\n    /**\n     * @dev Modifier that checks that an account has a specific role. Reverts\n     * with an {AccessControlUnauthorizedAccount} error including the required role.\n     */\n    modifier onlyRole(bytes32 role) {\n        _checkRole(role);\n        _;\n    }\n\n    /**\n     * @dev See {IERC165-supportsInterface}.\n     */\n    function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n        return interfaceId == type(IAccessControl).interfaceId || super.supportsInterface(interfaceId);\n    }\n\n    /**\n     * @dev Returns `true` if `account` has been granted `role`.\n     */\n    function hasRole(bytes32 role, address account) public view virtual returns (bool) {\n        return _roles[role].hasRole[account];\n    }\n\n    /**\n     * @dev Reverts with an {AccessControlUnauthorizedAccount} error if `_msgSender()`\n     * is missing `role`. Overriding this function changes the behavior of the {onlyRole} modifier.\n     */\n    function _checkRole(bytes32 role) internal view virtual {\n        _checkRole(role, _msgSender());\n    }\n\n    /**\n     * @dev Reverts with an {AccessControlUnauthorizedAccount} error if `account`\n     * is missing `role`.\n     */\n    function _checkRole(bytes32 role, address account) internal view virtual {\n        if (!hasRole(role, account)) {\n            revert AccessControlUnauthorizedAccount(account, role);\n        }\n    }\n\n    /**\n     * @dev Returns the admin role that controls `role`. See {grantRole} and\n     * {revokeRole}.\n     *\n     * To change a role's admin, use {_setRoleAdmin}.\n     */\n    function getRoleAdmin(bytes32 role) public view virtual returns (bytes32) {\n        return _roles[role].adminRole;\n    }\n\n    /**\n     * @dev Grants `role` to `account`.\n     *\n     * If `account` had not been already granted `role`, emits a {RoleGranted}\n     * event.\n     *\n     * Requirements:\n     *\n     * - the caller must have ``role``'s admin role.\n     *\n     * May emit a {RoleGranted} event.\n     */\n    function grantRole(bytes32 role, address account) public virtual onlyRole(getRoleAdmin(role)) {\n        _grantRole(role, account);\n    }\n\n    /**\n     * @dev Revokes `role` from `account`.\n     *\n     * If `account` had been granted `role`, emits a {RoleRevoked} event.\n     *\n     * Requirements:\n     *\n     * - the caller must have ``role``'s admin role.\n     *\n     * May emit a {RoleRevoked} event.\n     */\n    function revokeRole(bytes32 role, address account) public virtual onlyRole(getRoleAdmin(role)) {\n        _revokeRole(role, account);\n    }\n\n    /**\n     * @dev Revokes `role` from the calling account.\n     *\n     * Roles are often managed via {grantRole} and {revokeRole}: this function's\n     * purpose is to provide a mechanism for accounts to lose their privileges\n     * if they are compromised (such as when a trusted device is misplaced).\n     *\n     * If the calling account had been revoked `role`, emits a {RoleRevoked}\n     * event.\n     *\n     * Requirements:\n     *\n     * - the caller must be `callerConfirmation`.\n     *\n     * May emit a {RoleRevoked} event.\n     */\n    function renounceRole(bytes32 role, address callerConfirmation) public virtual {\n        if (callerConfirmation != _msgSender()) {\n            revert AccessControlBadConfirmation();\n        }\n\n        _revokeRole(role, callerConfirmation);\n    }\n\n    /**\n     * @dev Sets `adminRole` as ``role``'s admin role.\n     *\n     * Emits a {RoleAdminChanged} event.\n     */\n    function _setRoleAdmin(bytes32 role, bytes32 adminRole) internal virtual {\n        bytes32 previousAdminRole = getRoleAdmin(role);\n        _roles[role].adminRole = adminRole;\n        emit RoleAdminChanged(role, previousAdminRole, adminRole);\n    }\n\n    /**\n     * @dev Attempts to grant `role` to `account` and returns a boolean indicating if `role` was granted.\n     *\n     * Internal function without access restriction.\n     *\n     * May emit a {RoleGranted} event.\n     */\n    function _grantRole(bytes32 role, address account) internal virtual returns (bool) {\n        if (!hasRole(role, account)) {\n            _roles[role].hasRole[account] = true;\n            emit RoleGranted(role, account, _msgSender());\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n    /**\n     * @dev Attempts to revoke `role` to `account` and returns a boolean indicating if `role` was revoked.\n     *\n     * Internal function without access restriction.\n     *\n     * May emit a {RoleRevoked} event.\n     */\n    function _revokeRole(bytes32 role, address account) internal virtual returns (bool) {\n        if (hasRole(role, account)) {\n            _roles[role].hasRole[account] = false;\n            emit RoleRevoked(role, account, _msgSender());\n            return true;\n        } else {\n            return false;\n        }\n    }\n}\n"},"lib/openzeppelin-contracts/contracts/access/IAccessControl.sol":{"content":"// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.1.0) (access/IAccessControl.sol)\n\npragma solidity ^0.8.20;\n\n/**\n * @dev External interface of AccessControl declared to support ERC-165 detection.\n */\ninterface IAccessControl {\n    /**\n     * @dev The `account` is missing a role.\n     */\n    error AccessControlUnauthorizedAccount(address account, bytes32 neededRole);\n\n    /**\n     * @dev The caller of a function is not the expected one.\n     *\n     * NOTE: Don't confuse with {AccessControlUnauthorizedAccount}.\n     */\n    error AccessControlBadConfirmation();\n\n    /**\n     * @dev Emitted when `newAdminRole` is set as ``role``'s admin role, replacing `previousAdminRole`\n     *\n     * `DEFAULT_ADMIN_ROLE` is the starting admin for all roles, despite\n     * {RoleAdminChanged} not being emitted signaling this.\n     */\n    event RoleAdminChanged(bytes32 indexed role, bytes32 indexed previousAdminRole, bytes32 indexed newAdminRole);\n\n    /**\n     * @dev Emitted when `account` is granted `role`.\n     *\n     * `sender` is the account that originated the contract call. This account bears the admin role (for the granted role).\n     * Expected in cases where the role was granted using the internal {AccessControl-_grantRole}.\n     */\n    event RoleGranted(bytes32 indexed role, address indexed account, address indexed sender);\n\n    /**\n     * @dev Emitted when `account` is revoked `role`.\n     *\n     * `sender` is the account that originated the contract call:\n     *   - if using `revokeRole`, it is the admin role bearer\n     *   - if using `renounceRole`, it is the role bearer (i.e. `account`)\n     */\n    event RoleRevoked(bytes32 indexed role, address indexed account, address indexed sender);\n\n    /**\n     * @dev Returns `true` if `account` has been granted `role`.\n     */\n    function hasRole(bytes32 role, address account) external view returns (bool);\n\n    /**\n     * @dev Returns the admin role that controls `role`. See {grantRole} and\n     * {revokeRole}.\n     *\n     * To change a role's admin, use {AccessControl-_setRoleAdmin}.\n     */\n    function getRoleAdmin(bytes32 role) external view returns (bytes32);\n\n    /**\n     * @dev Grants `role` to `account`.\n     *\n     * If `account` had not been already granted `role`, emits a {RoleGranted}\n     * event.\n     *\n     * Requirements:\n     *\n     * - the caller must have ``role``'s admin role.\n     */\n    function grantRole(bytes32 role, address account) external;\n\n    /**\n     * @dev Revokes `role` from `account`.\n     *\n     * If `account` had been granted `role`, emits a {RoleRevoked} event.\n     *\n     * Requirements:\n     *\n     * - the caller must have ``role``'s admin role.\n     */\n    function revokeRole(bytes32 role, address account) external;\n\n    /**\n     * @dev Revokes `role` from the calling account.\n     *\n     * Roles are often managed via {grantRole} and {revokeRole}: this function's\n     * purpose is to provide a mechanism for accounts to lose their privileges\n     * if they are compromised (such as when a trusted device is misplaced).\n     *\n     * If the calling account had been granted `role`, emits a {RoleRevoked}\n     * event.\n     *\n     * Requirements:\n     *\n     * - the caller must be `callerConfirmation`.\n     */\n    function renounceRole(bytes32 role, address callerConfirmation) external;\n}\n"},"lib/openzeppelin-contracts/contracts/access/Ownable.sol":{"content":"// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (access/Ownable.sol)\n\npragma solidity ^0.8.20;\n\nimport {Context} from \"../utils/Context.sol\";\n\n/**\n * @dev Contract module which provides a basic access control mechanism, where\n * there is an account (an owner) that can be granted exclusive access to\n * specific functions.\n *\n * The initial owner is set to the address provided by the deployer. This can\n * later be changed with {transferOwnership}.\n *\n * This module is used through inheritance. It will make available the modifier\n * `onlyOwner`, which can be applied to your functions to restrict their use to\n * the owner.\n */\nabstract contract Ownable is Context {\n    address private _owner;\n\n    /**\n     * @dev The caller account is not authorized to perform an operation.\n     */\n    error OwnableUnauthorizedAccount(address account);\n\n    /**\n     * @dev The owner is not a valid owner account. (eg. `address(0)`)\n     */\n    error OwnableInvalidOwner(address owner);\n\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n    /**\n     * @dev Initializes the contract setting the address provided by the deployer as the initial owner.\n     */\n    constructor(address initialOwner) {\n        if (initialOwner == address(0)) {\n            revert OwnableInvalidOwner(address(0));\n        }\n        _transferOwnership(initialOwner);\n    }\n\n    /**\n     * @dev Throws if called by any account other than the owner.\n     */\n    modifier onlyOwner() {\n        _checkOwner();\n        _;\n    }\n\n    /**\n     * @dev Returns the address of the current owner.\n     */\n    function owner() public view virtual returns (address) {\n        return _owner;\n    }\n\n    /**\n     * @dev Throws if the sender is not the owner.\n     */\n    function _checkOwner() internal view virtual {\n        if (owner() != _msgSender()) {\n            revert OwnableUnauthorizedAccount(_msgSender());\n        }\n    }\n\n    /**\n     * @dev Leaves the contract without owner. It will not be possible to call\n     * `onlyOwner` functions. Can only be called by the current owner.\n     *\n     * NOTE: Renouncing ownership will leave the contract without an owner,\n     * thereby disabling any functionality that is only available to the owner.\n     */\n    function renounceOwnership() public virtual onlyOwner {\n        _transferOwnership(address(0));\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Can only be called by the current owner.\n     */\n    function transferOwnership(address newOwner) public virtual onlyOwner {\n        if (newOwner == address(0)) {\n            revert OwnableInvalidOwner(address(0));\n        }\n        _transferOwnership(newOwner);\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Internal function without access restriction.\n     */\n    function _transferOwnership(address newOwner) internal virtual {\n        address oldOwner = _owner;\n        _owner = newOwner;\n        emit OwnershipTransferred(oldOwner, newOwner);\n    }\n}\n"},"lib/openzeppelin-contracts/contracts/access/Ownable2Step.sol":{"content":"// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.1.0) (access/Ownable2Step.sol)\n\npragma solidity ^0.8.20;\n\nimport {Ownable} from \"./Ownable.sol\";\n\n/**\n * @dev Contract module which provides access control mechanism, where\n * there is an account (an owner) that can be granted exclusive access to\n * specific functions.\n *\n * This extension of the {Ownable} contract includes a two-step mechanism to transfer\n * ownership, where the new owner must call {acceptOwnership} in order to replace the\n * old one. This can help prevent common mistakes, such as transfers of ownership to\n * incorrect accounts, or to contracts that are unable to interact with the\n * permission system.\n *\n * The initial owner is specified at deployment time in the constructor for `Ownable`. This\n * can later be changed with {transferOwnership} and {acceptOwnership}.\n *\n * This module is used through inheritance. It will make available all functions\n * from parent (Ownable).\n */\nabstract contract Ownable2Step is Ownable {\n    address private _pendingOwner;\n\n    event OwnershipTransferStarted(address indexed previousOwner, address indexed newOwner);\n\n    /**\n     * @dev Returns the address of the pending owner.\n     */\n    function pendingOwner() public view virtual returns (address) {\n        return _pendingOwner;\n    }\n\n    /**\n     * @dev Starts the ownership transfer of the contract to a new account. Replaces the pending transfer if there is one.\n     * Can only be called by the current owner.\n     *\n     * Setting `newOwner` to the zero address is allowed; this can be used to cancel an initiated ownership transfer.\n     */\n    function transferOwnership(address newOwner) public virtual override onlyOwner {\n        _pendingOwner = newOwner;\n        emit OwnershipTransferStarted(owner(), newOwner);\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`) and deletes any pending owner.\n     * Internal function without access restriction.\n     */\n    function _transferOwnership(address newOwner) internal virtual override {\n        delete _pendingOwner;\n        super._transferOwnership(newOwner);\n    }\n\n    /**\n     * @dev The new owner accepts the ownership transfer.\n     */\n    function acceptOwnership() public virtual {\n        address sender = _msgSender();\n        if (pendingOwner() != sender) {\n            revert OwnableUnauthorizedAccount(sender);\n        }\n        _transferOwnership(sender);\n    }\n}\n"},"lib/openzeppelin-contracts/contracts/token/ERC20/IERC20.sol":{"content":"// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.1.0) (token/ERC20/IERC20.sol)\n\npragma solidity ^0.8.20;\n\n/**\n * @dev Interface of the ERC-20 standard as defined in the ERC.\n */\ninterface IERC20 {\n    /**\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n     * another (`to`).\n     *\n     * Note that `value` may be zero.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    /**\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n     * a call to {approve}. `value` is the new allowance.\n     */\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n\n    /**\n     * @dev Returns the value of tokens in existence.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns the value of tokens owned by `account`.\n     */\n    function balanceOf(address account) external view returns (uint256);\n\n    /**\n     * @dev Moves a `value` amount of tokens from the caller's account to `to`.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transfer(address to, uint256 value) external returns (bool);\n\n    /**\n     * @dev Returns the remaining number of tokens that `spender` will be\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n     * zero by default.\n     *\n     * This value changes when {approve} or {transferFrom} are called.\n     */\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    /**\n     * @dev Sets a `value` amount of tokens as the allowance of `spender` over the\n     * caller's tokens.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n     * that someone may use both the old and the new allowance by unfortunate\n     * transaction ordering. One possible solution to mitigate this race\n     * condition is to first reduce the spender's allowance to 0 and set the\n     * desired value afterwards:\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address spender, uint256 value) external returns (bool);\n\n    /**\n     * @dev Moves a `value` amount of tokens from `from` to `to` using the\n     * allowance mechanism. `value` is then deducted from the caller's\n     * allowance.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(address from, address to, uint256 value) external returns (bool);\n}\n"},"lib/openzeppelin-contracts/contracts/token/ERC721/IERC721.sol":{"content":"// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.1.0) (token/ERC721/IERC721.sol)\n\npragma solidity ^0.8.20;\n\nimport {IERC165} from \"../../utils/introspection/IERC165.sol\";\n\n/**\n * @dev Required interface of an ERC-721 compliant contract.\n */\ninterface IERC721 is IERC165 {\n    /**\n     * @dev Emitted when `tokenId` token is transferred from `from` to `to`.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 indexed tokenId);\n\n    /**\n     * @dev Emitted when `owner` enables `approved` to manage the `tokenId` token.\n     */\n    event Approval(address indexed owner, address indexed approved, uint256 indexed tokenId);\n\n    /**\n     * @dev Emitted when `owner` enables or disables (`approved`) `operator` to manage all of its assets.\n     */\n    event ApprovalForAll(address indexed owner, address indexed operator, bool approved);\n\n    /**\n     * @dev Returns the number of tokens in ``owner``'s account.\n     */\n    function balanceOf(address owner) external view returns (uint256 balance);\n\n    /**\n     * @dev Returns the owner of the `tokenId` token.\n     *\n     * Requirements:\n     *\n     * - `tokenId` must exist.\n     */\n    function ownerOf(uint256 tokenId) external view returns (address owner);\n\n    /**\n     * @dev Safely transfers `tokenId` token from `from` to `to`.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must exist and be owned by `from`.\n     * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon\n     *   a safe transfer.\n     *\n     * Emits a {Transfer} event.\n     */\n    function safeTransferFrom(address from, address to, uint256 tokenId, bytes calldata data) external;\n\n    /**\n     * @dev Safely transfers `tokenId` token from `from` to `to`, checking first that contract recipients\n     * are aware of the ERC-721 protocol to prevent tokens from being forever locked.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must exist and be owned by `from`.\n     * - If the caller is not `from`, it must have been allowed to move this token by either {approve} or\n     *   {setApprovalForAll}.\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon\n     *   a safe transfer.\n     *\n     * Emits a {Transfer} event.\n     */\n    function safeTransferFrom(address from, address to, uint256 tokenId) external;\n\n    /**\n     * @dev Transfers `tokenId` token from `from` to `to`.\n     *\n     * WARNING: Note that the caller is responsible to confirm that the recipient is capable of receiving ERC-721\n     * or else they may be permanently lost. Usage of {safeTransferFrom} prevents loss, though the caller must\n     * understand this adds an external call which potentially creates a reentrancy vulnerability.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must be owned by `from`.\n     * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(address from, address to, uint256 tokenId) external;\n\n    /**\n     * @dev Gives permission to `to` to transfer `tokenId` token to another account.\n     * The approval is cleared when the token is transferred.\n     *\n     * Only a single account can be approved at a time, so approving the zero address clears previous approvals.\n     *\n     * Requirements:\n     *\n     * - The caller must own the token or be an approved operator.\n     * - `tokenId` must exist.\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address to, uint256 tokenId) external;\n\n    /**\n     * @dev Approve or remove `operator` as an operator for the caller.\n     * Operators can call {transferFrom} or {safeTransferFrom} for any token owned by the caller.\n     *\n     * Requirements:\n     *\n     * - The `operator` cannot be the address zero.\n     *\n     * Emits an {ApprovalForAll} event.\n     */\n    function setApprovalForAll(address operator, bool approved) external;\n\n    /**\n     * @dev Returns the account approved for `tokenId` token.\n     *\n     * Requirements:\n     *\n     * - `tokenId` must exist.\n     */\n    function getApproved(uint256 tokenId) external view returns (address operator);\n\n    /**\n     * @dev Returns if the `operator` is allowed to manage all of the assets of `owner`.\n     *\n     * See {setApprovalForAll}\n     */\n    function isApprovedForAll(address owner, address operator) external view returns (bool);\n}\n"},"lib/openzeppelin-contracts/contracts/utils/Context.sol":{"content":"// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.1) (utils/Context.sol)\n\npragma solidity ^0.8.20;\n\n/**\n * @dev Provides information about the current execution context, including the\n * sender of the transaction and its data. While these are generally available\n * via msg.sender and msg.data, they should not be accessed in such a direct\n * manner, since when dealing with meta-transactions the account sending and\n * paying for execution may not be the actual sender (as far as an application\n * is concerned).\n *\n * This contract is only required for intermediate, library-like contracts.\n */\nabstract contract Context {\n    function _msgSender() internal view virtual returns (address) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view virtual returns (bytes calldata) {\n        return msg.data;\n    }\n\n    function _contextSuffixLength() internal view virtual returns (uint256) {\n        return 0;\n    }\n}\n"},"lib/openzeppelin-contracts/contracts/utils/Panic.sol":{"content":"// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.1.0) (utils/Panic.sol)\n\npragma solidity ^0.8.20;\n\n/**\n * @dev Helper library for emitting standardized panic codes.\n *\n * ```solidity\n * contract Example {\n *      using Panic for uint256;\n *\n *      // Use any of the declared internal constants\n *      function foo() { Panic.GENERIC.panic(); }\n *\n *      // Alternatively\n *      function foo() { Panic.panic(Panic.GENERIC); }\n * }\n * ```\n *\n * Follows the list from https://github.com/ethereum/solidity/blob/v0.8.24/libsolutil/ErrorCodes.h[libsolutil].\n *\n * _Available since v5.1._\n */\n// slither-disable-next-line unused-state\nlibrary Panic {\n    /// @dev generic / unspecified error\n    uint256 internal constant GENERIC = 0x00;\n    /// @dev used by the assert() builtin\n    uint256 internal constant ASSERT = 0x01;\n    /// @dev arithmetic underflow or overflow\n    uint256 internal constant UNDER_OVERFLOW = 0x11;\n    /// @dev division or modulo by zero\n    uint256 internal constant DIVISION_BY_ZERO = 0x12;\n    /// @dev enum conversion error\n    uint256 internal constant ENUM_CONVERSION_ERROR = 0x21;\n    /// @dev invalid encoding in storage\n    uint256 internal constant STORAGE_ENCODING_ERROR = 0x22;\n    /// @dev empty array pop\n    uint256 internal constant EMPTY_ARRAY_POP = 0x31;\n    /// @dev array out of bounds access\n    uint256 internal constant ARRAY_OUT_OF_BOUNDS = 0x32;\n    /// @dev resource error (too large allocation or too large array)\n    uint256 internal constant RESOURCE_ERROR = 0x41;\n    /// @dev calling invalid internal function\n    uint256 internal constant INVALID_INTERNAL_FUNCTION = 0x51;\n\n    /// @dev Reverts with a panic code. Recommended to use with\n    /// the internal constants with predefined codes.\n    function panic(uint256 code) internal pure {\n        assembly (\"memory-safe\") {\n            mstore(0x00, 0x4e487b71)\n            mstore(0x20, code)\n            revert(0x1c, 0x24)\n        }\n    }\n}\n"},"lib/openzeppelin-contracts/contracts/utils/introspection/ERC165.sol":{"content":"// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.1.0) (utils/introspection/ERC165.sol)\n\npragma solidity ^0.8.20;\n\nimport {IERC165} from \"./IERC165.sol\";\n\n/**\n * @dev Implementation of the {IERC165} interface.\n *\n * Contracts that want to implement ERC-165 should inherit from this contract and override {supportsInterface} to check\n * for the additional interface id that will be supported. For example:\n *\n * ```solidity\n * function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n *     return interfaceId == type(MyInterface).interfaceId || super.supportsInterface(interfaceId);\n * }\n * ```\n */\nabstract contract ERC165 is IERC165 {\n    /**\n     * @dev See {IERC165-supportsInterface}.\n     */\n    function supportsInterface(bytes4 interfaceId) public view virtual returns (bool) {\n        return interfaceId == type(IERC165).interfaceId;\n    }\n}\n"},"lib/openzeppelin-contracts/contracts/utils/introspection/IERC165.sol":{"content":"// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.1.0) (utils/introspection/IERC165.sol)\n\npragma solidity ^0.8.20;\n\n/**\n * @dev Interface of the ERC-165 standard, as defined in the\n * https://eips.ethereum.org/EIPS/eip-165[ERC].\n *\n * Implementers can declare support of contract interfaces, which can then be\n * queried by others ({ERC165Checker}).\n *\n * For an implementation, see {ERC165}.\n */\ninterface IERC165 {\n    /**\n     * @dev Returns true if this contract implements the interface defined by\n     * `interfaceId`. See the corresponding\n     * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[ERC section]\n     * to learn more about how these ids are created.\n     *\n     * This function call must use less than 30 000 gas.\n     */\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\n}\n"},"lib/openzeppelin-contracts/contracts/utils/math/Math.sol":{"content":"// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.1.0) (utils/math/Math.sol)\n\npragma solidity ^0.8.20;\n\nimport {Panic} from \"../Panic.sol\";\nimport {SafeCast} from \"./SafeCast.sol\";\n\n/**\n * @dev Standard math utilities missing in the Solidity language.\n */\nlibrary Math {\n    enum Rounding {\n        Floor, // Toward negative infinity\n        Ceil, // Toward positive infinity\n        Trunc, // Toward zero\n        Expand // Away from zero\n    }\n\n    /**\n     * @dev Returns the addition of two unsigned integers, with an success flag (no overflow).\n     */\n    function tryAdd(uint256 a, uint256 b) internal pure returns (bool success, uint256 result) {\n        unchecked {\n            uint256 c = a + b;\n            if (c < a) return (false, 0);\n            return (true, c);\n        }\n    }\n\n    /**\n     * @dev Returns the subtraction of two unsigned integers, with an success flag (no overflow).\n     */\n    function trySub(uint256 a, uint256 b) internal pure returns (bool success, uint256 result) {\n        unchecked {\n            if (b > a) return (false, 0);\n            return (true, a - b);\n        }\n    }\n\n    /**\n     * @dev Returns the multiplication of two unsigned integers, with an success flag (no overflow).\n     */\n    function tryMul(uint256 a, uint256 b) internal pure returns (bool success, uint256 result) {\n        unchecked {\n            // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\n            // benefit is lost if 'b' is also tested.\n            // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\n            if (a == 0) return (true, 0);\n            uint256 c = a * b;\n            if (c / a != b) return (false, 0);\n            return (true, c);\n        }\n    }\n\n    /**\n     * @dev Returns the division of two unsigned integers, with a success flag (no division by zero).\n     */\n    function tryDiv(uint256 a, uint256 b) internal pure returns (bool success, uint256 result) {\n        unchecked {\n            if (b == 0) return (false, 0);\n            return (true, a / b);\n        }\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers, with a success flag (no division by zero).\n     */\n    function tryMod(uint256 a, uint256 b) internal pure returns (bool success, uint256 result) {\n        unchecked {\n            if (b == 0) return (false, 0);\n            return (true, a % b);\n        }\n    }\n\n    /**\n     * @dev Branchless ternary evaluation for `a ? b : c`. Gas costs are constant.\n     *\n     * IMPORTANT: This function may reduce bytecode size and consume less gas when used standalone.\n     * However, the compiler may optimize Solidity ternary operations (i.e. `a ? b : c`) to only compute\n     * one branch when needed, making this function more expensive.\n     */\n    function ternary(bool condition, uint256 a, uint256 b) internal pure returns (uint256) {\n        unchecked {\n            // branchless ternary works because:\n            // b ^ (a ^ b) == a\n            // b ^ 0 == b\n            return b ^ ((a ^ b) * SafeCast.toUint(condition));\n        }\n    }\n\n    /**\n     * @dev Returns the largest of two numbers.\n     */\n    function max(uint256 a, uint256 b) internal pure returns (uint256) {\n        return ternary(a > b, a, b);\n    }\n\n    /**\n     * @dev Returns the smallest of two numbers.\n     */\n    function min(uint256 a, uint256 b) internal pure returns (uint256) {\n        return ternary(a < b, a, b);\n    }\n\n    /**\n     * @dev Returns the average of two numbers. The result is rounded towards\n     * zero.\n     */\n    function average(uint256 a, uint256 b) internal pure returns (uint256) {\n        // (a + b) / 2 can overflow.\n        return (a & b) + (a ^ b) / 2;\n    }\n\n    /**\n     * @dev Returns the ceiling of the division of two numbers.\n     *\n     * This differs from standard division with `/` in that it rounds towards infinity instead\n     * of rounding towards zero.\n     */\n    function ceilDiv(uint256 a, uint256 b) internal pure returns (uint256) {\n        if (b == 0) {\n            // Guarantee the same behavior as in a regular Solidity division.\n            Panic.panic(Panic.DIVISION_BY_ZERO);\n        }\n\n        // The following calculation ensures accurate ceiling division without overflow.\n        // Since a is non-zero, (a - 1) / b will not overflow.\n        // The largest possible result occurs when (a - 1) / b is type(uint256).max,\n        // but the largest value we can obtain is type(uint256).max - 1, which happens\n        // when a = type(uint256).max and b = 1.\n        unchecked {\n            return SafeCast.toUint(a > 0) * ((a - 1) / b + 1);\n        }\n    }\n\n    /**\n     * @dev Calculates floor(x * y / denominator) with full precision. Throws if result overflows a uint256 or\n     * denominator == 0.\n     *\n     * Original credit to Remco Bloemen under MIT license (https://xn--2-umb.com/21/muldiv) with further edits by\n     * Uniswap Labs also under MIT license.\n     */\n    function mulDiv(uint256 x, uint256 y, uint256 denominator) internal pure returns (uint256 result) {\n        unchecked {\n            // 512-bit multiply [prod1 prod0] = x * y. Compute the product mod 2 and mod 2 - 1, then use\n            // the Chinese Remainder Theorem to reconstruct the 512 bit result. The result is stored in two 256\n            // variables such that product = prod1 * 2 + prod0.\n            uint256 prod0 = x * y; // Least significant 256 bits of the product\n            uint256 prod1; // Most significant 256 bits of the product\n            assembly {\n                let mm := mulmod(x, y, not(0))\n                prod1 := sub(sub(mm, prod0), lt(mm, prod0))\n            }\n\n            // Handle non-overflow cases, 256 by 256 division.\n            if (prod1 == 0) {\n                // Solidity will revert if denominator == 0, unlike the div opcode on its own.\n                // The surrounding unchecked block does not change this fact.\n                // See https://docs.soliditylang.org/en/latest/control-structures.html#checked-or-unchecked-arithmetic.\n                return prod0 / denominator;\n            }\n\n            // Make sure the result is less than 2. Also prevents denominator == 0.\n            if (denominator <= prod1) {\n                Panic.panic(ternary(denominator == 0, Panic.DIVISION_BY_ZERO, Panic.UNDER_OVERFLOW));\n            }\n\n            ///////////////////////////////////////////////\n            // 512 by 256 division.\n            ///////////////////////////////////////////////\n\n            // Make division exact by subtracting the remainder from [prod1 prod0].\n            uint256 remainder;\n            assembly {\n                // Compute remainder using mulmod.\n                remainder := mulmod(x, y, denominator)\n\n                // Subtract 256 bit number from 512 bit number.\n                prod1 := sub(prod1, gt(remainder, prod0))\n                prod0 := sub(prod0, remainder)\n            }\n\n            // Factor powers of two out of denominator and compute largest power of two divisor of denominator.\n            // Always >= 1. See https://cs.stackexchange.com/q/138556/92363.\n\n            uint256 twos = denominator & (0 - denominator);\n            assembly {\n                // Divide denominator by twos.\n                denominator := div(denominator, twos)\n\n                // Divide [prod1 prod0] by twos.\n                prod0 := div(prod0, twos)\n\n                // Flip twos such that it is 2 / twos. If twos is zero, then it becomes one.\n                twos := add(div(sub(0, twos), twos), 1)\n            }\n\n            // Shift in bits from prod1 into prod0.\n            prod0 |= prod1 * twos;\n\n            // Invert denominator mod 2. Now that denominator is an odd number, it has an inverse modulo 2 such\n            // that denominator * inv  1 mod 2. Compute the inverse by starting with a seed that is correct for\n            // four bits. That is, denominator * inv  1 mod 2.\n            uint256 inverse = (3 * denominator) ^ 2;\n\n            // Use the Newton-Raphson iteration to improve the precision. Thanks to Hensel's lifting lemma, this also\n            // works in modular arithmetic, doubling the correct bits in each step.\n            inverse *= 2 - denominator * inverse; // inverse mod 2\n            inverse *= 2 - denominator * inverse; // inverse mod 2\n            inverse *= 2 - denominator * inverse; // inverse mod 2\n            inverse *= 2 - denominator * inverse; // inverse mod 2\n            inverse *= 2 - denominator * inverse; // inverse mod 2\n            inverse *= 2 - denominator * inverse; // inverse mod 2\n\n            // Because the division is now exact we can divide by multiplying with the modular inverse of denominator.\n            // This will give us the correct result modulo 2. Since the preconditions guarantee that the outcome is\n            // less than 2, this is the final result. We don't need to compute the high bits of the result and prod1\n            // is no longer required.\n            result = prod0 * inverse;\n            return result;\n        }\n    }\n\n    /**\n     * @dev Calculates x * y / denominator with full precision, following the selected rounding direction.\n     */\n    function mulDiv(uint256 x, uint256 y, uint256 denominator, Rounding rounding) internal pure returns (uint256) {\n        return mulDiv(x, y, denominator) + SafeCast.toUint(unsignedRoundsUp(rounding) && mulmod(x, y, denominator) > 0);\n    }\n\n    /**\n     * @dev Calculate the modular multiplicative inverse of a number in Z/nZ.\n     *\n     * If n is a prime, then Z/nZ is a field. In that case all elements are inversible, except 0.\n     * If n is not a prime, then Z/nZ is not a field, and some elements might not be inversible.\n     *\n     * If the input value is not inversible, 0 is returned.\n     *\n     * NOTE: If you know for sure that n is (big) a prime, it may be cheaper to use Fermat's little theorem and get the\n     * inverse using `Math.modExp(a, n - 2, n)`. See {invModPrime}.\n     */\n    function invMod(uint256 a, uint256 n) internal pure returns (uint256) {\n        unchecked {\n            if (n == 0) return 0;\n\n            // The inverse modulo is calculated using the Extended Euclidean Algorithm (iterative version)\n            // Used to compute integers x and y such that: ax + ny = gcd(a, n).\n            // When the gcd is 1, then the inverse of a modulo n exists and it's x.\n            // ax + ny = 1\n            // ax = 1 + (-y)n\n            // ax  1 (mod n) # x is the inverse of a modulo n\n\n            // If the remainder is 0 the gcd is n right away.\n            uint256 remainder = a % n;\n            uint256 gcd = n;\n\n            // Therefore the initial coefficients are:\n            // ax + ny = gcd(a, n) = n\n            // 0a + 1n = n\n            int256 x = 0;\n            int256 y = 1;\n\n            while (remainder != 0) {\n                uint256 quotient = gcd / remainder;\n\n                (gcd, remainder) = (\n                    // The old remainder is the next gcd to try.\n                    remainder,\n                    // Compute the next remainder.\n                    // Can't overflow given that (a % gcd) * (gcd // (a % gcd)) <= gcd\n                    // where gcd is at most n (capped to type(uint256).max)\n                    gcd - remainder * quotient\n                );\n\n                (x, y) = (\n                    // Increment the coefficient of a.\n                    y,\n                    // Decrement the coefficient of n.\n                    // Can overflow, but the result is casted to uint256 so that the\n                    // next value of y is \"wrapped around\" to a value between 0 and n - 1.\n                    x - y * int256(quotient)\n                );\n            }\n\n            if (gcd != 1) return 0; // No inverse exists.\n            return ternary(x < 0, n - uint256(-x), uint256(x)); // Wrap the result if it's negative.\n        }\n    }\n\n    /**\n     * @dev Variant of {invMod}. More efficient, but only works if `p` is known to be a prime greater than `2`.\n     *\n     * From https://en.wikipedia.org/wiki/Fermat%27s_little_theorem[Fermat's little theorem], we know that if p is\n     * prime, then `a**(p-1)  1 mod p`. As a consequence, we have `a * a**(p-2)  1 mod p`, which means that\n     * `a**(p-2)` is the modular multiplicative inverse of a in Fp.\n     *\n     * NOTE: this function does NOT check that `p` is a prime greater than `2`.\n     */\n    function invModPrime(uint256 a, uint256 p) internal view returns (uint256) {\n        unchecked {\n            return Math.modExp(a, p - 2, p);\n        }\n    }\n\n    /**\n     * @dev Returns the modular exponentiation of the specified base, exponent and modulus (b ** e % m)\n     *\n     * Requirements:\n     * - modulus can't be zero\n     * - underlying staticcall to precompile must succeed\n     *\n     * IMPORTANT: The result is only valid if the underlying call succeeds. When using this function, make\n     * sure the chain you're using it on supports the precompiled contract for modular exponentiation\n     * at address 0x05 as specified in https://eips.ethereum.org/EIPS/eip-198[EIP-198]. Otherwise,\n     * the underlying function will succeed given the lack of a revert, but the result may be incorrectly\n     * interpreted as 0.\n     */\n    function modExp(uint256 b, uint256 e, uint256 m) internal view returns (uint256) {\n        (bool success, uint256 result) = tryModExp(b, e, m);\n        if (!success) {\n            Panic.panic(Panic.DIVISION_BY_ZERO);\n        }\n        return result;\n    }\n\n    /**\n     * @dev Returns the modular exponentiation of the specified base, exponent and modulus (b ** e % m).\n     * It includes a success flag indicating if the operation succeeded. Operation will be marked as failed if trying\n     * to operate modulo 0 or if the underlying precompile reverted.\n     *\n     * IMPORTANT: The result is only valid if the success flag is true. When using this function, make sure the chain\n     * you're using it on supports the precompiled contract for modular exponentiation at address 0x05 as specified in\n     * https://eips.ethereum.org/EIPS/eip-198[EIP-198]. Otherwise, the underlying function will succeed given the lack\n     * of a revert, but the result may be incorrectly interpreted as 0.\n     */\n    function tryModExp(uint256 b, uint256 e, uint256 m) internal view returns (bool success, uint256 result) {\n        if (m == 0) return (false, 0);\n        assembly (\"memory-safe\") {\n            let ptr := mload(0x40)\n            // | Offset    | Content    | Content (Hex)                                                      |\n            // |-----------|------------|--------------------------------------------------------------------|\n            // | 0x00:0x1f | size of b  | 0x0000000000000000000000000000000000000000000000000000000000000020 |\n            // | 0x20:0x3f | size of e  | 0x0000000000000000000000000000000000000000000000000000000000000020 |\n            // | 0x40:0x5f | size of m  | 0x0000000000000000000000000000000000000000000000000000000000000020 |\n            // | 0x60:0x7f | value of b | 0x<.............................................................b> |\n            // | 0x80:0x9f | value of e | 0x<.............................................................e> |\n            // | 0xa0:0xbf | value of m | 0x<.............................................................m> |\n            mstore(ptr, 0x20)\n            mstore(add(ptr, 0x20), 0x20)\n            mstore(add(ptr, 0x40), 0x20)\n            mstore(add(ptr, 0x60), b)\n            mstore(add(ptr, 0x80), e)\n            mstore(add(ptr, 0xa0), m)\n\n            // Given the result < m, it's guaranteed to fit in 32 bytes,\n            // so we can use the memory scratch space located at offset 0.\n            success := staticcall(gas(), 0x05, ptr, 0xc0, 0x00, 0x20)\n            result := mload(0x00)\n        }\n    }\n\n    /**\n     * @dev Variant of {modExp} that supports inputs of arbitrary length.\n     */\n    function modExp(bytes memory b, bytes memory e, bytes memory m) internal view returns (bytes memory) {\n        (bool success, bytes memory result) = tryModExp(b, e, m);\n        if (!success) {\n            Panic.panic(Panic.DIVISION_BY_ZERO);\n        }\n        return result;\n    }\n\n    /**\n     * @dev Variant of {tryModExp} that supports inputs of arbitrary length.\n     */\n    function tryModExp(\n        bytes memory b,\n        bytes memory e,\n        bytes memory m\n    ) internal view returns (bool success, bytes memory result) {\n        if (_zeroBytes(m)) return (false, new bytes(0));\n\n        uint256 mLen = m.length;\n\n        // Encode call args in result and move the free memory pointer\n        result = abi.encodePacked(b.length, e.length, mLen, b, e, m);\n\n        assembly (\"memory-safe\") {\n            let dataPtr := add(result, 0x20)\n            // Write result on top of args to avoid allocating extra memory.\n            success := staticcall(gas(), 0x05, dataPtr, mload(result), dataPtr, mLen)\n            // Overwrite the length.\n            // result.length > returndatasize() is guaranteed because returndatasize() == m.length\n            mstore(result, mLen)\n            // Set the memory pointer after the returned data.\n            mstore(0x40, add(dataPtr, mLen))\n        }\n    }\n\n    /**\n     * @dev Returns whether the provided byte array is zero.\n     */\n    function _zeroBytes(bytes memory byteArray) private pure returns (bool) {\n        for (uint256 i = 0; i < byteArray.length; ++i) {\n            if (byteArray[i] != 0) {\n                return false;\n            }\n        }\n        return true;\n    }\n\n    /**\n     * @dev Returns the square root of a number. If the number is not a perfect square, the value is rounded\n     * towards zero.\n     *\n     * This method is based on Newton's method for computing square roots; the algorithm is restricted to only\n     * using integer operations.\n     */\n    function sqrt(uint256 a) internal pure returns (uint256) {\n        unchecked {\n            // Take care of easy edge cases when a == 0 or a == 1\n            if (a <= 1) {\n                return a;\n            }\n\n            // In this function, we use Newton's method to get a root of `f(x) := x - a`. It involves building a\n            // sequence x_n that converges toward sqrt(a). For each iteration x_n, we also define the error between\n            // the current value as `_n = | x_n - sqrt(a) |`.\n            //\n            // For our first estimation, we consider `e` the smallest power of 2 which is bigger than the square root\n            // of the target. (i.e. `2**(e-1)  sqrt(a) < 2**e`). We know that `e  128` because `(2) = 2` is\n            // bigger than any uint256.\n            //\n            // By noticing that\n            // `2**(e-1)  sqrt(a) < 2**e  (2**(e-1))  a < (2**e)  2**(2*e-2)  a < 2**(2*e)`\n            // we can deduce that `e - 1` is `log2(a) / 2`. We can thus compute `x_n = 2**(e-1)` using a method similar\n            // to the msb function.\n            uint256 aa = a;\n            uint256 xn = 1;\n\n            if (aa >= (1 << 128)) {\n                aa >>= 128;\n                xn <<= 64;\n            }\n            if (aa >= (1 << 64)) {\n                aa >>= 64;\n                xn <<= 32;\n            }\n            if (aa >= (1 << 32)) {\n                aa >>= 32;\n                xn <<= 16;\n            }\n            if (aa >= (1 << 16)) {\n                aa >>= 16;\n                xn <<= 8;\n            }\n            if (aa >= (1 << 8)) {\n                aa >>= 8;\n                xn <<= 4;\n            }\n            if (aa >= (1 << 4)) {\n                aa >>= 4;\n                xn <<= 2;\n            }\n            if (aa >= (1 << 2)) {\n                xn <<= 1;\n            }\n\n            // We now have x_n such that `x_n = 2**(e-1)  sqrt(a) < 2**e = 2 * x_n`. This implies _n  2**(e-1).\n            //\n            // We can refine our estimation by noticing that the middle of that interval minimizes the error.\n            // If we move x_n to equal 2**(e-1) + 2**(e-2), then we reduce the error to _n  2**(e-2).\n            // This is going to be our x_0 (and _0)\n            xn = (3 * xn) >> 1; // _0 := | x_0 - sqrt(a) |  2**(e-2)\n\n            // From here, Newton's method give us:\n            // x_{n+1} = (x_n + a / x_n) / 2\n            //\n            // One should note that:\n            // x_{n+1} - a = ((x_n + a / x_n) / 2) - a\n            //              = ((x_n + a) / (2 * x_n)) - a\n            //              = (x_n + 2 * a * x_n + a) / (4 * x_n) - a\n            //              = (x_n + 2 * a * x_n + a - 4 * a * x_n) / (4 * x_n)\n            //              = (x_n - 2 * a * x_n + a) / (4 * x_n)\n            //              = (x_n - a) / (2 * x_n)\n            //              = ((x_n - a) / (2 * x_n))\n            //               0\n            // Which proves that for all n  1, sqrt(a)  x_n\n            //\n            // This gives us the proof of quadratic convergence of the sequence:\n            // _{n+1} = | x_{n+1} - sqrt(a) |\n            //         = | (x_n + a / x_n) / 2 - sqrt(a) |\n            //         = | (x_n + a - 2*x_n*sqrt(a)) / (2 * x_n) |\n            //         = | (x_n - sqrt(a)) / (2 * x_n) |\n            //         = | _n / (2 * x_n) |\n            //         = _n / | (2 * x_n) |\n            //\n            // For the first iteration, we have a special case where x_0 is known:\n            // _1 = _0 / | (2 * x_0) |\n            //      (2**(e-2)) / (2 * (2**(e-1) + 2**(e-2)))\n            //      2**(2*e-4) / (3 * 2**(e-1))\n            //      2**(e-3) / 3\n            //      2**(e-3-log2(3))\n            //      2**(e-4.5)\n            //\n            // For the following iterations, we use the fact that, 2**(e-1)  sqrt(a)  x_n:\n            // _{n+1} = _n / | (2 * x_n) |\n            //          (2**(e-k)) / (2 * 2**(e-1))\n            //          2**(2*e-2*k) / 2**e\n            //          2**(e-2*k)\n            xn = (xn + a / xn) >> 1; // _1 := | x_1 - sqrt(a) |  2**(e-4.5)  -- special case, see above\n            xn = (xn + a / xn) >> 1; // _2 := | x_2 - sqrt(a) |  2**(e-9)    -- general case with k = 4.5\n            xn = (xn + a / xn) >> 1; // _3 := | x_3 - sqrt(a) |  2**(e-18)   -- general case with k = 9\n            xn = (xn + a / xn) >> 1; // _4 := | x_4 - sqrt(a) |  2**(e-36)   -- general case with k = 18\n            xn = (xn + a / xn) >> 1; // _5 := | x_5 - sqrt(a) |  2**(e-72)   -- general case with k = 36\n            xn = (xn + a / xn) >> 1; // _6 := | x_6 - sqrt(a) |  2**(e-144)  -- general case with k = 72\n\n            // Because e  128 (as discussed during the first estimation phase), we know have reached a precision\n            // _6  2**(e-144) < 1. Given we're operating on integers, then we can ensure that xn is now either\n            // sqrt(a) or sqrt(a) + 1.\n            return xn - SafeCast.toUint(xn > a / xn);\n        }\n    }\n\n    /**\n     * @dev Calculates sqrt(a), following the selected rounding direction.\n     */\n    function sqrt(uint256 a, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = sqrt(a);\n            return result + SafeCast.toUint(unsignedRoundsUp(rounding) && result * result < a);\n        }\n    }\n\n    /**\n     * @dev Return the log in base 2 of a positive value rounded towards zero.\n     * Returns 0 if given 0.\n     */\n    function log2(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        uint256 exp;\n        unchecked {\n            exp = 128 * SafeCast.toUint(value > (1 << 128) - 1);\n            value >>= exp;\n            result += exp;\n\n            exp = 64 * SafeCast.toUint(value > (1 << 64) - 1);\n            value >>= exp;\n            result += exp;\n\n            exp = 32 * SafeCast.toUint(value > (1 << 32) - 1);\n            value >>= exp;\n            result += exp;\n\n            exp = 16 * SafeCast.toUint(value > (1 << 16) - 1);\n            value >>= exp;\n            result += exp;\n\n            exp = 8 * SafeCast.toUint(value > (1 << 8) - 1);\n            value >>= exp;\n            result += exp;\n\n            exp = 4 * SafeCast.toUint(value > (1 << 4) - 1);\n            value >>= exp;\n            result += exp;\n\n            exp = 2 * SafeCast.toUint(value > (1 << 2) - 1);\n            value >>= exp;\n            result += exp;\n\n            result += SafeCast.toUint(value > 1);\n        }\n        return result;\n    }\n\n    /**\n     * @dev Return the log in base 2, following the selected rounding direction, of a positive value.\n     * Returns 0 if given 0.\n     */\n    function log2(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log2(value);\n            return result + SafeCast.toUint(unsignedRoundsUp(rounding) && 1 << result < value);\n        }\n    }\n\n    /**\n     * @dev Return the log in base 10 of a positive value rounded towards zero.\n     * Returns 0 if given 0.\n     */\n    function log10(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        unchecked {\n            if (value >= 10 ** 64) {\n                value /= 10 ** 64;\n                result += 64;\n            }\n            if (value >= 10 ** 32) {\n                value /= 10 ** 32;\n                result += 32;\n            }\n            if (value >= 10 ** 16) {\n                value /= 10 ** 16;\n                result += 16;\n            }\n            if (value >= 10 ** 8) {\n                value /= 10 ** 8;\n                result += 8;\n            }\n            if (value >= 10 ** 4) {\n                value /= 10 ** 4;\n                result += 4;\n            }\n            if (value >= 10 ** 2) {\n                value /= 10 ** 2;\n                result += 2;\n            }\n            if (value >= 10 ** 1) {\n                result += 1;\n            }\n        }\n        return result;\n    }\n\n    /**\n     * @dev Return the log in base 10, following the selected rounding direction, of a positive value.\n     * Returns 0 if given 0.\n     */\n    function log10(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log10(value);\n            return result + SafeCast.toUint(unsignedRoundsUp(rounding) && 10 ** result < value);\n        }\n    }\n\n    /**\n     * @dev Return the log in base 256 of a positive value rounded towards zero.\n     * Returns 0 if given 0.\n     *\n     * Adding one to the result gives the number of pairs of hex symbols needed to represent `value` as a hex string.\n     */\n    function log256(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        uint256 isGt;\n        unchecked {\n            isGt = SafeCast.toUint(value > (1 << 128) - 1);\n            value >>= isGt * 128;\n            result += isGt * 16;\n\n            isGt = SafeCast.toUint(value > (1 << 64) - 1);\n            value >>= isGt * 64;\n            result += isGt * 8;\n\n            isGt = SafeCast.toUint(value > (1 << 32) - 1);\n            value >>= isGt * 32;\n            result += isGt * 4;\n\n            isGt = SafeCast.toUint(value > (1 << 16) - 1);\n            value >>= isGt * 16;\n            result += isGt * 2;\n\n            result += SafeCast.toUint(value > (1 << 8) - 1);\n        }\n        return result;\n    }\n\n    /**\n     * @dev Return the log in base 256, following the selected rounding direction, of a positive value.\n     * Returns 0 if given 0.\n     */\n    function log256(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log256(value);\n            return result + SafeCast.toUint(unsignedRoundsUp(rounding) && 1 << (result << 3) < value);\n        }\n    }\n\n    /**\n     * @dev Returns whether a provided rounding mode is considered rounding up for unsigned integers.\n     */\n    function unsignedRoundsUp(Rounding rounding) internal pure returns (bool) {\n        return uint8(rounding) % 2 == 1;\n    }\n}\n"},"lib/openzeppelin-contracts/contracts/utils/math/SafeCast.sol":{"content":"// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.1.0) (utils/math/SafeCast.sol)\n// This file was procedurally generated from scripts/generate/templates/SafeCast.js.\n\npragma solidity ^0.8.20;\n\n/**\n * @dev Wrappers over Solidity's uintXX/intXX/bool casting operators with added overflow\n * checks.\n *\n * Downcasting from uint256/int256 in Solidity does not revert on overflow. This can\n * easily result in undesired exploitation or bugs, since developers usually\n * assume that overflows raise errors. `SafeCast` restores this intuition by\n * reverting the transaction when such an operation overflows.\n *\n * Using this library instead of the unchecked operations eliminates an entire\n * class of bugs, so it's recommended to use it always.\n */\nlibrary SafeCast {\n    /**\n     * @dev Value doesn't fit in an uint of `bits` size.\n     */\n    error SafeCastOverflowedUintDowncast(uint8 bits, uint256 value);\n\n    /**\n     * @dev An int value doesn't fit in an uint of `bits` size.\n     */\n    error SafeCastOverflowedIntToUint(int256 value);\n\n    /**\n     * @dev Value doesn't fit in an int of `bits` size.\n     */\n    error SafeCastOverflowedIntDowncast(uint8 bits, int256 value);\n\n    /**\n     * @dev An uint value doesn't fit in an int of `bits` size.\n     */\n    error SafeCastOverflowedUintToInt(uint256 value);\n\n    /**\n     * @dev Returns the downcasted uint248 from uint256, reverting on\n     * overflow (when the input is greater than largest uint248).\n     *\n     * Counterpart to Solidity's `uint248` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 248 bits\n     */\n    function toUint248(uint256 value) internal pure returns (uint248) {\n        if (value > type(uint248).max) {\n            revert SafeCastOverflowedUintDowncast(248, value);\n        }\n        return uint248(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint240 from uint256, reverting on\n     * overflow (when the input is greater than largest uint240).\n     *\n     * Counterpart to Solidity's `uint240` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 240 bits\n     */\n    function toUint240(uint256 value) internal pure returns (uint240) {\n        if (value > type(uint240).max) {\n            revert SafeCastOverflowedUintDowncast(240, value);\n        }\n        return uint240(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint232 from uint256, reverting on\n     * overflow (when the input is greater than largest uint232).\n     *\n     * Counterpart to Solidity's `uint232` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 232 bits\n     */\n    function toUint232(uint256 value) internal pure returns (uint232) {\n        if (value > type(uint232).max) {\n            revert SafeCastOverflowedUintDowncast(232, value);\n        }\n        return uint232(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint224 from uint256, reverting on\n     * overflow (when the input is greater than largest uint224).\n     *\n     * Counterpart to Solidity's `uint224` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 224 bits\n     */\n    function toUint224(uint256 value) internal pure returns (uint224) {\n        if (value > type(uint224).max) {\n            revert SafeCastOverflowedUintDowncast(224, value);\n        }\n        return uint224(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint216 from uint256, reverting on\n     * overflow (when the input is greater than largest uint216).\n     *\n     * Counterpart to Solidity's `uint216` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 216 bits\n     */\n    function toUint216(uint256 value) internal pure returns (uint216) {\n        if (value > type(uint216).max) {\n            revert SafeCastOverflowedUintDowncast(216, value);\n        }\n        return uint216(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint208 from uint256, reverting on\n     * overflow (when the input is greater than largest uint208).\n     *\n     * Counterpart to Solidity's `uint208` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 208 bits\n     */\n    function toUint208(uint256 value) internal pure returns (uint208) {\n        if (value > type(uint208).max) {\n            revert SafeCastOverflowedUintDowncast(208, value);\n        }\n        return uint208(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint200 from uint256, reverting on\n     * overflow (when the input is greater than largest uint200).\n     *\n     * Counterpart to Solidity's `uint200` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 200 bits\n     */\n    function toUint200(uint256 value) internal pure returns (uint200) {\n        if (value > type(uint200).max) {\n            revert SafeCastOverflowedUintDowncast(200, value);\n        }\n        return uint200(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint192 from uint256, reverting on\n     * overflow (when the input is greater than largest uint192).\n     *\n     * Counterpart to Solidity's `uint192` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 192 bits\n     */\n    function toUint192(uint256 value) internal pure returns (uint192) {\n        if (value > type(uint192).max) {\n            revert SafeCastOverflowedUintDowncast(192, value);\n        }\n        return uint192(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint184 from uint256, reverting on\n     * overflow (when the input is greater than largest uint184).\n     *\n     * Counterpart to Solidity's `uint184` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 184 bits\n     */\n    function toUint184(uint256 value) internal pure returns (uint184) {\n        if (value > type(uint184).max) {\n            revert SafeCastOverflowedUintDowncast(184, value);\n        }\n        return uint184(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint176 from uint256, reverting on\n     * overflow (when the input is greater than largest uint176).\n     *\n     * Counterpart to Solidity's `uint176` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 176 bits\n     */\n    function toUint176(uint256 value) internal pure returns (uint176) {\n        if (value > type(uint176).max) {\n            revert SafeCastOverflowedUintDowncast(176, value);\n        }\n        return uint176(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint168 from uint256, reverting on\n     * overflow (when the input is greater than largest uint168).\n     *\n     * Counterpart to Solidity's `uint168` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 168 bits\n     */\n    function toUint168(uint256 value) internal pure returns (uint168) {\n        if (value > type(uint168).max) {\n            revert SafeCastOverflowedUintDowncast(168, value);\n        }\n        return uint168(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint160 from uint256, reverting on\n     * overflow (when the input is greater than largest uint160).\n     *\n     * Counterpart to Solidity's `uint160` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 160 bits\n     */\n    function toUint160(uint256 value) internal pure returns (uint160) {\n        if (value > type(uint160).max) {\n            revert SafeCastOverflowedUintDowncast(160, value);\n        }\n        return uint160(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint152 from uint256, reverting on\n     * overflow (when the input is greater than largest uint152).\n     *\n     * Counterpart to Solidity's `uint152` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 152 bits\n     */\n    function toUint152(uint256 value) internal pure returns (uint152) {\n        if (value > type(uint152).max) {\n            revert SafeCastOverflowedUintDowncast(152, value);\n        }\n        return uint152(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint144 from uint256, reverting on\n     * overflow (when the input is greater than largest uint144).\n     *\n     * Counterpart to Solidity's `uint144` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 144 bits\n     */\n    function toUint144(uint256 value) internal pure returns (uint144) {\n        if (value > type(uint144).max) {\n            revert SafeCastOverflowedUintDowncast(144, value);\n        }\n        return uint144(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint136 from uint256, reverting on\n     * overflow (when the input is greater than largest uint136).\n     *\n     * Counterpart to Solidity's `uint136` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 136 bits\n     */\n    function toUint136(uint256 value) internal pure returns (uint136) {\n        if (value > type(uint136).max) {\n            revert SafeCastOverflowedUintDowncast(136, value);\n        }\n        return uint136(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint128 from uint256, reverting on\n     * overflow (when the input is greater than largest uint128).\n     *\n     * Counterpart to Solidity's `uint128` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 128 bits\n     */\n    function toUint128(uint256 value) internal pure returns (uint128) {\n        if (value > type(uint128).max) {\n            revert SafeCastOverflowedUintDowncast(128, value);\n        }\n        return uint128(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint120 from uint256, reverting on\n     * overflow (when the input is greater than largest uint120).\n     *\n     * Counterpart to Solidity's `uint120` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 120 bits\n     */\n    function toUint120(uint256 value) internal pure returns (uint120) {\n        if (value > type(uint120).max) {\n            revert SafeCastOverflowedUintDowncast(120, value);\n        }\n        return uint120(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint112 from uint256, reverting on\n     * overflow (when the input is greater than largest uint112).\n     *\n     * Counterpart to Solidity's `uint112` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 112 bits\n     */\n    function toUint112(uint256 value) internal pure returns (uint112) {\n        if (value > type(uint112).max) {\n            revert SafeCastOverflowedUintDowncast(112, value);\n        }\n        return uint112(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint104 from uint256, reverting on\n     * overflow (when the input is greater than largest uint104).\n     *\n     * Counterpart to Solidity's `uint104` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 104 bits\n     */\n    function toUint104(uint256 value) internal pure returns (uint104) {\n        if (value > type(uint104).max) {\n            revert SafeCastOverflowedUintDowncast(104, value);\n        }\n        return uint104(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint96 from uint256, reverting on\n     * overflow (when the input is greater than largest uint96).\n     *\n     * Counterpart to Solidity's `uint96` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 96 bits\n     */\n    function toUint96(uint256 value) internal pure returns (uint96) {\n        if (value > type(uint96).max) {\n            revert SafeCastOverflowedUintDowncast(96, value);\n        }\n        return uint96(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint88 from uint256, reverting on\n     * overflow (when the input is greater than largest uint88).\n     *\n     * Counterpart to Solidity's `uint88` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 88 bits\n     */\n    function toUint88(uint256 value) internal pure returns (uint88) {\n        if (value > type(uint88).max) {\n            revert SafeCastOverflowedUintDowncast(88, value);\n        }\n        return uint88(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint80 from uint256, reverting on\n     * overflow (when the input is greater than largest uint80).\n     *\n     * Counterpart to Solidity's `uint80` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 80 bits\n     */\n    function toUint80(uint256 value) internal pure returns (uint80) {\n        if (value > type(uint80).max) {\n            revert SafeCastOverflowedUintDowncast(80, value);\n        }\n        return uint80(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint72 from uint256, reverting on\n     * overflow (when the input is greater than largest uint72).\n     *\n     * Counterpart to Solidity's `uint72` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 72 bits\n     */\n    function toUint72(uint256 value) internal pure returns (uint72) {\n        if (value > type(uint72).max) {\n            revert SafeCastOverflowedUintDowncast(72, value);\n        }\n        return uint72(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint64 from uint256, reverting on\n     * overflow (when the input is greater than largest uint64).\n     *\n     * Counterpart to Solidity's `uint64` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 64 bits\n     */\n    function toUint64(uint256 value) internal pure returns (uint64) {\n        if (value > type(uint64).max) {\n            revert SafeCastOverflowedUintDowncast(64, value);\n        }\n        return uint64(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint56 from uint256, reverting on\n     * overflow (when the input is greater than largest uint56).\n     *\n     * Counterpart to Solidity's `uint56` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 56 bits\n     */\n    function toUint56(uint256 value) internal pure returns (uint56) {\n        if (value > type(uint56).max) {\n            revert SafeCastOverflowedUintDowncast(56, value);\n        }\n        return uint56(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint48 from uint256, reverting on\n     * overflow (when the input is greater than largest uint48).\n     *\n     * Counterpart to Solidity's `uint48` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 48 bits\n     */\n    function toUint48(uint256 value) internal pure returns (uint48) {\n        if (value > type(uint48).max) {\n            revert SafeCastOverflowedUintDowncast(48, value);\n        }\n        return uint48(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint40 from uint256, reverting on\n     * overflow (when the input is greater than largest uint40).\n     *\n     * Counterpart to Solidity's `uint40` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 40 bits\n     */\n    function toUint40(uint256 value) internal pure returns (uint40) {\n        if (value > type(uint40).max) {\n            revert SafeCastOverflowedUintDowncast(40, value);\n        }\n        return uint40(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint32 from uint256, reverting on\n     * overflow (when the input is greater than largest uint32).\n     *\n     * Counterpart to Solidity's `uint32` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 32 bits\n     */\n    function toUint32(uint256 value) internal pure returns (uint32) {\n        if (value > type(uint32).max) {\n            revert SafeCastOverflowedUintDowncast(32, value);\n        }\n        return uint32(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint24 from uint256, reverting on\n     * overflow (when the input is greater than largest uint24).\n     *\n     * Counterpart to Solidity's `uint24` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 24 bits\n     */\n    function toUint24(uint256 value) internal pure returns (uint24) {\n        if (value > type(uint24).max) {\n            revert SafeCastOverflowedUintDowncast(24, value);\n        }\n        return uint24(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint16 from uint256, reverting on\n     * overflow (when the input is greater than largest uint16).\n     *\n     * Counterpart to Solidity's `uint16` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 16 bits\n     */\n    function toUint16(uint256 value) internal pure returns (uint16) {\n        if (value > type(uint16).max) {\n            revert SafeCastOverflowedUintDowncast(16, value);\n        }\n        return uint16(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint8 from uint256, reverting on\n     * overflow (when the input is greater than largest uint8).\n     *\n     * Counterpart to Solidity's `uint8` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 8 bits\n     */\n    function toUint8(uint256 value) internal pure returns (uint8) {\n        if (value > type(uint8).max) {\n            revert SafeCastOverflowedUintDowncast(8, value);\n        }\n        return uint8(value);\n    }\n\n    /**\n     * @dev Converts a signed int256 into an unsigned uint256.\n     *\n     * Requirements:\n     *\n     * - input must be greater than or equal to 0.\n     */\n    function toUint256(int256 value) internal pure returns (uint256) {\n        if (value < 0) {\n            revert SafeCastOverflowedIntToUint(value);\n        }\n        return uint256(value);\n    }\n\n    /**\n     * @dev Returns the downcasted int248 from int256, reverting on\n     * overflow (when the input is less than smallest int248 or\n     * greater than largest int248).\n     *\n     * Counterpart to Solidity's `int248` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 248 bits\n     */\n    function toInt248(int256 value) internal pure returns (int248 downcasted) {\n        downcasted = int248(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(248, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int240 from int256, reverting on\n     * overflow (when the input is less than smallest int240 or\n     * greater than largest int240).\n     *\n     * Counterpart to Solidity's `int240` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 240 bits\n     */\n    function toInt240(int256 value) internal pure returns (int240 downcasted) {\n        downcasted = int240(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(240, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int232 from int256, reverting on\n     * overflow (when the input is less than smallest int232 or\n     * greater than largest int232).\n     *\n     * Counterpart to Solidity's `int232` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 232 bits\n     */\n    function toInt232(int256 value) internal pure returns (int232 downcasted) {\n        downcasted = int232(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(232, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int224 from int256, reverting on\n     * overflow (when the input is less than smallest int224 or\n     * greater than largest int224).\n     *\n     * Counterpart to Solidity's `int224` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 224 bits\n     */\n    function toInt224(int256 value) internal pure returns (int224 downcasted) {\n        downcasted = int224(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(224, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int216 from int256, reverting on\n     * overflow (when the input is less than smallest int216 or\n     * greater than largest int216).\n     *\n     * Counterpart to Solidity's `int216` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 216 bits\n     */\n    function toInt216(int256 value) internal pure returns (int216 downcasted) {\n        downcasted = int216(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(216, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int208 from int256, reverting on\n     * overflow (when the input is less than smallest int208 or\n     * greater than largest int208).\n     *\n     * Counterpart to Solidity's `int208` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 208 bits\n     */\n    function toInt208(int256 value) internal pure returns (int208 downcasted) {\n        downcasted = int208(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(208, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int200 from int256, reverting on\n     * overflow (when the input is less than smallest int200 or\n     * greater than largest int200).\n     *\n     * Counterpart to Solidity's `int200` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 200 bits\n     */\n    function toInt200(int256 value) internal pure returns (int200 downcasted) {\n        downcasted = int200(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(200, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int192 from int256, reverting on\n     * overflow (when the input is less than smallest int192 or\n     * greater than largest int192).\n     *\n     * Counterpart to Solidity's `int192` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 192 bits\n     */\n    function toInt192(int256 value) internal pure returns (int192 downcasted) {\n        downcasted = int192(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(192, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int184 from int256, reverting on\n     * overflow (when the input is less than smallest int184 or\n     * greater than largest int184).\n     *\n     * Counterpart to Solidity's `int184` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 184 bits\n     */\n    function toInt184(int256 value) internal pure returns (int184 downcasted) {\n        downcasted = int184(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(184, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int176 from int256, reverting on\n     * overflow (when the input is less than smallest int176 or\n     * greater than largest int176).\n     *\n     * Counterpart to Solidity's `int176` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 176 bits\n     */\n    function toInt176(int256 value) internal pure returns (int176 downcasted) {\n        downcasted = int176(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(176, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int168 from int256, reverting on\n     * overflow (when the input is less than smallest int168 or\n     * greater than largest int168).\n     *\n     * Counterpart to Solidity's `int168` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 168 bits\n     */\n    function toInt168(int256 value) internal pure returns (int168 downcasted) {\n        downcasted = int168(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(168, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int160 from int256, reverting on\n     * overflow (when the input is less than smallest int160 or\n     * greater than largest int160).\n     *\n     * Counterpart to Solidity's `int160` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 160 bits\n     */\n    function toInt160(int256 value) internal pure returns (int160 downcasted) {\n        downcasted = int160(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(160, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int152 from int256, reverting on\n     * overflow (when the input is less than smallest int152 or\n     * greater than largest int152).\n     *\n     * Counterpart to Solidity's `int152` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 152 bits\n     */\n    function toInt152(int256 value) internal pure returns (int152 downcasted) {\n        downcasted = int152(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(152, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int144 from int256, reverting on\n     * overflow (when the input is less than smallest int144 or\n     * greater than largest int144).\n     *\n     * Counterpart to Solidity's `int144` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 144 bits\n     */\n    function toInt144(int256 value) internal pure returns (int144 downcasted) {\n        downcasted = int144(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(144, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int136 from int256, reverting on\n     * overflow (when the input is less than smallest int136 or\n     * greater than largest int136).\n     *\n     * Counterpart to Solidity's `int136` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 136 bits\n     */\n    function toInt136(int256 value) internal pure returns (int136 downcasted) {\n        downcasted = int136(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(136, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int128 from int256, reverting on\n     * overflow (when the input is less than smallest int128 or\n     * greater than largest int128).\n     *\n     * Counterpart to Solidity's `int128` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 128 bits\n     */\n    function toInt128(int256 value) internal pure returns (int128 downcasted) {\n        downcasted = int128(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(128, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int120 from int256, reverting on\n     * overflow (when the input is less than smallest int120 or\n     * greater than largest int120).\n     *\n     * Counterpart to Solidity's `int120` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 120 bits\n     */\n    function toInt120(int256 value) internal pure returns (int120 downcasted) {\n        downcasted = int120(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(120, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int112 from int256, reverting on\n     * overflow (when the input is less than smallest int112 or\n     * greater than largest int112).\n     *\n     * Counterpart to Solidity's `int112` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 112 bits\n     */\n    function toInt112(int256 value) internal pure returns (int112 downcasted) {\n        downcasted = int112(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(112, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int104 from int256, reverting on\n     * overflow (when the input is less than smallest int104 or\n     * greater than largest int104).\n     *\n     * Counterpart to Solidity's `int104` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 104 bits\n     */\n    function toInt104(int256 value) internal pure returns (int104 downcasted) {\n        downcasted = int104(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(104, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int96 from int256, reverting on\n     * overflow (when the input is less than smallest int96 or\n     * greater than largest int96).\n     *\n     * Counterpart to Solidity's `int96` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 96 bits\n     */\n    function toInt96(int256 value) internal pure returns (int96 downcasted) {\n        downcasted = int96(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(96, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int88 from int256, reverting on\n     * overflow (when the input is less than smallest int88 or\n     * greater than largest int88).\n     *\n     * Counterpart to Solidity's `int88` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 88 bits\n     */\n    function toInt88(int256 value) internal pure returns (int88 downcasted) {\n        downcasted = int88(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(88, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int80 from int256, reverting on\n     * overflow (when the input is less than smallest int80 or\n     * greater than largest int80).\n     *\n     * Counterpart to Solidity's `int80` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 80 bits\n     */\n    function toInt80(int256 value) internal pure returns (int80 downcasted) {\n        downcasted = int80(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(80, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int72 from int256, reverting on\n     * overflow (when the input is less than smallest int72 or\n     * greater than largest int72).\n     *\n     * Counterpart to Solidity's `int72` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 72 bits\n     */\n    function toInt72(int256 value) internal pure returns (int72 downcasted) {\n        downcasted = int72(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(72, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int64 from int256, reverting on\n     * overflow (when the input is less than smallest int64 or\n     * greater than largest int64).\n     *\n     * Counterpart to Solidity's `int64` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 64 bits\n     */\n    function toInt64(int256 value) internal pure returns (int64 downcasted) {\n        downcasted = int64(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(64, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int56 from int256, reverting on\n     * overflow (when the input is less than smallest int56 or\n     * greater than largest int56).\n     *\n     * Counterpart to Solidity's `int56` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 56 bits\n     */\n    function toInt56(int256 value) internal pure returns (int56 downcasted) {\n        downcasted = int56(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(56, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int48 from int256, reverting on\n     * overflow (when the input is less than smallest int48 or\n     * greater than largest int48).\n     *\n     * Counterpart to Solidity's `int48` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 48 bits\n     */\n    function toInt48(int256 value) internal pure returns (int48 downcasted) {\n        downcasted = int48(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(48, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int40 from int256, reverting on\n     * overflow (when the input is less than smallest int40 or\n     * greater than largest int40).\n     *\n     * Counterpart to Solidity's `int40` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 40 bits\n     */\n    function toInt40(int256 value) internal pure returns (int40 downcasted) {\n        downcasted = int40(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(40, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int32 from int256, reverting on\n     * overflow (when the input is less than smallest int32 or\n     * greater than largest int32).\n     *\n     * Counterpart to Solidity's `int32` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 32 bits\n     */\n    function toInt32(int256 value) internal pure returns (int32 downcasted) {\n        downcasted = int32(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(32, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int24 from int256, reverting on\n     * overflow (when the input is less than smallest int24 or\n     * greater than largest int24).\n     *\n     * Counterpart to Solidity's `int24` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 24 bits\n     */\n    function toInt24(int256 value) internal pure returns (int24 downcasted) {\n        downcasted = int24(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(24, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int16 from int256, reverting on\n     * overflow (when the input is less than smallest int16 or\n     * greater than largest int16).\n     *\n     * Counterpart to Solidity's `int16` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 16 bits\n     */\n    function toInt16(int256 value) internal pure returns (int16 downcasted) {\n        downcasted = int16(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(16, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int8 from int256, reverting on\n     * overflow (when the input is less than smallest int8 or\n     * greater than largest int8).\n     *\n     * Counterpart to Solidity's `int8` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 8 bits\n     */\n    function toInt8(int256 value) internal pure returns (int8 downcasted) {\n        downcasted = int8(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(8, value);\n        }\n    }\n\n    /**\n     * @dev Converts an unsigned uint256 into a signed int256.\n     *\n     * Requirements:\n     *\n     * - input must be less than or equal to maxInt256.\n     */\n    function toInt256(uint256 value) internal pure returns (int256) {\n        // Note: Unsafe cast below is okay because `type(int256).max` is guaranteed to be positive\n        if (value > uint256(type(int256).max)) {\n            revert SafeCastOverflowedUintToInt(value);\n        }\n        return int256(value);\n    }\n\n    /**\n     * @dev Cast a boolean (false or true) to a uint256 (0 or 1) with no jump.\n     */\n    function toUint(bool b) internal pure returns (uint256 u) {\n        assembly (\"memory-safe\") {\n            u := iszero(iszero(b))\n        }\n    }\n}\n"},"lib/openzeppelin-contracts/contracts/utils/structs/EnumerableSet.sol":{"content":"// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.1.0) (utils/structs/EnumerableSet.sol)\n// This file was procedurally generated from scripts/generate/templates/EnumerableSet.js.\n\npragma solidity ^0.8.20;\n\n/**\n * @dev Library for managing\n * https://en.wikipedia.org/wiki/Set_(abstract_data_type)[sets] of primitive\n * types.\n *\n * Sets have the following properties:\n *\n * - Elements are added, removed, and checked for existence in constant time\n * (O(1)).\n * - Elements are enumerated in O(n). No guarantees are made on the ordering.\n *\n * ```solidity\n * contract Example {\n *     // Add the library methods\n *     using EnumerableSet for EnumerableSet.AddressSet;\n *\n *     // Declare a set state variable\n *     EnumerableSet.AddressSet private mySet;\n * }\n * ```\n *\n * As of v3.3.0, sets of type `bytes32` (`Bytes32Set`), `address` (`AddressSet`)\n * and `uint256` (`UintSet`) are supported.\n *\n * [WARNING]\n * ====\n * Trying to delete such a structure from storage will likely result in data corruption, rendering the structure\n * unusable.\n * See https://github.com/ethereum/solidity/pull/11843[ethereum/solidity#11843] for more info.\n *\n * In order to clean an EnumerableSet, you can either remove all elements one by one or create a fresh instance using an\n * array of EnumerableSet.\n * ====\n */\nlibrary EnumerableSet {\n    // To implement this library for multiple types with as little code\n    // repetition as possible, we write it in terms of a generic Set type with\n    // bytes32 values.\n    // The Set implementation uses private functions, and user-facing\n    // implementations (such as AddressSet) are just wrappers around the\n    // underlying Set.\n    // This means that we can only create new EnumerableSets for types that fit\n    // in bytes32.\n\n    struct Set {\n        // Storage of set values\n        bytes32[] _values;\n        // Position is the index of the value in the `values` array plus 1.\n        // Position 0 is used to mean a value is not in the set.\n        mapping(bytes32 value => uint256) _positions;\n    }\n\n    /**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     */\n    function _add(Set storage set, bytes32 value) private returns (bool) {\n        if (!_contains(set, value)) {\n            set._values.push(value);\n            // The value is stored at length-1, but we add 1 to all indexes\n            // and use 0 as a sentinel value\n            set._positions[value] = set._values.length;\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     */\n    function _remove(Set storage set, bytes32 value) private returns (bool) {\n        // We cache the value's position to prevent multiple reads from the same storage slot\n        uint256 position = set._positions[value];\n\n        if (position != 0) {\n            // Equivalent to contains(set, value)\n            // To delete an element from the _values array in O(1), we swap the element to delete with the last one in\n            // the array, and then remove the last element (sometimes called as 'swap and pop').\n            // This modifies the order of the array, as noted in {at}.\n\n            uint256 valueIndex = position - 1;\n            uint256 lastIndex = set._values.length - 1;\n\n            if (valueIndex != lastIndex) {\n                bytes32 lastValue = set._values[lastIndex];\n\n                // Move the lastValue to the index where the value to delete is\n                set._values[valueIndex] = lastValue;\n                // Update the tracked position of the lastValue (that was just moved)\n                set._positions[lastValue] = position;\n            }\n\n            // Delete the slot where the moved value was stored\n            set._values.pop();\n\n            // Delete the tracked position for the deleted slot\n            delete set._positions[value];\n\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n    /**\n     * @dev Returns true if the value is in the set. O(1).\n     */\n    function _contains(Set storage set, bytes32 value) private view returns (bool) {\n        return set._positions[value] != 0;\n    }\n\n    /**\n     * @dev Returns the number of values on the set. O(1).\n     */\n    function _length(Set storage set) private view returns (uint256) {\n        return set._values.length;\n    }\n\n    /**\n     * @dev Returns the value stored at position `index` in the set. O(1).\n     *\n     * Note that there are no guarantees on the ordering of values inside the\n     * array, and it may change when more values are added or removed.\n     *\n     * Requirements:\n     *\n     * - `index` must be strictly less than {length}.\n     */\n    function _at(Set storage set, uint256 index) private view returns (bytes32) {\n        return set._values[index];\n    }\n\n    /**\n     * @dev Return the entire set in an array\n     *\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\n     */\n    function _values(Set storage set) private view returns (bytes32[] memory) {\n        return set._values;\n    }\n\n    // Bytes32Set\n\n    struct Bytes32Set {\n        Set _inner;\n    }\n\n    /**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     */\n    function add(Bytes32Set storage set, bytes32 value) internal returns (bool) {\n        return _add(set._inner, value);\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     */\n    function remove(Bytes32Set storage set, bytes32 value) internal returns (bool) {\n        return _remove(set._inner, value);\n    }\n\n    /**\n     * @dev Returns true if the value is in the set. O(1).\n     */\n    function contains(Bytes32Set storage set, bytes32 value) internal view returns (bool) {\n        return _contains(set._inner, value);\n    }\n\n    /**\n     * @dev Returns the number of values in the set. O(1).\n     */\n    function length(Bytes32Set storage set) internal view returns (uint256) {\n        return _length(set._inner);\n    }\n\n    /**\n     * @dev Returns the value stored at position `index` in the set. O(1).\n     *\n     * Note that there are no guarantees on the ordering of values inside the\n     * array, and it may change when more values are added or removed.\n     *\n     * Requirements:\n     *\n     * - `index` must be strictly less than {length}.\n     */\n    function at(Bytes32Set storage set, uint256 index) internal view returns (bytes32) {\n        return _at(set._inner, index);\n    }\n\n    /**\n     * @dev Return the entire set in an array\n     *\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\n     */\n    function values(Bytes32Set storage set) internal view returns (bytes32[] memory) {\n        bytes32[] memory store = _values(set._inner);\n        bytes32[] memory result;\n\n        assembly (\"memory-safe\") {\n            result := store\n        }\n\n        return result;\n    }\n\n    // AddressSet\n\n    struct AddressSet {\n        Set _inner;\n    }\n\n    /**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     */\n    function add(AddressSet storage set, address value) internal returns (bool) {\n        return _add(set._inner, bytes32(uint256(uint160(value))));\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     */\n    function remove(AddressSet storage set, address value) internal returns (bool) {\n        return _remove(set._inner, bytes32(uint256(uint160(value))));\n    }\n\n    /**\n     * @dev Returns true if the value is in the set. O(1).\n     */\n    function contains(AddressSet storage set, address value) internal view returns (bool) {\n        return _contains(set._inner, bytes32(uint256(uint160(value))));\n    }\n\n    /**\n     * @dev Returns the number of values in the set. O(1).\n     */\n    function length(AddressSet storage set) internal view returns (uint256) {\n        return _length(set._inner);\n    }\n\n    /**\n     * @dev Returns the value stored at position `index` in the set. O(1).\n     *\n     * Note that there are no guarantees on the ordering of values inside the\n     * array, and it may change when more values are added or removed.\n     *\n     * Requirements:\n     *\n     * - `index` must be strictly less than {length}.\n     */\n    function at(AddressSet storage set, uint256 index) internal view returns (address) {\n        return address(uint160(uint256(_at(set._inner, index))));\n    }\n\n    /**\n     * @dev Return the entire set in an array\n     *\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\n     */\n    function values(AddressSet storage set) internal view returns (address[] memory) {\n        bytes32[] memory store = _values(set._inner);\n        address[] memory result;\n\n        assembly (\"memory-safe\") {\n            result := store\n        }\n\n        return result;\n    }\n\n    // UintSet\n\n    struct UintSet {\n        Set _inner;\n    }\n\n    /**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     */\n    function add(UintSet storage set, uint256 value) internal returns (bool) {\n        return _add(set._inner, bytes32(value));\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     */\n    function remove(UintSet storage set, uint256 value) internal returns (bool) {\n        return _remove(set._inner, bytes32(value));\n    }\n\n    /**\n     * @dev Returns true if the value is in the set. O(1).\n     */\n    function contains(UintSet storage set, uint256 value) internal view returns (bool) {\n        return _contains(set._inner, bytes32(value));\n    }\n\n    /**\n     * @dev Returns the number of values in the set. O(1).\n     */\n    function length(UintSet storage set) internal view returns (uint256) {\n        return _length(set._inner);\n    }\n\n    /**\n     * @dev Returns the value stored at position `index` in the set. O(1).\n     *\n     * Note that there are no guarantees on the ordering of values inside the\n     * array, and it may change when more values are added or removed.\n     *\n     * Requirements:\n     *\n     * - `index` must be strictly less than {length}.\n     */\n    function at(UintSet storage set, uint256 index) internal view returns (uint256) {\n        return uint256(_at(set._inner, index));\n    }\n\n    /**\n     * @dev Return the entire set in an array\n     *\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\n     */\n    function values(UintSet storage set) internal view returns (uint256[] memory) {\n        bytes32[] memory store = _values(set._inner);\n        uint256[] memory result;\n\n        assembly (\"memory-safe\") {\n            result := store\n        }\n\n        return result;\n    }\n}\n"},"lib/v4-core/lib/solmate/src/auth/Owned.sol":{"content":"// SPDX-License-Identifier: AGPL-3.0-only\npragma solidity >=0.8.0;\n\n/// @notice Simple single owner authorization mixin.\n/// @author Solmate (https://github.com/transmissions11/solmate/blob/main/src/auth/Owned.sol)\nabstract contract Owned {\n    /*//////////////////////////////////////////////////////////////\n                                 EVENTS\n    //////////////////////////////////////////////////////////////*/\n\n    event OwnershipTransferred(address indexed user, address indexed newOwner);\n\n    /*//////////////////////////////////////////////////////////////\n                            OWNERSHIP STORAGE\n    //////////////////////////////////////////////////////////////*/\n\n    address public owner;\n\n    modifier onlyOwner() virtual {\n        require(msg.sender == owner, \"UNAUTHORIZED\");\n\n        _;\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                               CONSTRUCTOR\n    //////////////////////////////////////////////////////////////*/\n\n    constructor(address _owner) {\n        owner = _owner;\n\n        emit OwnershipTransferred(address(0), _owner);\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                             OWNERSHIP LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n    function transferOwnership(address newOwner) public virtual onlyOwner {\n        owner = newOwner;\n\n        emit OwnershipTransferred(msg.sender, newOwner);\n    }\n}\n"},"lib/v4-core/lib/solmate/src/test/utils/mocks/MockERC20.sol":{"content":"// SPDX-License-Identifier: AGPL-3.0-only\npragma solidity >=0.8.0;\n\nimport {ERC20} from \"../../../tokens/ERC20.sol\";\n\ncontract MockERC20 is ERC20 {\n    constructor(\n        string memory _name,\n        string memory _symbol,\n        uint8 _decimals\n    ) ERC20(_name, _symbol, _decimals) {}\n\n    function mint(address to, uint256 value) public virtual {\n        _mint(to, value);\n    }\n\n    function burn(address from, uint256 value) public virtual {\n        _burn(from, value);\n    }\n}\n"},"lib/v4-core/lib/solmate/src/tokens/ERC20.sol":{"content":"// SPDX-License-Identifier: AGPL-3.0-only\npragma solidity >=0.8.0;\n\n/// @notice Modern and gas efficient ERC20 + EIP-2612 implementation.\n/// @author Solmate (https://github.com/transmissions11/solmate/blob/main/src/tokens/ERC20.sol)\n/// @author Modified from Uniswap (https://github.com/Uniswap/uniswap-v2-core/blob/master/contracts/UniswapV2ERC20.sol)\n/// @dev Do not manually set balances without updating totalSupply, as the sum of all user balances must not exceed it.\nabstract contract ERC20 {\n    /*//////////////////////////////////////////////////////////////\n                                 EVENTS\n    //////////////////////////////////////////////////////////////*/\n\n    event Transfer(address indexed from, address indexed to, uint256 amount);\n\n    event Approval(address indexed owner, address indexed spender, uint256 amount);\n\n    /*//////////////////////////////////////////////////////////////\n                            METADATA STORAGE\n    //////////////////////////////////////////////////////////////*/\n\n    string public name;\n\n    string public symbol;\n\n    uint8 public immutable decimals;\n\n    /*//////////////////////////////////////////////////////////////\n                              ERC20 STORAGE\n    //////////////////////////////////////////////////////////////*/\n\n    uint256 public totalSupply;\n\n    mapping(address => uint256) public balanceOf;\n\n    mapping(address => mapping(address => uint256)) public allowance;\n\n    /*//////////////////////////////////////////////////////////////\n                            EIP-2612 STORAGE\n    //////////////////////////////////////////////////////////////*/\n\n    uint256 internal immutable INITIAL_CHAIN_ID;\n\n    bytes32 internal immutable INITIAL_DOMAIN_SEPARATOR;\n\n    mapping(address => uint256) public nonces;\n\n    /*//////////////////////////////////////////////////////////////\n                               CONSTRUCTOR\n    //////////////////////////////////////////////////////////////*/\n\n    constructor(\n        string memory _name,\n        string memory _symbol,\n        uint8 _decimals\n    ) {\n        name = _name;\n        symbol = _symbol;\n        decimals = _decimals;\n\n        INITIAL_CHAIN_ID = block.chainid;\n        INITIAL_DOMAIN_SEPARATOR = computeDomainSeparator();\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                               ERC20 LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n    function approve(address spender, uint256 amount) public virtual returns (bool) {\n        allowance[msg.sender][spender] = amount;\n\n        emit Approval(msg.sender, spender, amount);\n\n        return true;\n    }\n\n    function transfer(address to, uint256 amount) public virtual returns (bool) {\n        balanceOf[msg.sender] -= amount;\n\n        // Cannot overflow because the sum of all user\n        // balances can't exceed the max uint256 value.\n        unchecked {\n            balanceOf[to] += amount;\n        }\n\n        emit Transfer(msg.sender, to, amount);\n\n        return true;\n    }\n\n    function transferFrom(\n        address from,\n        address to,\n        uint256 amount\n    ) public virtual returns (bool) {\n        uint256 allowed = allowance[from][msg.sender]; // Saves gas for limited approvals.\n\n        if (allowed != type(uint256).max) allowance[from][msg.sender] = allowed - amount;\n\n        balanceOf[from] -= amount;\n\n        // Cannot overflow because the sum of all user\n        // balances can't exceed the max uint256 value.\n        unchecked {\n            balanceOf[to] += amount;\n        }\n\n        emit Transfer(from, to, amount);\n\n        return true;\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                             EIP-2612 LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n    function permit(\n        address owner,\n        address spender,\n        uint256 value,\n        uint256 deadline,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) public virtual {\n        require(deadline >= block.timestamp, \"PERMIT_DEADLINE_EXPIRED\");\n\n        // Unchecked because the only math done is incrementing\n        // the owner's nonce which cannot realistically overflow.\n        unchecked {\n            address recoveredAddress = ecrecover(\n                keccak256(\n                    abi.encodePacked(\n                        \"\\x19\\x01\",\n                        DOMAIN_SEPARATOR(),\n                        keccak256(\n                            abi.encode(\n                                keccak256(\n                                    \"Permit(address owner,address spender,uint256 value,uint256 nonce,uint256 deadline)\"\n                                ),\n                                owner,\n                                spender,\n                                value,\n                                nonces[owner]++,\n                                deadline\n                            )\n                        )\n                    )\n                ),\n                v,\n                r,\n                s\n            );\n\n            require(recoveredAddress != address(0) && recoveredAddress == owner, \"INVALID_SIGNER\");\n\n            allowance[recoveredAddress][spender] = value;\n        }\n\n        emit Approval(owner, spender, value);\n    }\n\n    function DOMAIN_SEPARATOR() public view virtual returns (bytes32) {\n        return block.chainid == INITIAL_CHAIN_ID ? INITIAL_DOMAIN_SEPARATOR : computeDomainSeparator();\n    }\n\n    function computeDomainSeparator() internal view virtual returns (bytes32) {\n        return\n            keccak256(\n                abi.encode(\n                    keccak256(\"EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)\"),\n                    keccak256(bytes(name)),\n                    keccak256(\"1\"),\n                    block.chainid,\n                    address(this)\n                )\n            );\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                        INTERNAL MINT/BURN LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n    function _mint(address to, uint256 amount) internal virtual {\n        totalSupply += amount;\n\n        // Cannot overflow because the sum of all user\n        // balances can't exceed the max uint256 value.\n        unchecked {\n            balanceOf[to] += amount;\n        }\n\n        emit Transfer(address(0), to, amount);\n    }\n\n    function _burn(address from, uint256 amount) internal virtual {\n        balanceOf[from] -= amount;\n\n        // Cannot underflow because a user's balance\n        // will never be larger than the total supply.\n        unchecked {\n            totalSupply -= amount;\n        }\n\n        emit Transfer(from, address(0), amount);\n    }\n}\n"},"lib/v4-core/lib/solmate/src/tokens/ERC721.sol":{"content":"// SPDX-License-Identifier: AGPL-3.0-only\npragma solidity >=0.8.0;\n\n/// @notice Modern, minimalist, and gas efficient ERC-721 implementation.\n/// @author Solmate (https://github.com/transmissions11/solmate/blob/main/src/tokens/ERC721.sol)\nabstract contract ERC721 {\n    /*//////////////////////////////////////////////////////////////\n                                 EVENTS\n    //////////////////////////////////////////////////////////////*/\n\n    event Transfer(address indexed from, address indexed to, uint256 indexed id);\n\n    event Approval(address indexed owner, address indexed spender, uint256 indexed id);\n\n    event ApprovalForAll(address indexed owner, address indexed operator, bool approved);\n\n    /*//////////////////////////////////////////////////////////////\n                         METADATA STORAGE/LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n    string public name;\n\n    string public symbol;\n\n    function tokenURI(uint256 id) public view virtual returns (string memory);\n\n    /*//////////////////////////////////////////////////////////////\n                      ERC721 BALANCE/OWNER STORAGE\n    //////////////////////////////////////////////////////////////*/\n\n    mapping(uint256 => address) internal _ownerOf;\n\n    mapping(address => uint256) internal _balanceOf;\n\n    function ownerOf(uint256 id) public view virtual returns (address owner) {\n        require((owner = _ownerOf[id]) != address(0), \"NOT_MINTED\");\n    }\n\n    function balanceOf(address owner) public view virtual returns (uint256) {\n        require(owner != address(0), \"ZERO_ADDRESS\");\n\n        return _balanceOf[owner];\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                         ERC721 APPROVAL STORAGE\n    //////////////////////////////////////////////////////////////*/\n\n    mapping(uint256 => address) public getApproved;\n\n    mapping(address => mapping(address => bool)) public isApprovedForAll;\n\n    /*//////////////////////////////////////////////////////////////\n                               CONSTRUCTOR\n    //////////////////////////////////////////////////////////////*/\n\n    constructor(string memory _name, string memory _symbol) {\n        name = _name;\n        symbol = _symbol;\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                              ERC721 LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n    function approve(address spender, uint256 id) public virtual {\n        address owner = _ownerOf[id];\n\n        require(msg.sender == owner || isApprovedForAll[owner][msg.sender], \"NOT_AUTHORIZED\");\n\n        getApproved[id] = spender;\n\n        emit Approval(owner, spender, id);\n    }\n\n    function setApprovalForAll(address operator, bool approved) public virtual {\n        isApprovedForAll[msg.sender][operator] = approved;\n\n        emit ApprovalForAll(msg.sender, operator, approved);\n    }\n\n    function transferFrom(\n        address from,\n        address to,\n        uint256 id\n    ) public virtual {\n        require(from == _ownerOf[id], \"WRONG_FROM\");\n\n        require(to != address(0), \"INVALID_RECIPIENT\");\n\n        require(\n            msg.sender == from || isApprovedForAll[from][msg.sender] || msg.sender == getApproved[id],\n            \"NOT_AUTHORIZED\"\n        );\n\n        // Underflow of the sender's balance is impossible because we check for\n        // ownership above and the recipient's balance can't realistically overflow.\n        unchecked {\n            _balanceOf[from]--;\n\n            _balanceOf[to]++;\n        }\n\n        _ownerOf[id] = to;\n\n        delete getApproved[id];\n\n        emit Transfer(from, to, id);\n    }\n\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 id\n    ) public virtual {\n        transferFrom(from, to, id);\n\n        require(\n            to.code.length == 0 ||\n                ERC721TokenReceiver(to).onERC721Received(msg.sender, from, id, \"\") ==\n                ERC721TokenReceiver.onERC721Received.selector,\n            \"UNSAFE_RECIPIENT\"\n        );\n    }\n\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 id,\n        bytes calldata data\n    ) public virtual {\n        transferFrom(from, to, id);\n\n        require(\n            to.code.length == 0 ||\n                ERC721TokenReceiver(to).onERC721Received(msg.sender, from, id, data) ==\n                ERC721TokenReceiver.onERC721Received.selector,\n            \"UNSAFE_RECIPIENT\"\n        );\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                              ERC165 LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n    function supportsInterface(bytes4 interfaceId) public view virtual returns (bool) {\n        return\n            interfaceId == 0x01ffc9a7 || // ERC165 Interface ID for ERC165\n            interfaceId == 0x80ac58cd || // ERC165 Interface ID for ERC721\n            interfaceId == 0x5b5e139f; // ERC165 Interface ID for ERC721Metadata\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                        INTERNAL MINT/BURN LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n    function _mint(address to, uint256 id) internal virtual {\n        require(to != address(0), \"INVALID_RECIPIENT\");\n\n        require(_ownerOf[id] == address(0), \"ALREADY_MINTED\");\n\n        // Counter overflow is incredibly unrealistic.\n        unchecked {\n            _balanceOf[to]++;\n        }\n\n        _ownerOf[id] = to;\n\n        emit Transfer(address(0), to, id);\n    }\n\n    function _burn(uint256 id) internal virtual {\n        address owner = _ownerOf[id];\n\n        require(owner != address(0), \"NOT_MINTED\");\n\n        // Ownership check above ensures no underflow.\n        unchecked {\n            _balanceOf[owner]--;\n        }\n\n        delete _ownerOf[id];\n\n        delete getApproved[id];\n\n        emit Transfer(owner, address(0), id);\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                        INTERNAL SAFE MINT LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n    function _safeMint(address to, uint256 id) internal virtual {\n        _mint(to, id);\n\n        require(\n            to.code.length == 0 ||\n                ERC721TokenReceiver(to).onERC721Received(msg.sender, address(0), id, \"\") ==\n                ERC721TokenReceiver.onERC721Received.selector,\n            \"UNSAFE_RECIPIENT\"\n        );\n    }\n\n    function _safeMint(\n        address to,\n        uint256 id,\n        bytes memory data\n    ) internal virtual {\n        _mint(to, id);\n\n        require(\n            to.code.length == 0 ||\n                ERC721TokenReceiver(to).onERC721Received(msg.sender, address(0), id, data) ==\n                ERC721TokenReceiver.onERC721Received.selector,\n            \"UNSAFE_RECIPIENT\"\n        );\n    }\n}\n\n/// @notice A generic interface for a contract which properly accepts ERC721 tokens.\n/// @author Solmate (https://github.com/transmissions11/solmate/blob/main/src/tokens/ERC721.sol)\nabstract contract ERC721TokenReceiver {\n    function onERC721Received(\n        address,\n        address,\n        uint256,\n        bytes calldata\n    ) external virtual returns (bytes4) {\n        return ERC721TokenReceiver.onERC721Received.selector;\n    }\n}\n"},"lib/v4-core/src/libraries/BitMath.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\n/// @title BitMath\n/// @dev This library provides functionality for computing bit properties of an unsigned integer\n/// @author Solady (https://github.com/Vectorized/solady/blob/8200a70e8dc2a77ecb074fc2e99a2a0d36547522/src/utils/LibBit.sol)\nlibrary BitMath {\n    /// @notice Returns the index of the most significant bit of the number,\n    ///     where the least significant bit is at index 0 and the most significant bit is at index 255\n    /// @param x the value for which to compute the most significant bit, must be greater than 0\n    /// @return r the index of the most significant bit\n    function mostSignificantBit(uint256 x) internal pure returns (uint8 r) {\n        require(x > 0);\n\n        assembly (\"memory-safe\") {\n            r := shl(7, lt(0xffffffffffffffffffffffffffffffff, x))\n            r := or(r, shl(6, lt(0xffffffffffffffff, shr(r, x))))\n            r := or(r, shl(5, lt(0xffffffff, shr(r, x))))\n            r := or(r, shl(4, lt(0xffff, shr(r, x))))\n            r := or(r, shl(3, lt(0xff, shr(r, x))))\n            // forgefmt: disable-next-item\n            r := or(r, byte(and(0x1f, shr(shr(r, x), 0x8421084210842108cc6318c6db6d54be)),\n                0x0706060506020500060203020504000106050205030304010505030400000000))\n        }\n    }\n\n    /// @notice Returns the index of the least significant bit of the number,\n    ///     where the least significant bit is at index 0 and the most significant bit is at index 255\n    /// @param x the value for which to compute the least significant bit, must be greater than 0\n    /// @return r the index of the least significant bit\n    function leastSignificantBit(uint256 x) internal pure returns (uint8 r) {\n        require(x > 0);\n\n        assembly (\"memory-safe\") {\n            // Isolate the least significant bit.\n            x := and(x, sub(0, x))\n            // For the upper 3 bits of the result, use a De Bruijn-like lookup.\n            // Credit to adhusson: https://blog.adhusson.com/cheap-find-first-set-evm/\n            // forgefmt: disable-next-item\n            r := shl(5, shr(252, shl(shl(2, shr(250, mul(x,\n                0xb6db6db6ddddddddd34d34d349249249210842108c6318c639ce739cffffffff))),\n                0x8040405543005266443200005020610674053026020000107506200176117077)))\n            // For the lower 5 bits of the result, use a De Bruijn lookup.\n            // forgefmt: disable-next-item\n            r := or(r, byte(and(div(0xd76453e0, shr(r, x)), 0x1f),\n                0x001f0d1e100c1d070f090b19131c1706010e11080a1a141802121b1503160405))\n        }\n    }\n}\n"},"lib/v4-core/src/libraries/CustomRevert.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\n/// @title Library for reverting with custom errors efficiently\n/// @notice Contains functions for reverting with custom errors with different argument types efficiently\n/// @dev To use this library, declare `using CustomRevert for bytes4;` and replace `revert CustomError()` with\n/// `CustomError.selector.revertWith()`\n/// @dev The functions may tamper with the free memory pointer but it is fine since the call context is exited immediately\nlibrary CustomRevert {\n    /// @dev ERC-7751 error for wrapping bubbled up reverts\n    error WrappedError(address target, bytes4 selector, bytes reason, bytes details);\n\n    /// @dev Reverts with the selector of a custom error in the scratch space\n    function revertWith(bytes4 selector) internal pure {\n        assembly (\"memory-safe\") {\n            mstore(0, selector)\n            revert(0, 0x04)\n        }\n    }\n\n    /// @dev Reverts with a custom error with an address argument in the scratch space\n    function revertWith(bytes4 selector, address addr) internal pure {\n        assembly (\"memory-safe\") {\n            mstore(0, selector)\n            mstore(0x04, and(addr, 0xffffffffffffffffffffffffffffffffffffffff))\n            revert(0, 0x24)\n        }\n    }\n\n    /// @dev Reverts with a custom error with an int24 argument in the scratch space\n    function revertWith(bytes4 selector, int24 value) internal pure {\n        assembly (\"memory-safe\") {\n            mstore(0, selector)\n            mstore(0x04, signextend(2, value))\n            revert(0, 0x24)\n        }\n    }\n\n    /// @dev Reverts with a custom error with a uint160 argument in the scratch space\n    function revertWith(bytes4 selector, uint160 value) internal pure {\n        assembly (\"memory-safe\") {\n            mstore(0, selector)\n            mstore(0x04, and(value, 0xffffffffffffffffffffffffffffffffffffffff))\n            revert(0, 0x24)\n        }\n    }\n\n    /// @dev Reverts with a custom error with two int24 arguments\n    function revertWith(bytes4 selector, int24 value1, int24 value2) internal pure {\n        assembly (\"memory-safe\") {\n            let fmp := mload(0x40)\n            mstore(fmp, selector)\n            mstore(add(fmp, 0x04), signextend(2, value1))\n            mstore(add(fmp, 0x24), signextend(2, value2))\n            revert(fmp, 0x44)\n        }\n    }\n\n    /// @dev Reverts with a custom error with two uint160 arguments\n    function revertWith(bytes4 selector, uint160 value1, uint160 value2) internal pure {\n        assembly (\"memory-safe\") {\n            let fmp := mload(0x40)\n            mstore(fmp, selector)\n            mstore(add(fmp, 0x04), and(value1, 0xffffffffffffffffffffffffffffffffffffffff))\n            mstore(add(fmp, 0x24), and(value2, 0xffffffffffffffffffffffffffffffffffffffff))\n            revert(fmp, 0x44)\n        }\n    }\n\n    /// @dev Reverts with a custom error with two address arguments\n    function revertWith(bytes4 selector, address value1, address value2) internal pure {\n        assembly (\"memory-safe\") {\n            let fmp := mload(0x40)\n            mstore(fmp, selector)\n            mstore(add(fmp, 0x04), and(value1, 0xffffffffffffffffffffffffffffffffffffffff))\n            mstore(add(fmp, 0x24), and(value2, 0xffffffffffffffffffffffffffffffffffffffff))\n            revert(fmp, 0x44)\n        }\n    }\n\n    /// @notice bubble up the revert message returned by a call and revert with a wrapped ERC-7751 error\n    /// @dev this method can be vulnerable to revert data bombs\n    function bubbleUpAndRevertWith(\n        address revertingContract,\n        bytes4 revertingFunctionSelector,\n        bytes4 additionalContext\n    ) internal pure {\n        bytes4 wrappedErrorSelector = WrappedError.selector;\n        assembly (\"memory-safe\") {\n            // Ensure the size of the revert data is a multiple of 32 bytes\n            let encodedDataSize := mul(div(add(returndatasize(), 31), 32), 32)\n\n            let fmp := mload(0x40)\n\n            // Encode wrapped error selector, address, function selector, offset, additional context, size, revert reason\n            mstore(fmp, wrappedErrorSelector)\n            mstore(add(fmp, 0x04), and(revertingContract, 0xffffffffffffffffffffffffffffffffffffffff))\n            mstore(\n                add(fmp, 0x24),\n                and(revertingFunctionSelector, 0xffffffff00000000000000000000000000000000000000000000000000000000)\n            )\n            // offset revert reason\n            mstore(add(fmp, 0x44), 0x80)\n            // offset additional context\n            mstore(add(fmp, 0x64), add(0xa0, encodedDataSize))\n            // size revert reason\n            mstore(add(fmp, 0x84), returndatasize())\n            // revert reason\n            returndatacopy(add(fmp, 0xa4), 0, returndatasize())\n            // size additional context\n            mstore(add(fmp, add(0xa4, encodedDataSize)), 0x04)\n            // additional context\n            mstore(\n                add(fmp, add(0xc4, encodedDataSize)),\n                and(additionalContext, 0xffffffff00000000000000000000000000000000000000000000000000000000)\n            )\n            revert(fmp, add(0xe4, encodedDataSize))\n        }\n    }\n}\n"},"lib/v4-core/src/libraries/FixedPoint96.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\n/// @title FixedPoint96\n/// @notice A library for handling binary fixed point numbers, see https://en.wikipedia.org/wiki/Q_(number_format)\n/// @dev Used in SqrtPriceMath.sol\nlibrary FixedPoint96 {\n    uint8 internal constant RESOLUTION = 96;\n    uint256 internal constant Q96 = 0x1000000000000000000000000;\n}\n"},"lib/v4-core/src/libraries/FullMath.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\n/// @title Contains 512-bit math functions\n/// @notice Facilitates multiplication and division that can have overflow of an intermediate value without any loss of precision\n/// @dev Handles \"phantom overflow\" i.e., allows multiplication and division where an intermediate value overflows 256 bits\nlibrary FullMath {\n    /// @notice Calculates floor(abdenominator) with full precision. Throws if result overflows a uint256 or denominator == 0\n    /// @param a The multiplicand\n    /// @param b The multiplier\n    /// @param denominator The divisor\n    /// @return result The 256-bit result\n    /// @dev Credit to Remco Bloemen under MIT license https://xn--2-umb.com/21/muldiv\n    function mulDiv(uint256 a, uint256 b, uint256 denominator) internal pure returns (uint256 result) {\n        unchecked {\n            // 512-bit multiply [prod1 prod0] = a * b\n            // Compute the product mod 2**256 and mod 2**256 - 1\n            // then use the Chinese Remainder Theorem to reconstruct\n            // the 512 bit result. The result is stored in two 256\n            // variables such that product = prod1 * 2**256 + prod0\n            uint256 prod0 = a * b; // Least significant 256 bits of the product\n            uint256 prod1; // Most significant 256 bits of the product\n            assembly (\"memory-safe\") {\n                let mm := mulmod(a, b, not(0))\n                prod1 := sub(sub(mm, prod0), lt(mm, prod0))\n            }\n\n            // Make sure the result is less than 2**256.\n            // Also prevents denominator == 0\n            require(denominator > prod1);\n\n            // Handle non-overflow cases, 256 by 256 division\n            if (prod1 == 0) {\n                assembly (\"memory-safe\") {\n                    result := div(prod0, denominator)\n                }\n                return result;\n            }\n\n            ///////////////////////////////////////////////\n            // 512 by 256 division.\n            ///////////////////////////////////////////////\n\n            // Make division exact by subtracting the remainder from [prod1 prod0]\n            // Compute remainder using mulmod\n            uint256 remainder;\n            assembly (\"memory-safe\") {\n                remainder := mulmod(a, b, denominator)\n            }\n            // Subtract 256 bit number from 512 bit number\n            assembly (\"memory-safe\") {\n                prod1 := sub(prod1, gt(remainder, prod0))\n                prod0 := sub(prod0, remainder)\n            }\n\n            // Factor powers of two out of denominator\n            // Compute largest power of two divisor of denominator.\n            // Always >= 1.\n            uint256 twos = (0 - denominator) & denominator;\n            // Divide denominator by power of two\n            assembly (\"memory-safe\") {\n                denominator := div(denominator, twos)\n            }\n\n            // Divide [prod1 prod0] by the factors of two\n            assembly (\"memory-safe\") {\n                prod0 := div(prod0, twos)\n            }\n            // Shift in bits from prod1 into prod0. For this we need\n            // to flip `twos` such that it is 2**256 / twos.\n            // If twos is zero, then it becomes one\n            assembly (\"memory-safe\") {\n                twos := add(div(sub(0, twos), twos), 1)\n            }\n            prod0 |= prod1 * twos;\n\n            // Invert denominator mod 2**256\n            // Now that denominator is an odd number, it has an inverse\n            // modulo 2**256 such that denominator * inv = 1 mod 2**256.\n            // Compute the inverse by starting with a seed that is correct\n            // correct for four bits. That is, denominator * inv = 1 mod 2**4\n            uint256 inv = (3 * denominator) ^ 2;\n            // Now use Newton-Raphson iteration to improve the precision.\n            // Thanks to Hensel's lifting lemma, this also works in modular\n            // arithmetic, doubling the correct bits in each step.\n            inv *= 2 - denominator * inv; // inverse mod 2**8\n            inv *= 2 - denominator * inv; // inverse mod 2**16\n            inv *= 2 - denominator * inv; // inverse mod 2**32\n            inv *= 2 - denominator * inv; // inverse mod 2**64\n            inv *= 2 - denominator * inv; // inverse mod 2**128\n            inv *= 2 - denominator * inv; // inverse mod 2**256\n\n            // Because the division is now exact we can divide by multiplying\n            // with the modular inverse of denominator. This will give us the\n            // correct result modulo 2**256. Since the preconditions guarantee\n            // that the outcome is less than 2**256, this is the final result.\n            // We don't need to compute the high bits of the result and prod1\n            // is no longer required.\n            result = prod0 * inv;\n            return result;\n        }\n    }\n\n    /// @notice Calculates ceil(abdenominator) with full precision. Throws if result overflows a uint256 or denominator == 0\n    /// @param a The multiplicand\n    /// @param b The multiplier\n    /// @param denominator The divisor\n    /// @return result The 256-bit result\n    function mulDivRoundingUp(uint256 a, uint256 b, uint256 denominator) internal pure returns (uint256 result) {\n        unchecked {\n            result = mulDiv(a, b, denominator);\n            if (mulmod(a, b, denominator) != 0) {\n                require(++result > 0);\n            }\n        }\n    }\n}\n"},"lib/v4-core/src/libraries/TickMath.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport {BitMath} from \"./BitMath.sol\";\nimport {CustomRevert} from \"./CustomRevert.sol\";\n\n/// @title Math library for computing sqrt prices from ticks and vice versa\n/// @notice Computes sqrt price for ticks of size 1.0001, i.e. sqrt(1.0001^tick) as fixed point Q64.96 numbers. Supports\n/// prices between 2**-128 and 2**128\nlibrary TickMath {\n    using CustomRevert for bytes4;\n\n    /// @notice Thrown when the tick passed to #getSqrtPriceAtTick is not between MIN_TICK and MAX_TICK\n    error InvalidTick(int24 tick);\n    /// @notice Thrown when the price passed to #getTickAtSqrtPrice does not correspond to a price between MIN_TICK and MAX_TICK\n    error InvalidSqrtPrice(uint160 sqrtPriceX96);\n\n    /// @dev The minimum tick that may be passed to #getSqrtPriceAtTick computed from log base 1.0001 of 2**-128\n    /// @dev If ever MIN_TICK and MAX_TICK are not centered around 0, the absTick logic in getSqrtPriceAtTick cannot be used\n    int24 internal constant MIN_TICK = -887272;\n    /// @dev The maximum tick that may be passed to #getSqrtPriceAtTick computed from log base 1.0001 of 2**128\n    /// @dev If ever MIN_TICK and MAX_TICK are not centered around 0, the absTick logic in getSqrtPriceAtTick cannot be used\n    int24 internal constant MAX_TICK = 887272;\n\n    /// @dev The minimum tick spacing value drawn from the range of type int16 that is greater than 0, i.e. min from the range [1, 32767]\n    int24 internal constant MIN_TICK_SPACING = 1;\n    /// @dev The maximum tick spacing value drawn from the range of type int16, i.e. max from the range [1, 32767]\n    int24 internal constant MAX_TICK_SPACING = type(int16).max;\n\n    /// @dev The minimum value that can be returned from #getSqrtPriceAtTick. Equivalent to getSqrtPriceAtTick(MIN_TICK)\n    uint160 internal constant MIN_SQRT_PRICE = 4295128739;\n    /// @dev The maximum value that can be returned from #getSqrtPriceAtTick. Equivalent to getSqrtPriceAtTick(MAX_TICK)\n    uint160 internal constant MAX_SQRT_PRICE = 1461446703485210103287273052203988822378723970342;\n    /// @dev A threshold used for optimized bounds check, equals `MAX_SQRT_PRICE - MIN_SQRT_PRICE - 1`\n    uint160 internal constant MAX_SQRT_PRICE_MINUS_MIN_SQRT_PRICE_MINUS_ONE =\n        1461446703485210103287273052203988822378723970342 - 4295128739 - 1;\n\n    /// @notice Given a tickSpacing, compute the maximum usable tick\n    function maxUsableTick(int24 tickSpacing) internal pure returns (int24) {\n        unchecked {\n            return (MAX_TICK / tickSpacing) * tickSpacing;\n        }\n    }\n\n    /// @notice Given a tickSpacing, compute the minimum usable tick\n    function minUsableTick(int24 tickSpacing) internal pure returns (int24) {\n        unchecked {\n            return (MIN_TICK / tickSpacing) * tickSpacing;\n        }\n    }\n\n    /// @notice Calculates sqrt(1.0001^tick) * 2^96\n    /// @dev Throws if |tick| > max tick\n    /// @param tick The input tick for the above formula\n    /// @return sqrtPriceX96 A Fixed point Q64.96 number representing the sqrt of the price of the two assets (currency1/currency0)\n    /// at the given tick\n    function getSqrtPriceAtTick(int24 tick) internal pure returns (uint160 sqrtPriceX96) {\n        unchecked {\n            uint256 absTick;\n            assembly (\"memory-safe\") {\n                tick := signextend(2, tick)\n                // mask = 0 if tick >= 0 else -1 (all 1s)\n                let mask := sar(255, tick)\n                // if tick >= 0, |tick| = tick = 0 ^ tick\n                // if tick < 0, |tick| = ~~|tick| = ~(-|tick| - 1) = ~(tick - 1) = (-1) ^ (tick - 1)\n                // either way, |tick| = mask ^ (tick + mask)\n                absTick := xor(mask, add(mask, tick))\n            }\n\n            if (absTick > uint256(int256(MAX_TICK))) InvalidTick.selector.revertWith(tick);\n\n            // The tick is decomposed into bits, and for each bit with index i that is set, the product of 1/sqrt(1.0001^(2^i))\n            // is calculated (using Q128.128). The constants used for this calculation are rounded to the nearest integer\n\n            // Equivalent to:\n            //     price = absTick & 0x1 != 0 ? 0xfffcb933bd6fad37aa2d162d1a594001 : 0x100000000000000000000000000000000;\n            //     or price = int(2**128 / sqrt(1.0001)) if (absTick & 0x1) else 1 << 128\n            uint256 price;\n            assembly (\"memory-safe\") {\n                price := xor(shl(128, 1), mul(xor(shl(128, 1), 0xfffcb933bd6fad37aa2d162d1a594001), and(absTick, 0x1)))\n            }\n            if (absTick & 0x2 != 0) price = (price * 0xfff97272373d413259a46990580e213a) >> 128;\n            if (absTick & 0x4 != 0) price = (price * 0xfff2e50f5f656932ef12357cf3c7fdcc) >> 128;\n            if (absTick & 0x8 != 0) price = (price * 0xffe5caca7e10e4e61c3624eaa0941cd0) >> 128;\n            if (absTick & 0x10 != 0) price = (price * 0xffcb9843d60f6159c9db58835c926644) >> 128;\n            if (absTick & 0x20 != 0) price = (price * 0xff973b41fa98c081472e6896dfb254c0) >> 128;\n            if (absTick & 0x40 != 0) price = (price * 0xff2ea16466c96a3843ec78b326b52861) >> 128;\n            if (absTick & 0x80 != 0) price = (price * 0xfe5dee046a99a2a811c461f1969c3053) >> 128;\n            if (absTick & 0x100 != 0) price = (price * 0xfcbe86c7900a88aedcffc83b479aa3a4) >> 128;\n            if (absTick & 0x200 != 0) price = (price * 0xf987a7253ac413176f2b074cf7815e54) >> 128;\n            if (absTick & 0x400 != 0) price = (price * 0xf3392b0822b70005940c7a398e4b70f3) >> 128;\n            if (absTick & 0x800 != 0) price = (price * 0xe7159475a2c29b7443b29c7fa6e889d9) >> 128;\n            if (absTick & 0x1000 != 0) price = (price * 0xd097f3bdfd2022b8845ad8f792aa5825) >> 128;\n            if (absTick & 0x2000 != 0) price = (price * 0xa9f746462d870fdf8a65dc1f90e061e5) >> 128;\n            if (absTick & 0x4000 != 0) price = (price * 0x70d869a156d2a1b890bb3df62baf32f7) >> 128;\n            if (absTick & 0x8000 != 0) price = (price * 0x31be135f97d08fd981231505542fcfa6) >> 128;\n            if (absTick & 0x10000 != 0) price = (price * 0x9aa508b5b7a84e1c677de54f3e99bc9) >> 128;\n            if (absTick & 0x20000 != 0) price = (price * 0x5d6af8dedb81196699c329225ee604) >> 128;\n            if (absTick & 0x40000 != 0) price = (price * 0x2216e584f5fa1ea926041bedfe98) >> 128;\n            if (absTick & 0x80000 != 0) price = (price * 0x48a170391f7dc42444e8fa2) >> 128;\n\n            assembly (\"memory-safe\") {\n                // if (tick > 0) price = type(uint256).max / price;\n                if sgt(tick, 0) { price := div(not(0), price) }\n\n                // this divides by 1<<32 rounding up to go from a Q128.128 to a Q128.96.\n                // we then downcast because we know the result always fits within 160 bits due to our tick input constraint\n                // we round up in the division so getTickAtSqrtPrice of the output price is always consistent\n                // `sub(shl(32, 1), 1)` is `type(uint32).max`\n                // `price + type(uint32).max` will not overflow because `price` fits in 192 bits\n                sqrtPriceX96 := shr(32, add(price, sub(shl(32, 1), 1)))\n            }\n        }\n    }\n\n    /// @notice Calculates the greatest tick value such that getSqrtPriceAtTick(tick) <= sqrtPriceX96\n    /// @dev Throws in case sqrtPriceX96 < MIN_SQRT_PRICE, as MIN_SQRT_PRICE is the lowest value getSqrtPriceAtTick may\n    /// ever return.\n    /// @param sqrtPriceX96 The sqrt price for which to compute the tick as a Q64.96\n    /// @return tick The greatest tick for which the getSqrtPriceAtTick(tick) is less than or equal to the input sqrtPriceX96\n    function getTickAtSqrtPrice(uint160 sqrtPriceX96) internal pure returns (int24 tick) {\n        unchecked {\n            // Equivalent: if (sqrtPriceX96 < MIN_SQRT_PRICE || sqrtPriceX96 >= MAX_SQRT_PRICE) revert InvalidSqrtPrice();\n            // second inequality must be >= because the price can never reach the price at the max tick\n            // if sqrtPriceX96 < MIN_SQRT_PRICE, the `sub` underflows and `gt` is true\n            // if sqrtPriceX96 >= MAX_SQRT_PRICE, sqrtPriceX96 - MIN_SQRT_PRICE > MAX_SQRT_PRICE - MIN_SQRT_PRICE - 1\n            if ((sqrtPriceX96 - MIN_SQRT_PRICE) > MAX_SQRT_PRICE_MINUS_MIN_SQRT_PRICE_MINUS_ONE) {\n                InvalidSqrtPrice.selector.revertWith(sqrtPriceX96);\n            }\n\n            uint256 price = uint256(sqrtPriceX96) << 32;\n\n            uint256 r = price;\n            uint256 msb = BitMath.mostSignificantBit(r);\n\n            if (msb >= 128) r = price >> (msb - 127);\n            else r = price << (127 - msb);\n\n            int256 log_2 = (int256(msb) - 128) << 64;\n\n            assembly (\"memory-safe\") {\n                r := shr(127, mul(r, r))\n                let f := shr(128, r)\n                log_2 := or(log_2, shl(63, f))\n                r := shr(f, r)\n            }\n            assembly (\"memory-safe\") {\n                r := shr(127, mul(r, r))\n                let f := shr(128, r)\n                log_2 := or(log_2, shl(62, f))\n                r := shr(f, r)\n            }\n            assembly (\"memory-safe\") {\n                r := shr(127, mul(r, r))\n                let f := shr(128, r)\n                log_2 := or(log_2, shl(61, f))\n                r := shr(f, r)\n            }\n            assembly (\"memory-safe\") {\n                r := shr(127, mul(r, r))\n                let f := shr(128, r)\n                log_2 := or(log_2, shl(60, f))\n                r := shr(f, r)\n            }\n            assembly (\"memory-safe\") {\n                r := shr(127, mul(r, r))\n                let f := shr(128, r)\n                log_2 := or(log_2, shl(59, f))\n                r := shr(f, r)\n            }\n            assembly (\"memory-safe\") {\n                r := shr(127, mul(r, r))\n                let f := shr(128, r)\n                log_2 := or(log_2, shl(58, f))\n                r := shr(f, r)\n            }\n            assembly (\"memory-safe\") {\n                r := shr(127, mul(r, r))\n                let f := shr(128, r)\n                log_2 := or(log_2, shl(57, f))\n                r := shr(f, r)\n            }\n            assembly (\"memory-safe\") {\n                r := shr(127, mul(r, r))\n                let f := shr(128, r)\n                log_2 := or(log_2, shl(56, f))\n                r := shr(f, r)\n            }\n            assembly (\"memory-safe\") {\n                r := shr(127, mul(r, r))\n                let f := shr(128, r)\n                log_2 := or(log_2, shl(55, f))\n                r := shr(f, r)\n            }\n            assembly (\"memory-safe\") {\n                r := shr(127, mul(r, r))\n                let f := shr(128, r)\n                log_2 := or(log_2, shl(54, f))\n                r := shr(f, r)\n            }\n            assembly (\"memory-safe\") {\n                r := shr(127, mul(r, r))\n                let f := shr(128, r)\n                log_2 := or(log_2, shl(53, f))\n                r := shr(f, r)\n            }\n            assembly (\"memory-safe\") {\n                r := shr(127, mul(r, r))\n                let f := shr(128, r)\n                log_2 := or(log_2, shl(52, f))\n                r := shr(f, r)\n            }\n            assembly (\"memory-safe\") {\n                r := shr(127, mul(r, r))\n                let f := shr(128, r)\n                log_2 := or(log_2, shl(51, f))\n                r := shr(f, r)\n            }\n            assembly (\"memory-safe\") {\n                r := shr(127, mul(r, r))\n                let f := shr(128, r)\n                log_2 := or(log_2, shl(50, f))\n            }\n\n            int256 log_sqrt10001 = log_2 * 255738958999603826347141; // Q22.128 number\n\n            // Magic number represents the ceiling of the maximum value of the error when approximating log_sqrt10001(x)\n            int24 tickLow = int24((log_sqrt10001 - 3402992956809132418596140100660247210) >> 128);\n\n            // Magic number represents the minimum value of the error when approximating log_sqrt10001(x), when\n            // sqrtPrice is from the range (2^-64, 2^64). This is safe as MIN_SQRT_PRICE is more than 2^-64. If MIN_SQRT_PRICE\n            // is changed, this may need to be changed too\n            int24 tickHi = int24((log_sqrt10001 + 291339464771989622907027621153398088495) >> 128);\n\n            tick = tickLow == tickHi ? tickLow : getSqrtPriceAtTick(tickHi) <= sqrtPriceX96 ? tickHi : tickLow;\n        }\n    }\n}\n"},"lib/v4-core/test/utils/LiquidityAmounts.sol":{"content":"// SPDX-License-Identifier: UNLICENSED\npragma solidity ^0.8.20;\n\nimport \"../../src/libraries/FullMath.sol\";\nimport \"../../src/libraries/FixedPoint96.sol\";\n\n/// @title Liquidity amount functions\n/// @notice Provides functions for computing liquidity amounts from token amounts and prices\nlibrary LiquidityAmounts {\n    /// @notice Downcasts uint256 to uint128\n    /// @param x The uint258 to be downcasted\n    /// @return y The passed value, downcasted to uint128\n    function toUint128(uint256 x) private pure returns (uint128 y) {\n        require((y = uint128(x)) == x, \"liquidity overflow\");\n    }\n\n    /// @notice Computes the amount of liquidity received for a given amount of token0 and price range\n    /// @dev Calculates amount0 * (sqrt(upper) * sqrt(lower)) / (sqrt(upper) - sqrt(lower))\n    /// @param sqrtPriceAX96 A sqrt price representing the first tick boundary\n    /// @param sqrtPriceBX96 A sqrt price representing the second tick boundary\n    /// @param amount0 The amount0 being sent in\n    /// @return liquidity The amount of returned liquidity\n    function getLiquidityForAmount0(uint160 sqrtPriceAX96, uint160 sqrtPriceBX96, uint256 amount0)\n        internal\n        pure\n        returns (uint128 liquidity)\n    {\n        if (sqrtPriceAX96 > sqrtPriceBX96) (sqrtPriceAX96, sqrtPriceBX96) = (sqrtPriceBX96, sqrtPriceAX96);\n        uint256 intermediate = FullMath.mulDiv(sqrtPriceAX96, sqrtPriceBX96, FixedPoint96.Q96);\n        return toUint128(FullMath.mulDiv(amount0, intermediate, sqrtPriceBX96 - sqrtPriceAX96));\n    }\n\n    /// @notice Computes the amount of liquidity received for a given amount of token1 and price range\n    /// @dev Calculates amount1 / (sqrt(upper) - sqrt(lower)).\n    /// @param sqrtPriceAX96 A sqrt price representing the first tick boundary\n    /// @param sqrtPriceBX96 A sqrt price representing the second tick boundary\n    /// @param amount1 The amount1 being sent in\n    /// @return liquidity The amount of returned liquidity\n    function getLiquidityForAmount1(uint160 sqrtPriceAX96, uint160 sqrtPriceBX96, uint256 amount1)\n        internal\n        pure\n        returns (uint128 liquidity)\n    {\n        if (sqrtPriceAX96 > sqrtPriceBX96) (sqrtPriceAX96, sqrtPriceBX96) = (sqrtPriceBX96, sqrtPriceAX96);\n        return toUint128(FullMath.mulDiv(amount1, FixedPoint96.Q96, sqrtPriceBX96 - sqrtPriceAX96));\n    }\n\n    /// @notice Computes the maximum amount of liquidity received for a given amount of token0, token1, the current\n    /// pool prices and the prices at the tick boundaries\n    /// @param sqrtPriceX96 A sqrt price representing the current pool prices\n    /// @param sqrtPriceAX96 A sqrt price representing the first tick boundary\n    /// @param sqrtPriceBX96 A sqrt price representing the second tick boundary\n    /// @param amount0 The amount of token0 being sent in\n    /// @param amount1 The amount of token1 being sent in\n    /// @return liquidity The maximum amount of liquidity received\n    function getLiquidityForAmounts(\n        uint160 sqrtPriceX96,\n        uint160 sqrtPriceAX96,\n        uint160 sqrtPriceBX96,\n        uint256 amount0,\n        uint256 amount1\n    ) internal pure returns (uint128 liquidity) {\n        if (sqrtPriceAX96 > sqrtPriceBX96) (sqrtPriceAX96, sqrtPriceBX96) = (sqrtPriceBX96, sqrtPriceAX96);\n\n        if (sqrtPriceX96 <= sqrtPriceAX96) {\n            liquidity = getLiquidityForAmount0(sqrtPriceAX96, sqrtPriceBX96, amount0);\n        } else if (sqrtPriceX96 < sqrtPriceBX96) {\n            uint128 liquidity0 = getLiquidityForAmount0(sqrtPriceX96, sqrtPriceBX96, amount0);\n            uint128 liquidity1 = getLiquidityForAmount1(sqrtPriceAX96, sqrtPriceX96, amount1);\n\n            liquidity = liquidity0 < liquidity1 ? liquidity0 : liquidity1;\n        } else {\n            liquidity = getLiquidityForAmount1(sqrtPriceAX96, sqrtPriceBX96, amount1);\n        }\n    }\n\n    /// @notice Computes the amount of token0 for a given amount of liquidity and a price range\n    /// @param sqrtPriceAX96 A sqrt price representing the first tick boundary\n    /// @param sqrtPriceBX96 A sqrt price representing the second tick boundary\n    /// @param liquidity The liquidity being valued\n    /// @return amount0 The amount of token0\n    function getAmount0ForLiquidity(uint160 sqrtPriceAX96, uint160 sqrtPriceBX96, uint128 liquidity)\n        internal\n        pure\n        returns (uint256 amount0)\n    {\n        if (sqrtPriceAX96 > sqrtPriceBX96) (sqrtPriceAX96, sqrtPriceBX96) = (sqrtPriceBX96, sqrtPriceAX96);\n\n        return FullMath.mulDiv(\n            uint256(liquidity) << FixedPoint96.RESOLUTION, sqrtPriceBX96 - sqrtPriceAX96, sqrtPriceBX96\n        ) / sqrtPriceAX96;\n    }\n\n    /// @notice Computes the amount of token1 for a given amount of liquidity and a price range\n    /// @param sqrtPriceAX96 A sqrt price representing the first tick boundary\n    /// @param sqrtPriceBX96 A sqrt price representing the second tick boundary\n    /// @param liquidity The liquidity being valued\n    /// @return amount1 The amount of token1\n    function getAmount1ForLiquidity(uint160 sqrtPriceAX96, uint160 sqrtPriceBX96, uint128 liquidity)\n        internal\n        pure\n        returns (uint256 amount1)\n    {\n        if (sqrtPriceAX96 > sqrtPriceBX96) (sqrtPriceAX96, sqrtPriceBX96) = (sqrtPriceBX96, sqrtPriceAX96);\n\n        return FullMath.mulDiv(liquidity, sqrtPriceBX96 - sqrtPriceAX96, FixedPoint96.Q96);\n    }\n\n    /// @notice Computes the token0 and token1 value for a given amount of liquidity, the current\n    /// pool prices and the prices at the tick boundaries\n    /// @param sqrtPriceX96 A sqrt price representing the current pool prices\n    /// @param sqrtPriceAX96 A sqrt price representing the first tick boundary\n    /// @param sqrtPriceBX96 A sqrt price representing the second tick boundary\n    /// @param liquidity The liquidity being valued\n    /// @return amount0 The amount of token0\n    /// @return amount1 The amount of token1\n    function getAmountsForLiquidity(\n        uint160 sqrtPriceX96,\n        uint160 sqrtPriceAX96,\n        uint160 sqrtPriceBX96,\n        uint128 liquidity\n    ) internal pure returns (uint256 amount0, uint256 amount1) {\n        if (sqrtPriceAX96 > sqrtPriceBX96) (sqrtPriceAX96, sqrtPriceBX96) = (sqrtPriceBX96, sqrtPriceAX96);\n\n        if (sqrtPriceX96 <= sqrtPriceAX96) {\n            amount0 = getAmount0ForLiquidity(sqrtPriceAX96, sqrtPriceBX96, liquidity);\n        } else if (sqrtPriceX96 < sqrtPriceBX96) {\n            amount0 = getAmount0ForLiquidity(sqrtPriceX96, sqrtPriceBX96, liquidity);\n            amount1 = getAmount1ForLiquidity(sqrtPriceAX96, sqrtPriceX96, liquidity);\n        } else {\n            amount1 = getAmount1ForLiquidity(sqrtPriceAX96, sqrtPriceBX96, liquidity);\n        }\n    }\n}\n"},"lib/v4-periphery/lib/permit2/src/interfaces/IAllowanceTransfer.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport {IEIP712} from \"./IEIP712.sol\";\n\n/// @title AllowanceTransfer\n/// @notice Handles ERC20 token permissions through signature based allowance setting and ERC20 token transfers by checking allowed amounts\n/// @dev Requires user's token approval on the Permit2 contract\ninterface IAllowanceTransfer is IEIP712 {\n    /// @notice Thrown when an allowance on a token has expired.\n    /// @param deadline The timestamp at which the allowed amount is no longer valid\n    error AllowanceExpired(uint256 deadline);\n\n    /// @notice Thrown when an allowance on a token has been depleted.\n    /// @param amount The maximum amount allowed\n    error InsufficientAllowance(uint256 amount);\n\n    /// @notice Thrown when too many nonces are invalidated.\n    error ExcessiveInvalidation();\n\n    /// @notice Emits an event when the owner successfully invalidates an ordered nonce.\n    event NonceInvalidation(\n        address indexed owner, address indexed token, address indexed spender, uint48 newNonce, uint48 oldNonce\n    );\n\n    /// @notice Emits an event when the owner successfully sets permissions on a token for the spender.\n    event Approval(\n        address indexed owner, address indexed token, address indexed spender, uint160 amount, uint48 expiration\n    );\n\n    /// @notice Emits an event when the owner successfully sets permissions using a permit signature on a token for the spender.\n    event Permit(\n        address indexed owner,\n        address indexed token,\n        address indexed spender,\n        uint160 amount,\n        uint48 expiration,\n        uint48 nonce\n    );\n\n    /// @notice Emits an event when the owner sets the allowance back to 0 with the lockdown function.\n    event Lockdown(address indexed owner, address token, address spender);\n\n    /// @notice The permit data for a token\n    struct PermitDetails {\n        // ERC20 token address\n        address token;\n        // the maximum amount allowed to spend\n        uint160 amount;\n        // timestamp at which a spender's token allowances become invalid\n        uint48 expiration;\n        // an incrementing value indexed per owner,token,and spender for each signature\n        uint48 nonce;\n    }\n\n    /// @notice The permit message signed for a single token allowance\n    struct PermitSingle {\n        // the permit data for a single token alownce\n        PermitDetails details;\n        // address permissioned on the allowed tokens\n        address spender;\n        // deadline on the permit signature\n        uint256 sigDeadline;\n    }\n\n    /// @notice The permit message signed for multiple token allowances\n    struct PermitBatch {\n        // the permit data for multiple token allowances\n        PermitDetails[] details;\n        // address permissioned on the allowed tokens\n        address spender;\n        // deadline on the permit signature\n        uint256 sigDeadline;\n    }\n\n    /// @notice The saved permissions\n    /// @dev This info is saved per owner, per token, per spender and all signed over in the permit message\n    /// @dev Setting amount to type(uint160).max sets an unlimited approval\n    struct PackedAllowance {\n        // amount allowed\n        uint160 amount;\n        // permission expiry\n        uint48 expiration;\n        // an incrementing value indexed per owner,token,and spender for each signature\n        uint48 nonce;\n    }\n\n    /// @notice A token spender pair.\n    struct TokenSpenderPair {\n        // the token the spender is approved\n        address token;\n        // the spender address\n        address spender;\n    }\n\n    /// @notice Details for a token transfer.\n    struct AllowanceTransferDetails {\n        // the owner of the token\n        address from;\n        // the recipient of the token\n        address to;\n        // the amount of the token\n        uint160 amount;\n        // the token to be transferred\n        address token;\n    }\n\n    /// @notice A mapping from owner address to token address to spender address to PackedAllowance struct, which contains details and conditions of the approval.\n    /// @notice The mapping is indexed in the above order see: allowance[ownerAddress][tokenAddress][spenderAddress]\n    /// @dev The packed slot holds the allowed amount, expiration at which the allowed amount is no longer valid, and current nonce thats updated on any signature based approvals.\n    function allowance(address user, address token, address spender)\n        external\n        view\n        returns (uint160 amount, uint48 expiration, uint48 nonce);\n\n    /// @notice Approves the spender to use up to amount of the specified token up until the expiration\n    /// @param token The token to approve\n    /// @param spender The spender address to approve\n    /// @param amount The approved amount of the token\n    /// @param expiration The timestamp at which the approval is no longer valid\n    /// @dev The packed allowance also holds a nonce, which will stay unchanged in approve\n    /// @dev Setting amount to type(uint160).max sets an unlimited approval\n    function approve(address token, address spender, uint160 amount, uint48 expiration) external;\n\n    /// @notice Permit a spender to a given amount of the owners token via the owner's EIP-712 signature\n    /// @dev May fail if the owner's nonce was invalidated in-flight by invalidateNonce\n    /// @param owner The owner of the tokens being approved\n    /// @param permitSingle Data signed over by the owner specifying the terms of approval\n    /// @param signature The owner's signature over the permit data\n    function permit(address owner, PermitSingle memory permitSingle, bytes calldata signature) external;\n\n    /// @notice Permit a spender to the signed amounts of the owners tokens via the owner's EIP-712 signature\n    /// @dev May fail if the owner's nonce was invalidated in-flight by invalidateNonce\n    /// @param owner The owner of the tokens being approved\n    /// @param permitBatch Data signed over by the owner specifying the terms of approval\n    /// @param signature The owner's signature over the permit data\n    function permit(address owner, PermitBatch memory permitBatch, bytes calldata signature) external;\n\n    /// @notice Transfer approved tokens from one address to another\n    /// @param from The address to transfer from\n    /// @param to The address of the recipient\n    /// @param amount The amount of the token to transfer\n    /// @param token The token address to transfer\n    /// @dev Requires the from address to have approved at least the desired amount\n    /// of tokens to msg.sender.\n    function transferFrom(address from, address to, uint160 amount, address token) external;\n\n    /// @notice Transfer approved tokens in a batch\n    /// @param transferDetails Array of owners, recipients, amounts, and tokens for the transfers\n    /// @dev Requires the from addresses to have approved at least the desired amount\n    /// of tokens to msg.sender.\n    function transferFrom(AllowanceTransferDetails[] calldata transferDetails) external;\n\n    /// @notice Enables performing a \"lockdown\" of the sender's Permit2 identity\n    /// by batch revoking approvals\n    /// @param approvals Array of approvals to revoke.\n    function lockdown(TokenSpenderPair[] calldata approvals) external;\n\n    /// @notice Invalidate nonces for a given (token, spender) pair\n    /// @param token The token to invalidate nonces for\n    /// @param spender The spender to invalidate nonces for\n    /// @param newNonce The new nonce to set. Invalidates all nonces less than it.\n    /// @dev Can't invalidate more than 2**16 nonces per transaction.\n    function invalidateNonces(address token, address spender, uint48 newNonce) external;\n}\n"},"lib/v4-periphery/lib/permit2/src/interfaces/IEIP712.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\ninterface IEIP712 {\n    function DOMAIN_SEPARATOR() external view returns (bytes32);\n}\n"},"lib/v4-periphery/lib/permit2/src/interfaces/IERC1271.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\ninterface IERC1271 {\n    /// @dev Should return whether the signature provided is valid for the provided data\n    /// @param hash      Hash of the data to be signed\n    /// @param signature Signature byte array associated with _data\n    /// @return magicValue The bytes4 magic value 0x1626ba7e\n    function isValidSignature(bytes32 hash, bytes memory signature) external view returns (bytes4 magicValue);\n}\n"},"lib/v4-periphery/lib/permit2/src/libraries/SignatureVerification.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity ^0.8.17;\n\nimport {IERC1271} from \"../interfaces/IERC1271.sol\";\n\nlibrary SignatureVerification {\n    /// @notice Thrown when the passed in signature is not a valid length\n    error InvalidSignatureLength();\n\n    /// @notice Thrown when the recovered signer is equal to the zero address\n    error InvalidSignature();\n\n    /// @notice Thrown when the recovered signer does not equal the claimedSigner\n    error InvalidSigner();\n\n    /// @notice Thrown when the recovered contract signature is incorrect\n    error InvalidContractSignature();\n\n    bytes32 constant UPPER_BIT_MASK = (0x7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff);\n\n    function verify(bytes calldata signature, bytes32 hash, address claimedSigner) internal view {\n        bytes32 r;\n        bytes32 s;\n        uint8 v;\n\n        if (claimedSigner.code.length == 0) {\n            if (signature.length == 65) {\n                (r, s) = abi.decode(signature, (bytes32, bytes32));\n                v = uint8(signature[64]);\n            } else if (signature.length == 64) {\n                // EIP-2098\n                bytes32 vs;\n                (r, vs) = abi.decode(signature, (bytes32, bytes32));\n                s = vs & UPPER_BIT_MASK;\n                v = uint8(uint256(vs >> 255)) + 27;\n            } else {\n                revert InvalidSignatureLength();\n            }\n            address signer = ecrecover(hash, v, r, s);\n            if (signer == address(0)) revert InvalidSignature();\n            if (signer != claimedSigner) revert InvalidSigner();\n        } else {\n            bytes4 magicValue = IERC1271(claimedSigner).isValidSignature(hash, signature);\n            if (magicValue != IERC1271.isValidSignature.selector) revert InvalidContractSignature();\n        }\n    }\n}\n"},"lib/v4-periphery/lib/v4-core/src/ERC6909.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport {IERC6909Claims} from \"./interfaces/external/IERC6909Claims.sol\";\n\n/// @notice Minimalist and gas efficient standard ERC6909 implementation.\n/// @author Solmate (https://github.com/transmissions11/solmate/blob/main/src/tokens/ERC6909.sol)\n/// @dev Copied from the commit at 4b47a19038b798b4a33d9749d25e570443520647\n/// @dev This contract has been modified from the implementation at the above link.\nabstract contract ERC6909 is IERC6909Claims {\n    /*//////////////////////////////////////////////////////////////\n                             ERC6909 STORAGE\n    //////////////////////////////////////////////////////////////*/\n\n    mapping(address owner => mapping(address operator => bool isOperator)) public isOperator;\n\n    mapping(address owner => mapping(uint256 id => uint256 balance)) public balanceOf;\n\n    mapping(address owner => mapping(address spender => mapping(uint256 id => uint256 amount))) public allowance;\n\n    /*//////////////////////////////////////////////////////////////\n                              ERC6909 LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n    function transfer(address receiver, uint256 id, uint256 amount) public virtual returns (bool) {\n        balanceOf[msg.sender][id] -= amount;\n\n        balanceOf[receiver][id] += amount;\n\n        emit Transfer(msg.sender, msg.sender, receiver, id, amount);\n\n        return true;\n    }\n\n    function transferFrom(address sender, address receiver, uint256 id, uint256 amount) public virtual returns (bool) {\n        if (msg.sender != sender && !isOperator[sender][msg.sender]) {\n            uint256 allowed = allowance[sender][msg.sender][id];\n            if (allowed != type(uint256).max) allowance[sender][msg.sender][id] = allowed - amount;\n        }\n\n        balanceOf[sender][id] -= amount;\n\n        balanceOf[receiver][id] += amount;\n\n        emit Transfer(msg.sender, sender, receiver, id, amount);\n\n        return true;\n    }\n\n    function approve(address spender, uint256 id, uint256 amount) public virtual returns (bool) {\n        allowance[msg.sender][spender][id] = amount;\n\n        emit Approval(msg.sender, spender, id, amount);\n\n        return true;\n    }\n\n    function setOperator(address operator, bool approved) public virtual returns (bool) {\n        isOperator[msg.sender][operator] = approved;\n\n        emit OperatorSet(msg.sender, operator, approved);\n\n        return true;\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                              ERC165 LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n    function supportsInterface(bytes4 interfaceId) public view virtual returns (bool) {\n        return interfaceId == 0x01ffc9a7 // ERC165 Interface ID for ERC165\n            || interfaceId == 0x0f632fb3; // ERC165 Interface ID for ERC6909\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                        INTERNAL MINT/BURN LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n    function _mint(address receiver, uint256 id, uint256 amount) internal virtual {\n        balanceOf[receiver][id] += amount;\n\n        emit Transfer(msg.sender, address(0), receiver, id, amount);\n    }\n\n    function _burn(address sender, uint256 id, uint256 amount) internal virtual {\n        balanceOf[sender][id] -= amount;\n\n        emit Transfer(msg.sender, sender, address(0), id, amount);\n    }\n}\n"},"lib/v4-periphery/lib/v4-core/src/ERC6909Claims.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport {ERC6909} from \"./ERC6909.sol\";\n\n/// @notice ERC6909Claims inherits ERC6909 and implements an internal burnFrom function\nabstract contract ERC6909Claims is ERC6909 {\n    /// @notice Burn `amount` tokens of token type `id` from `from`.\n    /// @dev if sender is not `from` they must be an operator or have sufficient allowance.\n    /// @param from The address to burn tokens from.\n    /// @param id The currency to burn.\n    /// @param amount The amount to burn.\n    function _burnFrom(address from, uint256 id, uint256 amount) internal {\n        address sender = msg.sender;\n        if (from != sender && !isOperator[from][sender]) {\n            uint256 senderAllowance = allowance[from][sender][id];\n            if (senderAllowance != type(uint256).max) {\n                allowance[from][sender][id] = senderAllowance - amount;\n            }\n        }\n        _burn(from, id, amount);\n    }\n}\n"},"lib/v4-periphery/lib/v4-core/src/Extsload.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport {IExtsload} from \"./interfaces/IExtsload.sol\";\n\n/// @notice Enables public storage access for efficient state retrieval by external contracts.\n/// https://eips.ethereum.org/EIPS/eip-2330#rationale\nabstract contract Extsload is IExtsload {\n    /// @inheritdoc IExtsload\n    function extsload(bytes32 slot) external view returns (bytes32) {\n        assembly (\"memory-safe\") {\n            mstore(0, sload(slot))\n            return(0, 0x20)\n        }\n    }\n\n    /// @inheritdoc IExtsload\n    function extsload(bytes32 startSlot, uint256 nSlots) external view returns (bytes32[] memory) {\n        assembly (\"memory-safe\") {\n            let memptr := mload(0x40)\n            let start := memptr\n            // A left bit-shift of 5 is equivalent to multiplying by 32 but costs less gas.\n            let length := shl(5, nSlots)\n            // The abi offset of dynamic array in the returndata is 32.\n            mstore(memptr, 0x20)\n            // Store the length of the array returned\n            mstore(add(memptr, 0x20), nSlots)\n            // update memptr to the first location to hold a result\n            memptr := add(memptr, 0x40)\n            let end := add(memptr, length)\n            for {} 1 {} {\n                mstore(memptr, sload(startSlot))\n                memptr := add(memptr, 0x20)\n                startSlot := add(startSlot, 1)\n                if iszero(lt(memptr, end)) { break }\n            }\n            return(start, sub(end, start))\n        }\n    }\n\n    /// @inheritdoc IExtsload\n    function extsload(bytes32[] calldata slots) external view returns (bytes32[] memory) {\n        assembly (\"memory-safe\") {\n            let memptr := mload(0x40)\n            let start := memptr\n            // for abi encoding the response - the array will be found at 0x20\n            mstore(memptr, 0x20)\n            // next we store the length of the return array\n            mstore(add(memptr, 0x20), slots.length)\n            // update memptr to the first location to hold an array entry\n            memptr := add(memptr, 0x40)\n            // A left bit-shift of 5 is equivalent to multiplying by 32 but costs less gas.\n            let end := add(memptr, shl(5, slots.length))\n            let calldataptr := slots.offset\n            for {} 1 {} {\n                mstore(memptr, sload(calldataload(calldataptr)))\n                memptr := add(memptr, 0x20)\n                calldataptr := add(calldataptr, 0x20)\n                if iszero(lt(memptr, end)) { break }\n            }\n            return(start, sub(end, start))\n        }\n    }\n}\n"},"lib/v4-periphery/lib/v4-core/src/Exttload.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity ^0.8.24;\n\nimport {IExttload} from \"./interfaces/IExttload.sol\";\n\n/// @notice Enables public transient storage access for efficient state retrieval by external contracts.\n/// https://eips.ethereum.org/EIPS/eip-2330#rationale\nabstract contract Exttload is IExttload {\n    /// @inheritdoc IExttload\n    function exttload(bytes32 slot) external view returns (bytes32) {\n        assembly (\"memory-safe\") {\n            mstore(0, tload(slot))\n            return(0, 0x20)\n        }\n    }\n\n    /// @inheritdoc IExttload\n    function exttload(bytes32[] calldata slots) external view returns (bytes32[] memory) {\n        assembly (\"memory-safe\") {\n            let memptr := mload(0x40)\n            let start := memptr\n            // for abi encoding the response - the array will be found at 0x20\n            mstore(memptr, 0x20)\n            // next we store the length of the return array\n            mstore(add(memptr, 0x20), slots.length)\n            // update memptr to the first location to hold an array entry\n            memptr := add(memptr, 0x40)\n            // A left bit-shift of 5 is equivalent to multiplying by 32 but costs less gas.\n            let end := add(memptr, shl(5, slots.length))\n            let calldataptr := slots.offset\n            for {} 1 {} {\n                mstore(memptr, tload(calldataload(calldataptr)))\n                memptr := add(memptr, 0x20)\n                calldataptr := add(calldataptr, 0x20)\n                if iszero(lt(memptr, end)) { break }\n            }\n            return(start, sub(end, start))\n        }\n    }\n}\n"},"lib/v4-periphery/lib/v4-core/src/NoDelegateCall.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport {CustomRevert} from \"./libraries/CustomRevert.sol\";\n\n/// @title Prevents delegatecall to a contract\n/// @notice Base contract that provides a modifier for preventing delegatecall to methods in a child contract\nabstract contract NoDelegateCall {\n    using CustomRevert for bytes4;\n\n    error DelegateCallNotAllowed();\n\n    /// @dev The original address of this contract\n    address private immutable original;\n\n    constructor() {\n        // Immutables are computed in the init code of the contract, and then inlined into the deployed bytecode.\n        // In other words, this variable won't change when it's checked at runtime.\n        original = address(this);\n    }\n\n    /// @dev Private method is used instead of inlining into modifier because modifiers are copied into each method,\n    ///     and the use of immutable means the address bytes are copied in every place the modifier is used.\n    function checkNotDelegateCall() private view {\n        if (address(this) != original) DelegateCallNotAllowed.selector.revertWith();\n    }\n\n    /// @notice Prevents delegatecall into the modified method\n    modifier noDelegateCall() {\n        checkNotDelegateCall();\n        _;\n    }\n}\n"},"lib/v4-periphery/lib/v4-core/src/PoolManager.sol":{"content":"// SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.26;\n\nimport {Hooks} from \"./libraries/Hooks.sol\";\nimport {Pool} from \"./libraries/Pool.sol\";\nimport {SafeCast} from \"./libraries/SafeCast.sol\";\nimport {Position} from \"./libraries/Position.sol\";\nimport {LPFeeLibrary} from \"./libraries/LPFeeLibrary.sol\";\nimport {Currency, CurrencyLibrary} from \"./types/Currency.sol\";\nimport {PoolKey} from \"./types/PoolKey.sol\";\nimport {TickMath} from \"./libraries/TickMath.sol\";\nimport {NoDelegateCall} from \"./NoDelegateCall.sol\";\nimport {IHooks} from \"./interfaces/IHooks.sol\";\nimport {IPoolManager} from \"./interfaces/IPoolManager.sol\";\nimport {IUnlockCallback} from \"./interfaces/callback/IUnlockCallback.sol\";\nimport {ProtocolFees} from \"./ProtocolFees.sol\";\nimport {ERC6909Claims} from \"./ERC6909Claims.sol\";\nimport {PoolId} from \"./types/PoolId.sol\";\nimport {BalanceDelta, BalanceDeltaLibrary} from \"./types/BalanceDelta.sol\";\nimport {BeforeSwapDelta} from \"./types/BeforeSwapDelta.sol\";\nimport {Lock} from \"./libraries/Lock.sol\";\nimport {CurrencyDelta} from \"./libraries/CurrencyDelta.sol\";\nimport {NonzeroDeltaCount} from \"./libraries/NonzeroDeltaCount.sol\";\nimport {CurrencyReserves} from \"./libraries/CurrencyReserves.sol\";\nimport {Extsload} from \"./Extsload.sol\";\nimport {Exttload} from \"./Exttload.sol\";\nimport {CustomRevert} from \"./libraries/CustomRevert.sol\";\n\n//  4\n//   44\n//     444\n//       444                   4444\n//        4444            4444     4444\n//          4444          4444444    4444                           4\n//            4444        44444444     4444                         4\n//             44444       4444444       4444444444444444       444444\n//           4   44444     44444444       444444444444444444444    4444\n//            4    44444    4444444         4444444444444444444444  44444\n//             4     444444  4444444         44444444444444444444444 44  4\n//              44     44444   444444          444444444444444444444 4     4\n//               44      44444   44444           4444444444444444444 4 44\n//                44       4444     44             444444444444444     444\n//                444     4444                        4444444\n//               4444444444444                     44                      4\n//              44444444444                        444444     444444444    44\n//             444444           4444               4444     4444444444      44\n//             4444           44    44              4      44444444444\n//            44444          444444444                   444444444444    4444\n//            44444          44444444                  4444  44444444    444444\n//            44444                                  4444   444444444    44444444\n//           44444                                 4444     44444444    4444444444\n//          44444                                4444      444444444   444444444444\n//         44444                               4444        44444444    444444444444\n//       4444444                             4444          44444444         4444444\n//      4444444                            44444          44444444          4444444\n//     44444444                           44444444444444444444444444444        4444\n//   4444444444                           44444444444444444444444444444         444\n//  444444444444                         444444444444444444444444444444   444   444\n//  44444444444444                                      444444444         44444\n// 44444  44444444444         444                       44444444         444444\n// 44444  4444444444      4444444444      444444        44444444    444444444444\n//  444444444444444      4444  444444    4444444       44444444     444444444444\n//  444444444444444     444    444444     444444       44444444      44444444444\n//   4444444444444     4444   444444        4444                      4444444444\n//    444444444444      4     44444         4444                       444444444\n//     44444444444           444444         444                        44444444\n//      44444444            444444         4444                         4444444\n//                          44444          444                          44444\n//                          44444         444      4                    4444\n//                          44444        444      44                   444\n//                          44444       444      4444\n//                           444444  44444        444\n//                             444444444           444\n//                                                  44444   444\n//                                                      444\n\n/// @title PoolManager\n/// @notice Holds the state for all pools\ncontract PoolManager is IPoolManager, ProtocolFees, NoDelegateCall, ERC6909Claims, Extsload, Exttload {\n    using SafeCast for *;\n    using Pool for *;\n    using Hooks for IHooks;\n    using Position for mapping(bytes32 => Position.State);\n    using CurrencyDelta for Currency;\n    using LPFeeLibrary for uint24;\n    using CurrencyReserves for Currency;\n    using CustomRevert for bytes4;\n\n    int24 private constant MAX_TICK_SPACING = TickMath.MAX_TICK_SPACING;\n\n    int24 private constant MIN_TICK_SPACING = TickMath.MIN_TICK_SPACING;\n\n    mapping(PoolId id => Pool.State) internal _pools;\n\n    /// @notice This will revert if the contract is locked\n    modifier onlyWhenUnlocked() {\n        if (!Lock.isUnlocked()) ManagerLocked.selector.revertWith();\n        _;\n    }\n\n    constructor(address initialOwner) ProtocolFees(initialOwner) {}\n\n    /// @inheritdoc IPoolManager\n    function unlock(bytes calldata data) external override returns (bytes memory result) {\n        if (Lock.isUnlocked()) AlreadyUnlocked.selector.revertWith();\n\n        Lock.unlock();\n\n        // the caller does everything in this callback, including paying what they owe via calls to settle\n        result = IUnlockCallback(msg.sender).unlockCallback(data);\n\n        if (NonzeroDeltaCount.read() != 0) CurrencyNotSettled.selector.revertWith();\n        Lock.lock();\n    }\n\n    /// @inheritdoc IPoolManager\n    function initialize(PoolKey memory key, uint160 sqrtPriceX96) external noDelegateCall returns (int24 tick) {\n        // see TickBitmap.sol for overflow conditions that can arise from tick spacing being too large\n        if (key.tickSpacing > MAX_TICK_SPACING) TickSpacingTooLarge.selector.revertWith(key.tickSpacing);\n        if (key.tickSpacing < MIN_TICK_SPACING) TickSpacingTooSmall.selector.revertWith(key.tickSpacing);\n        if (key.currency0 >= key.currency1) {\n            CurrenciesOutOfOrderOrEqual.selector.revertWith(\n                Currency.unwrap(key.currency0), Currency.unwrap(key.currency1)\n            );\n        }\n        if (!key.hooks.isValidHookAddress(key.fee)) Hooks.HookAddressNotValid.selector.revertWith(address(key.hooks));\n\n        uint24 lpFee = key.fee.getInitialLPFee();\n\n        key.hooks.beforeInitialize(key, sqrtPriceX96);\n\n        PoolId id = key.toId();\n\n        tick = _pools[id].initialize(sqrtPriceX96, lpFee);\n\n        // event is emitted before the afterInitialize call to ensure events are always emitted in order\n        // emit all details of a pool key. poolkeys are not saved in storage and must always be provided by the caller\n        // the key's fee may be a static fee or a sentinel to denote a dynamic fee.\n        emit Initialize(id, key.currency0, key.currency1, key.fee, key.tickSpacing, key.hooks, sqrtPriceX96, tick);\n\n        key.hooks.afterInitialize(key, sqrtPriceX96, tick);\n    }\n\n    /// @inheritdoc IPoolManager\n    function modifyLiquidity(\n        PoolKey memory key,\n        IPoolManager.ModifyLiquidityParams memory params,\n        bytes calldata hookData\n    ) external onlyWhenUnlocked noDelegateCall returns (BalanceDelta callerDelta, BalanceDelta feesAccrued) {\n        PoolId id = key.toId();\n        {\n            Pool.State storage pool = _getPool(id);\n            pool.checkPoolInitialized();\n\n            key.hooks.beforeModifyLiquidity(key, params, hookData);\n\n            BalanceDelta principalDelta;\n            (principalDelta, feesAccrued) = pool.modifyLiquidity(\n                Pool.ModifyLiquidityParams({\n                    owner: msg.sender,\n                    tickLower: params.tickLower,\n                    tickUpper: params.tickUpper,\n                    liquidityDelta: params.liquidityDelta.toInt128(),\n                    tickSpacing: key.tickSpacing,\n                    salt: params.salt\n                })\n            );\n\n            // fee delta and principal delta are both accrued to the caller\n            callerDelta = principalDelta + feesAccrued;\n        }\n\n        // event is emitted before the afterModifyLiquidity call to ensure events are always emitted in order\n        emit ModifyLiquidity(id, msg.sender, params.tickLower, params.tickUpper, params.liquidityDelta, params.salt);\n\n        BalanceDelta hookDelta;\n        (callerDelta, hookDelta) = key.hooks.afterModifyLiquidity(key, params, callerDelta, feesAccrued, hookData);\n\n        // if the hook doesn't have the flag to be able to return deltas, hookDelta will always be 0\n        if (hookDelta != BalanceDeltaLibrary.ZERO_DELTA) _accountPoolBalanceDelta(key, hookDelta, address(key.hooks));\n\n        _accountPoolBalanceDelta(key, callerDelta, msg.sender);\n    }\n\n    /// @inheritdoc IPoolManager\n    function swap(PoolKey memory key, IPoolManager.SwapParams memory params, bytes calldata hookData)\n        external\n        onlyWhenUnlocked\n        noDelegateCall\n        returns (BalanceDelta swapDelta)\n    {\n        if (params.amountSpecified == 0) SwapAmountCannotBeZero.selector.revertWith();\n        PoolId id = key.toId();\n        Pool.State storage pool = _getPool(id);\n        pool.checkPoolInitialized();\n\n        BeforeSwapDelta beforeSwapDelta;\n        {\n            int256 amountToSwap;\n            uint24 lpFeeOverride;\n            (amountToSwap, beforeSwapDelta, lpFeeOverride) = key.hooks.beforeSwap(key, params, hookData);\n\n            // execute swap, account protocol fees, and emit swap event\n            // _swap is needed to avoid stack too deep error\n            swapDelta = _swap(\n                pool,\n                id,\n                Pool.SwapParams({\n                    tickSpacing: key.tickSpacing,\n                    zeroForOne: params.zeroForOne,\n                    amountSpecified: amountToSwap,\n                    sqrtPriceLimitX96: params.sqrtPriceLimitX96,\n                    lpFeeOverride: lpFeeOverride\n                }),\n                params.zeroForOne ? key.currency0 : key.currency1 // input token\n            );\n        }\n\n        BalanceDelta hookDelta;\n        (swapDelta, hookDelta) = key.hooks.afterSwap(key, params, swapDelta, hookData, beforeSwapDelta);\n\n        // if the hook doesn't have the flag to be able to return deltas, hookDelta will always be 0\n        if (hookDelta != BalanceDeltaLibrary.ZERO_DELTA) _accountPoolBalanceDelta(key, hookDelta, address(key.hooks));\n\n        _accountPoolBalanceDelta(key, swapDelta, msg.sender);\n    }\n\n    /// @notice Internal swap function to execute a swap, take protocol fees on input token, and emit the swap event\n    function _swap(Pool.State storage pool, PoolId id, Pool.SwapParams memory params, Currency inputCurrency)\n        internal\n        returns (BalanceDelta)\n    {\n        (BalanceDelta delta, uint256 amountToProtocol, uint24 swapFee, Pool.SwapResult memory result) =\n            pool.swap(params);\n\n        // the fee is on the input currency\n        if (amountToProtocol > 0) _updateProtocolFees(inputCurrency, amountToProtocol);\n\n        // event is emitted before the afterSwap call to ensure events are always emitted in order\n        emit Swap(\n            id,\n            msg.sender,\n            delta.amount0(),\n            delta.amount1(),\n            result.sqrtPriceX96,\n            result.liquidity,\n            result.tick,\n            swapFee\n        );\n\n        return delta;\n    }\n\n    /// @inheritdoc IPoolManager\n    function donate(PoolKey memory key, uint256 amount0, uint256 amount1, bytes calldata hookData)\n        external\n        onlyWhenUnlocked\n        noDelegateCall\n        returns (BalanceDelta delta)\n    {\n        PoolId poolId = key.toId();\n        Pool.State storage pool = _getPool(poolId);\n        pool.checkPoolInitialized();\n\n        key.hooks.beforeDonate(key, amount0, amount1, hookData);\n\n        delta = pool.donate(amount0, amount1);\n\n        _accountPoolBalanceDelta(key, delta, msg.sender);\n\n        // event is emitted before the afterDonate call to ensure events are always emitted in order\n        emit Donate(poolId, msg.sender, amount0, amount1);\n\n        key.hooks.afterDonate(key, amount0, amount1, hookData);\n    }\n\n    /// @inheritdoc IPoolManager\n    function sync(Currency currency) external {\n        // address(0) is used for the native currency\n        if (currency.isAddressZero()) {\n            // The reserves balance is not used for native settling, so we only need to reset the currency.\n            CurrencyReserves.resetCurrency();\n        } else {\n            uint256 balance = currency.balanceOfSelf();\n            CurrencyReserves.syncCurrencyAndReserves(currency, balance);\n        }\n    }\n\n    /// @inheritdoc IPoolManager\n    function take(Currency currency, address to, uint256 amount) external onlyWhenUnlocked {\n        unchecked {\n            // negation must be safe as amount is not negative\n            _accountDelta(currency, -(amount.toInt128()), msg.sender);\n            currency.transfer(to, amount);\n        }\n    }\n\n    /// @inheritdoc IPoolManager\n    function settle() external payable onlyWhenUnlocked returns (uint256) {\n        return _settle(msg.sender);\n    }\n\n    /// @inheritdoc IPoolManager\n    function settleFor(address recipient) external payable onlyWhenUnlocked returns (uint256) {\n        return _settle(recipient);\n    }\n\n    /// @inheritdoc IPoolManager\n    function clear(Currency currency, uint256 amount) external onlyWhenUnlocked {\n        int256 current = currency.getDelta(msg.sender);\n        // Because input is `uint256`, only positive amounts can be cleared.\n        int128 amountDelta = amount.toInt128();\n        if (amountDelta != current) MustClearExactPositiveDelta.selector.revertWith();\n        // negation must be safe as amountDelta is positive\n        unchecked {\n            _accountDelta(currency, -(amountDelta), msg.sender);\n        }\n    }\n\n    /// @inheritdoc IPoolManager\n    function mint(address to, uint256 id, uint256 amount) external onlyWhenUnlocked {\n        unchecked {\n            Currency currency = CurrencyLibrary.fromId(id);\n            // negation must be safe as amount is not negative\n            _accountDelta(currency, -(amount.toInt128()), msg.sender);\n            _mint(to, currency.toId(), amount);\n        }\n    }\n\n    /// @inheritdoc IPoolManager\n    function burn(address from, uint256 id, uint256 amount) external onlyWhenUnlocked {\n        Currency currency = CurrencyLibrary.fromId(id);\n        _accountDelta(currency, amount.toInt128(), msg.sender);\n        _burnFrom(from, currency.toId(), amount);\n    }\n\n    /// @inheritdoc IPoolManager\n    function updateDynamicLPFee(PoolKey memory key, uint24 newDynamicLPFee) external {\n        if (!key.fee.isDynamicFee() || msg.sender != address(key.hooks)) {\n            UnauthorizedDynamicLPFeeUpdate.selector.revertWith();\n        }\n        newDynamicLPFee.validate();\n        PoolId id = key.toId();\n        _pools[id].setLPFee(newDynamicLPFee);\n    }\n\n    // if settling native, integrators should still call `sync` first to avoid DoS attack vectors\n    function _settle(address recipient) internal returns (uint256 paid) {\n        Currency currency = CurrencyReserves.getSyncedCurrency();\n\n        // if not previously synced, or the syncedCurrency slot has been reset, expects native currency to be settled\n        if (currency.isAddressZero()) {\n            paid = msg.value;\n        } else {\n            if (msg.value > 0) NonzeroNativeValue.selector.revertWith();\n            // Reserves are guaranteed to be set because currency and reserves are always set together\n            uint256 reservesBefore = CurrencyReserves.getSyncedReserves();\n            uint256 reservesNow = currency.balanceOfSelf();\n            paid = reservesNow - reservesBefore;\n            CurrencyReserves.resetCurrency();\n        }\n\n        _accountDelta(currency, paid.toInt128(), recipient);\n    }\n\n    /// @notice Adds a balance delta in a currency for a target address\n    function _accountDelta(Currency currency, int128 delta, address target) internal {\n        if (delta == 0) return;\n\n        (int256 previous, int256 next) = currency.applyDelta(target, delta);\n\n        if (next == 0) {\n            NonzeroDeltaCount.decrement();\n        } else if (previous == 0) {\n            NonzeroDeltaCount.increment();\n        }\n    }\n\n    /// @notice Accounts the deltas of 2 currencies to a target address\n    function _accountPoolBalanceDelta(PoolKey memory key, BalanceDelta delta, address target) internal {\n        _accountDelta(key.currency0, delta.amount0(), target);\n        _accountDelta(key.currency1, delta.amount1(), target);\n    }\n\n    /// @notice Implementation of the _getPool function defined in ProtocolFees\n    function _getPool(PoolId id) internal view override returns (Pool.State storage) {\n        return _pools[id];\n    }\n\n    /// @notice Implementation of the _isUnlocked function defined in ProtocolFees\n    function _isUnlocked() internal view override returns (bool) {\n        return Lock.isUnlocked();\n    }\n}\n"},"lib/v4-periphery/lib/v4-core/src/ProtocolFees.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport {Currency} from \"./types/Currency.sol\";\nimport {CurrencyReserves} from \"./libraries/CurrencyReserves.sol\";\nimport {IProtocolFees} from \"./interfaces/IProtocolFees.sol\";\nimport {PoolKey} from \"./types/PoolKey.sol\";\nimport {ProtocolFeeLibrary} from \"./libraries/ProtocolFeeLibrary.sol\";\nimport {Owned} from \"solmate/src/auth/Owned.sol\";\nimport {PoolId} from \"./types/PoolId.sol\";\nimport {Pool} from \"./libraries/Pool.sol\";\nimport {CustomRevert} from \"./libraries/CustomRevert.sol\";\n\n/// @notice Contract handling the setting and accrual of protocol fees\nabstract contract ProtocolFees is IProtocolFees, Owned {\n    using ProtocolFeeLibrary for uint24;\n    using Pool for Pool.State;\n    using CustomRevert for bytes4;\n\n    /// @inheritdoc IProtocolFees\n    mapping(Currency currency => uint256 amount) public protocolFeesAccrued;\n\n    /// @inheritdoc IProtocolFees\n    address public protocolFeeController;\n\n    constructor(address initialOwner) Owned(initialOwner) {}\n\n    /// @inheritdoc IProtocolFees\n    function setProtocolFeeController(address controller) external onlyOwner {\n        protocolFeeController = controller;\n        emit ProtocolFeeControllerUpdated(controller);\n    }\n\n    /// @inheritdoc IProtocolFees\n    function setProtocolFee(PoolKey memory key, uint24 newProtocolFee) external {\n        if (msg.sender != protocolFeeController) InvalidCaller.selector.revertWith();\n        if (!newProtocolFee.isValidProtocolFee()) ProtocolFeeTooLarge.selector.revertWith(newProtocolFee);\n        PoolId id = key.toId();\n        _getPool(id).setProtocolFee(newProtocolFee);\n        emit ProtocolFeeUpdated(id, newProtocolFee);\n    }\n\n    /// @inheritdoc IProtocolFees\n    function collectProtocolFees(address recipient, Currency currency, uint256 amount)\n        external\n        returns (uint256 amountCollected)\n    {\n        if (msg.sender != protocolFeeController) InvalidCaller.selector.revertWith();\n        if (!currency.isAddressZero() && CurrencyReserves.getSyncedCurrency() == currency) {\n            // prevent transfer between the sync and settle balanceOfs (native settle uses msg.value)\n            ProtocolFeeCurrencySynced.selector.revertWith();\n        }\n\n        amountCollected = (amount == 0) ? protocolFeesAccrued[currency] : amount;\n        protocolFeesAccrued[currency] -= amountCollected;\n        currency.transfer(recipient, amountCollected);\n    }\n\n    /// @dev abstract internal function to allow the ProtocolFees contract to access the lock\n    function _isUnlocked() internal virtual returns (bool);\n\n    /// @dev abstract internal function to allow the ProtocolFees contract to access pool state\n    /// @dev this is overridden in PoolManager.sol to give access to the _pools mapping\n    function _getPool(PoolId id) internal virtual returns (Pool.State storage);\n\n    function _updateProtocolFees(Currency currency, uint256 amount) internal {\n        unchecked {\n            protocolFeesAccrued[currency] += amount;\n        }\n    }\n}\n"},"lib/v4-periphery/lib/v4-core/src/interfaces/IExtsload.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\n/// @notice Interface for functions to access any storage slot in a contract\ninterface IExtsload {\n    /// @notice Called by external contracts to access granular pool state\n    /// @param slot Key of slot to sload\n    /// @return value The value of the slot as bytes32\n    function extsload(bytes32 slot) external view returns (bytes32 value);\n\n    /// @notice Called by external contracts to access granular pool state\n    /// @param startSlot Key of slot to start sloading from\n    /// @param nSlots Number of slots to load into return value\n    /// @return values List of loaded values.\n    function extsload(bytes32 startSlot, uint256 nSlots) external view returns (bytes32[] memory values);\n\n    /// @notice Called by external contracts to access sparse pool state\n    /// @param slots List of slots to SLOAD from.\n    /// @return values List of loaded values.\n    function extsload(bytes32[] calldata slots) external view returns (bytes32[] memory values);\n}\n"},"lib/v4-periphery/lib/v4-core/src/interfaces/IExttload.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity ^0.8.24;\n\n/// @notice Interface for functions to access any transient storage slot in a contract\ninterface IExttload {\n    /// @notice Called by external contracts to access transient storage of the contract\n    /// @param slot Key of slot to tload\n    /// @return value The value of the slot as bytes32\n    function exttload(bytes32 slot) external view returns (bytes32 value);\n\n    /// @notice Called by external contracts to access sparse transient pool state\n    /// @param slots List of slots to tload\n    /// @return values List of loaded values\n    function exttload(bytes32[] calldata slots) external view returns (bytes32[] memory values);\n}\n"},"lib/v4-periphery/lib/v4-core/src/interfaces/IHooks.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport {PoolKey} from \"../types/PoolKey.sol\";\nimport {BalanceDelta} from \"../types/BalanceDelta.sol\";\nimport {IPoolManager} from \"./IPoolManager.sol\";\nimport {BeforeSwapDelta} from \"../types/BeforeSwapDelta.sol\";\n\n/// @notice V4 decides whether to invoke specific hooks by inspecting the least significant bits\n/// of the address that the hooks contract is deployed to.\n/// For example, a hooks contract deployed to address: 0x0000000000000000000000000000000000002400\n/// has the lowest bits '10 0100 0000 0000' which would cause the 'before initialize' and 'after add liquidity' hooks to be used.\n/// See the Hooks library for the full spec.\n/// @dev Should only be callable by the v4 PoolManager.\ninterface IHooks {\n    /// @notice The hook called before the state of a pool is initialized\n    /// @param sender The initial msg.sender for the initialize call\n    /// @param key The key for the pool being initialized\n    /// @param sqrtPriceX96 The sqrt(price) of the pool as a Q64.96\n    /// @return bytes4 The function selector for the hook\n    function beforeInitialize(address sender, PoolKey calldata key, uint160 sqrtPriceX96) external returns (bytes4);\n\n    /// @notice The hook called after the state of a pool is initialized\n    /// @param sender The initial msg.sender for the initialize call\n    /// @param key The key for the pool being initialized\n    /// @param sqrtPriceX96 The sqrt(price) of the pool as a Q64.96\n    /// @param tick The current tick after the state of a pool is initialized\n    /// @return bytes4 The function selector for the hook\n    function afterInitialize(address sender, PoolKey calldata key, uint160 sqrtPriceX96, int24 tick)\n        external\n        returns (bytes4);\n\n    /// @notice The hook called before liquidity is added\n    /// @param sender The initial msg.sender for the add liquidity call\n    /// @param key The key for the pool\n    /// @param params The parameters for adding liquidity\n    /// @param hookData Arbitrary data handed into the PoolManager by the liquidity provider to be passed on to the hook\n    /// @return bytes4 The function selector for the hook\n    function beforeAddLiquidity(\n        address sender,\n        PoolKey calldata key,\n        IPoolManager.ModifyLiquidityParams calldata params,\n        bytes calldata hookData\n    ) external returns (bytes4);\n\n    /// @notice The hook called after liquidity is added\n    /// @param sender The initial msg.sender for the add liquidity call\n    /// @param key The key for the pool\n    /// @param params The parameters for adding liquidity\n    /// @param delta The caller's balance delta after adding liquidity; the sum of principal delta, fees accrued, and hook delta\n    /// @param feesAccrued The fees accrued since the last time fees were collected from this position\n    /// @param hookData Arbitrary data handed into the PoolManager by the liquidity provider to be passed on to the hook\n    /// @return bytes4 The function selector for the hook\n    /// @return BalanceDelta The hook's delta in token0 and token1. Positive: the hook is owed/took currency, negative: the hook owes/sent currency\n    function afterAddLiquidity(\n        address sender,\n        PoolKey calldata key,\n        IPoolManager.ModifyLiquidityParams calldata params,\n        BalanceDelta delta,\n        BalanceDelta feesAccrued,\n        bytes calldata hookData\n    ) external returns (bytes4, BalanceDelta);\n\n    /// @notice The hook called before liquidity is removed\n    /// @param sender The initial msg.sender for the remove liquidity call\n    /// @param key The key for the pool\n    /// @param params The parameters for removing liquidity\n    /// @param hookData Arbitrary data handed into the PoolManager by the liquidity provider to be be passed on to the hook\n    /// @return bytes4 The function selector for the hook\n    function beforeRemoveLiquidity(\n        address sender,\n        PoolKey calldata key,\n        IPoolManager.ModifyLiquidityParams calldata params,\n        bytes calldata hookData\n    ) external returns (bytes4);\n\n    /// @notice The hook called after liquidity is removed\n    /// @param sender The initial msg.sender for the remove liquidity call\n    /// @param key The key for the pool\n    /// @param params The parameters for removing liquidity\n    /// @param delta The caller's balance delta after removing liquidity; the sum of principal delta, fees accrued, and hook delta\n    /// @param feesAccrued The fees accrued since the last time fees were collected from this position\n    /// @param hookData Arbitrary data handed into the PoolManager by the liquidity provider to be be passed on to the hook\n    /// @return bytes4 The function selector for the hook\n    /// @return BalanceDelta The hook's delta in token0 and token1. Positive: the hook is owed/took currency, negative: the hook owes/sent currency\n    function afterRemoveLiquidity(\n        address sender,\n        PoolKey calldata key,\n        IPoolManager.ModifyLiquidityParams calldata params,\n        BalanceDelta delta,\n        BalanceDelta feesAccrued,\n        bytes calldata hookData\n    ) external returns (bytes4, BalanceDelta);\n\n    /// @notice The hook called before a swap\n    /// @param sender The initial msg.sender for the swap call\n    /// @param key The key for the pool\n    /// @param params The parameters for the swap\n    /// @param hookData Arbitrary data handed into the PoolManager by the swapper to be be passed on to the hook\n    /// @return bytes4 The function selector for the hook\n    /// @return BeforeSwapDelta The hook's delta in specified and unspecified currencies. Positive: the hook is owed/took currency, negative: the hook owes/sent currency\n    /// @return uint24 Optionally override the lp fee, only used if three conditions are met: 1. the Pool has a dynamic fee, 2. the value's 2nd highest bit is set (23rd bit, 0x400000), and 3. the value is less than or equal to the maximum fee (1 million)\n    function beforeSwap(\n        address sender,\n        PoolKey calldata key,\n        IPoolManager.SwapParams calldata params,\n        bytes calldata hookData\n    ) external returns (bytes4, BeforeSwapDelta, uint24);\n\n    /// @notice The hook called after a swap\n    /// @param sender The initial msg.sender for the swap call\n    /// @param key The key for the pool\n    /// @param params The parameters for the swap\n    /// @param delta The amount owed to the caller (positive) or owed to the pool (negative)\n    /// @param hookData Arbitrary data handed into the PoolManager by the swapper to be be passed on to the hook\n    /// @return bytes4 The function selector for the hook\n    /// @return int128 The hook's delta in unspecified currency. Positive: the hook is owed/took currency, negative: the hook owes/sent currency\n    function afterSwap(\n        address sender,\n        PoolKey calldata key,\n        IPoolManager.SwapParams calldata params,\n        BalanceDelta delta,\n        bytes calldata hookData\n    ) external returns (bytes4, int128);\n\n    /// @notice The hook called before donate\n    /// @param sender The initial msg.sender for the donate call\n    /// @param key The key for the pool\n    /// @param amount0 The amount of token0 being donated\n    /// @param amount1 The amount of token1 being donated\n    /// @param hookData Arbitrary data handed into the PoolManager by the donor to be be passed on to the hook\n    /// @return bytes4 The function selector for the hook\n    function beforeDonate(\n        address sender,\n        PoolKey calldata key,\n        uint256 amount0,\n        uint256 amount1,\n        bytes calldata hookData\n    ) external returns (bytes4);\n\n    /// @notice The hook called after donate\n    /// @param sender The initial msg.sender for the donate call\n    /// @param key The key for the pool\n    /// @param amount0 The amount of token0 being donated\n    /// @param amount1 The amount of token1 being donated\n    /// @param hookData Arbitrary data handed into the PoolManager by the donor to be be passed on to the hook\n    /// @return bytes4 The function selector for the hook\n    function afterDonate(\n        address sender,\n        PoolKey calldata key,\n        uint256 amount0,\n        uint256 amount1,\n        bytes calldata hookData\n    ) external returns (bytes4);\n}\n"},"lib/v4-periphery/lib/v4-core/src/interfaces/IPoolManager.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity ^0.8.24;\n\nimport {Currency} from \"../types/Currency.sol\";\nimport {PoolKey} from \"../types/PoolKey.sol\";\nimport {IHooks} from \"./IHooks.sol\";\nimport {IERC6909Claims} from \"./external/IERC6909Claims.sol\";\nimport {IProtocolFees} from \"./IProtocolFees.sol\";\nimport {BalanceDelta} from \"../types/BalanceDelta.sol\";\nimport {PoolId} from \"../types/PoolId.sol\";\nimport {IExtsload} from \"./IExtsload.sol\";\nimport {IExttload} from \"./IExttload.sol\";\n\n/// @notice Interface for the PoolManager\ninterface IPoolManager is IProtocolFees, IERC6909Claims, IExtsload, IExttload {\n    /// @notice Thrown when a currency is not netted out after the contract is unlocked\n    error CurrencyNotSettled();\n\n    /// @notice Thrown when trying to interact with a non-initialized pool\n    error PoolNotInitialized();\n\n    /// @notice Thrown when unlock is called, but the contract is already unlocked\n    error AlreadyUnlocked();\n\n    /// @notice Thrown when a function is called that requires the contract to be unlocked, but it is not\n    error ManagerLocked();\n\n    /// @notice Pools are limited to type(int16).max tickSpacing in #initialize, to prevent overflow\n    error TickSpacingTooLarge(int24 tickSpacing);\n\n    /// @notice Pools must have a positive non-zero tickSpacing passed to #initialize\n    error TickSpacingTooSmall(int24 tickSpacing);\n\n    /// @notice PoolKey must have currencies where address(currency0) < address(currency1)\n    error CurrenciesOutOfOrderOrEqual(address currency0, address currency1);\n\n    /// @notice Thrown when a call to updateDynamicLPFee is made by an address that is not the hook,\n    /// or on a pool that does not have a dynamic swap fee.\n    error UnauthorizedDynamicLPFeeUpdate();\n\n    /// @notice Thrown when trying to swap amount of 0\n    error SwapAmountCannotBeZero();\n\n    ///@notice Thrown when native currency is passed to a non native settlement\n    error NonzeroNativeValue();\n\n    /// @notice Thrown when `clear` is called with an amount that is not exactly equal to the open currency delta.\n    error MustClearExactPositiveDelta();\n\n    /// @notice Emitted when a new pool is initialized\n    /// @param id The abi encoded hash of the pool key struct for the new pool\n    /// @param currency0 The first currency of the pool by address sort order\n    /// @param currency1 The second currency of the pool by address sort order\n    /// @param fee The fee collected upon every swap in the pool, denominated in hundredths of a bip\n    /// @param tickSpacing The minimum number of ticks between initialized ticks\n    /// @param hooks The hooks contract address for the pool, or address(0) if none\n    /// @param sqrtPriceX96 The price of the pool on initialization\n    /// @param tick The initial tick of the pool corresponding to the initialized price\n    event Initialize(\n        PoolId indexed id,\n        Currency indexed currency0,\n        Currency indexed currency1,\n        uint24 fee,\n        int24 tickSpacing,\n        IHooks hooks,\n        uint160 sqrtPriceX96,\n        int24 tick\n    );\n\n    /// @notice Emitted when a liquidity position is modified\n    /// @param id The abi encoded hash of the pool key struct for the pool that was modified\n    /// @param sender The address that modified the pool\n    /// @param tickLower The lower tick of the position\n    /// @param tickUpper The upper tick of the position\n    /// @param liquidityDelta The amount of liquidity that was added or removed\n    /// @param salt The extra data to make positions unique\n    event ModifyLiquidity(\n        PoolId indexed id, address indexed sender, int24 tickLower, int24 tickUpper, int256 liquidityDelta, bytes32 salt\n    );\n\n    /// @notice Emitted for swaps between currency0 and currency1\n    /// @param id The abi encoded hash of the pool key struct for the pool that was modified\n    /// @param sender The address that initiated the swap call, and that received the callback\n    /// @param amount0 The delta of the currency0 balance of the pool\n    /// @param amount1 The delta of the currency1 balance of the pool\n    /// @param sqrtPriceX96 The sqrt(price) of the pool after the swap, as a Q64.96\n    /// @param liquidity The liquidity of the pool after the swap\n    /// @param tick The log base 1.0001 of the price of the pool after the swap\n    /// @param fee The swap fee in hundredths of a bip\n    event Swap(\n        PoolId indexed id,\n        address indexed sender,\n        int128 amount0,\n        int128 amount1,\n        uint160 sqrtPriceX96,\n        uint128 liquidity,\n        int24 tick,\n        uint24 fee\n    );\n\n    /// @notice Emitted for donations\n    /// @param id The abi encoded hash of the pool key struct for the pool that was donated to\n    /// @param sender The address that initiated the donate call\n    /// @param amount0 The amount donated in currency0\n    /// @param amount1 The amount donated in currency1\n    event Donate(PoolId indexed id, address indexed sender, uint256 amount0, uint256 amount1);\n\n    /// @notice All interactions on the contract that account deltas require unlocking. A caller that calls `unlock` must implement\n    /// `IUnlockCallback(msg.sender).unlockCallback(data)`, where they interact with the remaining functions on this contract.\n    /// @dev The only functions callable without an unlocking are `initialize` and `updateDynamicLPFee`\n    /// @param data Any data to pass to the callback, via `IUnlockCallback(msg.sender).unlockCallback(data)`\n    /// @return The data returned by the call to `IUnlockCallback(msg.sender).unlockCallback(data)`\n    function unlock(bytes calldata data) external returns (bytes memory);\n\n    /// @notice Initialize the state for a given pool ID\n    /// @dev A swap fee totaling MAX_SWAP_FEE (100%) makes exact output swaps impossible since the input is entirely consumed by the fee\n    /// @param key The pool key for the pool to initialize\n    /// @param sqrtPriceX96 The initial square root price\n    /// @return tick The initial tick of the pool\n    function initialize(PoolKey memory key, uint160 sqrtPriceX96) external returns (int24 tick);\n\n    struct ModifyLiquidityParams {\n        // the lower and upper tick of the position\n        int24 tickLower;\n        int24 tickUpper;\n        // how to modify the liquidity\n        int256 liquidityDelta;\n        // a value to set if you want unique liquidity positions at the same range\n        bytes32 salt;\n    }\n\n    /// @notice Modify the liquidity for the given pool\n    /// @dev Poke by calling with a zero liquidityDelta\n    /// @param key The pool to modify liquidity in\n    /// @param params The parameters for modifying the liquidity\n    /// @param hookData The data to pass through to the add/removeLiquidity hooks\n    /// @return callerDelta The balance delta of the caller of modifyLiquidity. This is the total of both principal, fee deltas, and hook deltas if applicable\n    /// @return feesAccrued The balance delta of the fees generated in the liquidity range. Returned for informational purposes\n    function modifyLiquidity(PoolKey memory key, ModifyLiquidityParams memory params, bytes calldata hookData)\n        external\n        returns (BalanceDelta callerDelta, BalanceDelta feesAccrued);\n\n    struct SwapParams {\n        /// Whether to swap token0 for token1 or vice versa\n        bool zeroForOne;\n        /// The desired input amount if negative (exactIn), or the desired output amount if positive (exactOut)\n        int256 amountSpecified;\n        /// The sqrt price at which, if reached, the swap will stop executing\n        uint160 sqrtPriceLimitX96;\n    }\n\n    /// @notice Swap against the given pool\n    /// @param key The pool to swap in\n    /// @param params The parameters for swapping\n    /// @param hookData The data to pass through to the swap hooks\n    /// @return swapDelta The balance delta of the address swapping\n    /// @dev Swapping on low liquidity pools may cause unexpected swap amounts when liquidity available is less than amountSpecified.\n    /// Additionally note that if interacting with hooks that have the BEFORE_SWAP_RETURNS_DELTA_FLAG or AFTER_SWAP_RETURNS_DELTA_FLAG\n    /// the hook may alter the swap input/output. Integrators should perform checks on the returned swapDelta.\n    function swap(PoolKey memory key, SwapParams memory params, bytes calldata hookData)\n        external\n        returns (BalanceDelta swapDelta);\n\n    /// @notice Donate the given currency amounts to the in-range liquidity providers of a pool\n    /// @dev Calls to donate can be frontrun adding just-in-time liquidity, with the aim of receiving a portion donated funds.\n    /// Donors should keep this in mind when designing donation mechanisms.\n    /// @dev This function donates to in-range LPs at slot0.tick. In certain edge-cases of the swap algorithm, the `sqrtPrice` of\n    /// a pool can be at the lower boundary of tick `n`, but the `slot0.tick` of the pool is already `n - 1`. In this case a call to\n    /// `donate` would donate to tick `n - 1` (slot0.tick) not tick `n` (getTickAtSqrtPrice(slot0.sqrtPriceX96)).\n    /// Read the comments in `Pool.swap()` for more information about this.\n    /// @param key The key of the pool to donate to\n    /// @param amount0 The amount of currency0 to donate\n    /// @param amount1 The amount of currency1 to donate\n    /// @param hookData The data to pass through to the donate hooks\n    /// @return BalanceDelta The delta of the caller after the donate\n    function donate(PoolKey memory key, uint256 amount0, uint256 amount1, bytes calldata hookData)\n        external\n        returns (BalanceDelta);\n\n    /// @notice Writes the current ERC20 balance of the specified currency to transient storage\n    /// This is used to checkpoint balances for the manager and derive deltas for the caller.\n    /// @dev This MUST be called before any ERC20 tokens are sent into the contract, but can be skipped\n    /// for native tokens because the amount to settle is determined by the sent value.\n    /// However, if an ERC20 token has been synced and not settled, and the caller instead wants to settle\n    /// native funds, this function can be called with the native currency to then be able to settle the native currency\n    function sync(Currency currency) external;\n\n    /// @notice Called by the user to net out some value owed to the user\n    /// @dev Will revert if the requested amount is not available, consider using `mint` instead\n    /// @dev Can also be used as a mechanism for free flash loans\n    /// @param currency The currency to withdraw from the pool manager\n    /// @param to The address to withdraw to\n    /// @param amount The amount of currency to withdraw\n    function take(Currency currency, address to, uint256 amount) external;\n\n    /// @notice Called by the user to pay what is owed\n    /// @return paid The amount of currency settled\n    function settle() external payable returns (uint256 paid);\n\n    /// @notice Called by the user to pay on behalf of another address\n    /// @param recipient The address to credit for the payment\n    /// @return paid The amount of currency settled\n    function settleFor(address recipient) external payable returns (uint256 paid);\n\n    /// @notice WARNING - Any currency that is cleared, will be non-retrievable, and locked in the contract permanently.\n    /// A call to clear will zero out a positive balance WITHOUT a corresponding transfer.\n    /// @dev This could be used to clear a balance that is considered dust.\n    /// Additionally, the amount must be the exact positive balance. This is to enforce that the caller is aware of the amount being cleared.\n    function clear(Currency currency, uint256 amount) external;\n\n    /// @notice Called by the user to move value into ERC6909 balance\n    /// @param to The address to mint the tokens to\n    /// @param id The currency address to mint to ERC6909s, as a uint256\n    /// @param amount The amount of currency to mint\n    /// @dev The id is converted to a uint160 to correspond to a currency address\n    /// If the upper 12 bytes are not 0, they will be 0-ed out\n    function mint(address to, uint256 id, uint256 amount) external;\n\n    /// @notice Called by the user to move value from ERC6909 balance\n    /// @param from The address to burn the tokens from\n    /// @param id The currency address to burn from ERC6909s, as a uint256\n    /// @param amount The amount of currency to burn\n    /// @dev The id is converted to a uint160 to correspond to a currency address\n    /// If the upper 12 bytes are not 0, they will be 0-ed out\n    function burn(address from, uint256 id, uint256 amount) external;\n\n    /// @notice Updates the pools lp fees for the a pool that has enabled dynamic lp fees.\n    /// @dev A swap fee totaling MAX_SWAP_FEE (100%) makes exact output swaps impossible since the input is entirely consumed by the fee\n    /// @param key The key of the pool to update dynamic LP fees for\n    /// @param newDynamicLPFee The new dynamic pool LP fee\n    function updateDynamicLPFee(PoolKey memory key, uint24 newDynamicLPFee) external;\n}\n"},"lib/v4-periphery/lib/v4-core/src/interfaces/IProtocolFees.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport {Currency} from \"../types/Currency.sol\";\nimport {PoolId} from \"../types/PoolId.sol\";\nimport {PoolKey} from \"../types/PoolKey.sol\";\n\n/// @notice Interface for all protocol-fee related functions in the pool manager\ninterface IProtocolFees {\n    /// @notice Thrown when protocol fee is set too high\n    error ProtocolFeeTooLarge(uint24 fee);\n\n    /// @notice Thrown when collectProtocolFees or setProtocolFee is not called by the controller.\n    error InvalidCaller();\n\n    /// @notice Thrown when collectProtocolFees is attempted on a token that is synced.\n    error ProtocolFeeCurrencySynced();\n\n    /// @notice Emitted when the protocol fee controller address is updated in setProtocolFeeController.\n    event ProtocolFeeControllerUpdated(address indexed protocolFeeController);\n\n    /// @notice Emitted when the protocol fee is updated for a pool.\n    event ProtocolFeeUpdated(PoolId indexed id, uint24 protocolFee);\n\n    /// @notice Given a currency address, returns the protocol fees accrued in that currency\n    /// @param currency The currency to check\n    /// @return amount The amount of protocol fees accrued in the currency\n    function protocolFeesAccrued(Currency currency) external view returns (uint256 amount);\n\n    /// @notice Sets the protocol fee for the given pool\n    /// @param key The key of the pool to set a protocol fee for\n    /// @param newProtocolFee The fee to set\n    function setProtocolFee(PoolKey memory key, uint24 newProtocolFee) external;\n\n    /// @notice Sets the protocol fee controller\n    /// @param controller The new protocol fee controller\n    function setProtocolFeeController(address controller) external;\n\n    /// @notice Collects the protocol fees for a given recipient and currency, returning the amount collected\n    /// @dev This will revert if the contract is unlocked\n    /// @param recipient The address to receive the protocol fees\n    /// @param currency The currency to withdraw\n    /// @param amount The amount of currency to withdraw\n    /// @return amountCollected The amount of currency successfully withdrawn\n    function collectProtocolFees(address recipient, Currency currency, uint256 amount)\n        external\n        returns (uint256 amountCollected);\n\n    /// @notice Returns the current protocol fee controller address\n    /// @return address The current protocol fee controller address\n    function protocolFeeController() external view returns (address);\n}\n"},"lib/v4-periphery/lib/v4-core/src/interfaces/callback/IUnlockCallback.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\n/// @notice Interface for the callback executed when an address unlocks the pool manager\ninterface IUnlockCallback {\n    /// @notice Called by the pool manager on `msg.sender` when the manager is unlocked\n    /// @param data The data that was passed to the call to unlock\n    /// @return Any data that you want to be returned from the unlock call\n    function unlockCallback(bytes calldata data) external returns (bytes memory);\n}\n"},"lib/v4-periphery/lib/v4-core/src/interfaces/external/IERC20Minimal.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\n/// @title Minimal ERC20 interface for Uniswap\n/// @notice Contains a subset of the full ERC20 interface that is used in Uniswap V3\ninterface IERC20Minimal {\n    /// @notice Returns an account's balance in the token\n    /// @param account The account for which to look up the number of tokens it has, i.e. its balance\n    /// @return The number of tokens held by the account\n    function balanceOf(address account) external view returns (uint256);\n\n    /// @notice Transfers the amount of token from the `msg.sender` to the recipient\n    /// @param recipient The account that will receive the amount transferred\n    /// @param amount The number of tokens to send from the sender to the recipient\n    /// @return Returns true for a successful transfer, false for an unsuccessful transfer\n    function transfer(address recipient, uint256 amount) external returns (bool);\n\n    /// @notice Returns the current allowance given to a spender by an owner\n    /// @param owner The account of the token owner\n    /// @param spender The account of the token spender\n    /// @return The current allowance granted by `owner` to `spender`\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    /// @notice Sets the allowance of a spender from the `msg.sender` to the value `amount`\n    /// @param spender The account which will be allowed to spend a given amount of the owners tokens\n    /// @param amount The amount of tokens allowed to be used by `spender`\n    /// @return Returns true for a successful approval, false for unsuccessful\n    function approve(address spender, uint256 amount) external returns (bool);\n\n    /// @notice Transfers `amount` tokens from `sender` to `recipient` up to the allowance given to the `msg.sender`\n    /// @param sender The account from which the transfer will be initiated\n    /// @param recipient The recipient of the transfer\n    /// @param amount The amount of the transfer\n    /// @return Returns true for a successful transfer, false for unsuccessful\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\n\n    /// @notice Event emitted when tokens are transferred from one address to another, either via `#transfer` or `#transferFrom`.\n    /// @param from The account from which the tokens were sent, i.e. the balance decreased\n    /// @param to The account to which the tokens were sent, i.e. the balance increased\n    /// @param value The amount of tokens that were transferred\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    /// @notice Event emitted when the approval amount for the spender of a given owner's tokens changes.\n    /// @param owner The account that approved spending of its tokens\n    /// @param spender The account for which the spending allowance was modified\n    /// @param value The new allowance from the owner to the spender\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n}\n"},"lib/v4-periphery/lib/v4-core/src/interfaces/external/IERC6909Claims.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\n/// @notice Interface for claims over a contract balance, wrapped as a ERC6909\ninterface IERC6909Claims {\n    /*//////////////////////////////////////////////////////////////\n                                 EVENTS\n    //////////////////////////////////////////////////////////////*/\n\n    event OperatorSet(address indexed owner, address indexed operator, bool approved);\n\n    event Approval(address indexed owner, address indexed spender, uint256 indexed id, uint256 amount);\n\n    event Transfer(address caller, address indexed from, address indexed to, uint256 indexed id, uint256 amount);\n\n    /*//////////////////////////////////////////////////////////////\n                                 FUNCTIONS\n    //////////////////////////////////////////////////////////////*/\n\n    /// @notice Owner balance of an id.\n    /// @param owner The address of the owner.\n    /// @param id The id of the token.\n    /// @return amount The balance of the token.\n    function balanceOf(address owner, uint256 id) external view returns (uint256 amount);\n\n    /// @notice Spender allowance of an id.\n    /// @param owner The address of the owner.\n    /// @param spender The address of the spender.\n    /// @param id The id of the token.\n    /// @return amount The allowance of the token.\n    function allowance(address owner, address spender, uint256 id) external view returns (uint256 amount);\n\n    /// @notice Checks if a spender is approved by an owner as an operator\n    /// @param owner The address of the owner.\n    /// @param spender The address of the spender.\n    /// @return approved The approval status.\n    function isOperator(address owner, address spender) external view returns (bool approved);\n\n    /// @notice Transfers an amount of an id from the caller to a receiver.\n    /// @param receiver The address of the receiver.\n    /// @param id The id of the token.\n    /// @param amount The amount of the token.\n    /// @return bool True, always, unless the function reverts\n    function transfer(address receiver, uint256 id, uint256 amount) external returns (bool);\n\n    /// @notice Transfers an amount of an id from a sender to a receiver.\n    /// @param sender The address of the sender.\n    /// @param receiver The address of the receiver.\n    /// @param id The id of the token.\n    /// @param amount The amount of the token.\n    /// @return bool True, always, unless the function reverts\n    function transferFrom(address sender, address receiver, uint256 id, uint256 amount) external returns (bool);\n\n    /// @notice Approves an amount of an id to a spender.\n    /// @param spender The address of the spender.\n    /// @param id The id of the token.\n    /// @param amount The amount of the token.\n    /// @return bool True, always\n    function approve(address spender, uint256 id, uint256 amount) external returns (bool);\n\n    /// @notice Sets or removes an operator for the caller.\n    /// @param operator The address of the operator.\n    /// @param approved The approval status.\n    /// @return bool True, always\n    function setOperator(address operator, bool approved) external returns (bool);\n}\n"},"lib/v4-periphery/lib/v4-core/src/libraries/BitMath.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\n/// @title BitMath\n/// @dev This library provides functionality for computing bit properties of an unsigned integer\n/// @author Solady (https://github.com/Vectorized/solady/blob/8200a70e8dc2a77ecb074fc2e99a2a0d36547522/src/utils/LibBit.sol)\nlibrary BitMath {\n    /// @notice Returns the index of the most significant bit of the number,\n    ///     where the least significant bit is at index 0 and the most significant bit is at index 255\n    /// @param x the value for which to compute the most significant bit, must be greater than 0\n    /// @return r the index of the most significant bit\n    function mostSignificantBit(uint256 x) internal pure returns (uint8 r) {\n        require(x > 0);\n\n        assembly (\"memory-safe\") {\n            r := shl(7, lt(0xffffffffffffffffffffffffffffffff, x))\n            r := or(r, shl(6, lt(0xffffffffffffffff, shr(r, x))))\n            r := or(r, shl(5, lt(0xffffffff, shr(r, x))))\n            r := or(r, shl(4, lt(0xffff, shr(r, x))))\n            r := or(r, shl(3, lt(0xff, shr(r, x))))\n            // forgefmt: disable-next-item\n            r := or(r, byte(and(0x1f, shr(shr(r, x), 0x8421084210842108cc6318c6db6d54be)),\n                0x0706060506020500060203020504000106050205030304010505030400000000))\n        }\n    }\n\n    /// @notice Returns the index of the least significant bit of the number,\n    ///     where the least significant bit is at index 0 and the most significant bit is at index 255\n    /// @param x the value for which to compute the least significant bit, must be greater than 0\n    /// @return r the index of the least significant bit\n    function leastSignificantBit(uint256 x) internal pure returns (uint8 r) {\n        require(x > 0);\n\n        assembly (\"memory-safe\") {\n            // Isolate the least significant bit.\n            x := and(x, sub(0, x))\n            // For the upper 3 bits of the result, use a De Bruijn-like lookup.\n            // Credit to adhusson: https://blog.adhusson.com/cheap-find-first-set-evm/\n            // forgefmt: disable-next-item\n            r := shl(5, shr(252, shl(shl(2, shr(250, mul(x,\n                0xb6db6db6ddddddddd34d34d349249249210842108c6318c639ce739cffffffff))),\n                0x8040405543005266443200005020610674053026020000107506200176117077)))\n            // For the lower 5 bits of the result, use a De Bruijn lookup.\n            // forgefmt: disable-next-item\n            r := or(r, byte(and(div(0xd76453e0, shr(r, x)), 0x1f),\n                0x001f0d1e100c1d070f090b19131c1706010e11080a1a141802121b1503160405))\n        }\n    }\n}\n"},"lib/v4-periphery/lib/v4-core/src/libraries/CurrencyDelta.sol":{"content":"// SPDX-License-Identifier: BUSL-1.1\npragma solidity ^0.8.24;\n\nimport {Currency} from \"../types/Currency.sol\";\n\n/// @title a library to store callers' currency deltas in transient storage\n/// @dev this library implements the equivalent of a mapping, as transient storage can only be accessed in assembly\nlibrary CurrencyDelta {\n    /// @notice calculates which storage slot a delta should be stored in for a given account and currency\n    function _computeSlot(address target, Currency currency) internal pure returns (bytes32 hashSlot) {\n        assembly (\"memory-safe\") {\n            mstore(0, and(target, 0xffffffffffffffffffffffffffffffffffffffff))\n            mstore(32, and(currency, 0xffffffffffffffffffffffffffffffffffffffff))\n            hashSlot := keccak256(0, 64)\n        }\n    }\n\n    function getDelta(Currency currency, address target) internal view returns (int256 delta) {\n        bytes32 hashSlot = _computeSlot(target, currency);\n        assembly (\"memory-safe\") {\n            delta := tload(hashSlot)\n        }\n    }\n\n    /// @notice applies a new currency delta for a given account and currency\n    /// @return previous The prior value\n    /// @return next The modified result\n    function applyDelta(Currency currency, address target, int128 delta)\n        internal\n        returns (int256 previous, int256 next)\n    {\n        bytes32 hashSlot = _computeSlot(target, currency);\n\n        assembly (\"memory-safe\") {\n            previous := tload(hashSlot)\n        }\n        next = previous + delta;\n        assembly (\"memory-safe\") {\n            tstore(hashSlot, next)\n        }\n    }\n}\n"},"lib/v4-periphery/lib/v4-core/src/libraries/CurrencyReserves.sol":{"content":"// SPDX-License-Identifier: BUSL-1.1\npragma solidity ^0.8.24;\n\nimport {Currency} from \"../types/Currency.sol\";\nimport {CustomRevert} from \"./CustomRevert.sol\";\n\nlibrary CurrencyReserves {\n    using CustomRevert for bytes4;\n\n    /// bytes32(uint256(keccak256(\"ReservesOf\")) - 1)\n    bytes32 constant RESERVES_OF_SLOT = 0x1e0745a7db1623981f0b2a5d4232364c00787266eb75ad546f190e6cebe9bd95;\n    /// bytes32(uint256(keccak256(\"Currency\")) - 1)\n    bytes32 constant CURRENCY_SLOT = 0x27e098c505d44ec3574004bca052aabf76bd35004c182099d8c575fb238593b9;\n\n    function getSyncedCurrency() internal view returns (Currency currency) {\n        assembly (\"memory-safe\") {\n            currency := tload(CURRENCY_SLOT)\n        }\n    }\n\n    function resetCurrency() internal {\n        assembly (\"memory-safe\") {\n            tstore(CURRENCY_SLOT, 0)\n        }\n    }\n\n    function syncCurrencyAndReserves(Currency currency, uint256 value) internal {\n        assembly (\"memory-safe\") {\n            tstore(CURRENCY_SLOT, and(currency, 0xffffffffffffffffffffffffffffffffffffffff))\n            tstore(RESERVES_OF_SLOT, value)\n        }\n    }\n\n    function getSyncedReserves() internal view returns (uint256 value) {\n        assembly (\"memory-safe\") {\n            value := tload(RESERVES_OF_SLOT)\n        }\n    }\n}\n"},"lib/v4-periphery/lib/v4-core/src/libraries/CustomRevert.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\n/// @title Library for reverting with custom errors efficiently\n/// @notice Contains functions for reverting with custom errors with different argument types efficiently\n/// @dev To use this library, declare `using CustomRevert for bytes4;` and replace `revert CustomError()` with\n/// `CustomError.selector.revertWith()`\n/// @dev The functions may tamper with the free memory pointer but it is fine since the call context is exited immediately\nlibrary CustomRevert {\n    /// @dev ERC-7751 error for wrapping bubbled up reverts\n    error WrappedError(address target, bytes4 selector, bytes reason, bytes details);\n\n    /// @dev Reverts with the selector of a custom error in the scratch space\n    function revertWith(bytes4 selector) internal pure {\n        assembly (\"memory-safe\") {\n            mstore(0, selector)\n            revert(0, 0x04)\n        }\n    }\n\n    /// @dev Reverts with a custom error with an address argument in the scratch space\n    function revertWith(bytes4 selector, address addr) internal pure {\n        assembly (\"memory-safe\") {\n            mstore(0, selector)\n            mstore(0x04, and(addr, 0xffffffffffffffffffffffffffffffffffffffff))\n            revert(0, 0x24)\n        }\n    }\n\n    /// @dev Reverts with a custom error with an int24 argument in the scratch space\n    function revertWith(bytes4 selector, int24 value) internal pure {\n        assembly (\"memory-safe\") {\n            mstore(0, selector)\n            mstore(0x04, signextend(2, value))\n            revert(0, 0x24)\n        }\n    }\n\n    /// @dev Reverts with a custom error with a uint160 argument in the scratch space\n    function revertWith(bytes4 selector, uint160 value) internal pure {\n        assembly (\"memory-safe\") {\n            mstore(0, selector)\n            mstore(0x04, and(value, 0xffffffffffffffffffffffffffffffffffffffff))\n            revert(0, 0x24)\n        }\n    }\n\n    /// @dev Reverts with a custom error with two int24 arguments\n    function revertWith(bytes4 selector, int24 value1, int24 value2) internal pure {\n        assembly (\"memory-safe\") {\n            let fmp := mload(0x40)\n            mstore(fmp, selector)\n            mstore(add(fmp, 0x04), signextend(2, value1))\n            mstore(add(fmp, 0x24), signextend(2, value2))\n            revert(fmp, 0x44)\n        }\n    }\n\n    /// @dev Reverts with a custom error with two uint160 arguments\n    function revertWith(bytes4 selector, uint160 value1, uint160 value2) internal pure {\n        assembly (\"memory-safe\") {\n            let fmp := mload(0x40)\n            mstore(fmp, selector)\n            mstore(add(fmp, 0x04), and(value1, 0xffffffffffffffffffffffffffffffffffffffff))\n            mstore(add(fmp, 0x24), and(value2, 0xffffffffffffffffffffffffffffffffffffffff))\n            revert(fmp, 0x44)\n        }\n    }\n\n    /// @dev Reverts with a custom error with two address arguments\n    function revertWith(bytes4 selector, address value1, address value2) internal pure {\n        assembly (\"memory-safe\") {\n            let fmp := mload(0x40)\n            mstore(fmp, selector)\n            mstore(add(fmp, 0x04), and(value1, 0xffffffffffffffffffffffffffffffffffffffff))\n            mstore(add(fmp, 0x24), and(value2, 0xffffffffffffffffffffffffffffffffffffffff))\n            revert(fmp, 0x44)\n        }\n    }\n\n    /// @notice bubble up the revert message returned by a call and revert with a wrapped ERC-7751 error\n    /// @dev this method can be vulnerable to revert data bombs\n    function bubbleUpAndRevertWith(\n        address revertingContract,\n        bytes4 revertingFunctionSelector,\n        bytes4 additionalContext\n    ) internal pure {\n        bytes4 wrappedErrorSelector = WrappedError.selector;\n        assembly (\"memory-safe\") {\n            // Ensure the size of the revert data is a multiple of 32 bytes\n            let encodedDataSize := mul(div(add(returndatasize(), 31), 32), 32)\n\n            let fmp := mload(0x40)\n\n            // Encode wrapped error selector, address, function selector, offset, additional context, size, revert reason\n            mstore(fmp, wrappedErrorSelector)\n            mstore(add(fmp, 0x04), and(revertingContract, 0xffffffffffffffffffffffffffffffffffffffff))\n            mstore(\n                add(fmp, 0x24),\n                and(revertingFunctionSelector, 0xffffffff00000000000000000000000000000000000000000000000000000000)\n            )\n            // offset revert reason\n            mstore(add(fmp, 0x44), 0x80)\n            // offset additional context\n            mstore(add(fmp, 0x64), add(0xa0, encodedDataSize))\n            // size revert reason\n            mstore(add(fmp, 0x84), returndatasize())\n            // revert reason\n            returndatacopy(add(fmp, 0xa4), 0, returndatasize())\n            // size additional context\n            mstore(add(fmp, add(0xa4, encodedDataSize)), 0x04)\n            // additional context\n            mstore(\n                add(fmp, add(0xc4, encodedDataSize)),\n                and(additionalContext, 0xffffffff00000000000000000000000000000000000000000000000000000000)\n            )\n            revert(fmp, add(0xe4, encodedDataSize))\n        }\n    }\n}\n"},"lib/v4-periphery/lib/v4-core/src/libraries/FixedPoint128.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\n/// @title FixedPoint128\n/// @notice A library for handling binary fixed point numbers, see https://en.wikipedia.org/wiki/Q_(number_format)\nlibrary FixedPoint128 {\n    uint256 internal constant Q128 = 0x100000000000000000000000000000000;\n}\n"},"lib/v4-periphery/lib/v4-core/src/libraries/FixedPoint96.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\n/// @title FixedPoint96\n/// @notice A library for handling binary fixed point numbers, see https://en.wikipedia.org/wiki/Q_(number_format)\n/// @dev Used in SqrtPriceMath.sol\nlibrary FixedPoint96 {\n    uint8 internal constant RESOLUTION = 96;\n    uint256 internal constant Q96 = 0x1000000000000000000000000;\n}\n"},"lib/v4-periphery/lib/v4-core/src/libraries/FullMath.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\n/// @title Contains 512-bit math functions\n/// @notice Facilitates multiplication and division that can have overflow of an intermediate value without any loss of precision\n/// @dev Handles \"phantom overflow\" i.e., allows multiplication and division where an intermediate value overflows 256 bits\nlibrary FullMath {\n    /// @notice Calculates floor(abdenominator) with full precision. Throws if result overflows a uint256 or denominator == 0\n    /// @param a The multiplicand\n    /// @param b The multiplier\n    /// @param denominator The divisor\n    /// @return result The 256-bit result\n    /// @dev Credit to Remco Bloemen under MIT license https://xn--2-umb.com/21/muldiv\n    function mulDiv(uint256 a, uint256 b, uint256 denominator) internal pure returns (uint256 result) {\n        unchecked {\n            // 512-bit multiply [prod1 prod0] = a * b\n            // Compute the product mod 2**256 and mod 2**256 - 1\n            // then use the Chinese Remainder Theorem to reconstruct\n            // the 512 bit result. The result is stored in two 256\n            // variables such that product = prod1 * 2**256 + prod0\n            uint256 prod0 = a * b; // Least significant 256 bits of the product\n            uint256 prod1; // Most significant 256 bits of the product\n            assembly (\"memory-safe\") {\n                let mm := mulmod(a, b, not(0))\n                prod1 := sub(sub(mm, prod0), lt(mm, prod0))\n            }\n\n            // Make sure the result is less than 2**256.\n            // Also prevents denominator == 0\n            require(denominator > prod1);\n\n            // Handle non-overflow cases, 256 by 256 division\n            if (prod1 == 0) {\n                assembly (\"memory-safe\") {\n                    result := div(prod0, denominator)\n                }\n                return result;\n            }\n\n            ///////////////////////////////////////////////\n            // 512 by 256 division.\n            ///////////////////////////////////////////////\n\n            // Make division exact by subtracting the remainder from [prod1 prod0]\n            // Compute remainder using mulmod\n            uint256 remainder;\n            assembly (\"memory-safe\") {\n                remainder := mulmod(a, b, denominator)\n            }\n            // Subtract 256 bit number from 512 bit number\n            assembly (\"memory-safe\") {\n                prod1 := sub(prod1, gt(remainder, prod0))\n                prod0 := sub(prod0, remainder)\n            }\n\n            // Factor powers of two out of denominator\n            // Compute largest power of two divisor of denominator.\n            // Always >= 1.\n            uint256 twos = (0 - denominator) & denominator;\n            // Divide denominator by power of two\n            assembly (\"memory-safe\") {\n                denominator := div(denominator, twos)\n            }\n\n            // Divide [prod1 prod0] by the factors of two\n            assembly (\"memory-safe\") {\n                prod0 := div(prod0, twos)\n            }\n            // Shift in bits from prod1 into prod0. For this we need\n            // to flip `twos` such that it is 2**256 / twos.\n            // If twos is zero, then it becomes one\n            assembly (\"memory-safe\") {\n                twos := add(div(sub(0, twos), twos), 1)\n            }\n            prod0 |= prod1 * twos;\n\n            // Invert denominator mod 2**256\n            // Now that denominator is an odd number, it has an inverse\n            // modulo 2**256 such that denominator * inv = 1 mod 2**256.\n            // Compute the inverse by starting with a seed that is correct\n            // correct for four bits. That is, denominator * inv = 1 mod 2**4\n            uint256 inv = (3 * denominator) ^ 2;\n            // Now use Newton-Raphson iteration to improve the precision.\n            // Thanks to Hensel's lifting lemma, this also works in modular\n            // arithmetic, doubling the correct bits in each step.\n            inv *= 2 - denominator * inv; // inverse mod 2**8\n            inv *= 2 - denominator * inv; // inverse mod 2**16\n            inv *= 2 - denominator * inv; // inverse mod 2**32\n            inv *= 2 - denominator * inv; // inverse mod 2**64\n            inv *= 2 - denominator * inv; // inverse mod 2**128\n            inv *= 2 - denominator * inv; // inverse mod 2**256\n\n            // Because the division is now exact we can divide by multiplying\n            // with the modular inverse of denominator. This will give us the\n            // correct result modulo 2**256. Since the preconditions guarantee\n            // that the outcome is less than 2**256, this is the final result.\n            // We don't need to compute the high bits of the result and prod1\n            // is no longer required.\n            result = prod0 * inv;\n            return result;\n        }\n    }\n\n    /// @notice Calculates ceil(abdenominator) with full precision. Throws if result overflows a uint256 or denominator == 0\n    /// @param a The multiplicand\n    /// @param b The multiplier\n    /// @param denominator The divisor\n    /// @return result The 256-bit result\n    function mulDivRoundingUp(uint256 a, uint256 b, uint256 denominator) internal pure returns (uint256 result) {\n        unchecked {\n            result = mulDiv(a, b, denominator);\n            if (mulmod(a, b, denominator) != 0) {\n                require(++result > 0);\n            }\n        }\n    }\n}\n"},"lib/v4-periphery/lib/v4-core/src/libraries/Hooks.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport {PoolKey} from \"../types/PoolKey.sol\";\nimport {IHooks} from \"../interfaces/IHooks.sol\";\nimport {SafeCast} from \"./SafeCast.sol\";\nimport {LPFeeLibrary} from \"./LPFeeLibrary.sol\";\nimport {BalanceDelta, toBalanceDelta, BalanceDeltaLibrary} from \"../types/BalanceDelta.sol\";\nimport {BeforeSwapDelta, BeforeSwapDeltaLibrary} from \"../types/BeforeSwapDelta.sol\";\nimport {IPoolManager} from \"../interfaces/IPoolManager.sol\";\nimport {ParseBytes} from \"./ParseBytes.sol\";\nimport {CustomRevert} from \"./CustomRevert.sol\";\n\n/// @notice V4 decides whether to invoke specific hooks by inspecting the least significant bits\n/// of the address that the hooks contract is deployed to.\n/// For example, a hooks contract deployed to address: 0x0000000000000000000000000000000000002400\n/// has the lowest bits '10 0100 0000 0000' which would cause the 'before initialize' and 'after add liquidity' hooks to be used.\nlibrary Hooks {\n    using LPFeeLibrary for uint24;\n    using Hooks for IHooks;\n    using SafeCast for int256;\n    using BeforeSwapDeltaLibrary for BeforeSwapDelta;\n    using ParseBytes for bytes;\n    using CustomRevert for bytes4;\n\n    uint160 internal constant ALL_HOOK_MASK = uint160((1 << 14) - 1);\n\n    uint160 internal constant BEFORE_INITIALIZE_FLAG = 1 << 13;\n    uint160 internal constant AFTER_INITIALIZE_FLAG = 1 << 12;\n\n    uint160 internal constant BEFORE_ADD_LIQUIDITY_FLAG = 1 << 11;\n    uint160 internal constant AFTER_ADD_LIQUIDITY_FLAG = 1 << 10;\n\n    uint160 internal constant BEFORE_REMOVE_LIQUIDITY_FLAG = 1 << 9;\n    uint160 internal constant AFTER_REMOVE_LIQUIDITY_FLAG = 1 << 8;\n\n    uint160 internal constant BEFORE_SWAP_FLAG = 1 << 7;\n    uint160 internal constant AFTER_SWAP_FLAG = 1 << 6;\n\n    uint160 internal constant BEFORE_DONATE_FLAG = 1 << 5;\n    uint160 internal constant AFTER_DONATE_FLAG = 1 << 4;\n\n    uint160 internal constant BEFORE_SWAP_RETURNS_DELTA_FLAG = 1 << 3;\n    uint160 internal constant AFTER_SWAP_RETURNS_DELTA_FLAG = 1 << 2;\n    uint160 internal constant AFTER_ADD_LIQUIDITY_RETURNS_DELTA_FLAG = 1 << 1;\n    uint160 internal constant AFTER_REMOVE_LIQUIDITY_RETURNS_DELTA_FLAG = 1 << 0;\n\n    struct Permissions {\n        bool beforeInitialize;\n        bool afterInitialize;\n        bool beforeAddLiquidity;\n        bool afterAddLiquidity;\n        bool beforeRemoveLiquidity;\n        bool afterRemoveLiquidity;\n        bool beforeSwap;\n        bool afterSwap;\n        bool beforeDonate;\n        bool afterDonate;\n        bool beforeSwapReturnDelta;\n        bool afterSwapReturnDelta;\n        bool afterAddLiquidityReturnDelta;\n        bool afterRemoveLiquidityReturnDelta;\n    }\n\n    /// @notice Thrown if the address will not lead to the specified hook calls being called\n    /// @param hooks The address of the hooks contract\n    error HookAddressNotValid(address hooks);\n\n    /// @notice Hook did not return its selector\n    error InvalidHookResponse();\n\n    /// @notice Additional context for ERC-7751 wrapped error when a hook call fails\n    error HookCallFailed();\n\n    /// @notice The hook's delta changed the swap from exactIn to exactOut or vice versa\n    error HookDeltaExceedsSwapAmount();\n\n    /// @notice Utility function intended to be used in hook constructors to ensure\n    /// the deployed hooks address causes the intended hooks to be called\n    /// @param permissions The hooks that are intended to be called\n    /// @dev permissions param is memory as the function will be called from constructors\n    function validateHookPermissions(IHooks self, Permissions memory permissions) internal pure {\n        if (\n            permissions.beforeInitialize != self.hasPermission(BEFORE_INITIALIZE_FLAG)\n                || permissions.afterInitialize != self.hasPermission(AFTER_INITIALIZE_FLAG)\n                || permissions.beforeAddLiquidity != self.hasPermission(BEFORE_ADD_LIQUIDITY_FLAG)\n                || permissions.afterAddLiquidity != self.hasPermission(AFTER_ADD_LIQUIDITY_FLAG)\n                || permissions.beforeRemoveLiquidity != self.hasPermission(BEFORE_REMOVE_LIQUIDITY_FLAG)\n                || permissions.afterRemoveLiquidity != self.hasPermission(AFTER_REMOVE_LIQUIDITY_FLAG)\n                || permissions.beforeSwap != self.hasPermission(BEFORE_SWAP_FLAG)\n                || permissions.afterSwap != self.hasPermission(AFTER_SWAP_FLAG)\n                || permissions.beforeDonate != self.hasPermission(BEFORE_DONATE_FLAG)\n                || permissions.afterDonate != self.hasPermission(AFTER_DONATE_FLAG)\n                || permissions.beforeSwapReturnDelta != self.hasPermission(BEFORE_SWAP_RETURNS_DELTA_FLAG)\n                || permissions.afterSwapReturnDelta != self.hasPermission(AFTER_SWAP_RETURNS_DELTA_FLAG)\n                || permissions.afterAddLiquidityReturnDelta != self.hasPermission(AFTER_ADD_LIQUIDITY_RETURNS_DELTA_FLAG)\n                || permissions.afterRemoveLiquidityReturnDelta\n                    != self.hasPermission(AFTER_REMOVE_LIQUIDITY_RETURNS_DELTA_FLAG)\n        ) {\n            HookAddressNotValid.selector.revertWith(address(self));\n        }\n    }\n\n    /// @notice Ensures that the hook address includes at least one hook flag or dynamic fees, or is the 0 address\n    /// @param self The hook to verify\n    /// @param fee The fee of the pool the hook is used with\n    /// @return bool True if the hook address is valid\n    function isValidHookAddress(IHooks self, uint24 fee) internal pure returns (bool) {\n        // The hook can only have a flag to return a hook delta on an action if it also has the corresponding action flag\n        if (!self.hasPermission(BEFORE_SWAP_FLAG) && self.hasPermission(BEFORE_SWAP_RETURNS_DELTA_FLAG)) return false;\n        if (!self.hasPermission(AFTER_SWAP_FLAG) && self.hasPermission(AFTER_SWAP_RETURNS_DELTA_FLAG)) return false;\n        if (!self.hasPermission(AFTER_ADD_LIQUIDITY_FLAG) && self.hasPermission(AFTER_ADD_LIQUIDITY_RETURNS_DELTA_FLAG))\n        {\n            return false;\n        }\n        if (\n            !self.hasPermission(AFTER_REMOVE_LIQUIDITY_FLAG)\n                && self.hasPermission(AFTER_REMOVE_LIQUIDITY_RETURNS_DELTA_FLAG)\n        ) return false;\n\n        // If there is no hook contract set, then fee cannot be dynamic\n        // If a hook contract is set, it must have at least 1 flag set, or have a dynamic fee\n        return address(self) == address(0)\n            ? !fee.isDynamicFee()\n            : (uint160(address(self)) & ALL_HOOK_MASK > 0 || fee.isDynamicFee());\n    }\n\n    /// @notice performs a hook call using the given calldata on the given hook that doesn't return a delta\n    /// @return result The complete data returned by the hook\n    function callHook(IHooks self, bytes memory data) internal returns (bytes memory result) {\n        bool success;\n        assembly (\"memory-safe\") {\n            success := call(gas(), self, 0, add(data, 0x20), mload(data), 0, 0)\n        }\n        // Revert with FailedHookCall, containing any error message to bubble up\n        if (!success) CustomRevert.bubbleUpAndRevertWith(address(self), bytes4(data), HookCallFailed.selector);\n\n        // The call was successful, fetch the returned data\n        assembly (\"memory-safe\") {\n            // allocate result byte array from the free memory pointer\n            result := mload(0x40)\n            // store new free memory pointer at the end of the array padded to 32 bytes\n            mstore(0x40, add(result, and(add(returndatasize(), 0x3f), not(0x1f))))\n            // store length in memory\n            mstore(result, returndatasize())\n            // copy return data to result\n            returndatacopy(add(result, 0x20), 0, returndatasize())\n        }\n\n        // Length must be at least 32 to contain the selector. Check expected selector and returned selector match.\n        if (result.length < 32 || result.parseSelector() != data.parseSelector()) {\n            InvalidHookResponse.selector.revertWith();\n        }\n    }\n\n    /// @notice performs a hook call using the given calldata on the given hook\n    /// @return int256 The delta returned by the hook\n    function callHookWithReturnDelta(IHooks self, bytes memory data, bool parseReturn) internal returns (int256) {\n        bytes memory result = callHook(self, data);\n\n        // If this hook wasn't meant to return something, default to 0 delta\n        if (!parseReturn) return 0;\n\n        // A length of 64 bytes is required to return a bytes4, and a 32 byte delta\n        if (result.length != 64) InvalidHookResponse.selector.revertWith();\n        return result.parseReturnDelta();\n    }\n\n    /// @notice modifier to prevent calling a hook if they initiated the action\n    modifier noSelfCall(IHooks self) {\n        if (msg.sender != address(self)) {\n            _;\n        }\n    }\n\n    /// @notice calls beforeInitialize hook if permissioned and validates return value\n    function beforeInitialize(IHooks self, PoolKey memory key, uint160 sqrtPriceX96) internal noSelfCall(self) {\n        if (self.hasPermission(BEFORE_INITIALIZE_FLAG)) {\n            self.callHook(abi.encodeCall(IHooks.beforeInitialize, (msg.sender, key, sqrtPriceX96)));\n        }\n    }\n\n    /// @notice calls afterInitialize hook if permissioned and validates return value\n    function afterInitialize(IHooks self, PoolKey memory key, uint160 sqrtPriceX96, int24 tick)\n        internal\n        noSelfCall(self)\n    {\n        if (self.hasPermission(AFTER_INITIALIZE_FLAG)) {\n            self.callHook(abi.encodeCall(IHooks.afterInitialize, (msg.sender, key, sqrtPriceX96, tick)));\n        }\n    }\n\n    /// @notice calls beforeModifyLiquidity hook if permissioned and validates return value\n    function beforeModifyLiquidity(\n        IHooks self,\n        PoolKey memory key,\n        IPoolManager.ModifyLiquidityParams memory params,\n        bytes calldata hookData\n    ) internal noSelfCall(self) {\n        if (params.liquidityDelta > 0 && self.hasPermission(BEFORE_ADD_LIQUIDITY_FLAG)) {\n            self.callHook(abi.encodeCall(IHooks.beforeAddLiquidity, (msg.sender, key, params, hookData)));\n        } else if (params.liquidityDelta <= 0 && self.hasPermission(BEFORE_REMOVE_LIQUIDITY_FLAG)) {\n            self.callHook(abi.encodeCall(IHooks.beforeRemoveLiquidity, (msg.sender, key, params, hookData)));\n        }\n    }\n\n    /// @notice calls afterModifyLiquidity hook if permissioned and validates return value\n    function afterModifyLiquidity(\n        IHooks self,\n        PoolKey memory key,\n        IPoolManager.ModifyLiquidityParams memory params,\n        BalanceDelta delta,\n        BalanceDelta feesAccrued,\n        bytes calldata hookData\n    ) internal returns (BalanceDelta callerDelta, BalanceDelta hookDelta) {\n        if (msg.sender == address(self)) return (delta, BalanceDeltaLibrary.ZERO_DELTA);\n\n        callerDelta = delta;\n        if (params.liquidityDelta > 0) {\n            if (self.hasPermission(AFTER_ADD_LIQUIDITY_FLAG)) {\n                hookDelta = BalanceDelta.wrap(\n                    self.callHookWithReturnDelta(\n                        abi.encodeCall(\n                            IHooks.afterAddLiquidity, (msg.sender, key, params, delta, feesAccrued, hookData)\n                        ),\n                        self.hasPermission(AFTER_ADD_LIQUIDITY_RETURNS_DELTA_FLAG)\n                    )\n                );\n                callerDelta = callerDelta - hookDelta;\n            }\n        } else {\n            if (self.hasPermission(AFTER_REMOVE_LIQUIDITY_FLAG)) {\n                hookDelta = BalanceDelta.wrap(\n                    self.callHookWithReturnDelta(\n                        abi.encodeCall(\n                            IHooks.afterRemoveLiquidity, (msg.sender, key, params, delta, feesAccrued, hookData)\n                        ),\n                        self.hasPermission(AFTER_REMOVE_LIQUIDITY_RETURNS_DELTA_FLAG)\n                    )\n                );\n                callerDelta = callerDelta - hookDelta;\n            }\n        }\n    }\n\n    /// @notice calls beforeSwap hook if permissioned and validates return value\n    function beforeSwap(IHooks self, PoolKey memory key, IPoolManager.SwapParams memory params, bytes calldata hookData)\n        internal\n        returns (int256 amountToSwap, BeforeSwapDelta hookReturn, uint24 lpFeeOverride)\n    {\n        amountToSwap = params.amountSpecified;\n        if (msg.sender == address(self)) return (amountToSwap, BeforeSwapDeltaLibrary.ZERO_DELTA, lpFeeOverride);\n\n        if (self.hasPermission(BEFORE_SWAP_FLAG)) {\n            bytes memory result = callHook(self, abi.encodeCall(IHooks.beforeSwap, (msg.sender, key, params, hookData)));\n\n            // A length of 96 bytes is required to return a bytes4, a 32 byte delta, and an LP fee\n            if (result.length != 96) InvalidHookResponse.selector.revertWith();\n\n            // dynamic fee pools that want to override the cache fee, return a valid fee with the override flag. If override flag\n            // is set but an invalid fee is returned, the transaction will revert. Otherwise the current LP fee will be used\n            if (key.fee.isDynamicFee()) lpFeeOverride = result.parseFee();\n\n            // skip this logic for the case where the hook return is 0\n            if (self.hasPermission(BEFORE_SWAP_RETURNS_DELTA_FLAG)) {\n                hookReturn = BeforeSwapDelta.wrap(result.parseReturnDelta());\n\n                // any return in unspecified is passed to the afterSwap hook for handling\n                int128 hookDeltaSpecified = hookReturn.getSpecifiedDelta();\n\n                // Update the swap amount according to the hook's return, and check that the swap type doesn't change (exact input/output)\n                if (hookDeltaSpecified != 0) {\n                    bool exactInput = amountToSwap < 0;\n                    amountToSwap += hookDeltaSpecified;\n                    if (exactInput ? amountToSwap > 0 : amountToSwap < 0) {\n                        HookDeltaExceedsSwapAmount.selector.revertWith();\n                    }\n                }\n            }\n        }\n    }\n\n    /// @notice calls afterSwap hook if permissioned and validates return value\n    function afterSwap(\n        IHooks self,\n        PoolKey memory key,\n        IPoolManager.SwapParams memory params,\n        BalanceDelta swapDelta,\n        bytes calldata hookData,\n        BeforeSwapDelta beforeSwapHookReturn\n    ) internal returns (BalanceDelta, BalanceDelta) {\n        if (msg.sender == address(self)) return (swapDelta, BalanceDeltaLibrary.ZERO_DELTA);\n\n        int128 hookDeltaSpecified = beforeSwapHookReturn.getSpecifiedDelta();\n        int128 hookDeltaUnspecified = beforeSwapHookReturn.getUnspecifiedDelta();\n\n        if (self.hasPermission(AFTER_SWAP_FLAG)) {\n            hookDeltaUnspecified += self.callHookWithReturnDelta(\n                abi.encodeCall(IHooks.afterSwap, (msg.sender, key, params, swapDelta, hookData)),\n                self.hasPermission(AFTER_SWAP_RETURNS_DELTA_FLAG)\n            ).toInt128();\n        }\n\n        BalanceDelta hookDelta;\n        if (hookDeltaUnspecified != 0 || hookDeltaSpecified != 0) {\n            hookDelta = (params.amountSpecified < 0 == params.zeroForOne)\n                ? toBalanceDelta(hookDeltaSpecified, hookDeltaUnspecified)\n                : toBalanceDelta(hookDeltaUnspecified, hookDeltaSpecified);\n\n            // the caller has to pay for (or receive) the hook's delta\n            swapDelta = swapDelta - hookDelta;\n        }\n        return (swapDelta, hookDelta);\n    }\n\n    /// @notice calls beforeDonate hook if permissioned and validates return value\n    function beforeDonate(IHooks self, PoolKey memory key, uint256 amount0, uint256 amount1, bytes calldata hookData)\n        internal\n        noSelfCall(self)\n    {\n        if (self.hasPermission(BEFORE_DONATE_FLAG)) {\n            self.callHook(abi.encodeCall(IHooks.beforeDonate, (msg.sender, key, amount0, amount1, hookData)));\n        }\n    }\n\n    /// @notice calls afterDonate hook if permissioned and validates return value\n    function afterDonate(IHooks self, PoolKey memory key, uint256 amount0, uint256 amount1, bytes calldata hookData)\n        internal\n        noSelfCall(self)\n    {\n        if (self.hasPermission(AFTER_DONATE_FLAG)) {\n            self.callHook(abi.encodeCall(IHooks.afterDonate, (msg.sender, key, amount0, amount1, hookData)));\n        }\n    }\n\n    function hasPermission(IHooks self, uint160 flag) internal pure returns (bool) {\n        return uint160(address(self)) & flag != 0;\n    }\n}\n"},"lib/v4-periphery/lib/v4-core/src/libraries/LPFeeLibrary.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport {CustomRevert} from \"./CustomRevert.sol\";\n\n/// @notice Library of helper functions for a pools LP fee\nlibrary LPFeeLibrary {\n    using LPFeeLibrary for uint24;\n    using CustomRevert for bytes4;\n\n    /// @notice Thrown when the static or dynamic fee on a pool exceeds 100%.\n    error LPFeeTooLarge(uint24 fee);\n\n    /// @notice An lp fee of exactly 0b1000000... signals a dynamic fee pool. This isn't a valid static fee as it is > MAX_LP_FEE\n    uint24 public constant DYNAMIC_FEE_FLAG = 0x800000;\n\n    /// @notice the second bit of the fee returned by beforeSwap is used to signal if the stored LP fee should be overridden in this swap\n    // only dynamic-fee pools can return a fee via the beforeSwap hook\n    uint24 public constant OVERRIDE_FEE_FLAG = 0x400000;\n\n    /// @notice mask to remove the override fee flag from a fee returned by the beforeSwaphook\n    uint24 public constant REMOVE_OVERRIDE_MASK = 0xBFFFFF;\n\n    /// @notice the lp fee is represented in hundredths of a bip, so the max is 100%\n    uint24 public constant MAX_LP_FEE = 1000000;\n\n    /// @notice returns true if a pool's LP fee signals that the pool has a dynamic fee\n    /// @param self The fee to check\n    /// @return bool True of the fee is dynamic\n    function isDynamicFee(uint24 self) internal pure returns (bool) {\n        return self == DYNAMIC_FEE_FLAG;\n    }\n\n    /// @notice returns true if an LP fee is valid, aka not above the maximum permitted fee\n    /// @param self The fee to check\n    /// @return bool True of the fee is valid\n    function isValid(uint24 self) internal pure returns (bool) {\n        return self <= MAX_LP_FEE;\n    }\n\n    /// @notice validates whether an LP fee is larger than the maximum, and reverts if invalid\n    /// @param self The fee to validate\n    function validate(uint24 self) internal pure {\n        if (!self.isValid()) LPFeeTooLarge.selector.revertWith(self);\n    }\n\n    /// @notice gets and validates the initial LP fee for a pool. Dynamic fee pools have an initial fee of 0.\n    /// @dev if a dynamic fee pool wants a non-0 initial fee, it should call `updateDynamicLPFee` in the afterInitialize hook\n    /// @param self The fee to get the initial LP from\n    /// @return initialFee 0 if the fee is dynamic, otherwise the fee (if valid)\n    function getInitialLPFee(uint24 self) internal pure returns (uint24) {\n        // the initial fee for a dynamic fee pool is 0\n        if (self.isDynamicFee()) return 0;\n        self.validate();\n        return self;\n    }\n\n    /// @notice returns true if the fee has the override flag set (2nd highest bit of the uint24)\n    /// @param self The fee to check\n    /// @return bool True of the fee has the override flag set\n    function isOverride(uint24 self) internal pure returns (bool) {\n        return self & OVERRIDE_FEE_FLAG != 0;\n    }\n\n    /// @notice returns a fee with the override flag removed\n    /// @param self The fee to remove the override flag from\n    /// @return fee The fee without the override flag set\n    function removeOverrideFlag(uint24 self) internal pure returns (uint24) {\n        return self & REMOVE_OVERRIDE_MASK;\n    }\n\n    /// @notice Removes the override flag and validates the fee (reverts if the fee is too large)\n    /// @param self The fee to remove the override flag from, and then validate\n    /// @return fee The fee without the override flag set (if valid)\n    function removeOverrideFlagAndValidate(uint24 self) internal pure returns (uint24 fee) {\n        fee = self.removeOverrideFlag();\n        fee.validate();\n    }\n}\n"},"lib/v4-periphery/lib/v4-core/src/libraries/LiquidityMath.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\n/// @title Math library for liquidity\nlibrary LiquidityMath {\n    /// @notice Add a signed liquidity delta to liquidity and revert if it overflows or underflows\n    /// @param x The liquidity before change\n    /// @param y The delta by which liquidity should be changed\n    /// @return z The liquidity delta\n    function addDelta(uint128 x, int128 y) internal pure returns (uint128 z) {\n        assembly (\"memory-safe\") {\n            z := add(and(x, 0xffffffffffffffffffffffffffffffff), signextend(15, y))\n            if shr(128, z) {\n                // revert SafeCastOverflow()\n                mstore(0, 0x93dafdf1)\n                revert(0x1c, 0x04)\n            }\n        }\n    }\n}\n"},"lib/v4-periphery/lib/v4-core/src/libraries/Lock.sol":{"content":"// SPDX-License-Identifier: BUSL-1.1\npragma solidity ^0.8.24;\n\n/// @notice This is a temporary library that allows us to use transient storage (tstore/tload)\n/// TODO: This library can be deleted when we have the transient keyword support in solidity.\nlibrary Lock {\n    // The slot holding the unlocked state, transiently. bytes32(uint256(keccak256(\"Unlocked\")) - 1)\n    bytes32 internal constant IS_UNLOCKED_SLOT = 0xc090fc4683624cfc3884e9d8de5eca132f2d0ec062aff75d43c0465d5ceeab23;\n\n    function unlock() internal {\n        assembly (\"memory-safe\") {\n            // unlock\n            tstore(IS_UNLOCKED_SLOT, true)\n        }\n    }\n\n    function lock() internal {\n        assembly (\"memory-safe\") {\n            tstore(IS_UNLOCKED_SLOT, false)\n        }\n    }\n\n    function isUnlocked() internal view returns (bool unlocked) {\n        assembly (\"memory-safe\") {\n            unlocked := tload(IS_UNLOCKED_SLOT)\n        }\n    }\n}\n"},"lib/v4-periphery/lib/v4-core/src/libraries/NonzeroDeltaCount.sol":{"content":"// SPDX-License-Identifier: BUSL-1.1\npragma solidity ^0.8.24;\n\n/// @notice This is a temporary library that allows us to use transient storage (tstore/tload)\n/// for the nonzero delta count.\n/// TODO: This library can be deleted when we have the transient keyword support in solidity.\nlibrary NonzeroDeltaCount {\n    // The slot holding the number of nonzero deltas. bytes32(uint256(keccak256(\"NonzeroDeltaCount\")) - 1)\n    bytes32 internal constant NONZERO_DELTA_COUNT_SLOT =\n        0x7d4b3164c6e45b97e7d87b7125a44c5828d005af88f9d751cfd78729c5d99a0b;\n\n    function read() internal view returns (uint256 count) {\n        assembly (\"memory-safe\") {\n            count := tload(NONZERO_DELTA_COUNT_SLOT)\n        }\n    }\n\n    function increment() internal {\n        assembly (\"memory-safe\") {\n            let count := tload(NONZERO_DELTA_COUNT_SLOT)\n            count := add(count, 1)\n            tstore(NONZERO_DELTA_COUNT_SLOT, count)\n        }\n    }\n\n    /// @notice Potential to underflow. Ensure checks are performed by integrating contracts to ensure this does not happen.\n    /// Current usage ensures this will not happen because we call decrement with known boundaries (only up to the number of times we call increment).\n    function decrement() internal {\n        assembly (\"memory-safe\") {\n            let count := tload(NONZERO_DELTA_COUNT_SLOT)\n            count := sub(count, 1)\n            tstore(NONZERO_DELTA_COUNT_SLOT, count)\n        }\n    }\n}\n"},"lib/v4-periphery/lib/v4-core/src/libraries/ParseBytes.sol":{"content":"// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\n/// @notice Parses bytes returned from hooks and the byte selector used to check return selectors from hooks.\n/// @dev parseSelector also is used to parse the expected selector\n/// For parsing hook returns, note that all hooks return either bytes4 or (bytes4, 32-byte-delta) or (bytes4, 32-byte-delta, uint24).\nlibrary ParseBytes {\n    function parseSelector(bytes memory result) internal pure returns (bytes4 selector) {\n        // equivalent: (selector,) = abi.decode(result, (bytes4, int256));\n        assembly (\"memory-safe\") {\n            selector := mload(add(result, 0x20))\n        }\n    }\n\n    function parseFee(bytes memory result) internal pure returns (uint24 lpFee) {\n        // equivalent: (,, lpFee) = abi.decode(result, (bytes4, int256, uint24));\n        assembly (\"memory-safe\") {\n            lpFee := mload(add(result, 0x60))\n        }\n    }\n\n    function parseReturnDelta(bytes memory result) internal pure returns (int256 hookReturn) {\n        // equivalent: (, hookReturnDelta) = abi.decode(result, (bytes4, int256));\n        assembly (\"memory-safe\") {\n            hookReturn := mload(add(result, 0x40))\n        }\n    }\n}\n"},"lib/v4-periphery/lib/v4-core/src/libraries/Pool.sol":{"content":"// SPDX-License-Identifier: BUSL-1.1\npragma solidity ^0.8.0;\n\nimport {SafeCast} from \"./SafeCast.sol\";\nimport {TickBitmap} from \"./TickBitmap.sol\";\nimport {Position} from \"./Position.sol\";\nimport {UnsafeMath} from \"./UnsafeMath.sol\";\nimport {FixedPoint128} from \"./FixedPoint128.sol\";\nimport {TickMath} from \"./TickMath.sol\";\nimport {SqrtPriceMath} from \"./SqrtPriceMath.sol\";\nimport {SwapMath} from \"./SwapMath.sol\";\nimport {BalanceDelta, toBalanceDelta, BalanceDeltaLibrary} from \"../types/BalanceDelta.sol\";\nimport {Slot0} from \"../types/Slot0.sol\";\nimport {ProtocolFeeLibrary} from \"./ProtocolFeeLibrary.sol\";\nimport {LiquidityMath} from \"./LiquidityMath.sol\";\nimport {LPFeeLibrary} from \"./LPFeeLibrary.sol\";\nimport {CustomRevert} from \"./CustomRevert.sol\";\n\n/// @notice a library with all actions that can be performed on a pool\nlibrary Pool {\n    using SafeCast for *;\n    using TickBitmap for mapping(int16 => uint256);\n    using Position for mapping(bytes32 => Position.State);\n    using Position for Position.State;\n    using Pool for State;\n    using ProtocolFeeLibrary for *;\n    using LPFeeLibrary for uint24;\n    using CustomRevert for bytes4;\n\n    /// @notice Thrown when tickLower is not below tickUpper\n    /// @param tickLower The invalid tickLower\n    /// @param tickUpper The invalid tickUpper\n    error TicksMisordered(int24 tickLower, int24 tickUpper);\n\n    /// @notice Thrown when tickLower is less than min tick\n    /// @param tickLower The invalid tickLower\n    error TickLowerOutOfBounds(int24 tickLower);\n\n    /// @notice Thrown when tickUpper exceeds max tick\n    /// @param tickUpper The invalid tickUpper\n    error TickUpperOutOfBounds(int24 tickUpper);\n\n    /// @notice For the tick spacing, the tick has too much liquidity\n    error TickLiquidityOverflow(int24 tick);\n\n    /// @notice Thrown when trying to initialize an already initialized pool\n    error PoolAlreadyInitialized();\n\n    /// @notice Thrown when trying to interact with a non-initialized pool\n    error PoolNotInitialized();\n\n    /// @notice Thrown when sqrtPriceLimitX96 on a swap has already exceeded its limit\n    /// @param sqrtPriceCurrentX96 The invalid, already surpassed sqrtPriceLimitX96\n    /// @param sqrtPriceLimitX96 The surpassed price limit\n    error PriceLimitAlreadyExceeded(uint160 sqrtPriceCurrentX96, uint160 sqrtPriceLimitX96);\n\n    /// @notice Thrown when sqrtPriceLimitX96 lies outside of valid tick/price range\n    /// @param sqrtPriceLimitX96 The invalid, out-of-bounds sqrtPriceLimitX96\n    error PriceLimitOutOfBounds(uint160 sqrtPriceLimitX96);\n\n    /// @notice Thrown by donate if there is currently 0 liquidity, since the fees will not go to any liquidity providers\n    error NoLiquidityToReceiveFees();\n\n    /// @notice Thrown when trying to swap with max lp fee and specifying an output amount\n    error InvalidFeeForExactOut();\n\n    // info stored for each initialized individual tick\n    struct TickInfo {\n        // the total position liquidity that references this tick\n        uint128 liquidityGross;\n        // amount of net liquidity added (subtracted) when tick is crossed from left to right (right to left),\n        int128 liquidityNet;\n        // fee growth per unit of liquidity on the _other_ side of this tick (relative to the current tick)\n        // only has relative meaning, not absolute  the value depends on when the tick is initialized\n        uint256 feeGrowthOutside0X128;\n        uint256 feeGrowthOutside1X128;\n    }\n\n    /// @dev The state of a pool\n    struct State {\n        Slot0 slot0;\n        uint256 feeGrowthGlobal0X128;\n        uint256 feeGrowthGlobal1X128;\n        uint128 liquidity;\n        mapping(int24 tick => TickInfo) ticks;\n        mapping(int16 wordPos => uint256) tickBitmap;\n        mapping(bytes32 positionKey => Position.State) positions;\n    }\n\n    /// @dev Common checks for valid tick inputs.\n    function checkTicks(int24 tickLower, int24 tickUpper) private pure {\n        if (tickLower >= tickUpper) TicksMisordered.selector.revertWith(tickLower, tickUpper);\n        if (tickLower < TickMath.MIN_TICK) TickLowerOutOfBounds.selector.revertWith(tickLower);\n        if (tickUpper > TickMath.MAX_TICK) TickUpperOutOfBounds.selector.revertWith(tickUpper);\n    }\n\n    function initialize(State storage self, uint160 sqrtPriceX96, uint24 lpFee) internal returns (int24 tick) {\n        if (self.slot0.sqrtPriceX96() != 0) PoolAlreadyInitialized.selector.revertWith();\n\n        tick = TickMath.getTickAtSqrtPrice(sqrtPriceX96);\n\n        // the initial protocolFee is 0 so doesn't need to be set\n        self.slot0 = Slot0.wrap(bytes32(0)).setSqrtPriceX96(sqrtPriceX96).setTick(tick).setLpFee(lpFee);\n    }\n\n    function setProtocolFee(State storage self, uint24 protocolFee) internal {\n        self.checkPoolInitialized();\n        self.slot0 = self.slot0.setProtocolFee(protocolFee);\n    }\n\n    /// @notice Only dynamic fee pools may update the lp fee.\n    function setLPFee(State storage self, uint24 lpFee) internal {\n        self.checkPoolInitialized();\n        self.slot0 = self.slot0.setLpFee(lpFee);\n    }\n\n    struct ModifyLiquidityParams {\n        // the address that owns the position\n        address owner;\n        // the lower and upper tick of the position\n        int24 tickLower;\n        int24 tickUpper;\n        // any change in liquidity\n        int128 liquidityDelta;\n        // the spacing between ticks\n        int24 tickSpacing;\n        // used to distinguish positions of the same owner, at the same tick range\n        bytes32 salt;\n    }\n\n    struct ModifyLiquidityState {\n        bool flippedLower;\n        uint128 liquidityGrossAfterLower;\n        bool flippedUpper;\n        uint128 liquidityGrossAfterUpper;\n    }\n\n    /// @notice Effect changes to a position in a pool\n    /// @dev PoolManager checks that the pool is initialized before calling\n    /// @param params the position details and the change to the position's liquidity to effect\n    /// @return delta the deltas of the token balances of the pool, from the liquidity change\n    /// @return feeDelta the fees generated by the liquidity range\n    function modifyLiquidity(State storage self, ModifyLiquidityParams memory params)\n        internal\n        returns (BalanceDelta delta, BalanceDelta feeDelta)\n    {\n        int128 liquidityDelta = params.liquidityDelta;\n        int24 tickLower = params.tickLower;\n        int24 tickUpper = params.tickUpper;\n        checkTicks(tickLower, tickUpper);\n\n        {\n            ModifyLiquidityState memory state;\n\n            // if we need to update the ticks, do it\n            if (liquidityDelta != 0) {\n                (state.flippedLower, state.liquidityGrossAfterLower) =\n                    updateTick(self, tickLower, liquidityDelta, false);\n                (state.flippedUpper, state.liquidityGrossAfterUpper) = updateTick(self, tickUpper, liquidityDelta, true);\n\n                // `>` and `>=` are logically equivalent here but `>=` is cheaper\n                if (liquidityDelta >= 0) {\n                    uint128 maxLiquidityPerTick = tickSpacingToMaxLiquidityPerTick(params.tickSpacing);\n                    if (state.liquidityGrossAfterLower > maxLiquidityPerTick) {\n                        TickLiquidityOverflow.selector.revertWith(tickLower);\n                    }\n                    if (state.liquidityGrossAfterUpper > maxLiquidityPerTick) {\n                        TickLiquidityOverflow.selector.revertWith(tickUpper);\n                    }\n                }\n\n                if (state.flippedLower) {\n                    self.tickBitmap.flipTick(tickLower, params.tickSpacing);\n                }\n                if (state.flippedUpper) {\n                    self.tickBitmap.flipTick(tickUpper, params.tickSpacing);\n                }\n            }\n\n            {\n                (uint256 feeGrowthInside0X128, uint256 feeGrowthInside1X128) =\n                    getFeeGrowthInside(self, tickLower, tickUpper);\n\n                Position.State storage position = self.positions.get(params.owner, tickLower, tickUpper, params.salt);\n                (uint256 feesOwed0, uint256 feesOwed1) =\n                    position.update(liquidityDelta, feeGrowthInside0X128, feeGrowthInside1X128);\n\n                // Fees earned from LPing are calculated, and returned\n                feeDelta = toBalanceDelta(feesOwed0.toInt128(), feesOwed1.toInt128());\n            }\n\n            // clear any tick data that is no longer needed\n            if (liquidityDelta < 0) {\n                if (state.flippedLower) {\n                    clearTick(self, tickLower);\n                }\n                if (state.flippedUpper) {\n                    clearTick(self, tickUpper);\n                }\n            }\n        }\n\n        if (liquidityDelta != 0) {\n            Slot0 _slot0 = self.slot0;\n            (int24 tick, uint160 sqrtPriceX96) = (_slot0.tick(), _slot0.sqrtPriceX96());\n            if (tick < tickLower) {\n                // current tick is below the passed range; liquidity can only become in range by crossing from left to\n                // right, when we'll need _more_ currency0 (it's becoming more valuable) so user must provide it\n                delta = toBalanceDelta(\n                    SqrtPriceMath.getAmount0Delta(\n                        TickMath.getSqrtPriceAtTick(tickLower), TickMath.getSqrtPriceAtTick(tickUpper), liquidityDelta\n                    ).toInt128(),\n                    0\n                );\n            } else if (tick < tickUpper) {\n                delta = toBalanceDelta(\n                    SqrtPriceMath.getAmount0Delta(sqrtPriceX96, TickMath.getSqrtPriceAtTick(tickUpper), liquidityDelta)\n                        .toInt128(),\n                    SqrtPriceMath.getAmount1Delta(TickMath.getSqrtPriceAtTick(tickLower), sqrtPriceX96, liquidityDelta)\n                        .toInt128()\n                );\n\n                self.liquidity = LiquidityMath.addDelta(self.liquidity, liquidityDelta);\n            } else {\n                // current tick is above the passed range; liquidity can only become in range by crossing from right to\n                // left, when we'll need _more_ currency1 (it's becoming more valuable) so user must provide it\n                delta = toBalanceDelta(\n                    0,\n                    SqrtPriceMath.getAmount1Delta(\n                        TickMath.getSqrtPriceAtTick(tickLower), TickMath.getSqrtPriceAtTick(tickUpper), liquidityDelta\n                    ).toInt128()\n                );\n            }\n        }\n    }\n\n    // Tracks the state of a pool throughout a swap, and returns these values at the end of the swap\n    struct SwapResult {\n        // the current sqrt(price)\n        uint160 sqrtPriceX96;\n        // the tick associated with the current price\n        int24 tick;\n        // the current liquidity in range\n        uint128 liquidity;\n    }\n\n    struct StepComputations {\n        // the price at the beginning of the step\n        uint160 sqrtPriceStartX96;\n        // the next tick to swap to from the current tick in the swap direction\n        int24 tickNext;\n        // whether tickNext is initialized or not\n        bool initialized;\n        // sqrt(price) for the next tick (1/0)\n        uint160 sqrtPriceNextX96;\n        // how much is being swapped in in this step\n        uint256 amountIn;\n        // how much is being swapped out\n        uint256 amountOut;\n        // how much fee is being paid in\n        uint256 feeAmount;\n        // the global fee growth of the input token. updated in storage at the end of swap\n        uint256 feeGrowthGlobalX128;\n    }\n\n    struct SwapParams {\n        int256 amountSpecified;\n        int24 tickSpacing;\n        bool zeroForOne;\n        uint160 sqrtPriceLimitX96;\n        uint24 lpFeeOverride;\n    }\n\n    /// @notice Executes a swap against the state, and returns the amount deltas of the pool\n    /// @dev PoolManager checks that the pool is initialized before calling\n    function swap(State storage self, SwapParams memory params)\n        internal\n        returns (BalanceDelta swapDelta, uint256 amountToProtocol, uint24 swapFee, SwapResult memory result)\n    {\n        Slot0 slot0Start = self.slot0;\n        bool zeroForOne = params.zeroForOne;\n\n        uint256 protocolFee =\n            zeroForOne ? slot0Start.protocolFee().getZeroForOneFee() : slot0Start.protocolFee().getOneForZeroFee();\n\n        // the amount remaining to be swapped in/out of the input/output asset. initially set to the amountSpecified\n        int256 amountSpecifiedRemaining = params.amountSpecified;\n        // the amount swapped out/in of the output/input asset. initially set to 0\n        int256 amountCalculated = 0;\n        // initialize to the current sqrt(price)\n        result.sqrtPriceX96 = slot0Start.sqrtPriceX96();\n        // initialize to the current tick\n        result.tick = slot0Start.tick();\n        // initialize to the current liquidity\n        result.liquidity = self.liquidity;\n\n        // if the beforeSwap hook returned a valid fee override, use that as the LP fee, otherwise load from storage\n        // lpFee, swapFee, and protocolFee are all in pips\n        {\n            uint24 lpFee = params.lpFeeOverride.isOverride()\n                ? params.lpFeeOverride.removeOverrideFlagAndValidate()\n                : slot0Start.lpFee();\n\n            swapFee = protocolFee == 0 ? lpFee : uint16(protocolFee).calculateSwapFee(lpFee);\n        }\n\n        // a swap fee totaling MAX_SWAP_FEE (100%) makes exact output swaps impossible since the input is entirely consumed by the fee\n        if (swapFee >= SwapMath.MAX_SWAP_FEE) {\n            // if exactOutput\n            if (params.amountSpecified > 0) {\n                InvalidFeeForExactOut.selector.revertWith();\n            }\n        }\n\n        // swapFee is the pool's fee in pips (LP fee + protocol fee)\n        // when the amount swapped is 0, there is no protocolFee applied and the fee amount paid to the protocol is set to 0\n        if (params.amountSpecified == 0) return (BalanceDeltaLibrary.ZERO_DELTA, 0, swapFee, result);\n\n        if (zeroForOne) {\n            if (params.sqrtPriceLimitX96 >= slot0Start.sqrtPriceX96()) {\n                PriceLimitAlreadyExceeded.selector.revertWith(slot0Start.sqrtPriceX96(), params.sqrtPriceLimitX96);\n            }\n            // Swaps can never occur at MIN_TICK, only at MIN_TICK + 1, except at initialization of a pool\n            // Under certain circumstances outlined below, the tick will preemptively reach MIN_TICK without swapping there\n            if (params.sqrtPriceLimitX96 <= TickMath.MIN_SQRT_PRICE) {\n                PriceLimitOutOfBounds.selector.revertWith(params.sqrtPriceLimitX96);\n            }\n        } else {\n            if (params.sqrtPriceLimitX96 <= slot0Start.sqrtPriceX96()) {\n                PriceLimitAlreadyExceeded.selector.revertWith(slot0Start.sqrtPriceX96(), params.sqrtPriceLimitX96);\n            }\n            if (params.sqrtPriceLimitX96 >= TickMath.MAX_SQRT_PRICE) {\n                PriceLimitOutOfBounds.selector.revertWith(params.sqrtPriceLimitX96);\n            }\n        }\n\n        StepComputations memory step;\n        step.feeGrowthGlobalX128 = zeroForOne ? self.feeGrowthGlobal0X128 : self.feeGrowthGlobal1X128;\n\n        // continue swapping as long as we haven't used the entire input/output and haven't reached the price limit\n        while (!(amountSpecifiedRemaining == 0 || result.sqrtPriceX96 == params.sqrtPriceLimitX96)) {\n            step.sqrtPriceStartX96 = result.sqrtPriceX96;\n\n            (step.tickNext, step.initialized) =\n                self.tickBitmap.nextInitializedTickWithinOneWord(result.tick, params.tickSpacing, zeroForOne);\n\n            // ensure that we do not overshoot the min/max tick, as the tick bitmap is not aware of these bounds\n            if (step.tickNext <= TickMath.MIN_TICK) {\n                step.tickNext = TickMath.MIN_TICK;\n            }\n            if (step.tickNext >= TickMath.MAX_TICK) {\n                step.tickNext = TickMath.MAX_TICK;\n            }\n\n            // get the price for the next tick\n            step.sqrtPriceNextX96 = TickMath.getSqrtPriceAtTick(step.tickNext);\n\n            // compute values to swap to the target tick, price limit, or point where input/output amount is exhausted\n            (result.sqrtPriceX96, step.amountIn, step.amountOut, step.feeAmount) = SwapMath.computeSwapStep(\n                result.sqrtPriceX96,\n                SwapMath.getSqrtPriceTarget(zeroForOne, step.sqrtPriceNextX96, params.sqrtPriceLimitX96),\n                result.liquidity,\n                amountSpecifiedRemaining,\n                swapFee\n            );\n\n            // if exactOutput\n            if (params.amountSpecified > 0) {\n                unchecked {\n                    amountSpecifiedRemaining -= step.amountOut.toInt256();\n                }\n                amountCalculated -= (step.amountIn + step.feeAmount).toInt256();\n            } else {\n                // safe because we test that amountSpecified > amountIn + feeAmount in SwapMath\n                unchecked {\n                    amountSpecifiedRemaining += (step.amountIn + step.feeAmount).toInt256();\n                }\n                amountCalculated += step.amountOut.toInt256();\n            }\n\n            // if the protocol fee is on, calculate how much is owed, decrement feeAmount, and increment protocolFee\n            if (protocolFee > 0) {\n                unchecked {\n                    // step.amountIn does not include the swap fee, as it's already been taken from it,\n                    // so add it back to get the total amountIn and use that to calculate the amount of fees owed to the protocol\n                    // cannot overflow due to limits on the size of protocolFee and params.amountSpecified\n                    // this rounds down to favor LPs over the protocol\n                    uint256 delta = (swapFee == protocolFee)\n                        ? step.feeAmount // lp fee is 0, so the entire fee is owed to the protocol instead\n                        : (step.amountIn + step.feeAmount) * protocolFee / ProtocolFeeLibrary.PIPS_DENOMINATOR;\n                    // subtract it from the total fee and add it to the protocol fee\n                    step.feeAmount -= delta;\n                    amountToProtocol += delta;\n                }\n            }\n\n            // update global fee tracker\n            if (result.liquidity > 0) {\n                unchecked {\n                    // FullMath.mulDiv isn't needed as the numerator can't overflow uint256 since tokens have a max supply of type(uint128).max\n                    step.feeGrowthGlobalX128 +=\n                        UnsafeMath.simpleMulDiv(step.feeAmount, FixedPoint128.Q128, result.liquidity);\n                }\n            }\n\n            // Shift tick if we reached the next price, and preemptively decrement for zeroForOne swaps to tickNext - 1.\n            // If the swap doesn't continue (if amountRemaining == 0 or sqrtPriceLimit is met), slot0.tick will be 1 less\n            // than getTickAtSqrtPrice(slot0.sqrtPrice). This doesn't affect swaps, but donation calls should verify both\n            // price and tick to reward the correct LPs.\n            if (result.sqrtPriceX96 == step.sqrtPriceNextX96) {\n                // if the tick is initialized, run the tick transition\n                if (step.initialized) {\n                    (uint256 feeGrowthGlobal0X128, uint256 feeGrowthGlobal1X128) = zeroForOne\n                        ? (step.feeGrowthGlobalX128, self.feeGrowthGlobal1X128)\n                        : (self.feeGrowthGlobal0X128, step.feeGrowthGlobalX128);\n                    int128 liquidityNet =\n                        Pool.crossTick(self, step.tickNext, feeGrowthGlobal0X128, feeGrowthGlobal1X128);\n                    // if we're moving leftward, we interpret liquidityNet as the opposite sign\n                    // safe because liquidityNet cannot be type(int128).min\n                    unchecked {\n                        if (zeroForOne) liquidityNet = -liquidityNet;\n                    }\n\n                    result.liquidity = LiquidityMath.addDelta(result.liquidity, liquidityNet);\n                }\n\n                unchecked {\n                    result.tick = zeroForOne ? step.tickNext - 1 : step.tickNext;\n                }\n            } else if (result.sqrtPriceX96 != step.sqrtPriceStartX96) {\n                // recompute unless we're on a lower tick boundary (i.e. already transitioned ticks), and haven't moved\n                result.tick = TickMath.getTickAtSqrtPrice(result.sqrtPriceX96);\n            }\n        }\n\n        self.slot0 = slot0Start.setTick(result.tick).setSqrtPriceX96(result.sqrtPriceX96);\n\n        // update liquidity if it changed\n        if (self.liquidity != result.liquidity) self.liquidity = result.liquidity;\n\n        // update fee growth global\n        if (!zeroForOne) {\n            self.feeGrowthGlobal1X128 = step.feeGrowthGlobalX128;\n        } else {\n            self.feeGrowthGlobal0X128 = step.feeGrowthGlobalX128;\n        }\n\n        unchecked {\n            // \"if currency1 is specified\"\n            if (zeroForOne != (params.amountSpecified < 0)) {\n                swapDelta = toBalanceDelta(\n                    amountCalculated.toInt128(), (params.amountSpecified - amountSpecifiedRemaining).toInt128()\n                );\n            } else {\n                swapDelta = toBalanceDelta(\n                    (params.amountSpecified - amountSpecifiedRemaining).toInt128(), amountCalculated.toInt128()\n                );\n            }\n        }\n    }\n\n    /// @notice Donates the given amount of currency0 and currency1 to the pool\n    function donate(State storage state, uint256 amount0, uint256 amount1) internal returns (BalanceDelta delta) {\n        uint128 liquidity = state.liquidity;\n        if (liquidity == 0) NoLiquidityToReceiveFees.selector.revertWith();\n        unchecked {\n            // negation safe as amount0 and amount1 are always positive\n            delta = toBalanceDelta(-(amount0.toInt128()), -(amount1.toInt128()));\n            // FullMath.mulDiv is unnecessary because the numerator is bounded by type(int128).max * Q128, which is less than type(uint256).max\n            if (amount0 > 0) {\n                state.feeGrowthGlobal0X128 += UnsafeMath.simpleMulDiv(amount0, FixedPoint128.Q128, liquidity);\n            }\n            if (amount1 > 0) {\n                state.feeGrowthGlobal1X128 += UnsafeMath.simpleMulDiv(amount1, FixedPoint128.Q128, liquidity);\n            }\n        }\n    }\n\n    /// @notice Retrieves fee growth data\n    /// @param self The Pool state struct\n    /// @param tickLower The lower tick boundary of the position\n    /// @param tickUpper The upper tick boundary of the position\n    /// @return feeGrowthInside0X128 The all-time fee growth in token0, per unit of liquidity, inside the position's tick boundaries\n    /// @return feeGrowthInside1X128 The all-time fee growth in token1, per unit of liquidity, inside the position's tick boundaries\n    function getFeeGrowthInside(State storage self, int24 tickLower, int24 tickUpper)\n        internal\n        view\n        returns (uint256 feeGrowthInside0X128, uint256 feeGrowthInside1X128)\n    {\n        TickInfo storage lower = self.ticks[tickLower];\n        TickInfo storage upper = self.ticks[tickUpper];\n        int24 tickCurrent = self.slot0.tick();\n\n        unchecked {\n            if (tickCurrent < tickLower) {\n                feeGrowthInside0X128 = lower.feeGrowthOutside0X128 - upper.feeGrowthOutside0X128;\n                feeGrowthInside1X128 = lower.feeGrowthOutside1X128 - upper.feeGrowthOutside1X128;\n            } else if (tickCurrent >= tickUpper) {\n                feeGrowthInside0X128 = upper.feeGrowthOutside0X128 - lower.feeGrowthOutside0X128;\n                feeGrowthInside1X128 = upper.feeGrowthOutside1X128 - lower.feeGrowthOutside1X128;\n            } else {\n                feeGrowthInside0X128 =\n                    self.feeGrowthGlobal0X128 - lower.feeGrowthOutside0X128 - upper.feeGrowthOutside0X128;\n                feeGrowthInside1X128 =\n                    self.feeGrowthGlobal1X128 - lower.feeGrowthOutside1X128 - upper.feeGrowthOutside1X128;\n            }\n        }\n    }\n\n    /// @notice Updates a tick and returns true if the tick was flipped from initialized to uninitialized, or vice versa\n    /// @param self The mapping containing all tick information for initialized ticks\n    /// @param tick The tick that will be updated\n    /// @param liquidityDelta A new amount of liquidity to be added (subtracted) when tick is crossed from left to right (right to left)\n    /// @param upper true for updating a position's upper tick, or false for updating a position's lower tick\n    /// @return flipped Whether the tick was flipped from initialized to uninitialized, or vice versa\n    /// @return liquidityGrossAfter The total amount of liquidity for all positions that references the tick after the update\n    function updateTick(State storage self, int24 tick, int128 liquidityDelta, bool upper)\n        internal\n        returns (bool flipped, uint128 liquidityGrossAfter)\n    {\n        TickInfo storage info = self.ticks[tick];\n\n        uint128 liquidityGrossBefore = info.liquidityGross;\n        int128 liquidityNetBefore = info.liquidityNet;\n\n        liquidityGrossAfter = LiquidityMath.addDelta(liquidityGrossBefore, liquidityDelta);\n\n        flipped = (liquidityGrossAfter == 0) != (liquidityGrossBefore == 0);\n\n        if (liquidityGrossBefore == 0) {\n            // by convention, we assume that all growth before a tick was initialized happened _below_ the tick\n            if (tick <= self.slot0.tick()) {\n                info.feeGrowthOutside0X128 = self.feeGrowthGlobal0X128;\n                info.feeGrowthOutside1X128 = self.feeGrowthGlobal1X128;\n            }\n        }\n\n        // when the lower (upper) tick is crossed left to right, liquidity must be added (removed)\n        // when the lower (upper) tick is crossed right to left, liquidity must be removed (added)\n        int128 liquidityNet = upper ? liquidityNetBefore - liquidityDelta : liquidityNetBefore + liquidityDelta;\n        assembly (\"memory-safe\") {\n            // liquidityGrossAfter and liquidityNet are packed in the first slot of `info`\n            // So we can store them with a single sstore by packing them ourselves first\n            sstore(\n                info.slot,\n                // bitwise OR to pack liquidityGrossAfter and liquidityNet\n                or(\n                    // Put liquidityGrossAfter in the lower bits, clearing out the upper bits\n                    and(liquidityGrossAfter, 0xffffffffffffffffffffffffffffffff),\n                    // Shift liquidityNet to put it in the upper bits (no need for signextend since we're shifting left)\n                    shl(128, liquidityNet)\n                )\n            )\n        }\n    }\n\n    /// @notice Derives max liquidity per tick from given tick spacing\n    /// @dev Executed when adding liquidity\n    /// @param tickSpacing The amount of required tick separation, realized in multiples of `tickSpacing`\n    ///     e.g., a tickSpacing of 3 requires ticks to be initialized every 3rd tick i.e., ..., -6, -3, 0, 3, 6, ...\n    /// @return result The max liquidity per tick\n    function tickSpacingToMaxLiquidityPerTick(int24 tickSpacing) internal pure returns (uint128 result) {\n        // Equivalent to:\n        // int24 minTick = (TickMath.MIN_TICK / tickSpacing);\n        // if (TickMath.MIN_TICK  % tickSpacing != 0) minTick--;\n        // int24 maxTick = (TickMath.MAX_TICK / tickSpacing);\n        // uint24 numTicks = maxTick - minTick + 1;\n        // return type(uint128).max / numTicks;\n        int24 MAX_TICK = TickMath.MAX_TICK;\n        int24 MIN_TICK = TickMath.MIN_TICK;\n        // tick spacing will never be 0 since TickMath.MIN_TICK_SPACING is 1\n        assembly (\"memory-safe\") {\n            tickSpacing := signextend(2, tickSpacing)\n            let minTick := sub(sdiv(MIN_TICK, tickSpacing), slt(smod(MIN_TICK, tickSpacing), 0))\n            let maxTick := sdiv(MAX_TICK, tickSpacing)\n            let numTicks := add(sub(maxTick, minTick), 1)\n            result := div(sub(shl(128, 1), 1), numTicks)\n        }\n    }\n\n    /// @notice Reverts if the given pool has not been initialized\n    function checkPoolInitialized(State storage self) internal view {\n        if (self.slot0.sqrtPriceX96() == 0) PoolNotInitialized.selector.revertWith();\n    }\n\n    /// @notice Clears tick data\n    /// @param self The mapping containing all initialized tick information for initialized ticks\n    /// @param tick The tick that will be cleared\n    function clearTick(State storage self, int24 tick) internal {\n        delete self.ticks[tick];\n    }\n\n    /// @notice Transitions to next tick as needed by price movement\n    /// @param self The Pool state struct\n    /// @param tick The destination tick of the transition\n    /// @param feeGrowthGlobal0X128 The all-time global fee growth, per unit of liquidity, in token0\n    /// @param feeGrowthGlobal1X128 The all-time global fee growth, per unit of liquidity, in token1\n    /// @return liquidityNet The amount of liquidity added (subtracted) when tick is crossed from left to right (right to left)\n    function crossTick(State storage self, int24 tick, uint256 feeGrowthGlobal0X128, uint256 feeGrowthGlobal1X128)\n        internal\n        returns (int128 liquidityNet)\n    {\n        unchecked {\n            TickInfo storage info = self.ticks[tick];\n            info.feeGrowthOutside0X128 = feeGrowthGlobal0X128 - info.feeGrowthOutside0X128;\n            info.feeGrowthOutside1X128 = feeGrowthGlobal1X128 - info.feeGrowthOutside1X128;\n            liquidityNet = info.liquidityNet;\n        }\n    }\n}\n"},"lib/v4-periphery/lib/v4-core/src/libraries/Position.sol":{"content":"// SPDX-License-Identifier: BUSL-1.1\npragma solidity ^0.8.0;\n\nimport {FullMath} from \"./FullMath.sol\";\nimport {FixedPoint128} from \"./FixedPoint128.sol\";\nimport {LiquidityMath} from \"./LiquidityMath.sol\";\nimport {CustomRevert} from \"./CustomRevert.sol\";\n\n/// @title Position\n/// @notice Positions represent an owner address' liquidity between a lower and upper tick boundary\n/// @dev Positions store additional state for tracking fees owed to the position\nlibrary Position {\n    using CustomRevert for bytes4;\n\n    /// @notice Cannot update a position with no liquidity\n    error CannotUpdateEmptyPosition();\n\n    // info stored for each user's position\n    struct State {\n        // the amount of liquidity owned by this position\n        uint128 liquidity;\n        // fee growth per unit of liquidity as of the last update to liquidity or fees owed\n        uint256 feeGrowthInside0LastX128;\n        uint256 feeGrowthInside1LastX128;\n    }\n\n    /// @notice Returns the State struct of a position, given an owner and position boundaries\n    /// @param self The mapping containing all user positions\n    /// @param owner The address of the position owner\n    /// @param tickLower The lower tick boundary of the position\n    /// @param tickUpper The upper tick boundary of the position\n    /// @param salt A unique value to differentiate between multiple positions in the same range\n    /// @return position The position info struct of the given owners' position\n    function get(mapping(bytes32 => State) storage self, address owner, int24 tickLower, int24 tickUpper, bytes32 salt)\n        internal\n        view\n        returns (State storage position)\n    {\n        bytes32 positionKey = calculatePositionKey(owner, tickLower, tickUpper, salt);\n        position = self[positionKey];\n    }\n\n    /// @notice A helper function to calculate the position key\n    /// @param owner The address of the position owner\n    /// @param tickLower the lower tick boundary of the position\n    /// @param tickUpper the upper tick boundary of the position\n    /// @param salt A unique value to differentiate between multiple positions in the same range, by the same owner. Passed in by the caller.\n    function calculatePositionKey(address owner, int24 tickLower, int24 tickUpper, bytes32 salt)\n        internal\n        pure\n        returns (bytes32 positionKey)\n    {\n        // positionKey = keccak256(abi.encodePacked(owner, tickLower, tickUpper, salt))\n        assembly (\"memory-safe\") {\n            let fmp := mload(0x40)\n            mstore(add(fmp, 0x26), salt) // [0x26, 0x46)\n            mstore(add(fmp, 0x06), tickUpper) // [0x23, 0x26)\n            mstore(add(fmp, 0x03), tickLower) // [0x20, 0x23)\n            mstore(fmp, owner) // [0x0c, 0x20)\n            positionKey := keccak256(add(fmp, 0x0c), 0x3a) // len is 58 bytes\n\n            // now clean the memory we used\n            mstore(add(fmp, 0x40), 0) // fmp+0x40 held salt\n            mstore(add(fmp, 0x20), 0) // fmp+0x20 held tickLower, tickUpper, salt\n            mstore(fmp, 0) // fmp held owner\n        }\n    }\n\n    /// @notice Credits accumulated fees to a user's position\n    /// @param self The individual position to update\n    /// @param liquidityDelta The change in pool liquidity as a result of the position update\n    /// @param feeGrowthInside0X128 The all-time fee growth in currency0, per unit of liquidity, inside the position's tick boundaries\n    /// @param feeGrowthInside1X128 The all-time fee growth in currency1, per unit of liquidity, inside the position's tick boundaries\n    /// @return feesOwed0 The amount of currency0 owed to the position owner\n    /// @return feesOwed1 The amount of currency1 owed to the position owner\n    function update(\n        State storage self,\n        int128 liquidityDelta,\n        uint256 feeGrowthInside0X128,\n        uint256 feeGrowthInside1X128\n    ) internal returns (uint256 feesOwed0, uint256 feesOwed1) {\n        uint128 liquidity = self.liquidity;\n\n        if (liquidityDelta == 0) {\n            // disallow pokes for 0 liquidity positions\n            if (liquidity == 0) CannotUpdateEmptyPosition.selector.revertWith();\n        } else {\n            self.liquidity = LiquidityMath.addDelta(liquidity, liquidityDelta);\n        }\n\n        // calculate accumulated fees. overflow in the subtraction of fee growth is expected\n        unchecked {\n            feesOwed0 =\n                FullMath.mulDiv(feeGrowthInside0X128 - self.feeGrowthInside0LastX128, liquidity, FixedPoint128.Q128);\n            feesOwed1 =\n                FullMath.mulDiv(feeGrowthInside1X128 - self.feeGrowthInside1LastX128, liquidity, FixedPoint128.Q128);\n        }\n\n        // update the position\n        self.feeGrowthInside0LastX128 = feeGrowthInside0X128;\n        self.feeGrowthInside1LastX128 = feeGrowthInside1X128;\n    }\n}\n"},"lib/v4-periphery/lib/v4-core/src/libraries/ProtocolFeeLibrary.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\n/// @notice library of functions related to protocol fees\nlibrary ProtocolFeeLibrary {\n    /// @notice Max protocol fee is 0.1% (1000 pips)\n    /// @dev Increasing these values could lead to overflow in Pool.swap\n    uint16 public constant MAX_PROTOCOL_FEE = 1000;\n\n    /// @notice Thresholds used for optimized bounds checks on protocol fees\n    uint24 internal constant FEE_0_THRESHOLD = 1001;\n    uint24 internal constant FEE_1_THRESHOLD = 1001 << 12;\n\n    /// @notice the protocol fee is represented in hundredths of a bip\n    uint256 internal constant PIPS_DENOMINATOR = 1_000_000;\n\n    function getZeroForOneFee(uint24 self) internal pure returns (uint16) {\n        return uint16(self & 0xfff);\n    }\n\n    function getOneForZeroFee(uint24 self) internal pure returns (uint16) {\n        return uint16(self >> 12);\n    }\n\n    function isValidProtocolFee(uint24 self) internal pure returns (bool valid) {\n        // Equivalent to: getZeroForOneFee(self) <= MAX_PROTOCOL_FEE && getOneForZeroFee(self) <= MAX_PROTOCOL_FEE\n        assembly (\"memory-safe\") {\n            let isZeroForOneFeeOk := lt(and(self, 0xfff), FEE_0_THRESHOLD)\n            let isOneForZeroFeeOk := lt(and(self, 0xfff000), FEE_1_THRESHOLD)\n            valid := and(isZeroForOneFeeOk, isOneForZeroFeeOk)\n        }\n    }\n\n    // The protocol fee is taken from the input amount first and then the LP fee is taken from the remaining\n    // The swap fee is capped at 100%\n    // Equivalent to protocolFee + lpFee(1_000_000 - protocolFee) / 1_000_000 (rounded up)\n    /// @dev here `self` is just a single direction's protocol fee, not a packed type of 2 protocol fees\n    function calculateSwapFee(uint16 self, uint24 lpFee) internal pure returns (uint24 swapFee) {\n        // protocolFee + lpFee - (protocolFee * lpFee / 1_000_000)\n        assembly (\"memory-safe\") {\n            self := and(self, 0xfff)\n            lpFee := and(lpFee, 0xffffff)\n            let numerator := mul(self, lpFee)\n            swapFee := sub(add(self, lpFee), div(numerator, PIPS_DENOMINATOR))\n        }\n    }\n}\n"},"lib/v4-periphery/lib/v4-core/src/libraries/SafeCast.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport {CustomRevert} from \"./CustomRevert.sol\";\n\n/// @title Safe casting methods\n/// @notice Contains methods for safely casting between types\nlibrary SafeCast {\n    using CustomRevert for bytes4;\n\n    error SafeCastOverflow();\n\n    /// @notice Cast a uint256 to a uint160, revert on overflow\n    /// @param x The uint256 to be downcasted\n    /// @return y The downcasted integer, now type uint160\n    function toUint160(uint256 x) internal pure returns (uint160 y) {\n        y = uint160(x);\n        if (y != x) SafeCastOverflow.selector.revertWith();\n    }\n\n    /// @notice Cast a uint256 to a uint128, revert on overflow\n    /// @param x The uint256 to be downcasted\n    /// @return y The downcasted integer, now type uint128\n    function toUint128(uint256 x) internal pure returns (uint128 y) {\n        y = uint128(x);\n        if (x != y) SafeCastOverflow.selector.revertWith();\n    }\n\n    /// @notice Cast a int128 to a uint128, revert on overflow or underflow\n    /// @param x The int128 to be casted\n    /// @return y The casted integer, now type uint128\n    function toUint128(int128 x) internal pure returns (uint128 y) {\n        if (x < 0) SafeCastOverflow.selector.revertWith();\n        y = uint128(x);\n    }\n\n    /// @notice Cast a int256 to a int128, revert on overflow or underflow\n    /// @param x The int256 to be downcasted\n    /// @return y The downcasted integer, now type int128\n    function toInt128(int256 x) internal pure returns (int128 y) {\n        y = int128(x);\n        if (y != x) SafeCastOverflow.selector.revertWith();\n    }\n\n    /// @notice Cast a uint256 to a int256, revert on overflow\n    /// @param x The uint256 to be casted\n    /// @return y The casted integer, now type int256\n    function toInt256(uint256 x) internal pure returns (int256 y) {\n        y = int256(x);\n        if (y < 0) SafeCastOverflow.selector.revertWith();\n    }\n\n    /// @notice Cast a uint256 to a int128, revert on overflow\n    /// @param x The uint256 to be downcasted\n    /// @return The downcasted integer, now type int128\n    function toInt128(uint256 x) internal pure returns (int128) {\n        if (x >= 1 << 127) SafeCastOverflow.selector.revertWith();\n        return int128(int256(x));\n    }\n}\n"},"lib/v4-periphery/lib/v4-core/src/libraries/SqrtPriceMath.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport {SafeCast} from \"./SafeCast.sol\";\n\nimport {FullMath} from \"./FullMath.sol\";\nimport {UnsafeMath} from \"./UnsafeMath.sol\";\nimport {FixedPoint96} from \"./FixedPoint96.sol\";\n\n/// @title Functions based on Q64.96 sqrt price and liquidity\n/// @notice Contains the math that uses square root of price as a Q64.96 and liquidity to compute deltas\nlibrary SqrtPriceMath {\n    using SafeCast for uint256;\n\n    error InvalidPriceOrLiquidity();\n    error InvalidPrice();\n    error NotEnoughLiquidity();\n    error PriceOverflow();\n\n    /// @notice Gets the next sqrt price given a delta of currency0\n    /// @dev Always rounds up, because in the exact output case (increasing price) we need to move the price at least\n    /// far enough to get the desired output amount, and in the exact input case (decreasing price) we need to move the\n    /// price less in order to not send too much output.\n    /// The most precise formula for this is liquidity * sqrtPX96 / (liquidity +- amount * sqrtPX96),\n    /// if this is impossible because of overflow, we calculate liquidity / (liquidity / sqrtPX96 +- amount).\n    /// @param sqrtPX96 The starting price, i.e. before accounting for the currency0 delta\n    /// @param liquidity The amount of usable liquidity\n    /// @param amount How much of currency0 to add or remove from virtual reserves\n    /// @param add Whether to add or remove the amount of currency0\n    /// @return The price after adding or removing amount, depending on add\n    function getNextSqrtPriceFromAmount0RoundingUp(uint160 sqrtPX96, uint128 liquidity, uint256 amount, bool add)\n        internal\n        pure\n        returns (uint160)\n    {\n        // we short circuit amount == 0 because the result is otherwise not guaranteed to equal the input price\n        if (amount == 0) return sqrtPX96;\n        uint256 numerator1 = uint256(liquidity) << FixedPoint96.RESOLUTION;\n\n        if (add) {\n            unchecked {\n                uint256 product = amount * sqrtPX96;\n                if (product / amount == sqrtPX96) {\n                    uint256 denominator = numerator1 + product;\n                    if (denominator >= numerator1) {\n                        // always fits in 160 bits\n                        return uint160(FullMath.mulDivRoundingUp(numerator1, sqrtPX96, denominator));\n                    }\n                }\n            }\n            // denominator is checked for overflow\n            return uint160(UnsafeMath.divRoundingUp(numerator1, (numerator1 / sqrtPX96) + amount));\n        } else {\n            unchecked {\n                uint256 product = amount * sqrtPX96;\n                // if the product overflows, we know the denominator underflows\n                // in addition, we must check that the denominator does not underflow\n                // equivalent: if (product / amount != sqrtPX96 || numerator1 <= product) revert PriceOverflow();\n                assembly (\"memory-safe\") {\n                    if iszero(\n                        and(\n                            eq(div(product, amount), and(sqrtPX96, 0xffffffffffffffffffffffffffffffffffffffff)),\n                            gt(numerator1, product)\n                        )\n                    ) {\n                        mstore(0, 0xf5c787f1) // selector for PriceOverflow()\n                        revert(0x1c, 0x04)\n                    }\n                }\n                uint256 denominator = numerator1 - product;\n                return FullMath.mulDivRoundingUp(numerator1, sqrtPX96, denominator).toUint160();\n            }\n        }\n    }\n\n    /// @notice Gets the next sqrt price given a delta of currency1\n    /// @dev Always rounds down, because in the exact output case (decreasing price) we need to move the price at least\n    /// far enough to get the desired output amount, and in the exact input case (increasing price) we need to move the\n    /// price less in order to not send too much output.\n    /// The formula we compute is within <1 wei of the lossless version: sqrtPX96 +- amount / liquidity\n    /// @param sqrtPX96 The starting price, i.e., before accounting for the currency1 delta\n    /// @param liquidity The amount of usable liquidity\n    /// @param amount How much of currency1 to add, or remove, from virtual reserves\n    /// @param add Whether to add, or remove, the amount of currency1\n    /// @return The price after adding or removing `amount`\n    function getNextSqrtPriceFromAmount1RoundingDown(uint160 sqrtPX96, uint128 liquidity, uint256 amount, bool add)\n        internal\n        pure\n        returns (uint160)\n    {\n        // if we're adding (subtracting), rounding down requires rounding the quotient down (up)\n        // in both cases, avoid a mulDiv for most inputs\n        if (add) {\n            uint256 quotient = (\n                amount <= type(uint160).max\n                    ? (amount << FixedPoint96.RESOLUTION) / liquidity\n                    : FullMath.mulDiv(amount, FixedPoint96.Q96, liquidity)\n            );\n\n            return (uint256(sqrtPX96) + quotient).toUint160();\n        } else {\n            uint256 quotient = (\n                amount <= type(uint160).max\n                    ? UnsafeMath.divRoundingUp(amount << FixedPoint96.RESOLUTION, liquidity)\n                    : FullMath.mulDivRoundingUp(amount, FixedPoint96.Q96, liquidity)\n            );\n\n            // equivalent: if (sqrtPX96 <= quotient) revert NotEnoughLiquidity();\n            assembly (\"memory-safe\") {\n                if iszero(gt(and(sqrtPX96, 0xffffffffffffffffffffffffffffffffffffffff), quotient)) {\n                    mstore(0, 0x4323a555) // selector for NotEnoughLiquidity()\n                    revert(0x1c, 0x04)\n                }\n            }\n            // always fits 160 bits\n            unchecked {\n                return uint160(sqrtPX96 - quotient);\n            }\n        }\n    }\n\n    /// @notice Gets the next sqrt price given an input amount of currency0 or currency1\n    /// @dev Throws if price or liquidity are 0, or if the next price is out of bounds\n    /// @param sqrtPX96 The starting price, i.e., before accounting for the input amount\n    /// @param liquidity The amount of usable liquidity\n    /// @param amountIn How much of currency0, or currency1, is being swapped in\n    /// @param zeroForOne Whether the amount in is currency0 or currency1\n    /// @return uint160 The price after adding the input amount to currency0 or currency1\n    function getNextSqrtPriceFromInput(uint160 sqrtPX96, uint128 liquidity, uint256 amountIn, bool zeroForOne)\n        internal\n        pure\n        returns (uint160)\n    {\n        // equivalent: if (sqrtPX96 == 0 || liquidity == 0) revert InvalidPriceOrLiquidity();\n        assembly (\"memory-safe\") {\n            if or(\n                iszero(and(sqrtPX96, 0xffffffffffffffffffffffffffffffffffffffff)),\n                iszero(and(liquidity, 0xffffffffffffffffffffffffffffffff))\n            ) {\n                mstore(0, 0x4f2461b8) // selector for InvalidPriceOrLiquidity()\n                revert(0x1c, 0x04)\n            }\n        }\n\n        // round to make sure that we don't pass the target price\n        return zeroForOne\n            ? getNextSqrtPriceFromAmount0RoundingUp(sqrtPX96, liquidity, amountIn, true)\n            : getNextSqrtPriceFromAmount1RoundingDown(sqrtPX96, liquidity, amountIn, true);\n    }\n\n    /// @notice Gets the next sqrt price given an output amount of currency0 or currency1\n    /// @dev Throws if price or liquidity are 0 or the next price is out of bounds\n    /// @param sqrtPX96 The starting price before accounting for the output amount\n    /// @param liquidity The amount of usable liquidity\n    /// @param amountOut How much of currency0, or currency1, is being swapped out\n    /// @param zeroForOne Whether the amount out is currency1 or currency0\n    /// @return uint160 The price after removing the output amount of currency0 or currency1\n    function getNextSqrtPriceFromOutput(uint160 sqrtPX96, uint128 liquidity, uint256 amountOut, bool zeroForOne)\n        internal\n        pure\n        returns (uint160)\n    {\n        // equivalent: if (sqrtPX96 == 0 || liquidity == 0) revert InvalidPriceOrLiquidity();\n        assembly (\"memory-safe\") {\n            if or(\n                iszero(and(sqrtPX96, 0xffffffffffffffffffffffffffffffffffffffff)),\n                iszero(and(liquidity, 0xffffffffffffffffffffffffffffffff))\n            ) {\n                mstore(0, 0x4f2461b8) // selector for InvalidPriceOrLiquidity()\n                revert(0x1c, 0x04)\n            }\n        }\n\n        // round to make sure that we pass the target price\n        return zeroForOne\n            ? getNextSqrtPriceFromAmount1RoundingDown(sqrtPX96, liquidity, amountOut, false)\n            : getNextSqrtPriceFromAmount0RoundingUp(sqrtPX96, liquidity, amountOut, false);\n    }\n\n    /// @notice Gets the amount0 delta between two prices\n    /// @dev Calculates liquidity / sqrt(lower) - liquidity / sqrt(upper),\n    /// i.e. liquidity * (sqrt(upper) - sqrt(lower)) / (sqrt(upper) * sqrt(lower))\n    /// @param sqrtPriceAX96 A sqrt price\n    /// @param sqrtPriceBX96 Another sqrt price\n    /// @param liquidity The amount of usable liquidity\n    /// @param roundUp Whether to round the amount up or down\n    /// @return uint256 Amount of currency0 required to cover a position of size liquidity between the two passed prices\n    function getAmount0Delta(uint160 sqrtPriceAX96, uint160 sqrtPriceBX96, uint128 liquidity, bool roundUp)\n        internal\n        pure\n        returns (uint256)\n    {\n        unchecked {\n            if (sqrtPriceAX96 > sqrtPriceBX96) (sqrtPriceAX96, sqrtPriceBX96) = (sqrtPriceBX96, sqrtPriceAX96);\n\n            // equivalent: if (sqrtPriceAX96 == 0) revert InvalidPrice();\n            assembly (\"memory-safe\") {\n                if iszero(and(sqrtPriceAX96, 0xffffffffffffffffffffffffffffffffffffffff)) {\n                    mstore(0, 0x00bfc921) // selector for InvalidPrice()\n                    revert(0x1c, 0x04)\n                }\n            }\n\n            uint256 numerator1 = uint256(liquidity) << FixedPoint96.RESOLUTION;\n            uint256 numerator2 = sqrtPriceBX96 - sqrtPriceAX96;\n\n            return roundUp\n                ? UnsafeMath.divRoundingUp(FullMath.mulDivRoundingUp(numerator1, numerator2, sqrtPriceBX96), sqrtPriceAX96)\n                : FullMath.mulDiv(numerator1, numerator2, sqrtPriceBX96) / sqrtPriceAX96;\n        }\n    }\n\n    /// @notice Equivalent to: `a >= b ? a - b : b - a`\n    function absDiff(uint160 a, uint160 b) internal pure returns (uint256 res) {\n        assembly (\"memory-safe\") {\n            let diff :=\n                sub(and(a, 0xffffffffffffffffffffffffffffffffffffffff), and(b, 0xffffffffffffffffffffffffffffffffffffffff))\n            // mask = 0 if a >= b else -1 (all 1s)\n            let mask := sar(255, diff)\n            // if a >= b, res = a - b = 0 ^ (a - b)\n            // if a < b, res = b - a = ~~(b - a) = ~(-(b - a) - 1) = ~(a - b - 1) = (-1) ^ (a - b - 1)\n            // either way, res = mask ^ (a - b + mask)\n            res := xor(mask, add(mask, diff))\n        }\n    }\n\n    /// @notice Gets the amount1 delta between two prices\n    /// @dev Calculates liquidity * (sqrt(upper) - sqrt(lower))\n    /// @param sqrtPriceAX96 A sqrt price\n    /// @param sqrtPriceBX96 Another sqrt price\n    /// @param liquidity The amount of usable liquidity\n    /// @param roundUp Whether to round the amount up, or down\n    /// @return amount1 Amount of currency1 required to cover a position of size liquidity between the two passed prices\n    function getAmount1Delta(uint160 sqrtPriceAX96, uint160 sqrtPriceBX96, uint128 liquidity, bool roundUp)\n        internal\n        pure\n        returns (uint256 amount1)\n    {\n        uint256 numerator = absDiff(sqrtPriceAX96, sqrtPriceBX96);\n        uint256 denominator = FixedPoint96.Q96;\n        uint256 _liquidity = uint256(liquidity);\n\n        /**\n         * Equivalent to:\n         *   amount1 = roundUp\n         *       ? FullMath.mulDivRoundingUp(liquidity, sqrtPriceBX96 - sqrtPriceAX96, FixedPoint96.Q96)\n         *       : FullMath.mulDiv(liquidity, sqrtPriceBX96 - sqrtPriceAX96, FixedPoint96.Q96);\n         * Cannot overflow because `type(uint128).max * type(uint160).max >> 96 < (1 << 192)`.\n         */\n        amount1 = FullMath.mulDiv(_liquidity, numerator, denominator);\n        assembly (\"memory-safe\") {\n            amount1 := add(amount1, and(gt(mulmod(_liquidity, numerator, denominator), 0), roundUp))\n        }\n    }\n\n    /// @notice Helper that gets signed currency0 delta\n    /// @param sqrtPriceAX96 A sqrt price\n    /// @param sqrtPriceBX96 Another sqrt price\n    /// @param liquidity The change in liquidity for which to compute the amount0 delta\n    /// @return int256 Amount of currency0 corresponding to the passed liquidityDelta between the two prices\n    function getAmount0Delta(uint160 sqrtPriceAX96, uint160 sqrtPriceBX96, int128 liquidity)\n        internal\n        pure\n        returns (int256)\n    {\n        unchecked {\n            return liquidity < 0\n                ? getAmount0Delta(sqrtPriceAX96, sqrtPriceBX96, uint128(-liquidity), false).toInt256()\n                : -getAmount0Delta(sqrtPriceAX96, sqrtPriceBX96, uint128(liquidity), true).toInt256();\n        }\n    }\n\n    /// @notice Helper that gets signed currency1 delta\n    /// @param sqrtPriceAX96 A sqrt price\n    /// @param sqrtPriceBX96 Another sqrt price\n    /// @param liquidity The change in liquidity for which to compute the amount1 delta\n    /// @return int256 Amount of currency1 corresponding to the passed liquidityDelta between the two prices\n    function getAmount1Delta(uint160 sqrtPriceAX96, uint160 sqrtPriceBX96, int128 liquidity)\n        internal\n        pure\n        returns (int256)\n    {\n        unchecked {\n            return liquidity < 0\n                ? getAmount1Delta(sqrtPriceAX96, sqrtPriceBX96, uint128(-liquidity), false).toInt256()\n                : -getAmount1Delta(sqrtPriceAX96, sqrtPriceBX96, uint128(liquidity), true).toInt256();\n        }\n    }\n}\n"},"lib/v4-periphery/lib/v4-core/src/libraries/StateLibrary.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport {PoolId} from \"../types/PoolId.sol\";\nimport {IPoolManager} from \"../interfaces/IPoolManager.sol\";\nimport {Position} from \"./Position.sol\";\n\n/// @notice A helper library to provide state getters that use extsload\nlibrary StateLibrary {\n    /// @notice index of pools mapping in the PoolManager\n    bytes32 public constant POOLS_SLOT = bytes32(uint256(6));\n\n    /// @notice index of feeGrowthGlobal0X128 in Pool.State\n    uint256 public constant FEE_GROWTH_GLOBAL0_OFFSET = 1;\n\n    // feeGrowthGlobal1X128 offset in Pool.State = 2\n\n    /// @notice index of liquidity in Pool.State\n    uint256 public constant LIQUIDITY_OFFSET = 3;\n\n    /// @notice index of TicksInfo mapping in Pool.State: mapping(int24 => TickInfo) ticks;\n    uint256 public constant TICKS_OFFSET = 4;\n\n    /// @notice index of tickBitmap mapping in Pool.State\n    uint256 public constant TICK_BITMAP_OFFSET = 5;\n\n    /// @notice index of Position.State mapping in Pool.State: mapping(bytes32 => Position.State) positions;\n    uint256 public constant POSITIONS_OFFSET = 6;\n\n    /**\n     * @notice Get Slot0 of the pool: sqrtPriceX96, tick, protocolFee, lpFee\n     * @dev Corresponds to pools[poolId].slot0\n     * @param manager The pool manager contract.\n     * @param poolId The ID of the pool.\n     * @return sqrtPriceX96 The square root of the price of the pool, in Q96 precision.\n     * @return tick The current tick of the pool.\n     * @return protocolFee The protocol fee of the pool.\n     * @return lpFee The swap fee of the pool.\n     */\n    function getSlot0(IPoolManager manager, PoolId poolId)\n        internal\n        view\n        returns (uint160 sqrtPriceX96, int24 tick, uint24 protocolFee, uint24 lpFee)\n    {\n        // slot key of Pool.State value: `pools[poolId]`\n        bytes32 stateSlot = _getPoolStateSlot(poolId);\n\n        bytes32 data = manager.extsload(stateSlot);\n\n        //   24 bits  |24bits|24bits      |24 bits|160 bits\n        // 0x000000   |000bb8|000000      |ffff75 |0000000000000000fe3aa841ba359daa0ea9eff7\n        // ---------- | fee  |protocolfee | tick  | sqrtPriceX96\n        assembly (\"memory-safe\") {\n            // bottom 160 bits of data\n            sqrtPriceX96 := and(data, 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF)\n            // next 24 bits of data\n            tick := signextend(2, shr(160, data))\n            // next 24 bits of data\n            protocolFee := and(shr(184, data), 0xFFFFFF)\n            // last 24 bits of data\n            lpFee := and(shr(208, data), 0xFFFFFF)\n        }\n    }\n\n    /**\n     * @notice Retrieves the tick information of a pool at a specific tick.\n     * @dev Corresponds to pools[poolId].ticks[tick]\n     * @param manager The pool manager contract.\n     * @param poolId The ID of the pool.\n     * @param tick The tick to retrieve information for.\n     * @return liquidityGross The total position liquidity that references this tick\n     * @return liquidityNet The amount of net liquidity added (subtracted) when tick is crossed from left to right (right to left)\n     * @return feeGrowthOutside0X128 fee growth per unit of liquidity on the _other_ side of this tick (relative to the current tick)\n     * @return feeGrowthOutside1X128 fee growth per unit of liquidity on the _other_ side of this tick (relative to the current tick)\n     */\n    function getTickInfo(IPoolManager manager, PoolId poolId, int24 tick)\n        internal\n        view\n        returns (\n            uint128 liquidityGross,\n            int128 liquidityNet,\n            uint256 feeGrowthOutside0X128,\n            uint256 feeGrowthOutside1X128\n        )\n    {\n        bytes32 slot = _getTickInfoSlot(poolId, tick);\n\n        // read all 3 words of the TickInfo struct\n        bytes32[] memory data = manager.extsload(slot, 3);\n        assembly (\"memory-safe\") {\n            let firstWord := mload(add(data, 32))\n            liquidityNet := sar(128, firstWord)\n            liquidityGross := and(firstWord, 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF)\n            feeGrowthOutside0X128 := mload(add(data, 64))\n            feeGrowthOutside1X128 := mload(add(data, 96))\n        }\n    }\n\n    /**\n     * @notice Retrieves the liquidity information of a pool at a specific tick.\n     * @dev Corresponds to pools[poolId].ticks[tick].liquidityGross and pools[poolId].ticks[tick].liquidityNet. A more gas efficient version of getTickInfo\n     * @param manager The pool manager contract.\n     * @param poolId The ID of the pool.\n     * @param tick The tick to retrieve liquidity for.\n     * @return liquidityGross The total position liquidity that references this tick\n     * @return liquidityNet The amount of net liquidity added (subtracted) when tick is crossed from left to right (right to left)\n     */\n    function getTickLiquidity(IPoolManager manager, PoolId poolId, int24 tick)\n        internal\n        view\n        returns (uint128 liquidityGross, int128 liquidityNet)\n    {\n        bytes32 slot = _getTickInfoSlot(poolId, tick);\n\n        bytes32 value = manager.extsload(slot);\n        assembly (\"memory-safe\") {\n            liquidityNet := sar(128, value)\n            liquidityGross := and(value, 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF)\n        }\n    }\n\n    /**\n     * @notice Retrieves the fee growth outside a tick range of a pool\n     * @dev Corresponds to pools[poolId].ticks[tick].feeGrowthOutside0X128 and pools[poolId].ticks[tick].feeGrowthOutside1X128. A more gas efficient version of getTickInfo\n     * @param manager The pool manager contract.\n     * @param poolId The ID of the pool.\n     * @param tick The tick to retrieve fee growth for.\n     * @return feeGrowthOutside0X128 fee growth per unit of liquidity on the _other_ side of this tick (relative to the current tick)\n     * @return feeGrowthOutside1X128 fee growth per unit of liquidity on the _other_ side of this tick (relative to the current tick)\n     */\n    function getTickFeeGrowthOutside(IPoolManager manager, PoolId poolId, int24 tick)\n        internal\n        view\n        returns (uint256 feeGrowthOutside0X128, uint256 feeGrowthOutside1X128)\n    {\n        bytes32 slot = _getTickInfoSlot(poolId, tick);\n\n        // offset by 1 word, since the first word is liquidityGross + liquidityNet\n        bytes32[] memory data = manager.extsload(bytes32(uint256(slot) + 1), 2);\n        assembly (\"memory-safe\") {\n            feeGrowthOutside0X128 := mload(add(data, 32))\n            feeGrowthOutside1X128 := mload(add(data, 64))\n        }\n    }\n\n    /**\n     * @notice Retrieves the global fee growth of a pool.\n     * @dev Corresponds to pools[poolId].feeGrowthGlobal0X128 and pools[poolId].feeGrowthGlobal1X128\n     * @param manager The pool manager contract.\n     * @param poolId The ID of the pool.\n     * @return feeGrowthGlobal0 The global fee growth for token0.\n     * @return feeGrowthGlobal1 The global fee growth for token1.\n     */\n    function getFeeGrowthGlobals(IPoolManager manager, PoolId poolId)\n        internal\n        view\n        returns (uint256 feeGrowthGlobal0, uint256 feeGrowthGlobal1)\n    {\n        // slot key of Pool.State value: `pools[poolId]`\n        bytes32 stateSlot = _getPoolStateSlot(poolId);\n\n        // Pool.State, `uint256 feeGrowthGlobal0X128`\n        bytes32 slot_feeGrowthGlobal0X128 = bytes32(uint256(stateSlot) + FEE_GROWTH_GLOBAL0_OFFSET);\n\n        // read the 2 words of feeGrowthGlobal\n        bytes32[] memory data = manager.extsload(slot_feeGrowthGlobal0X128, 2);\n        assembly (\"memory-safe\") {\n            feeGrowthGlobal0 := mload(add(data, 32))\n            feeGrowthGlobal1 := mload(add(data, 64))\n        }\n    }\n\n    /**\n     * @notice Retrieves total the liquidity of a pool.\n     * @dev Corresponds to pools[poolId].liquidity\n     * @param manager The pool manager contract.\n     * @param poolId The ID of the pool.\n     * @return liquidity The liquidity of the pool.\n     */\n    function getLiquidity(IPoolManager manager, PoolId poolId) internal view returns (uint128 liquidity) {\n        // slot key of Pool.State value: `pools[poolId]`\n        bytes32 stateSlot = _getPoolStateSlot(poolId);\n\n        // Pool.State: `uint128 liquidity`\n        bytes32 slot = bytes32(uint256(stateSlot) + LIQUIDITY_OFFSET);\n\n        liquidity = uint128(uint256(manager.extsload(slot)));\n    }\n\n    /**\n     * @notice Retrieves the tick bitmap of a pool at a specific tick.\n     * @dev Corresponds to pools[poolId].tickBitmap[tick]\n     * @param manager The pool manager contract.\n     * @param poolId The ID of the pool.\n     * @param tick The tick to retrieve the bitmap for.\n     * @return tickBitmap The bitmap of the tick.\n     */\n    function getTickBitmap(IPoolManager manager, PoolId poolId, int16 tick)\n        internal\n        view\n        returns (uint256 tickBitmap)\n    {\n        // slot key of Pool.State value: `pools[poolId]`\n        bytes32 stateSlot = _getPoolStateSlot(poolId);\n\n        // Pool.State: `mapping(int16 => uint256) tickBitmap;`\n        bytes32 tickBitmapMapping = bytes32(uint256(stateSlot) + TICK_BITMAP_OFFSET);\n\n        // slot id of the mapping key: `pools[poolId].tickBitmap[tick]\n        bytes32 slot = keccak256(abi.encodePacked(int256(tick), tickBitmapMapping));\n\n        tickBitmap = uint256(manager.extsload(slot));\n    }\n\n    /**\n     * @notice Retrieves the position information of a pool without needing to calculate the `positionId`.\n     * @dev Corresponds to pools[poolId].positions[positionId]\n     * @param poolId The ID of the pool.\n     * @param owner The owner of the liquidity position.\n     * @param tickLower The lower tick of the liquidity range.\n     * @param tickUpper The upper tick of the liquidity range.\n     * @param salt The bytes32 randomness to further distinguish position state.\n     * @return liquidity The liquidity of the position.\n     * @return feeGrowthInside0LastX128 The fee growth inside the position for token0.\n     * @return feeGrowthInside1LastX128 The fee growth inside the position for token1.\n     */\n    function getPositionInfo(\n        IPoolManager manager,\n        PoolId poolId,\n        address owner,\n        int24 tickLower,\n        int24 tickUpper,\n        bytes32 salt\n    ) internal view returns (uint128 liquidity, uint256 feeGrowthInside0LastX128, uint256 feeGrowthInside1LastX128) {\n        // positionKey = keccak256(abi.encodePacked(owner, tickLower, tickUpper, salt))\n        bytes32 positionKey = Position.calculatePositionKey(owner, tickLower, tickUpper, salt);\n\n        (liquidity, feeGrowthInside0LastX128, feeGrowthInside1LastX128) = getPositionInfo(manager, poolId, positionKey);\n    }\n\n    /**\n     * @notice Retrieves the position information of a pool at a specific position ID.\n     * @dev Corresponds to pools[poolId].positions[positionId]\n     * @param manager The pool manager contract.\n     * @param poolId The ID of the pool.\n     * @param positionId The ID of the position.\n     * @return liquidity The liquidity of the position.\n     * @return feeGrowthInside0LastX128 The fee growth inside the position for token0.\n     * @return feeGrowthInside1LastX128 The fee growth inside the position for token1.\n     */\n    function getPositionInfo(IPoolManager manager, PoolId poolId, bytes32 positionId)\n        internal\n        view\n        returns (uint128 liquidity, uint256 feeGrowthInside0LastX128, uint256 feeGrowthInside1LastX128)\n    {\n        bytes32 slot = _getPositionInfoSlot(poolId, positionId);\n\n        // read all 3 words of the Position.State struct\n        bytes32[] memory data = manager.extsload(slot, 3);\n\n        assembly (\"memory-safe\") {\n            liquidity := mload(add(data, 32))\n            feeGrowthInside0LastX128 := mload(add(data, 64))\n            feeGrowthInside1LastX128 := mload(add(data, 96))\n        }\n    }\n\n    /**\n     * @notice Retrieves the liquidity of a position.\n     * @dev Corresponds to pools[poolId].positions[positionId].liquidity. More gas efficient for just retrieiving liquidity as compared to getPositionInfo\n     * @param manager The pool manager contract.\n     * @param poolId The ID of the pool.\n     * @param positionId The ID of the position.\n     * @return liquidity The liquidity of the position.\n     */\n    function getPositionLiquidity(IPoolManager manager, PoolId poolId, bytes32 positionId)\n        internal\n        view\n        returns (uint128 liquidity)\n    {\n        bytes32 slot = _getPositionInfoSlot(poolId, positionId);\n        liquidity = uint128(uint256(manager.extsload(slot)));\n    }\n\n    /**\n     * @notice Calculate the fee growth inside a tick range of a pool\n     * @dev pools[poolId].feeGrowthInside0LastX128 in Position.State is cached and can become stale. This function will calculate the up to date feeGrowthInside\n     * @param manager The pool manager contract.\n     * @param poolId The ID of the pool.\n     * @param tickLower The lower tick of the range.\n     * @param tickUpper The upper tick of the range.\n     * @return feeGrowthInside0X128 The fee growth inside the tick range for token0.\n     * @return feeGrowthInside1X128 The fee growth inside the tick range for token1.\n     */\n    function getFeeGrowthInside(IPoolManager manager, PoolId poolId, int24 tickLower, int24 tickUpper)\n        internal\n        view\n        returns (uint256 feeGrowthInside0X128, uint256 feeGrowthInside1X128)\n    {\n        (uint256 feeGrowthGlobal0X128, uint256 feeGrowthGlobal1X128) = getFeeGrowthGlobals(manager, poolId);\n\n        (uint256 lowerFeeGrowthOutside0X128, uint256 lowerFeeGrowthOutside1X128) =\n            getTickFeeGrowthOutside(manager, poolId, tickLower);\n        (uint256 upperFeeGrowthOutside0X128, uint256 upperFeeGrowthOutside1X128) =\n            getTickFeeGrowthOutside(manager, poolId, tickUpper);\n        (, int24 tickCurrent,,) = getSlot0(manager, poolId);\n        unchecked {\n            if (tickCurrent < tickLower) {\n                feeGrowthInside0X128 = lowerFeeGrowthOutside0X128 - upperFeeGrowthOutside0X128;\n                feeGrowthInside1X128 = lowerFeeGrowthOutside1X128 - upperFeeGrowthOutside1X128;\n            } else if (tickCurrent >= tickUpper) {\n                feeGrowthInside0X128 = upperFeeGrowthOutside0X128 - lowerFeeGrowthOutside0X128;\n                feeGrowthInside1X128 = upperFeeGrowthOutside1X128 - lowerFeeGrowthOutside1X128;\n            } else {\n                feeGrowthInside0X128 = feeGrowthGlobal0X128 - lowerFeeGrowthOutside0X128 - upperFeeGrowthOutside0X128;\n                feeGrowthInside1X128 = feeGrowthGlobal1X128 - lowerFeeGrowthOutside1X128 - upperFeeGrowthOutside1X128;\n            }\n        }\n    }\n\n    function _getPoolStateSlot(PoolId poolId) internal pure returns (bytes32) {\n        return keccak256(abi.encodePacked(PoolId.unwrap(poolId), POOLS_SLOT));\n    }\n\n    function _getTickInfoSlot(PoolId poolId, int24 tick) internal pure returns (bytes32) {\n        // slot key of Pool.State value: `pools[poolId]`\n        bytes32 stateSlot = _getPoolStateSlot(poolId);\n\n        // Pool.State: `mapping(int24 => TickInfo) ticks`\n        bytes32 ticksMappingSlot = bytes32(uint256(stateSlot) + TICKS_OFFSET);\n\n        // slot key of the tick key: `pools[poolId].ticks[tick]\n        return keccak256(abi.encodePacked(int256(tick), ticksMappingSlot));\n    }\n\n    function _getPositionInfoSlot(PoolId poolId, bytes32 positionId) internal pure returns (bytes32) {\n        // slot key of Pool.State value: `pools[poolId]`\n        bytes32 stateSlot = _getPoolStateSlot(poolId);\n\n        // Pool.State: `mapping(bytes32 => Position.State) positions;`\n        bytes32 positionMapping = bytes32(uint256(stateSlot) + POSITIONS_OFFSET);\n\n        // slot of the mapping key: `pools[poolId].positions[positionId]\n        return keccak256(abi.encodePacked(positionId, positionMapping));\n    }\n}\n"},"lib/v4-periphery/lib/v4-core/src/libraries/SwapMath.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport {FullMath} from \"./FullMath.sol\";\nimport {SqrtPriceMath} from \"./SqrtPriceMath.sol\";\n\n/// @title Computes the result of a swap within ticks\n/// @notice Contains methods for computing the result of a swap within a single tick price range, i.e., a single tick.\nlibrary SwapMath {\n    /// @notice the swap fee is represented in hundredths of a bip, so the max is 100%\n    /// @dev the swap fee is the total fee on a swap, including both LP and Protocol fee\n    uint256 internal constant MAX_SWAP_FEE = 1e6;\n\n    /// @notice Computes the sqrt price target for the next swap step\n    /// @param zeroForOne The direction of the swap, true for currency0 to currency1, false for currency1 to currency0\n    /// @param sqrtPriceNextX96 The Q64.96 sqrt price for the next initialized tick\n    /// @param sqrtPriceLimitX96 The Q64.96 sqrt price limit. If zero for one, the price cannot be less than this value\n    /// after the swap. If one for zero, the price cannot be greater than this value after the swap\n    /// @return sqrtPriceTargetX96 The price target for the next swap step\n    function getSqrtPriceTarget(bool zeroForOne, uint160 sqrtPriceNextX96, uint160 sqrtPriceLimitX96)\n        internal\n        pure\n        returns (uint160 sqrtPriceTargetX96)\n    {\n        assembly (\"memory-safe\") {\n            // a flag to toggle between sqrtPriceNextX96 and sqrtPriceLimitX96\n            // when zeroForOne == true, nextOrLimit reduces to sqrtPriceNextX96 >= sqrtPriceLimitX96\n            // sqrtPriceTargetX96 = max(sqrtPriceNextX96, sqrtPriceLimitX96)\n            // when zeroForOne == false, nextOrLimit reduces to sqrtPriceNextX96 < sqrtPriceLimitX96\n            // sqrtPriceTargetX96 = min(sqrtPriceNextX96, sqrtPriceLimitX96)\n            sqrtPriceNextX96 := and(sqrtPriceNextX96, 0xffffffffffffffffffffffffffffffffffffffff)\n            sqrtPriceLimitX96 := and(sqrtPriceLimitX96, 0xffffffffffffffffffffffffffffffffffffffff)\n            let nextOrLimit := xor(lt(sqrtPriceNextX96, sqrtPriceLimitX96), and(zeroForOne, 0x1))\n            let symDiff := xor(sqrtPriceNextX96, sqrtPriceLimitX96)\n            sqrtPriceTargetX96 := xor(sqrtPriceLimitX96, mul(symDiff, nextOrLimit))\n        }\n    }\n\n    /// @notice Computes the result of swapping some amount in, or amount out, given the parameters of the swap\n    /// @dev If the swap's amountSpecified is negative, the combined fee and input amount will never exceed the absolute value of the remaining amount.\n    /// @param sqrtPriceCurrentX96 The current sqrt price of the pool\n    /// @param sqrtPriceTargetX96 The price that cannot be exceeded, from which the direction of the swap is inferred\n    /// @param liquidity The usable liquidity\n    /// @param amountRemaining How much input or output amount is remaining to be swapped in/out\n    /// @param feePips The fee taken from the input amount, expressed in hundredths of a bip\n    /// @return sqrtPriceNextX96 The price after swapping the amount in/out, not to exceed the price target\n    /// @return amountIn The amount to be swapped in, of either currency0 or currency1, based on the direction of the swap\n    /// @return amountOut The amount to be received, of either currency0 or currency1, based on the direction of the swap\n    /// @return feeAmount The amount of input that will be taken as a fee\n    /// @dev feePips must be no larger than MAX_SWAP_FEE for this function. We ensure that before setting a fee using LPFeeLibrary.isValid.\n    function computeSwapStep(\n        uint160 sqrtPriceCurrentX96,\n        uint160 sqrtPriceTargetX96,\n        uint128 liquidity,\n        int256 amountRemaining,\n        uint24 feePips\n    ) internal pure returns (uint160 sqrtPriceNextX96, uint256 amountIn, uint256 amountOut, uint256 feeAmount) {\n        unchecked {\n            uint256 _feePips = feePips; // upcast once and cache\n            bool zeroForOne = sqrtPriceCurrentX96 >= sqrtPriceTargetX96;\n            bool exactIn = amountRemaining < 0;\n\n            if (exactIn) {\n                uint256 amountRemainingLessFee =\n                    FullMath.mulDiv(uint256(-amountRemaining), MAX_SWAP_FEE - _feePips, MAX_SWAP_FEE);\n                amountIn = zeroForOne\n                    ? SqrtPriceMath.getAmount0Delta(sqrtPriceTargetX96, sqrtPriceCurrentX96, liquidity, true)\n                    : SqrtPriceMath.getAmount1Delta(sqrtPriceCurrentX96, sqrtPriceTargetX96, liquidity, true);\n                if (amountRemainingLessFee >= amountIn) {\n                    // `amountIn` is capped by the target price\n                    sqrtPriceNextX96 = sqrtPriceTargetX96;\n                    feeAmount = _feePips == MAX_SWAP_FEE\n                        ? amountIn // amountIn is always 0 here, as amountRemainingLessFee == 0 and amountRemainingLessFee >= amountIn\n                        : FullMath.mulDivRoundingUp(amountIn, _feePips, MAX_SWAP_FEE - _feePips);\n                } else {\n                    // exhaust the remaining amount\n                    amountIn = amountRemainingLessFee;\n                    sqrtPriceNextX96 = SqrtPriceMath.getNextSqrtPriceFromInput(\n                        sqrtPriceCurrentX96, liquidity, amountRemainingLessFee, zeroForOne\n                    );\n                    // we didn't reach the target, so take the remainder of the maximum input as fee\n                    feeAmount = uint256(-amountRemaining) - amountIn;\n                }\n                amountOut = zeroForOne\n                    ? SqrtPriceMath.getAmount1Delta(sqrtPriceNextX96, sqrtPriceCurrentX96, liquidity, false)\n                    : SqrtPriceMath.getAmount0Delta(sqrtPriceCurrentX96, sqrtPriceNextX96, liquidity, false);\n            } else {\n                amountOut = zeroForOne\n                    ? SqrtPriceMath.getAmount1Delta(sqrtPriceTargetX96, sqrtPriceCurrentX96, liquidity, false)\n                    : SqrtPriceMath.getAmount0Delta(sqrtPriceCurrentX96, sqrtPriceTargetX96, liquidity, false);\n                if (uint256(amountRemaining) >= amountOut) {\n                    // `amountOut` is capped by the target price\n                    sqrtPriceNextX96 = sqrtPriceTargetX96;\n                } else {\n                    // cap the output amount to not exceed the remaining output amount\n                    amountOut = uint256(amountRemaining);\n                    sqrtPriceNextX96 =\n                        SqrtPriceMath.getNextSqrtPriceFromOutput(sqrtPriceCurrentX96, liquidity, amountOut, zeroForOne);\n                }\n                amountIn = zeroForOne\n                    ? SqrtPriceMath.getAmount0Delta(sqrtPriceNextX96, sqrtPriceCurrentX96, liquidity, true)\n                    : SqrtPriceMath.getAmount1Delta(sqrtPriceCurrentX96, sqrtPriceNextX96, liquidity, true);\n                // `feePips` cannot be `MAX_SWAP_FEE` for exact out\n                feeAmount = FullMath.mulDivRoundingUp(amountIn, _feePips, MAX_SWAP_FEE - _feePips);\n            }\n        }\n    }\n}\n"},"lib/v4-periphery/lib/v4-core/src/libraries/TickBitmap.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport {BitMath} from \"./BitMath.sol\";\n\n/// @title Packed tick initialized state library\n/// @notice Stores a packed mapping of tick index to its initialized state\n/// @dev The mapping uses int16 for keys since ticks are represented as int24 and there are 256 (2^8) values per word.\nlibrary TickBitmap {\n    /// @notice Thrown when the tick is not enumerated by the tick spacing\n    /// @param tick the invalid tick\n    /// @param tickSpacing The tick spacing of the pool\n    error TickMisaligned(int24 tick, int24 tickSpacing);\n\n    /// @dev round towards negative infinity\n    function compress(int24 tick, int24 tickSpacing) internal pure returns (int24 compressed) {\n        // compressed = tick / tickSpacing;\n        // if (tick < 0 && tick % tickSpacing != 0) compressed--;\n        assembly (\"memory-safe\") {\n            tick := signextend(2, tick)\n            tickSpacing := signextend(2, tickSpacing)\n            compressed :=\n                sub(\n                    sdiv(tick, tickSpacing),\n                    // if (tick < 0 && tick % tickSpacing != 0) then tick % tickSpacing < 0, vice versa\n                    slt(smod(tick, tickSpacing), 0)\n                )\n        }\n    }\n\n    /// @notice Computes the position in the mapping where the initialized bit for a tick lives\n    /// @param tick The tick for which to compute the position\n    /// @return wordPos The key in the mapping containing the word in which the bit is stored\n    /// @return bitPos The bit position in the word where the flag is stored\n    function position(int24 tick) internal pure returns (int16 wordPos, uint8 bitPos) {\n        assembly (\"memory-safe\") {\n            // signed arithmetic shift right\n            wordPos := sar(8, signextend(2, tick))\n            bitPos := and(tick, 0xff)\n        }\n    }\n\n    /// @notice Flips the initialized state for a given tick from false to true, or vice versa\n    /// @param self The mapping in which to flip the tick\n    /// @param tick The tick to flip\n    /// @param tickSpacing The spacing between usable ticks\n    function flipTick(mapping(int16 => uint256) storage self, int24 tick, int24 tickSpacing) internal {\n        // Equivalent to the following Solidity:\n        //     if (tick % tickSpacing != 0) revert TickMisaligned(tick, tickSpacing);\n        //     (int16 wordPos, uint8 bitPos) = position(tick / tickSpacing);\n        //     uint256 mask = 1 << bitPos;\n        //     self[wordPos] ^= mask;\n        assembly (\"memory-safe\") {\n            tick := signextend(2, tick)\n            tickSpacing := signextend(2, tickSpacing)\n            // ensure that the tick is spaced\n            if smod(tick, tickSpacing) {\n                let fmp := mload(0x40)\n                mstore(fmp, 0xd4d8f3e6) // selector for TickMisaligned(int24,int24)\n                mstore(add(fmp, 0x20), tick)\n                mstore(add(fmp, 0x40), tickSpacing)\n                revert(add(fmp, 0x1c), 0x44)\n            }\n            tick := sdiv(tick, tickSpacing)\n            // calculate the storage slot corresponding to the tick\n            // wordPos = tick >> 8\n            mstore(0, sar(8, tick))\n            mstore(0x20, self.slot)\n            // the slot of self[wordPos] is keccak256(abi.encode(wordPos, self.slot))\n            let slot := keccak256(0, 0x40)\n            // mask = 1 << bitPos = 1 << (tick % 256)\n            // self[wordPos] ^= mask\n            sstore(slot, xor(sload(slot), shl(and(tick, 0xff), 1)))\n        }\n    }\n\n    /// @notice Returns the next initialized tick contained in the same word (or adjacent word) as the tick that is either\n    /// to the left (less than or equal to) or right (greater than) of the given tick\n    /// @param self The mapping in which to compute the next initialized tick\n    /// @param tick The starting tick\n    /// @param tickSpacing The spacing between usable ticks\n    /// @param lte Whether to search for the next initialized tick to the left (less than or equal to the starting tick)\n    /// @return next The next initialized or uninitialized tick up to 256 ticks away from the current tick\n    /// @return initialized Whether the next tick is initialized, as the function only searches within up to 256 ticks\n    function nextInitializedTickWithinOneWord(\n        mapping(int16 => uint256) storage self,\n        int24 tick,\n        int24 tickSpacing,\n        bool lte\n    ) internal view returns (int24 next, bool initialized) {\n        unchecked {\n            int24 compressed = compress(tick, tickSpacing);\n\n            if (lte) {\n                (int16 wordPos, uint8 bitPos) = position(compressed);\n                // all the 1s at or to the right of the current bitPos\n                uint256 mask = type(uint256).max >> (uint256(type(uint8).max) - bitPos);\n                uint256 masked = self[wordPos] & mask;\n\n                // if there are no initialized ticks to the right of or at the current tick, return rightmost in the word\n                initialized = masked != 0;\n                // overflow/underflow is possible, but prevented externally by limiting both tickSpacing and tick\n                next = initialized\n                    ? (compressed - int24(uint24(bitPos - BitMath.mostSignificantBit(masked)))) * tickSpacing\n                    : (compressed - int24(uint24(bitPos))) * tickSpacing;\n            } else {\n                // start from the word of the next tick, since the current tick state doesn't matter\n                (int16 wordPos, uint8 bitPos) = position(++compressed);\n                // all the 1s at or to the left of the bitPos\n                uint256 mask = ~((1 << bitPos) - 1);\n                uint256 masked = self[wordPos] & mask;\n\n                // if there are no initialized ticks to the left of the current tick, return leftmost in the word\n                initialized = masked != 0;\n                // overflow/underflow is possible, but prevented externally by limiting both tickSpacing and tick\n                next = initialized\n                    ? (compressed + int24(uint24(BitMath.leastSignificantBit(masked) - bitPos))) * tickSpacing\n                    : (compressed + int24(uint24(type(uint8).max - bitPos))) * tickSpacing;\n            }\n        }\n    }\n}\n"},"lib/v4-periphery/lib/v4-core/src/libraries/TickMath.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport {BitMath} from \"./BitMath.sol\";\nimport {CustomRevert} from \"./CustomRevert.sol\";\n\n/// @title Math library for computing sqrt prices from ticks and vice versa\n/// @notice Computes sqrt price for ticks of size 1.0001, i.e. sqrt(1.0001^tick) as fixed point Q64.96 numbers. Supports\n/// prices between 2**-128 and 2**128\nlibrary TickMath {\n    using CustomRevert for bytes4;\n\n    /// @notice Thrown when the tick passed to #getSqrtPriceAtTick is not between MIN_TICK and MAX_TICK\n    error InvalidTick(int24 tick);\n    /// @notice Thrown when the price passed to #getTickAtSqrtPrice does not correspond to a price between MIN_TICK and MAX_TICK\n    error InvalidSqrtPrice(uint160 sqrtPriceX96);\n\n    /// @dev The minimum tick that may be passed to #getSqrtPriceAtTick computed from log base 1.0001 of 2**-128\n    /// @dev If ever MIN_TICK and MAX_TICK are not centered around 0, the absTick logic in getSqrtPriceAtTick cannot be used\n    int24 internal constant MIN_TICK = -887272;\n    /// @dev The maximum tick that may be passed to #getSqrtPriceAtTick computed from log base 1.0001 of 2**128\n    /// @dev If ever MIN_TICK and MAX_TICK are not centered around 0, the absTick logic in getSqrtPriceAtTick cannot be used\n    int24 internal constant MAX_TICK = 887272;\n\n    /// @dev The minimum tick spacing value drawn from the range of type int16 that is greater than 0, i.e. min from the range [1, 32767]\n    int24 internal constant MIN_TICK_SPACING = 1;\n    /// @dev The maximum tick spacing value drawn from the range of type int16, i.e. max from the range [1, 32767]\n    int24 internal constant MAX_TICK_SPACING = type(int16).max;\n\n    /// @dev The minimum value that can be returned from #getSqrtPriceAtTick. Equivalent to getSqrtPriceAtTick(MIN_TICK)\n    uint160 internal constant MIN_SQRT_PRICE = 4295128739;\n    /// @dev The maximum value that can be returned from #getSqrtPriceAtTick. Equivalent to getSqrtPriceAtTick(MAX_TICK)\n    uint160 internal constant MAX_SQRT_PRICE = 1461446703485210103287273052203988822378723970342;\n    /// @dev A threshold used for optimized bounds check, equals `MAX_SQRT_PRICE - MIN_SQRT_PRICE - 1`\n    uint160 internal constant MAX_SQRT_PRICE_MINUS_MIN_SQRT_PRICE_MINUS_ONE =\n        1461446703485210103287273052203988822378723970342 - 4295128739 - 1;\n\n    /// @notice Given a tickSpacing, compute the maximum usable tick\n    function maxUsableTick(int24 tickSpacing) internal pure returns (int24) {\n        unchecked {\n            return (MAX_TICK / tickSpacing) * tickSpacing;\n        }\n    }\n\n    /// @notice Given a tickSpacing, compute the minimum usable tick\n    function minUsableTick(int24 tickSpacing) internal pure returns (int24) {\n        unchecked {\n            return (MIN_TICK / tickSpacing) * tickSpacing;\n        }\n    }\n\n    /// @notice Calculates sqrt(1.0001^tick) * 2^96\n    /// @dev Throws if |tick| > max tick\n    /// @param tick The input tick for the above formula\n    /// @return sqrtPriceX96 A Fixed point Q64.96 number representing the sqrt of the price of the two assets (currency1/currency0)\n    /// at the given tick\n    function getSqrtPriceAtTick(int24 tick) internal pure returns (uint160 sqrtPriceX96) {\n        unchecked {\n            uint256 absTick;\n            assembly (\"memory-safe\") {\n                tick := signextend(2, tick)\n                // mask = 0 if tick >= 0 else -1 (all 1s)\n                let mask := sar(255, tick)\n                // if tick >= 0, |tick| = tick = 0 ^ tick\n                // if tick < 0, |tick| = ~~|tick| = ~(-|tick| - 1) = ~(tick - 1) = (-1) ^ (tick - 1)\n                // either way, |tick| = mask ^ (tick + mask)\n                absTick := xor(mask, add(mask, tick))\n            }\n\n            if (absTick > uint256(int256(MAX_TICK))) InvalidTick.selector.revertWith(tick);\n\n            // The tick is decomposed into bits, and for each bit with index i that is set, the product of 1/sqrt(1.0001^(2^i))\n            // is calculated (using Q128.128). The constants used for this calculation are rounded to the nearest integer\n\n            // Equivalent to:\n            //     price = absTick & 0x1 != 0 ? 0xfffcb933bd6fad37aa2d162d1a594001 : 0x100000000000000000000000000000000;\n            //     or price = int(2**128 / sqrt(1.0001)) if (absTick & 0x1) else 1 << 128\n            uint256 price;\n            assembly (\"memory-safe\") {\n                price := xor(shl(128, 1), mul(xor(shl(128, 1), 0xfffcb933bd6fad37aa2d162d1a594001), and(absTick, 0x1)))\n            }\n            if (absTick & 0x2 != 0) price = (price * 0xfff97272373d413259a46990580e213a) >> 128;\n            if (absTick & 0x4 != 0) price = (price * 0xfff2e50f5f656932ef12357cf3c7fdcc) >> 128;\n            if (absTick & 0x8 != 0) price = (price * 0xffe5caca7e10e4e61c3624eaa0941cd0) >> 128;\n            if (absTick & 0x10 != 0) price = (price * 0xffcb9843d60f6159c9db58835c926644) >> 128;\n            if (absTick & 0x20 != 0) price = (price * 0xff973b41fa98c081472e6896dfb254c0) >> 128;\n            if (absTick & 0x40 != 0) price = (price * 0xff2ea16466c96a3843ec78b326b52861) >> 128;\n            if (absTick & 0x80 != 0) price = (price * 0xfe5dee046a99a2a811c461f1969c3053) >> 128;\n            if (absTick & 0x100 != 0) price = (price * 0xfcbe86c7900a88aedcffc83b479aa3a4) >> 128;\n            if (absTick & 0x200 != 0) price = (price * 0xf987a7253ac413176f2b074cf7815e54) >> 128;\n            if (absTick & 0x400 != 0) price = (price * 0xf3392b0822b70005940c7a398e4b70f3) >> 128;\n            if (absTick & 0x800 != 0) price = (price * 0xe7159475a2c29b7443b29c7fa6e889d9) >> 128;\n            if (absTick & 0x1000 != 0) price = (price * 0xd097f3bdfd2022b8845ad8f792aa5825) >> 128;\n            if (absTick & 0x2000 != 0) price = (price * 0xa9f746462d870fdf8a65dc1f90e061e5) >> 128;\n            if (absTick & 0x4000 != 0) price = (price * 0x70d869a156d2a1b890bb3df62baf32f7) >> 128;\n            if (absTick & 0x8000 != 0) price = (price * 0x31be135f97d08fd981231505542fcfa6) >> 128;\n            if (absTick & 0x10000 != 0) price = (price * 0x9aa508b5b7a84e1c677de54f3e99bc9) >> 128;\n            if (absTick & 0x20000 != 0) price = (price * 0x5d6af8dedb81196699c329225ee604) >> 128;\n            if (absTick & 0x40000 != 0) price = (price * 0x2216e584f5fa1ea926041bedfe98) >> 128;\n            if (absTick & 0x80000 != 0) price = (price * 0x48a170391f7dc42444e8fa2) >> 128;\n\n            assembly (\"memory-safe\") {\n                // if (tick > 0) price = type(uint256).max / price;\n                if sgt(tick, 0) { price := div(not(0), price) }\n\n                // this divides by 1<<32 rounding up to go from a Q128.128 to a Q128.96.\n                // we then downcast because we know the result always fits within 160 bits due to our tick input constraint\n                // we round up in the division so getTickAtSqrtPrice of the output price is always consistent\n                // `sub(shl(32, 1), 1)` is `type(uint32).max`\n                // `price + type(uint32).max` will not overflow because `price` fits in 192 bits\n                sqrtPriceX96 := shr(32, add(price, sub(shl(32, 1), 1)))\n            }\n        }\n    }\n\n    /// @notice Calculates the greatest tick value such that getSqrtPriceAtTick(tick) <= sqrtPriceX96\n    /// @dev Throws in case sqrtPriceX96 < MIN_SQRT_PRICE, as MIN_SQRT_PRICE is the lowest value getSqrtPriceAtTick may\n    /// ever return.\n    /// @param sqrtPriceX96 The sqrt price for which to compute the tick as a Q64.96\n    /// @return tick The greatest tick for which the getSqrtPriceAtTick(tick) is less than or equal to the input sqrtPriceX96\n    function getTickAtSqrtPrice(uint160 sqrtPriceX96) internal pure returns (int24 tick) {\n        unchecked {\n            // Equivalent: if (sqrtPriceX96 < MIN_SQRT_PRICE || sqrtPriceX96 >= MAX_SQRT_PRICE) revert InvalidSqrtPrice();\n            // second inequality must be >= because the price can never reach the price at the max tick\n            // if sqrtPriceX96 < MIN_SQRT_PRICE, the `sub` underflows and `gt` is true\n            // if sqrtPriceX96 >= MAX_SQRT_PRICE, sqrtPriceX96 - MIN_SQRT_PRICE > MAX_SQRT_PRICE - MIN_SQRT_PRICE - 1\n            if ((sqrtPriceX96 - MIN_SQRT_PRICE) > MAX_SQRT_PRICE_MINUS_MIN_SQRT_PRICE_MINUS_ONE) {\n                InvalidSqrtPrice.selector.revertWith(sqrtPriceX96);\n            }\n\n            uint256 price = uint256(sqrtPriceX96) << 32;\n\n            uint256 r = price;\n            uint256 msb = BitMath.mostSignificantBit(r);\n\n            if (msb >= 128) r = price >> (msb - 127);\n            else r = price << (127 - msb);\n\n            int256 log_2 = (int256(msb) - 128) << 64;\n\n            assembly (\"memory-safe\") {\n                r := shr(127, mul(r, r))\n                let f := shr(128, r)\n                log_2 := or(log_2, shl(63, f))\n                r := shr(f, r)\n            }\n            assembly (\"memory-safe\") {\n                r := shr(127, mul(r, r))\n                let f := shr(128, r)\n                log_2 := or(log_2, shl(62, f))\n                r := shr(f, r)\n            }\n            assembly (\"memory-safe\") {\n                r := shr(127, mul(r, r))\n                let f := shr(128, r)\n                log_2 := or(log_2, shl(61, f))\n                r := shr(f, r)\n            }\n            assembly (\"memory-safe\") {\n                r := shr(127, mul(r, r))\n                let f := shr(128, r)\n                log_2 := or(log_2, shl(60, f))\n                r := shr(f, r)\n            }\n            assembly (\"memory-safe\") {\n                r := shr(127, mul(r, r))\n                let f := shr(128, r)\n                log_2 := or(log_2, shl(59, f))\n                r := shr(f, r)\n            }\n            assembly (\"memory-safe\") {\n                r := shr(127, mul(r, r))\n                let f := shr(128, r)\n                log_2 := or(log_2, shl(58, f))\n                r := shr(f, r)\n            }\n            assembly (\"memory-safe\") {\n                r := shr(127, mul(r, r))\n                let f := shr(128, r)\n                log_2 := or(log_2, shl(57, f))\n                r := shr(f, r)\n            }\n            assembly (\"memory-safe\") {\n                r := shr(127, mul(r, r))\n                let f := shr(128, r)\n                log_2 := or(log_2, shl(56, f))\n                r := shr(f, r)\n            }\n            assembly (\"memory-safe\") {\n                r := shr(127, mul(r, r))\n                let f := shr(128, r)\n                log_2 := or(log_2, shl(55, f))\n                r := shr(f, r)\n            }\n            assembly (\"memory-safe\") {\n                r := shr(127, mul(r, r))\n                let f := shr(128, r)\n                log_2 := or(log_2, shl(54, f))\n                r := shr(f, r)\n            }\n            assembly (\"memory-safe\") {\n                r := shr(127, mul(r, r))\n                let f := shr(128, r)\n                log_2 := or(log_2, shl(53, f))\n                r := shr(f, r)\n            }\n            assembly (\"memory-safe\") {\n                r := shr(127, mul(r, r))\n                let f := shr(128, r)\n                log_2 := or(log_2, shl(52, f))\n                r := shr(f, r)\n            }\n            assembly (\"memory-safe\") {\n                r := shr(127, mul(r, r))\n                let f := shr(128, r)\n                log_2 := or(log_2, shl(51, f))\n                r := shr(f, r)\n            }\n            assembly (\"memory-safe\") {\n                r := shr(127, mul(r, r))\n                let f := shr(128, r)\n                log_2 := or(log_2, shl(50, f))\n            }\n\n            int256 log_sqrt10001 = log_2 * 255738958999603826347141; // Q22.128 number\n\n            // Magic number represents the ceiling of the maximum value of the error when approximating log_sqrt10001(x)\n            int24 tickLow = int24((log_sqrt10001 - 3402992956809132418596140100660247210) >> 128);\n\n            // Magic number represents the minimum value of the error when approximating log_sqrt10001(x), when\n            // sqrtPrice is from the range (2^-64, 2^64). This is safe as MIN_SQRT_PRICE is more than 2^-64. If MIN_SQRT_PRICE\n            // is changed, this may need to be changed too\n            int24 tickHi = int24((log_sqrt10001 + 291339464771989622907027621153398088495) >> 128);\n\n            tick = tickLow == tickHi ? tickLow : getSqrtPriceAtTick(tickHi) <= sqrtPriceX96 ? tickHi : tickLow;\n        }\n    }\n}\n"},"lib/v4-periphery/lib/v4-core/src/libraries/TransientStateLibrary.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity ^0.8.24;\n\nimport {IPoolManager} from \"../interfaces/IPoolManager.sol\";\nimport {Currency} from \"../types/Currency.sol\";\nimport {CurrencyReserves} from \"./CurrencyReserves.sol\";\nimport {NonzeroDeltaCount} from \"./NonzeroDeltaCount.sol\";\nimport {Lock} from \"./Lock.sol\";\n\n/// @notice A helper library to provide state getters that use exttload\nlibrary TransientStateLibrary {\n    /// @notice returns the reserves for the synced currency\n    /// @param manager The pool manager contract.\n\n    /// @return uint256 The reserves of the currency.\n    /// @dev returns 0 if the reserves are not synced or value is 0.\n    /// Checks the synced currency to only return valid reserve values (after a sync and before a settle).\n    function getSyncedReserves(IPoolManager manager) internal view returns (uint256) {\n        if (getSyncedCurrency(manager).isAddressZero()) return 0;\n        return uint256(manager.exttload(CurrencyReserves.RESERVES_OF_SLOT));\n    }\n\n    function getSyncedCurrency(IPoolManager manager) internal view returns (Currency) {\n        return Currency.wrap(address(uint160(uint256(manager.exttload(CurrencyReserves.CURRENCY_SLOT)))));\n    }\n\n    /// @notice Returns the number of nonzero deltas open on the PoolManager that must be zeroed out before the contract is locked\n    function getNonzeroDeltaCount(IPoolManager manager) internal view returns (uint256) {\n        return uint256(manager.exttload(NonzeroDeltaCount.NONZERO_DELTA_COUNT_SLOT));\n    }\n\n    /// @notice Get the current delta for a caller in the given currency\n    /// @param target The credited account address\n    /// @param currency The currency for which to lookup the delta\n    function currencyDelta(IPoolManager manager, address target, Currency currency) internal view returns (int256) {\n        bytes32 key;\n        assembly (\"memory-safe\") {\n            mstore(0, and(target, 0xffffffffffffffffffffffffffffffffffffffff))\n            mstore(32, and(currency, 0xffffffffffffffffffffffffffffffffffffffff))\n            key := keccak256(0, 64)\n        }\n        return int256(uint256(manager.exttload(key)));\n    }\n\n    /// @notice Returns whether the contract is unlocked or not\n    function isUnlocked(IPoolManager manager) internal view returns (bool) {\n        return manager.exttload(Lock.IS_UNLOCKED_SLOT) != 0x0;\n    }\n}\n"},"lib/v4-periphery/lib/v4-core/src/libraries/UnsafeMath.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\n/// @title Math functions that do not check inputs or outputs\n/// @notice Contains methods that perform common math functions but do not do any overflow or underflow checks\nlibrary UnsafeMath {\n    /// @notice Returns ceil(x / y)\n    /// @dev division by 0 will return 0, and should be checked externally\n    /// @param x The dividend\n    /// @param y The divisor\n    /// @return z The quotient, ceil(x / y)\n    function divRoundingUp(uint256 x, uint256 y) internal pure returns (uint256 z) {\n        assembly (\"memory-safe\") {\n            z := add(div(x, y), gt(mod(x, y), 0))\n        }\n    }\n\n    /// @notice Calculates floor(abdenominator)\n    /// @dev division by 0 will return 0, and should be checked externally\n    /// @param a The multiplicand\n    /// @param b The multiplier\n    /// @param denominator The divisor\n    /// @return result The 256-bit result, floor(abdenominator)\n    function simpleMulDiv(uint256 a, uint256 b, uint256 denominator) internal pure returns (uint256 result) {\n        assembly (\"memory-safe\") {\n            result := div(mul(a, b), denominator)\n        }\n    }\n}\n"},"lib/v4-periphery/lib/v4-core/src/test/ActionsRouter.sol":{"content":"// SPDX-License-Identifier: UNLICENSED\npragma solidity ^0.8.24;\n\nimport \"forge-std/Test.sol\";\nimport {IPoolManager} from \"../interfaces/IPoolManager.sol\";\nimport {IUnlockCallback} from \"../interfaces/callback/IUnlockCallback.sol\";\nimport {Currency} from \"../types/Currency.sol\";\nimport {MockERC20} from \"solmate/src/test/utils/mocks/MockERC20.sol\";\nimport {StateLibrary} from \"../libraries/StateLibrary.sol\";\nimport {TransientStateLibrary} from \"../libraries/TransientStateLibrary.sol\";\n\n// Supported Actions.\nenum Actions {\n    SETTLE,\n    SETTLE_NATIVE,\n    SETTLE_FOR,\n    TAKE,\n    PRANK_TAKE_FROM,\n    SYNC,\n    MINT,\n    CLEAR,\n    ASSERT_BALANCE_EQUALS,\n    ASSERT_RESERVES_EQUALS,\n    ASSERT_DELTA_EQUALS,\n    ASSERT_NONZERO_DELTA_COUNT_EQUALS,\n    TRANSFER_FROM,\n    COLLECT_PROTOCOL_FEES\n}\n// TODO: Add other actions as needed.\n// BURN,\n// MODIFY_POSITION,\n// INITIALIZE,\n// DONATE\n\n/// @notice A router that handles an arbitrary input of actions.\n/// TODO: Can continue to add functions per action.\ncontract ActionsRouter is IUnlockCallback, Test {\n    using StateLibrary for IPoolManager;\n    using TransientStateLibrary for IPoolManager;\n\n    error ActionNotSupported();\n\n    // error thrown so that incorrectly formatted tests don't pass silently\n    error CheckParameters();\n\n    IPoolManager manager;\n\n    constructor(IPoolManager _manager) {\n        manager = _manager;\n    }\n\n    function unlockCallback(bytes calldata data) external returns (bytes memory) {\n        (Actions[] memory actions, bytes[] memory params) = abi.decode(data, (Actions[], bytes[]));\n        if (actions.length != params.length || actions.length == 0) revert CheckParameters();\n        for (uint256 i = 0; i < actions.length; i++) {\n            Actions action = actions[i];\n            bytes memory param = params[i];\n            if (action == Actions.SETTLE) {\n                _settle();\n            } else if (action == Actions.SETTLE_NATIVE) {\n                _settleNative(param);\n            } else if (action == Actions.SETTLE_FOR) {\n                _settleFor(param);\n            } else if (action == Actions.TAKE) {\n                _take(param);\n            } else if (action == Actions.PRANK_TAKE_FROM) {\n                _prankTakeFrom(param);\n            } else if (action == Actions.SYNC) {\n                _sync(param);\n            } else if (action == Actions.MINT) {\n                _mint(param);\n            } else if (action == Actions.CLEAR) {\n                _clear(param);\n            } else if (action == Actions.ASSERT_BALANCE_EQUALS) {\n                _assertBalanceEquals(param);\n            } else if (action == Actions.ASSERT_RESERVES_EQUALS) {\n                _assertReservesEquals(param);\n            } else if (action == Actions.ASSERT_DELTA_EQUALS) {\n                _assertDeltaEquals(param);\n            } else if (action == Actions.ASSERT_NONZERO_DELTA_COUNT_EQUALS) {\n                _assertNonzeroDeltaCountEquals(param);\n            } else if (action == Actions.TRANSFER_FROM) {\n                _transferFrom(param);\n            } else if (action == Actions.COLLECT_PROTOCOL_FEES) {\n                _collectProtocolFees(param);\n            }\n        }\n        return \"\";\n    }\n\n    function executeActions(Actions[] memory actions, bytes[] memory params) external payable {\n        manager.unlock(abi.encode(actions, params));\n    }\n\n    function _settle() internal {\n        manager.settle();\n    }\n\n    function _settleNative(bytes memory params) internal {\n        uint256 amount = abi.decode(params, (uint256));\n        manager.settle{value: amount}();\n    }\n\n    function _settleFor(bytes memory params) internal {\n        address recipient = abi.decode(params, (address));\n        manager.settleFor(recipient);\n    }\n\n    function _take(bytes memory params) internal {\n        (Currency currency, address recipient, int128 amount) = abi.decode(params, (Currency, address, int128));\n        manager.take(currency, recipient, uint128(amount));\n    }\n\n    function _prankTakeFrom(bytes memory params) internal {\n        (Currency currency, address from, address recipient, uint256 amount) =\n            abi.decode(params, (Currency, address, address, uint256));\n        vm.prank(from);\n        manager.take(currency, recipient, amount);\n    }\n\n    function _sync(bytes memory params) internal {\n        Currency currency = Currency.wrap(abi.decode(params, (address)));\n        manager.sync(currency);\n    }\n\n    function _mint(bytes memory params) internal {\n        (address recipient, Currency currency, uint256 amount) = abi.decode(params, (address, Currency, uint256));\n        manager.mint(recipient, currency.toId(), amount);\n    }\n\n    function _clear(bytes memory params) internal {\n        (Currency currency, uint256 amount, bool measureGas, string memory gasSnapName) =\n            abi.decode(params, (Currency, uint256, bool, string));\n\n        manager.clear(currency, amount);\n        if (measureGas) vm.snapshotGasLastCall(gasSnapName);\n    }\n\n    function _assertBalanceEquals(bytes memory params) internal view {\n        (Currency currency, address user, uint256 expectedBalance) = abi.decode(params, (Currency, address, uint256));\n        assertEq(currency.balanceOf(user), expectedBalance, \"usertoken value incorrect\");\n    }\n\n    function _assertReservesEquals(bytes memory params) internal view {\n        uint256 expectedReserves = abi.decode(params, (uint256));\n        assertEq(manager.getSyncedReserves(), expectedReserves, \"reserves value incorrect\");\n    }\n\n    function _assertDeltaEquals(bytes memory params) internal view {\n        (Currency currency, address caller, int256 expectedDelta) = abi.decode(params, (Currency, address, int256));\n\n        assertEq(manager.currencyDelta(caller, currency), expectedDelta, \"delta value incorrect\");\n    }\n\n    function _assertNonzeroDeltaCountEquals(bytes memory params) internal view {\n        (uint256 expectedCount) = abi.decode(params, (uint256));\n        assertEq(manager.getNonzeroDeltaCount(), expectedCount, \"nonzero delta count incorrect\");\n    }\n\n    function _transferFrom(bytes memory params) internal {\n        (Currency currency, address from, address recipient, uint256 amount) =\n            abi.decode(params, (Currency, address, address, uint256));\n        MockERC20(Currency.unwrap(currency)).transferFrom(from, recipient, uint256(amount));\n    }\n\n    function _collectProtocolFees(bytes memory params) internal {\n        (address to, Currency currency, uint256 amount) = abi.decode(params, (address, Currency, uint256));\n        manager.collectProtocolFees(to, currency, amount);\n    }\n}\n"},"lib/v4-periphery/lib/v4-core/src/test/PoolClaimsTest.sol":{"content":"// SPDX-License-Identifier: UNLICENSED\npragma solidity ^0.8.24;\n\nimport {Currency} from \"../types/Currency.sol\";\nimport {BalanceDelta} from \"../types/BalanceDelta.sol\";\nimport {IPoolManager} from \"../interfaces/IPoolManager.sol\";\nimport {PoolTestBase} from \"./PoolTestBase.sol\";\nimport {SafeCast} from \"../libraries/SafeCast.sol\";\nimport {CurrencySettler} from \"../../test/utils/CurrencySettler.sol\";\n\ncontract PoolClaimsTest is PoolTestBase {\n    using CurrencySettler for Currency;\n    using SafeCast for uint256;\n\n    constructor(IPoolManager _manager) PoolTestBase(_manager) {}\n\n    struct CallbackData {\n        address sender;\n        address user;\n        Currency currency;\n        uint256 amount;\n        bool deposit;\n    }\n\n    /// @notice Convert ERC20 into a claimable 6909\n    function deposit(Currency currency, address user, uint256 amount) external payable {\n        manager.unlock(abi.encode(CallbackData(msg.sender, user, currency, amount, true)));\n    }\n\n    /// @notice Redeem claimable 6909 for ERC20\n    function withdraw(Currency currency, address user, uint256 amount) external payable {\n        manager.unlock(abi.encode(CallbackData(msg.sender, user, currency, amount, false)));\n    }\n\n    function unlockCallback(bytes calldata rawData) external returns (bytes memory) {\n        require(msg.sender == address(manager));\n\n        CallbackData memory data = abi.decode(rawData, (CallbackData));\n\n        if (data.deposit) {\n            data.currency.take(manager, data.user, data.amount, true); // mint 6909\n            data.currency.settle(manager, data.user, data.amount, false); // transfer ERC20\n        } else {\n            data.currency.settle(manager, data.user, data.amount, true); // burn 6909\n            data.currency.take(manager, data.user, data.amount, false); // claim ERC20\n        }\n\n        return abi.encode(0);\n    }\n}\n"},"lib/v4-periphery/lib/v4-core/src/test/PoolDonateTest.sol":{"content":"// SPDX-License-Identifier: UNLICENSED\npragma solidity ^0.8.24;\n\nimport {Currency, CurrencyLibrary} from \"../types/Currency.sol\";\nimport {IPoolManager} from \"../interfaces/IPoolManager.sol\";\nimport {PoolKey} from \"../types/PoolKey.sol\";\nimport {BalanceDelta} from \"../types/BalanceDelta.sol\";\nimport {PoolTestBase} from \"./PoolTestBase.sol\";\nimport {IHooks} from \"../interfaces/IHooks.sol\";\nimport {Hooks} from \"../libraries/Hooks.sol\";\nimport {CurrencySettler} from \"../../test/utils/CurrencySettler.sol\";\n\ncontract PoolDonateTest is PoolTestBase {\n    using CurrencySettler for Currency;\n    using Hooks for IHooks;\n\n    constructor(IPoolManager _manager) PoolTestBase(_manager) {}\n\n    struct CallbackData {\n        address sender;\n        PoolKey key;\n        uint256 amount0;\n        uint256 amount1;\n        bytes hookData;\n    }\n\n    function donate(PoolKey memory key, uint256 amount0, uint256 amount1, bytes memory hookData)\n        external\n        payable\n        returns (BalanceDelta delta)\n    {\n        delta = abi.decode(\n            manager.unlock(abi.encode(CallbackData(msg.sender, key, amount0, amount1, hookData))), (BalanceDelta)\n        );\n\n        uint256 ethBalance = address(this).balance;\n        if (ethBalance > 0) {\n            CurrencyLibrary.ADDRESS_ZERO.transfer(msg.sender, ethBalance);\n        }\n    }\n\n    function unlockCallback(bytes calldata rawData) external returns (bytes memory) {\n        require(msg.sender == address(manager));\n\n        CallbackData memory data = abi.decode(rawData, (CallbackData));\n\n        (,, int256 deltaBefore0) = _fetchBalances(data.key.currency0, data.sender, address(this));\n        (,, int256 deltaBefore1) = _fetchBalances(data.key.currency1, data.sender, address(this));\n\n        require(deltaBefore0 == 0, \"deltaBefore0 is not 0\");\n        require(deltaBefore1 == 0, \"deltaBefore1 is not 0\");\n\n        BalanceDelta delta = manager.donate(data.key, data.amount0, data.amount1, data.hookData);\n\n        (,, int256 deltaAfter0) = _fetchBalances(data.key.currency0, data.sender, address(this));\n        (,, int256 deltaAfter1) = _fetchBalances(data.key.currency1, data.sender, address(this));\n\n        require(deltaAfter0 == -int256(data.amount0), \"deltaAfter0 is not equal to -int256(data.amount0)\");\n        require(deltaAfter1 == -int256(data.amount1), \"deltaAfter1 is not equal to -int256(data.amount1)\");\n\n        if (deltaAfter0 < 0) data.key.currency0.settle(manager, data.sender, uint256(-deltaAfter0), false);\n        if (deltaAfter1 < 0) data.key.currency1.settle(manager, data.sender, uint256(-deltaAfter1), false);\n        if (deltaAfter0 > 0) data.key.currency0.take(manager, data.sender, uint256(deltaAfter0), false);\n        if (deltaAfter1 > 0) data.key.currency1.take(manager, data.sender, uint256(deltaAfter1), false);\n\n        return abi.encode(delta);\n    }\n}\n"},"lib/v4-periphery/lib/v4-core/src/test/PoolModifyLiquidityTest.sol":{"content":"// SPDX-License-Identifier: UNLICENSED\npragma solidity ^0.8.24;\n\nimport {CurrencyLibrary, Currency} from \"../types/Currency.sol\";\nimport {IPoolManager} from \"../interfaces/IPoolManager.sol\";\nimport {BalanceDelta} from \"../types/BalanceDelta.sol\";\nimport {PoolKey} from \"../types/PoolKey.sol\";\nimport {PoolTestBase} from \"./PoolTestBase.sol\";\nimport {IHooks} from \"../interfaces/IHooks.sol\";\nimport {Hooks} from \"../libraries/Hooks.sol\";\nimport {LPFeeLibrary} from \"../libraries/LPFeeLibrary.sol\";\nimport {CurrencySettler} from \"../../test/utils/CurrencySettler.sol\";\nimport {StateLibrary} from \"../libraries/StateLibrary.sol\";\n\ncontract PoolModifyLiquidityTest is PoolTestBase {\n    using CurrencySettler for Currency;\n    using Hooks for IHooks;\n    using LPFeeLibrary for uint24;\n    using StateLibrary for IPoolManager;\n\n    constructor(IPoolManager _manager) PoolTestBase(_manager) {}\n\n    struct CallbackData {\n        address sender;\n        PoolKey key;\n        IPoolManager.ModifyLiquidityParams params;\n        bytes hookData;\n        bool settleUsingBurn;\n        bool takeClaims;\n    }\n\n    function modifyLiquidity(\n        PoolKey memory key,\n        IPoolManager.ModifyLiquidityParams memory params,\n        bytes memory hookData\n    ) external payable returns (BalanceDelta delta) {\n        delta = modifyLiquidity(key, params, hookData, false, false);\n    }\n\n    function modifyLiquidity(\n        PoolKey memory key,\n        IPoolManager.ModifyLiquidityParams memory params,\n        bytes memory hookData,\n        bool settleUsingBurn,\n        bool takeClaims\n    ) public payable returns (BalanceDelta delta) {\n        delta = abi.decode(\n            manager.unlock(abi.encode(CallbackData(msg.sender, key, params, hookData, settleUsingBurn, takeClaims))),\n            (BalanceDelta)\n        );\n\n        uint256 ethBalance = address(this).balance;\n        if (ethBalance > 0) {\n            CurrencyLibrary.ADDRESS_ZERO.transfer(msg.sender, ethBalance);\n        }\n    }\n\n    function unlockCallback(bytes calldata rawData) external returns (bytes memory) {\n        require(msg.sender == address(manager));\n\n        CallbackData memory data = abi.decode(rawData, (CallbackData));\n\n        (uint128 liquidityBefore,,) = manager.getPositionInfo(\n            data.key.toId(), address(this), data.params.tickLower, data.params.tickUpper, data.params.salt\n        );\n\n        (BalanceDelta delta,) = manager.modifyLiquidity(data.key, data.params, data.hookData);\n\n        (uint128 liquidityAfter,,) = manager.getPositionInfo(\n            data.key.toId(), address(this), data.params.tickLower, data.params.tickUpper, data.params.salt\n        );\n\n        (,, int256 delta0) = _fetchBalances(data.key.currency0, data.sender, address(this));\n        (,, int256 delta1) = _fetchBalances(data.key.currency1, data.sender, address(this));\n\n        require(\n            int128(liquidityBefore) + data.params.liquidityDelta == int128(liquidityAfter), \"liquidity change incorrect\"\n        );\n\n        if (data.params.liquidityDelta < 0) {\n            assert(delta0 > 0 || delta1 > 0);\n            assert(!(delta0 < 0 || delta1 < 0));\n        } else if (data.params.liquidityDelta > 0) {\n            assert(delta0 < 0 || delta1 < 0);\n            assert(!(delta0 > 0 || delta1 > 0));\n        }\n\n        if (delta0 < 0) data.key.currency0.settle(manager, data.sender, uint256(-delta0), data.settleUsingBurn);\n        if (delta1 < 0) data.key.currency1.settle(manager, data.sender, uint256(-delta1), data.settleUsingBurn);\n        if (delta0 > 0) data.key.currency0.take(manager, data.sender, uint256(delta0), data.takeClaims);\n        if (delta1 > 0) data.key.currency1.take(manager, data.sender, uint256(delta1), data.takeClaims);\n\n        return abi.encode(delta);\n    }\n}\n"},"lib/v4-periphery/lib/v4-core/src/test/PoolModifyLiquidityTestNoChecks.sol":{"content":"// SPDX-License-Identifier: UNLICENSED\npragma solidity ^0.8.24;\n\nimport {CurrencyLibrary, Currency} from \"../types/Currency.sol\";\nimport {IPoolManager} from \"../interfaces/IPoolManager.sol\";\nimport {BalanceDelta} from \"../types/BalanceDelta.sol\";\nimport {PoolKey} from \"../types/PoolKey.sol\";\nimport {PoolTestBase} from \"./PoolTestBase.sol\";\nimport {IHooks} from \"../interfaces/IHooks.sol\";\nimport {Hooks} from \"../libraries/Hooks.sol\";\nimport {LPFeeLibrary} from \"../libraries/LPFeeLibrary.sol\";\nimport {CurrencySettler} from \"../../test/utils/CurrencySettler.sol\";\n\ncontract PoolModifyLiquidityTestNoChecks is PoolTestBase {\n    using CurrencySettler for Currency;\n    using Hooks for IHooks;\n    using LPFeeLibrary for uint24;\n\n    constructor(IPoolManager _manager) PoolTestBase(_manager) {}\n\n    struct CallbackData {\n        address sender;\n        PoolKey key;\n        IPoolManager.ModifyLiquidityParams params;\n        bytes hookData;\n        bool settleUsingBurn;\n        bool takeClaims;\n    }\n\n    function modifyLiquidity(\n        PoolKey memory key,\n        IPoolManager.ModifyLiquidityParams memory params,\n        bytes memory hookData\n    ) external payable returns (BalanceDelta delta) {\n        delta = modifyLiquidity(key, params, hookData, false, false);\n    }\n\n    function modifyLiquidity(\n        PoolKey memory key,\n        IPoolManager.ModifyLiquidityParams memory params,\n        bytes memory hookData,\n        bool settleUsingBurn,\n        bool takeClaims\n    ) public payable returns (BalanceDelta delta) {\n        delta = abi.decode(\n            manager.unlock(abi.encode(CallbackData(msg.sender, key, params, hookData, settleUsingBurn, takeClaims))),\n            (BalanceDelta)\n        );\n\n        uint256 ethBalance = address(this).balance;\n        if (ethBalance > 0) {\n            CurrencyLibrary.ADDRESS_ZERO.transfer(msg.sender, ethBalance);\n        }\n    }\n\n    function unlockCallback(bytes calldata rawData) external returns (bytes memory) {\n        require(msg.sender == address(manager));\n\n        CallbackData memory data = abi.decode(rawData, (CallbackData));\n\n        (BalanceDelta delta,) = manager.modifyLiquidity(data.key, data.params, data.hookData);\n\n        int256 delta0 = delta.amount0();\n        int256 delta1 = delta.amount1();\n\n        if (delta0 < 0) data.key.currency0.settle(manager, data.sender, uint256(-delta0), data.settleUsingBurn);\n        if (delta1 < 0) data.key.currency1.settle(manager, data.sender, uint256(-delta1), data.settleUsingBurn);\n        if (delta0 > 0) data.key.currency0.take(manager, data.sender, uint256(delta0), data.takeClaims);\n        if (delta1 > 0) data.key.currency1.take(manager, data.sender, uint256(delta1), data.takeClaims);\n\n        return abi.encode(delta);\n    }\n}\n"},"lib/v4-periphery/lib/v4-core/src/test/PoolNestedActionsTest.sol":{"content":"// SPDX-License-Identifier: UNLICENSED\npragma solidity ^0.8.20;\n\nimport {IPoolManager} from \"../interfaces/IPoolManager.sol\";\nimport {IUnlockCallback} from \"../interfaces/callback/IUnlockCallback.sol\";\nimport {PoolTestBase} from \"./PoolTestBase.sol\";\nimport {PoolKey} from \"../types/PoolKey.sol\";\nimport {Constants} from \"../../test/utils/Constants.sol\";\nimport {Test} from \"forge-std/Test.sol\";\nimport {BalanceDelta} from \"../types/BalanceDelta.sol\";\nimport {Currency} from \"../types/Currency.sol\";\nimport {PoolId} from \"../types/PoolId.sol\";\nimport {CurrencySettler} from \"../../test/utils/CurrencySettler.sol\";\nimport {StateLibrary} from \"../libraries/StateLibrary.sol\";\nimport {TransientStateLibrary} from \"../libraries/TransientStateLibrary.sol\";\n\nenum Action {\n    NESTED_SELF_UNLOCK,\n    NESTED_EXECUTOR_UNLOCK,\n    SWAP_AND_SETTLE,\n    DONATE_AND_SETTLE,\n    ADD_LIQUIDITY_AND_SETTLE,\n    REMOVE_LIQUIDITY_AND_SETTLE,\n    INITIALIZE\n}\n\ncontract PoolNestedActionsTest is Test, IUnlockCallback {\n    using StateLibrary for IPoolManager;\n    using TransientStateLibrary for IPoolManager;\n\n    IPoolManager manager;\n    NestedActionExecutor public executor;\n    address user;\n\n    constructor(IPoolManager _manager) {\n        manager = _manager;\n        user = msg.sender;\n        executor = new NestedActionExecutor(manager, user);\n    }\n\n    function unlock(bytes calldata data) external {\n        manager.unlock(data);\n    }\n\n    /// @notice Called by the pool manager on `msg.sender` when the manager is unlocked\n    function unlockCallback(bytes calldata data) external override returns (bytes memory) {\n        Action[] memory actions = abi.decode(data, (Action[]));\n        if (actions.length == 1 && actions[0] == Action.NESTED_SELF_UNLOCK) {\n            _nestedUnlock();\n        } else {\n            executor.execute(actions);\n        }\n        return \"\";\n    }\n\n    function _nestedUnlock() internal {\n        bool unlocked = manager.isUnlocked();\n        assertEq(unlocked, true);\n        vm.expectRevert(abi.encodeWithSelector(IPoolManager.AlreadyUnlocked.selector));\n        manager.unlock(\"\");\n        unlocked = manager.isUnlocked();\n        assertEq(unlocked, true);\n    }\n}\n\ncontract NestedActionExecutor is Test, PoolTestBase {\n    using StateLibrary for IPoolManager;\n    using TransientStateLibrary for IPoolManager;\n    using CurrencySettler for Currency;\n\n    PoolKey internal key;\n    address user;\n\n    error KeyNotSet();\n\n    IPoolManager.ModifyLiquidityParams internal ADD_LIQUIDITY_PARAMS =\n        IPoolManager.ModifyLiquidityParams({tickLower: -120, tickUpper: 120, liquidityDelta: 1e18, salt: 0});\n\n    IPoolManager.ModifyLiquidityParams internal REMOVE_LIQUIDITY_PARAMS =\n        IPoolManager.ModifyLiquidityParams({tickLower: -120, tickUpper: 120, liquidityDelta: -1e18, salt: 0});\n\n    IPoolManager.SwapParams internal SWAP_PARAMS =\n        IPoolManager.SwapParams({zeroForOne: true, amountSpecified: -100, sqrtPriceLimitX96: Constants.SQRT_PRICE_1_2});\n\n    uint256 internal DONATE_AMOUNT0 = 12345e6;\n    uint256 internal DONATE_AMOUNT1 = 98765e4;\n\n    constructor(IPoolManager _manager, address _user) PoolTestBase(_manager) {\n        user = _user;\n    }\n\n    function setKey(PoolKey memory _key) external {\n        key = _key;\n    }\n\n    function execute(Action[] memory actions) public {\n        if (Currency.unwrap(key.currency0) == address(0)) revert KeyNotSet();\n        for (uint256 i = 0; i < actions.length; i++) {\n            Action action = actions[i];\n            if (action == Action.NESTED_EXECUTOR_UNLOCK) _nestedUnlock();\n            else if (action == Action.SWAP_AND_SETTLE) _swap(msg.sender);\n            else if (action == Action.ADD_LIQUIDITY_AND_SETTLE) _addLiquidity(msg.sender);\n            else if (action == Action.REMOVE_LIQUIDITY_AND_SETTLE) _removeLiquidity(msg.sender);\n            else if (action == Action.DONATE_AND_SETTLE) _donate(msg.sender);\n            else if (action == Action.INITIALIZE) _initialize();\n        }\n    }\n\n    function _nestedUnlock() internal {\n        bool unlocked = manager.isUnlocked();\n        assertEq(unlocked, true);\n        vm.expectRevert(abi.encodeWithSelector(IPoolManager.AlreadyUnlocked.selector));\n        manager.unlock(\"\");\n        unlocked = manager.isUnlocked();\n        assertEq(unlocked, true);\n    }\n\n    function _swap(address caller) internal {\n        bool unlocked = manager.isUnlocked();\n        assertEq(unlocked, true);\n        (,, int256 deltaCallerBefore0) = _fetchBalances(key.currency0, user, caller);\n        (,, int256 deltaCallerBefore1) = _fetchBalances(key.currency1, user, caller);\n        (,, int256 deltaThisBefore0) = _fetchBalances(key.currency0, user, address(this));\n        (,, int256 deltaThisBefore1) = _fetchBalances(key.currency1, user, address(this));\n\n        BalanceDelta delta = manager.swap(key, SWAP_PARAMS, \"\");\n\n        (,, int256 deltaCallerAfter0) = _fetchBalances(key.currency0, user, caller);\n        (,, int256 deltaCallerAfter1) = _fetchBalances(key.currency1, user, caller);\n        (,, int256 deltaThisAfter0) = _fetchBalances(key.currency0, user, address(this));\n        (,, int256 deltaThisAfter1) = _fetchBalances(key.currency1, user, address(this));\n\n        assertEq(deltaCallerBefore0, deltaCallerAfter0, \"Caller delta 0\");\n        assertEq(deltaCallerBefore1, deltaCallerAfter1, \"Caller delta 1\");\n        assertEq(deltaThisBefore0 + SWAP_PARAMS.amountSpecified, deltaThisAfter0, \"Executor delta 0\");\n        assertEq(deltaThisBefore1 + 98, deltaThisAfter1, \"Executor delta 1\");\n        assertEq(delta.amount0(), deltaThisAfter0, \"Swap delta 0\");\n        assertEq(delta.amount1(), deltaThisAfter1, \"Swap delta 1\");\n\n        key.currency0.settle(manager, user, uint256(-deltaThisAfter0), false);\n        key.currency1.take(manager, user, uint256(deltaThisAfter1), false);\n    }\n\n    function _addLiquidity(address caller) internal {\n        bool unlocked = manager.isUnlocked();\n        assertEq(unlocked, true);\n        (,, int256 deltaCallerBefore0) = _fetchBalances(key.currency0, user, caller);\n        (,, int256 deltaCallerBefore1) = _fetchBalances(key.currency1, user, caller);\n        (,, int256 deltaThisBefore0) = _fetchBalances(key.currency0, user, address(this));\n        (,, int256 deltaThisBefore1) = _fetchBalances(key.currency1, user, address(this));\n\n        (BalanceDelta delta,) = manager.modifyLiquidity(key, ADD_LIQUIDITY_PARAMS, \"\");\n\n        (,, int256 deltaCallerAfter0) = _fetchBalances(key.currency0, user, caller);\n        (,, int256 deltaCallerAfter1) = _fetchBalances(key.currency1, user, caller);\n        (,, int256 deltaThisAfter0) = _fetchBalances(key.currency0, user, address(this));\n        (,, int256 deltaThisAfter1) = _fetchBalances(key.currency1, user, address(this));\n\n        assertEq(deltaCallerBefore0, deltaCallerAfter0, \"Caller delta 0\");\n        assertEq(deltaCallerBefore1, deltaCallerAfter1, \"Caller delta 1\");\n        assertEq(deltaThisBefore0 + delta.amount0(), deltaThisAfter0, \"Executor delta 0\");\n        assertEq(deltaThisBefore1 + delta.amount1(), deltaThisAfter1, \"Executor delta 1\");\n\n        key.currency0.settle(manager, user, uint256(-deltaThisAfter0), false);\n        key.currency1.settle(manager, user, uint256(-deltaThisAfter1), false);\n    }\n\n    // cannot remove non-existent liquidity - need to perform an add before this removal\n    function _removeLiquidity(address caller) internal {\n        bool unlocked = manager.isUnlocked();\n        assertEq(unlocked, true);\n        (,, int256 deltaCallerBefore0) = _fetchBalances(key.currency0, user, caller);\n        (,, int256 deltaCallerBefore1) = _fetchBalances(key.currency1, user, caller);\n        (,, int256 deltaThisBefore0) = _fetchBalances(key.currency0, user, address(this));\n        (,, int256 deltaThisBefore1) = _fetchBalances(key.currency1, user, address(this));\n\n        (BalanceDelta delta,) = manager.modifyLiquidity(key, REMOVE_LIQUIDITY_PARAMS, \"\");\n\n        (,, int256 deltaCallerAfter0) = _fetchBalances(key.currency0, user, caller);\n        (,, int256 deltaCallerAfter1) = _fetchBalances(key.currency1, user, caller);\n        (,, int256 deltaThisAfter0) = _fetchBalances(key.currency0, user, address(this));\n        (,, int256 deltaThisAfter1) = _fetchBalances(key.currency1, user, address(this));\n\n        assertEq(deltaCallerBefore0, deltaCallerAfter0, \"Caller delta 0\");\n        assertEq(deltaCallerBefore1, deltaCallerAfter1, \"Caller delta 1\");\n        assertEq(deltaThisBefore0 + delta.amount0(), deltaThisAfter0, \"Executor delta 0\");\n        assertEq(deltaThisBefore1 + delta.amount1(), deltaThisAfter1, \"Executor delta 1\");\n\n        key.currency0.take(manager, user, uint256(deltaThisAfter0), false);\n        key.currency1.take(manager, user, uint256(deltaThisAfter1), false);\n    }\n\n    function _donate(address caller) internal {\n        bool unlocked = manager.isUnlocked();\n        assertEq(unlocked, true);\n        (,, int256 deltaCallerBefore0) = _fetchBalances(key.currency0, user, caller);\n        (,, int256 deltaCallerBefore1) = _fetchBalances(key.currency1, user, caller);\n        (,, int256 deltaThisBefore0) = _fetchBalances(key.currency0, user, address(this));\n        (,, int256 deltaThisBefore1) = _fetchBalances(key.currency1, user, address(this));\n\n        BalanceDelta delta = manager.donate(key, DONATE_AMOUNT0, DONATE_AMOUNT1, \"\");\n\n        (,, int256 deltaCallerAfter0) = _fetchBalances(key.currency0, user, caller);\n        (,, int256 deltaCallerAfter1) = _fetchBalances(key.currency1, user, caller);\n        (,, int256 deltaThisAfter0) = _fetchBalances(key.currency0, user, address(this));\n        (,, int256 deltaThisAfter1) = _fetchBalances(key.currency1, user, address(this));\n\n        assertEq(deltaCallerBefore0, deltaCallerAfter0, \"Caller delta 0\");\n        assertEq(deltaCallerBefore1, deltaCallerAfter1, \"Caller delta 1\");\n        assertEq(deltaThisBefore0 - int256(DONATE_AMOUNT0), deltaThisAfter0, \"Executor delta 0\");\n        assertEq(deltaThisBefore1 - int256(DONATE_AMOUNT1), deltaThisAfter1, \"Executor delta 1\");\n        assertEq(-delta.amount0(), int256(DONATE_AMOUNT0), \"Donate delta 0\");\n        assertEq(-delta.amount1(), int256(DONATE_AMOUNT1), \"Donate delta 1\");\n\n        key.currency0.settle(manager, user, uint256(-deltaThisAfter0), false);\n        key.currency1.settle(manager, user, uint256(-deltaThisAfter1), false);\n    }\n\n    function _initialize() internal {\n        bool unlocked = manager.isUnlocked();\n        assertEq(unlocked, true);\n        key.tickSpacing = 50;\n        PoolId id = key.toId();\n        (uint256 price,,,) = manager.getSlot0(id);\n        assertEq(price, 0);\n        manager.initialize(key, Constants.SQRT_PRICE_1_2);\n        (price,,,) = manager.getSlot0(id);\n        assertEq(price, Constants.SQRT_PRICE_1_2);\n    }\n\n    // This will never actually be used - its just to allow us to use the PoolTestBase helper contact\n    function unlockCallback(bytes calldata) external pure override returns (bytes memory) {\n        return \"\";\n    }\n}\n"},"lib/v4-periphery/lib/v4-core/src/test/PoolSwapTest.sol":{"content":"// SPDX-License-Identifier: UNLICENSED\npragma solidity ^0.8.24;\n\nimport {CurrencyLibrary, Currency} from \"../types/Currency.sol\";\nimport {IPoolManager} from \"../interfaces/IPoolManager.sol\";\nimport {BalanceDelta} from \"../types/BalanceDelta.sol\";\nimport {PoolKey} from \"../types/PoolKey.sol\";\nimport {IHooks} from \"../interfaces/IHooks.sol\";\nimport {Hooks} from \"../libraries/Hooks.sol\";\nimport {PoolTestBase} from \"./PoolTestBase.sol\";\nimport {CurrencySettler} from \"../../test/utils/CurrencySettler.sol\";\n\ncontract PoolSwapTest is PoolTestBase {\n    using CurrencySettler for Currency;\n    using Hooks for IHooks;\n\n    constructor(IPoolManager _manager) PoolTestBase(_manager) {}\n\n    error NoSwapOccurred();\n\n    struct CallbackData {\n        address sender;\n        TestSettings testSettings;\n        PoolKey key;\n        IPoolManager.SwapParams params;\n        bytes hookData;\n    }\n\n    struct TestSettings {\n        bool takeClaims;\n        bool settleUsingBurn;\n    }\n\n    function swap(\n        PoolKey memory key,\n        IPoolManager.SwapParams memory params,\n        TestSettings memory testSettings,\n        bytes memory hookData\n    ) external payable returns (BalanceDelta delta) {\n        delta = abi.decode(\n            manager.unlock(abi.encode(CallbackData(msg.sender, testSettings, key, params, hookData))), (BalanceDelta)\n        );\n\n        uint256 ethBalance = address(this).balance;\n        if (ethBalance > 0) CurrencyLibrary.ADDRESS_ZERO.transfer(msg.sender, ethBalance);\n    }\n\n    function unlockCallback(bytes calldata rawData) external returns (bytes memory) {\n        require(msg.sender == address(manager));\n\n        CallbackData memory data = abi.decode(rawData, (CallbackData));\n\n        (,, int256 deltaBefore0) = _fetchBalances(data.key.currency0, data.sender, address(this));\n        (,, int256 deltaBefore1) = _fetchBalances(data.key.currency1, data.sender, address(this));\n\n        require(deltaBefore0 == 0, \"deltaBefore0 is not equal to 0\");\n        require(deltaBefore1 == 0, \"deltaBefore1 is not equal to 0\");\n\n        BalanceDelta delta = manager.swap(data.key, data.params, data.hookData);\n\n        (,, int256 deltaAfter0) = _fetchBalances(data.key.currency0, data.sender, address(this));\n        (,, int256 deltaAfter1) = _fetchBalances(data.key.currency1, data.sender, address(this));\n\n        if (data.params.zeroForOne) {\n            if (data.params.amountSpecified < 0) {\n                // exact input, 0 for 1\n                require(\n                    deltaAfter0 >= data.params.amountSpecified,\n                    \"deltaAfter0 is not greater than or equal to data.params.amountSpecified\"\n                );\n                require(delta.amount0() == deltaAfter0, \"delta.amount0() is not equal to deltaAfter0\");\n                require(deltaAfter1 >= 0, \"deltaAfter1 is not greater than or equal to 0\");\n            } else {\n                // exact output, 0 for 1\n                require(deltaAfter0 <= 0, \"deltaAfter0 is not less than or equal to zero\");\n                require(delta.amount1() == deltaAfter1, \"delta.amount1() is not equal to deltaAfter1\");\n                require(\n                    deltaAfter1 <= data.params.amountSpecified,\n                    \"deltaAfter1 is not less than or equal to data.params.amountSpecified\"\n                );\n            }\n        } else {\n            if (data.params.amountSpecified < 0) {\n                // exact input, 1 for 0\n                require(\n                    deltaAfter1 >= data.params.amountSpecified,\n                    \"deltaAfter1 is not greater than or equal to data.params.amountSpecified\"\n                );\n                require(delta.amount1() == deltaAfter1, \"delta.amount1() is not equal to deltaAfter1\");\n                require(deltaAfter0 >= 0, \"deltaAfter0 is not greater than or equal to 0\");\n            } else {\n                // exact output, 1 for 0\n                require(deltaAfter1 <= 0, \"deltaAfter1 is not less than or equal to 0\");\n                require(delta.amount0() == deltaAfter0, \"delta.amount0() is not equal to deltaAfter0\");\n                require(\n                    deltaAfter0 <= data.params.amountSpecified,\n                    \"deltaAfter0 is not less than or equal to data.params.amountSpecified\"\n                );\n            }\n        }\n\n        if (deltaAfter0 < 0) {\n            data.key.currency0.settle(manager, data.sender, uint256(-deltaAfter0), data.testSettings.settleUsingBurn);\n        }\n        if (deltaAfter1 < 0) {\n            data.key.currency1.settle(manager, data.sender, uint256(-deltaAfter1), data.testSettings.settleUsingBurn);\n        }\n        if (deltaAfter0 > 0) {\n            data.key.currency0.take(manager, data.sender, uint256(deltaAfter0), data.testSettings.takeClaims);\n        }\n        if (deltaAfter1 > 0) {\n            data.key.currency1.take(manager, data.sender, uint256(deltaAfter1), data.testSettings.takeClaims);\n        }\n\n        return abi.encode(delta);\n    }\n}\n"},"lib/v4-periphery/lib/v4-core/src/test/PoolTakeTest.sol":{"content":"// SPDX-License-Identifier: UNLICENSED\npragma solidity ^0.8.24;\n\nimport {Currency} from \"../types/Currency.sol\";\nimport {IPoolManager} from \"../interfaces/IPoolManager.sol\";\nimport {PoolKey} from \"../types/PoolKey.sol\";\nimport {PoolTestBase} from \"./PoolTestBase.sol\";\nimport {SafeCast} from \"../libraries/SafeCast.sol\";\nimport {CurrencySettler} from \"../../test/utils/CurrencySettler.sol\";\n\ncontract PoolTakeTest is PoolTestBase {\n    using CurrencySettler for Currency;\n    using SafeCast for uint256;\n\n    constructor(IPoolManager _manager) PoolTestBase(_manager) {}\n\n    struct CallbackData {\n        address sender;\n        PoolKey key;\n        uint256 amount0;\n        uint256 amount1;\n    }\n\n    function take(PoolKey memory key, uint256 amount0, uint256 amount1) external payable {\n        manager.unlock(abi.encode(CallbackData(msg.sender, key, amount0, amount1)));\n    }\n\n    function unlockCallback(bytes calldata rawData) external returns (bytes memory) {\n        require(msg.sender == address(manager));\n\n        CallbackData memory data = abi.decode(rawData, (CallbackData));\n\n        if (data.amount0 > 0) _testTake(data.key.currency0, data.sender, data.amount0);\n        if (data.amount1 > 0) _testTake(data.key.currency1, data.sender, data.amount1);\n\n        return abi.encode(0);\n    }\n\n    function _testTake(Currency currency, address sender, uint256 amount) internal {\n        (uint256 userBalBefore, uint256 pmBalBefore, int256 deltaBefore) =\n            _fetchBalances(currency, sender, address(this));\n        require(deltaBefore == 0, \"deltaBefore is not equal to 0\");\n\n        currency.take(manager, sender, amount, false);\n\n        (uint256 userBalAfter, uint256 pmBalAfter, int256 deltaAfter) = _fetchBalances(currency, sender, address(this));\n\n        require(deltaAfter == -amount.toInt128(), \"deltaAfter is not equal to -amount.toInt128()\");\n\n        require(\n            userBalAfter - userBalBefore == amount,\n            \"the difference between userBalAfter and userBalBefore is not equal to amount\"\n        );\n        require(\n            pmBalBefore - pmBalAfter == amount,\n            \"the difference between pmBalBefore and pmBalAfter is not equal to amount\"\n        );\n\n        currency.settle(manager, sender, amount, false);\n    }\n}\n"},"lib/v4-periphery/lib/v4-core/src/test/PoolTestBase.sol":{"content":"// SPDX-License-Identifier: UNLICENSED\npragma solidity ^0.8.24;\n\nimport {Currency} from \"../types/Currency.sol\";\n\nimport {IUnlockCallback} from \"../interfaces/callback/IUnlockCallback.sol\";\nimport {IPoolManager} from \"../interfaces/IPoolManager.sol\";\n\nimport {StateLibrary} from \"../libraries/StateLibrary.sol\";\nimport {TransientStateLibrary} from \"../libraries/TransientStateLibrary.sol\";\n\nabstract contract PoolTestBase is IUnlockCallback {\n    using StateLibrary for IPoolManager;\n    using TransientStateLibrary for IPoolManager;\n\n    IPoolManager public immutable manager;\n\n    constructor(IPoolManager _manager) {\n        manager = _manager;\n    }\n\n    function _fetchBalances(Currency currency, address user, address deltaHolder)\n        internal\n        view\n        returns (uint256 userBalance, uint256 poolBalance, int256 delta)\n    {\n        userBalance = currency.balanceOf(user);\n        poolBalance = currency.balanceOf(address(manager));\n        delta = manager.currencyDelta(deltaHolder, currency);\n    }\n}\n"},"lib/v4-periphery/lib/v4-core/src/test/SwapRouterNoChecks.sol":{"content":"// SPDX-License-Identifier: UNLICENSED\npragma solidity ^0.8.24;\n\nimport {Currency} from \"../types/Currency.sol\";\nimport {IPoolManager} from \"../interfaces/IPoolManager.sol\";\nimport {BalanceDelta} from \"../types/BalanceDelta.sol\";\nimport {PoolKey} from \"../types/PoolKey.sol\";\nimport {IHooks} from \"../interfaces/IHooks.sol\";\nimport {Hooks} from \"../libraries/Hooks.sol\";\nimport {PoolTestBase} from \"./PoolTestBase.sol\";\nimport {CurrencySettler} from \"../../test/utils/CurrencySettler.sol\";\n\ncontract SwapRouterNoChecks is PoolTestBase {\n    using CurrencySettler for Currency;\n    using Hooks for IHooks;\n\n    constructor(IPoolManager _manager) PoolTestBase(_manager) {}\n\n    error NoSwapOccurred();\n\n    struct CallbackData {\n        address sender;\n        PoolKey key;\n        IPoolManager.SwapParams params;\n    }\n\n    function swap(PoolKey memory key, IPoolManager.SwapParams memory params) external payable {\n        manager.unlock(abi.encode(CallbackData(msg.sender, key, params)));\n    }\n\n    function unlockCallback(bytes calldata rawData) external returns (bytes memory) {\n        require(msg.sender == address(manager));\n\n        CallbackData memory data = abi.decode(rawData, (CallbackData));\n\n        BalanceDelta delta = manager.swap(data.key, data.params, new bytes(0));\n\n        if (data.params.zeroForOne) {\n            data.key.currency0.settle(manager, data.sender, uint256(int256(-delta.amount0())), false);\n            data.key.currency1.take(manager, data.sender, uint256(int256(delta.amount1())), false);\n        } else {\n            data.key.currency1.settle(manager, data.sender, uint256(int256(-delta.amount1())), false);\n            data.key.currency0.take(manager, data.sender, uint256(int256(delta.amount0())), false);\n        }\n\n        return \"\";\n    }\n}\n"},"lib/v4-periphery/lib/v4-core/src/types/BalanceDelta.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport {SafeCast} from \"../libraries/SafeCast.sol\";\n\n/// @dev Two `int128` values packed into a single `int256` where the upper 128 bits represent the amount0\n/// and the lower 128 bits represent the amount1.\ntype BalanceDelta is int256;\n\nusing {add as +, sub as -, eq as ==, neq as !=} for BalanceDelta global;\nusing BalanceDeltaLibrary for BalanceDelta global;\nusing SafeCast for int256;\n\nfunction toBalanceDelta(int128 _amount0, int128 _amount1) pure returns (BalanceDelta balanceDelta) {\n    assembly (\"memory-safe\") {\n        balanceDelta := or(shl(128, _amount0), and(sub(shl(128, 1), 1), _amount1))\n    }\n}\n\nfunction add(BalanceDelta a, BalanceDelta b) pure returns (BalanceDelta) {\n    int256 res0;\n    int256 res1;\n    assembly (\"memory-safe\") {\n        let a0 := sar(128, a)\n        let a1 := signextend(15, a)\n        let b0 := sar(128, b)\n        let b1 := signextend(15, b)\n        res0 := add(a0, b0)\n        res1 := add(a1, b1)\n    }\n    return toBalanceDelta(res0.toInt128(), res1.toInt128());\n}\n\nfunction sub(BalanceDelta a, BalanceDelta b) pure returns (BalanceDelta) {\n    int256 res0;\n    int256 res1;\n    assembly (\"memory-safe\") {\n        let a0 := sar(128, a)\n        let a1 := signextend(15, a)\n        let b0 := sar(128, b)\n        let b1 := signextend(15, b)\n        res0 := sub(a0, b0)\n        res1 := sub(a1, b1)\n    }\n    return toBalanceDelta(res0.toInt128(), res1.toInt128());\n}\n\nfunction eq(BalanceDelta a, BalanceDelta b) pure returns (bool) {\n    return BalanceDelta.unwrap(a) == BalanceDelta.unwrap(b);\n}\n\nfunction neq(BalanceDelta a, BalanceDelta b) pure returns (bool) {\n    return BalanceDelta.unwrap(a) != BalanceDelta.unwrap(b);\n}\n\n/// @notice Library for getting the amount0 and amount1 deltas from the BalanceDelta type\nlibrary BalanceDeltaLibrary {\n    /// @notice A BalanceDelta of 0\n    BalanceDelta public constant ZERO_DELTA = BalanceDelta.wrap(0);\n\n    function amount0(BalanceDelta balanceDelta) internal pure returns (int128 _amount0) {\n        assembly (\"memory-safe\") {\n            _amount0 := sar(128, balanceDelta)\n        }\n    }\n\n    function amount1(BalanceDelta balanceDelta) internal pure returns (int128 _amount1) {\n        assembly (\"memory-safe\") {\n            _amount1 := signextend(15, balanceDelta)\n        }\n    }\n}\n"},"lib/v4-periphery/lib/v4-core/src/types/BeforeSwapDelta.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\n// Return type of the beforeSwap hook.\n// Upper 128 bits is the delta in specified tokens. Lower 128 bits is delta in unspecified tokens (to match the afterSwap hook)\ntype BeforeSwapDelta is int256;\n\n// Creates a BeforeSwapDelta from specified and unspecified\nfunction toBeforeSwapDelta(int128 deltaSpecified, int128 deltaUnspecified)\n    pure\n    returns (BeforeSwapDelta beforeSwapDelta)\n{\n    assembly (\"memory-safe\") {\n        beforeSwapDelta := or(shl(128, deltaSpecified), and(sub(shl(128, 1), 1), deltaUnspecified))\n    }\n}\n\n/// @notice Library for getting the specified and unspecified deltas from the BeforeSwapDelta type\nlibrary BeforeSwapDeltaLibrary {\n    /// @notice A BeforeSwapDelta of 0\n    BeforeSwapDelta public constant ZERO_DELTA = BeforeSwapDelta.wrap(0);\n\n    /// extracts int128 from the upper 128 bits of the BeforeSwapDelta\n    /// returned by beforeSwap\n    function getSpecifiedDelta(BeforeSwapDelta delta) internal pure returns (int128 deltaSpecified) {\n        assembly (\"memory-safe\") {\n            deltaSpecified := sar(128, delta)\n        }\n    }\n\n    /// extracts int128 from the lower 128 bits of the BeforeSwapDelta\n    /// returned by beforeSwap and afterSwap\n    function getUnspecifiedDelta(BeforeSwapDelta delta) internal pure returns (int128 deltaUnspecified) {\n        assembly (\"memory-safe\") {\n            deltaUnspecified := signextend(15, delta)\n        }\n    }\n}\n"},"lib/v4-periphery/lib/v4-core/src/types/Currency.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport {IERC20Minimal} from \"../interfaces/external/IERC20Minimal.sol\";\nimport {CustomRevert} from \"../libraries/CustomRevert.sol\";\n\ntype Currency is address;\n\nusing {greaterThan as >, lessThan as <, greaterThanOrEqualTo as >=, equals as ==} for Currency global;\nusing CurrencyLibrary for Currency global;\n\nfunction equals(Currency currency, Currency other) pure returns (bool) {\n    return Currency.unwrap(currency) == Currency.unwrap(other);\n}\n\nfunction greaterThan(Currency currency, Currency other) pure returns (bool) {\n    return Currency.unwrap(currency) > Currency.unwrap(other);\n}\n\nfunction lessThan(Currency currency, Currency other) pure returns (bool) {\n    return Currency.unwrap(currency) < Currency.unwrap(other);\n}\n\nfunction greaterThanOrEqualTo(Currency currency, Currency other) pure returns (bool) {\n    return Currency.unwrap(currency) >= Currency.unwrap(other);\n}\n\n/// @title CurrencyLibrary\n/// @dev This library allows for transferring and holding native tokens and ERC20 tokens\nlibrary CurrencyLibrary {\n    /// @notice Additional context for ERC-7751 wrapped error when a native transfer fails\n    error NativeTransferFailed();\n\n    /// @notice Additional context for ERC-7751 wrapped error when an ERC20 transfer fails\n    error ERC20TransferFailed();\n\n    /// @notice A constant to represent the native currency\n    Currency public constant ADDRESS_ZERO = Currency.wrap(address(0));\n\n    function transfer(Currency currency, address to, uint256 amount) internal {\n        // altered from https://github.com/transmissions11/solmate/blob/44a9963d4c78111f77caa0e65d677b8b46d6f2e6/src/utils/SafeTransferLib.sol\n        // modified custom error selectors\n\n        bool success;\n        if (currency.isAddressZero()) {\n            assembly (\"memory-safe\") {\n                // Transfer the ETH and revert if it fails.\n                success := call(gas(), to, amount, 0, 0, 0, 0)\n            }\n            // revert with NativeTransferFailed, containing the bubbled up error as an argument\n            if (!success) {\n                CustomRevert.bubbleUpAndRevertWith(to, bytes4(0), NativeTransferFailed.selector);\n            }\n        } else {\n            assembly (\"memory-safe\") {\n                // Get a pointer to some free memory.\n                let fmp := mload(0x40)\n\n                // Write the abi-encoded calldata into memory, beginning with the function selector.\n                mstore(fmp, 0xa9059cbb00000000000000000000000000000000000000000000000000000000)\n                mstore(add(fmp, 4), and(to, 0xffffffffffffffffffffffffffffffffffffffff)) // Append and mask the \"to\" argument.\n                mstore(add(fmp, 36), amount) // Append the \"amount\" argument. Masking not required as it's a full 32 byte type.\n\n                success :=\n                    and(\n                        // Set success to whether the call reverted, if not we check it either\n                        // returned exactly 1 (can't just be non-zero data), or had no return data.\n                        or(and(eq(mload(0), 1), gt(returndatasize(), 31)), iszero(returndatasize())),\n                        // We use 68 because the length of our calldata totals up like so: 4 + 32 * 2.\n                        // We use 0 and 32 to copy up to 32 bytes of return data into the scratch space.\n                        // Counterintuitively, this call must be positioned second to the or() call in the\n                        // surrounding and() call or else returndatasize() will be zero during the computation.\n                        call(gas(), currency, 0, fmp, 68, 0, 32)\n                    )\n\n                // Now clean the memory we used\n                mstore(fmp, 0) // 4 byte `selector` and 28 bytes of `to` were stored here\n                mstore(add(fmp, 0x20), 0) // 4 bytes of `to` and 28 bytes of `amount` were stored here\n                mstore(add(fmp, 0x40), 0) // 4 bytes of `amount` were stored here\n            }\n            // revert with ERC20TransferFailed, containing the bubbled up error as an argument\n            if (!success) {\n                CustomRevert.bubbleUpAndRevertWith(\n                    Currency.unwrap(currency), IERC20Minimal.transfer.selector, ERC20TransferFailed.selector\n                );\n            }\n        }\n    }\n\n    function balanceOfSelf(Currency currency) internal view returns (uint256) {\n        if (currency.isAddressZero()) {\n            return address(this).balance;\n        } else {\n            return IERC20Minimal(Currency.unwrap(currency)).balanceOf(address(this));\n        }\n    }\n\n    function balanceOf(Currency currency, address owner) internal view returns (uint256) {\n        if (currency.isAddressZero()) {\n            return owner.balance;\n        } else {\n            return IERC20Minimal(Currency.unwrap(currency)).balanceOf(owner);\n        }\n    }\n\n    function isAddressZero(Currency currency) internal pure returns (bool) {\n        return Currency.unwrap(currency) == Currency.unwrap(ADDRESS_ZERO);\n    }\n\n    function toId(Currency currency) internal pure returns (uint256) {\n        return uint160(Currency.unwrap(currency));\n    }\n\n    // If the upper 12 bytes are non-zero, they will be zero-ed out\n    // Therefore, fromId() and toId() are not inverses of each other\n    function fromId(uint256 id) internal pure returns (Currency) {\n        return Currency.wrap(address(uint160(id)));\n    }\n}\n"},"lib/v4-periphery/lib/v4-core/src/types/PoolId.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport {PoolKey} from \"./PoolKey.sol\";\n\ntype PoolId is bytes32;\n\n/// @notice Library for computing the ID of a pool\nlibrary PoolIdLibrary {\n    /// @notice Returns value equal to keccak256(abi.encode(poolKey))\n    function toId(PoolKey memory poolKey) internal pure returns (PoolId poolId) {\n        assembly (\"memory-safe\") {\n            // 0xa0 represents the total size of the poolKey struct (5 slots of 32 bytes)\n            poolId := keccak256(poolKey, 0xa0)\n        }\n    }\n}\n"},"lib/v4-periphery/lib/v4-core/src/types/PoolKey.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport {Currency} from \"./Currency.sol\";\nimport {IHooks} from \"../interfaces/IHooks.sol\";\nimport {PoolIdLibrary} from \"./PoolId.sol\";\n\nusing PoolIdLibrary for PoolKey global;\n\n/// @notice Returns the key for identifying a pool\nstruct PoolKey {\n    /// @notice The lower currency of the pool, sorted numerically\n    Currency currency0;\n    /// @notice The higher currency of the pool, sorted numerically\n    Currency currency1;\n    /// @notice The pool LP fee, capped at 1_000_000. If the highest bit is 1, the pool has a dynamic fee and must be exactly equal to 0x800000\n    uint24 fee;\n    /// @notice Ticks that involve positions must be a multiple of tick spacing\n    int24 tickSpacing;\n    /// @notice The hooks of the pool\n    IHooks hooks;\n}\n"},"lib/v4-periphery/lib/v4-core/src/types/Slot0.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\n/**\n * @dev Slot0 is a packed version of solidity structure.\n * Using the packaged version saves gas by not storing the structure fields in memory slots.\n *\n * Layout:\n * 24 bits empty | 24 bits lpFee | 12 bits protocolFee 1->0 | 12 bits protocolFee 0->1 | 24 bits tick | 160 bits sqrtPriceX96\n *\n * Fields in the direction from the least significant bit:\n *\n * The current price\n * uint160 sqrtPriceX96;\n *\n * The current tick\n * int24 tick;\n *\n * Protocol fee, expressed in hundredths of a bip, upper 12 bits are for 1->0, and the lower 12 are for 0->1\n * the maximum is 1000 - meaning the maximum protocol fee is 0.1%\n * the protocolFee is taken from the input first, then the lpFee is taken from the remaining input\n * uint24 protocolFee;\n *\n * The current LP fee of the pool. If the pool is dynamic, this does not include the dynamic fee flag.\n * uint24 lpFee;\n */\ntype Slot0 is bytes32;\n\nusing Slot0Library for Slot0 global;\n\n/// @notice Library for getting and setting values in the Slot0 type\nlibrary Slot0Library {\n    uint160 internal constant MASK_160_BITS = 0x00FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF;\n    uint24 internal constant MASK_24_BITS = 0xFFFFFF;\n\n    uint8 internal constant TICK_OFFSET = 160;\n    uint8 internal constant PROTOCOL_FEE_OFFSET = 184;\n    uint8 internal constant LP_FEE_OFFSET = 208;\n\n    // #### GETTERS ####\n    function sqrtPriceX96(Slot0 _packed) internal pure returns (uint160 _sqrtPriceX96) {\n        assembly (\"memory-safe\") {\n            _sqrtPriceX96 := and(MASK_160_BITS, _packed)\n        }\n    }\n\n    function tick(Slot0 _packed) internal pure returns (int24 _tick) {\n        assembly (\"memory-safe\") {\n            _tick := signextend(2, shr(TICK_OFFSET, _packed))\n        }\n    }\n\n    function protocolFee(Slot0 _packed) internal pure returns (uint24 _protocolFee) {\n        assembly (\"memory-safe\") {\n            _protocolFee := and(MASK_24_BITS, shr(PROTOCOL_FEE_OFFSET, _packed))\n        }\n    }\n\n    function lpFee(Slot0 _packed) internal pure returns (uint24 _lpFee) {\n        assembly (\"memory-safe\") {\n            _lpFee := and(MASK_24_BITS, shr(LP_FEE_OFFSET, _packed))\n        }\n    }\n\n    // #### SETTERS ####\n    function setSqrtPriceX96(Slot0 _packed, uint160 _sqrtPriceX96) internal pure returns (Slot0 _result) {\n        assembly (\"memory-safe\") {\n            _result := or(and(not(MASK_160_BITS), _packed), and(MASK_160_BITS, _sqrtPriceX96))\n        }\n    }\n\n    function setTick(Slot0 _packed, int24 _tick) internal pure returns (Slot0 _result) {\n        assembly (\"memory-safe\") {\n            _result := or(and(not(shl(TICK_OFFSET, MASK_24_BITS)), _packed), shl(TICK_OFFSET, and(MASK_24_BITS, _tick)))\n        }\n    }\n\n    function setProtocolFee(Slot0 _packed, uint24 _protocolFee) internal pure returns (Slot0 _result) {\n        assembly (\"memory-safe\") {\n            _result :=\n                or(\n                    and(not(shl(PROTOCOL_FEE_OFFSET, MASK_24_BITS)), _packed),\n                    shl(PROTOCOL_FEE_OFFSET, and(MASK_24_BITS, _protocolFee))\n                )\n        }\n    }\n\n    function setLpFee(Slot0 _packed, uint24 _lpFee) internal pure returns (Slot0 _result) {\n        assembly (\"memory-safe\") {\n            _result :=\n                or(and(not(shl(LP_FEE_OFFSET, MASK_24_BITS)), _packed), shl(LP_FEE_OFFSET, and(MASK_24_BITS, _lpFee)))\n        }\n    }\n}\n"},"lib/v4-periphery/lib/v4-core/test/utils/Constants.sol":{"content":"// SPDX-License-Identifier: UNLICENSED\npragma solidity ^0.8.20;\n\nlibrary Constants {\n    /// @dev All sqrtPrice calculations are calculated as\n    /// sqrtPriceX96 = floor(sqrt(A / B) * 2 ** 96) where A and B are the currency reserves\n    uint160 public constant SQRT_PRICE_1_1 = 79228162514264337593543950336;\n    uint160 public constant SQRT_PRICE_1_2 = 56022770974786139918731938227;\n    uint160 public constant SQRT_PRICE_1_4 = 39614081257132168796771975168;\n    uint160 public constant SQRT_PRICE_2_1 = 112045541949572279837463876454;\n    uint160 public constant SQRT_PRICE_4_1 = 158456325028528675187087900672;\n    uint160 public constant SQRT_PRICE_121_100 = 87150978765690771352898345369;\n    uint160 public constant SQRT_PRICE_99_100 = 78831026366734652303669917531;\n    uint160 public constant SQRT_PRICE_99_1000 = 24928559360766947368818086097;\n    uint160 public constant SQRT_PRICE_101_100 = 79623317895830914510639640423;\n    uint160 public constant SQRT_PRICE_1000_100 = 250541448375047931186413801569;\n    uint160 public constant SQRT_PRICE_1010_100 = 251791039410471229173201122529;\n    uint160 public constant SQRT_PRICE_10000_100 = 792281625142643375935439503360;\n\n    uint256 constant MAX_UINT256 = type(uint256).max;\n    uint128 constant MAX_UINT128 = type(uint128).max;\n    uint160 constant MAX_UINT160 = type(uint160).max;\n\n    address constant ADDRESS_ZERO = address(0);\n\n    /// 0011 1111 1111 1111\n    address payable constant ALL_HOOKS = payable(0x0000000000000000000000000000000000003fFF);\n\n    uint256 constant TICKS_OFFSET = 4;\n\n    uint24 constant FEE_LOW = 500;\n    uint24 constant FEE_MEDIUM = 3000;\n    uint24 constant FEE_HIGH = 10000;\n\n    bytes constant ZERO_BYTES = new bytes(0);\n}\n"},"lib/v4-periphery/lib/v4-core/test/utils/CurrencySettler.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity ^0.8.20;\n\nimport {Currency} from \"../../src/types/Currency.sol\";\nimport {IERC20Minimal} from \"../../src/interfaces/external/IERC20Minimal.sol\";\nimport {IPoolManager} from \"../../src/interfaces/IPoolManager.sol\";\n\n/// @notice Library used to interact with PoolManager.sol to settle any open deltas.\n/// To settle a positive delta (a credit to the user), a user may take or mint.\n/// To settle a negative delta (a debt on the user), a user make transfer or burn to pay off a debt.\n/// @dev Note that sync() is called before any erc-20 transfer in `settle`.\nlibrary CurrencySettler {\n    /// @notice Settle (pay) a currency to the PoolManager\n    /// @param currency Currency to settle\n    /// @param manager IPoolManager to settle to\n    /// @param payer Address of the payer, the token sender\n    /// @param amount Amount to send\n    /// @param burn If true, burn the ERC-6909 token, otherwise ERC20-transfer to the PoolManager\n    function settle(Currency currency, IPoolManager manager, address payer, uint256 amount, bool burn) internal {\n        // for native currencies or burns, calling sync is not required\n        // short circuit for ERC-6909 burns to support ERC-6909-wrapped native tokens\n        if (burn) {\n            manager.burn(payer, currency.toId(), amount);\n        } else if (currency.isAddressZero()) {\n            manager.settle{value: amount}();\n        } else {\n            manager.sync(currency);\n            if (payer != address(this)) {\n                IERC20Minimal(Currency.unwrap(currency)).transferFrom(payer, address(manager), amount);\n            } else {\n                IERC20Minimal(Currency.unwrap(currency)).transfer(address(manager), amount);\n            }\n            manager.settle();\n        }\n    }\n\n    /// @notice Take (receive) a currency from the PoolManager\n    /// @param currency Currency to take\n    /// @param manager IPoolManager to take from\n    /// @param recipient Address of the recipient, the token receiver\n    /// @param amount Amount to receive\n    /// @param claims If true, mint the ERC-6909 token, otherwise ERC20-transfer from the PoolManager to recipient\n    function take(Currency currency, IPoolManager manager, address recipient, uint256 amount, bool claims) internal {\n        claims ? manager.mint(recipient, currency.toId(), amount) : manager.take(currency, recipient, amount);\n    }\n}\n"},"lib/v4-periphery/lib/v4-core/test/utils/Deployers.sol":{"content":"// SPDX-License-Identifier: UNLICENSED\npragma solidity ^0.8.20;\n\nimport \"forge-std/Test.sol\";\nimport {MockERC20} from \"solmate/src/test/utils/mocks/MockERC20.sol\";\nimport {Hooks} from \"../../src/libraries/Hooks.sol\";\nimport {Currency, CurrencyLibrary} from \"../../src/types/Currency.sol\";\nimport {IHooks} from \"../../src/interfaces/IHooks.sol\";\nimport {IPoolManager} from \"../../src/interfaces/IPoolManager.sol\";\nimport {PoolManager} from \"../../src/PoolManager.sol\";\nimport {PoolId} from \"../../src/types/PoolId.sol\";\nimport {LPFeeLibrary} from \"../../src/libraries/LPFeeLibrary.sol\";\nimport {PoolKey} from \"../../src/types/PoolKey.sol\";\nimport {BalanceDelta} from \"../../src/types/BalanceDelta.sol\";\nimport {TickMath} from \"../../src/libraries/TickMath.sol\";\nimport {Constants} from \"../utils/Constants.sol\";\nimport {SortTokens} from \"./SortTokens.sol\";\nimport {PoolModifyLiquidityTest} from \"../../src/test/PoolModifyLiquidityTest.sol\";\nimport {PoolModifyLiquidityTestNoChecks} from \"../../src/test/PoolModifyLiquidityTestNoChecks.sol\";\nimport {PoolSwapTest} from \"../../src/test/PoolSwapTest.sol\";\nimport {SwapRouterNoChecks} from \"../../src/test/SwapRouterNoChecks.sol\";\nimport {PoolDonateTest} from \"../../src/test/PoolDonateTest.sol\";\nimport {PoolNestedActionsTest} from \"../../src/test/PoolNestedActionsTest.sol\";\nimport {PoolTakeTest} from \"../../src/test/PoolTakeTest.sol\";\nimport {PoolClaimsTest} from \"../../src/test/PoolClaimsTest.sol\";\nimport {ActionsRouter} from \"../../src/test/ActionsRouter.sol\";\nimport {LiquidityAmounts} from \"../../test/utils/LiquidityAmounts.sol\";\nimport {StateLibrary} from \"../../src/libraries/StateLibrary.sol\";\n\ncontract Deployers is Test {\n    using LPFeeLibrary for uint24;\n    using StateLibrary for IPoolManager;\n\n    // Helpful test constants\n    bytes constant ZERO_BYTES = Constants.ZERO_BYTES;\n    uint160 constant SQRT_PRICE_1_1 = Constants.SQRT_PRICE_1_1;\n    uint160 constant SQRT_PRICE_1_2 = Constants.SQRT_PRICE_1_2;\n    uint160 constant SQRT_PRICE_2_1 = Constants.SQRT_PRICE_2_1;\n    uint160 constant SQRT_PRICE_1_4 = Constants.SQRT_PRICE_1_4;\n    uint160 constant SQRT_PRICE_4_1 = Constants.SQRT_PRICE_4_1;\n\n    uint160 public constant MIN_PRICE_LIMIT = TickMath.MIN_SQRT_PRICE + 1;\n    uint160 public constant MAX_PRICE_LIMIT = TickMath.MAX_SQRT_PRICE - 1;\n\n    IPoolManager.ModifyLiquidityParams public LIQUIDITY_PARAMS =\n        IPoolManager.ModifyLiquidityParams({tickLower: -120, tickUpper: 120, liquidityDelta: 1e18, salt: 0});\n    IPoolManager.ModifyLiquidityParams public REMOVE_LIQUIDITY_PARAMS =\n        IPoolManager.ModifyLiquidityParams({tickLower: -120, tickUpper: 120, liquidityDelta: -1e18, salt: 0});\n    IPoolManager.SwapParams public SWAP_PARAMS =\n        IPoolManager.SwapParams({zeroForOne: true, amountSpecified: -100, sqrtPriceLimitX96: SQRT_PRICE_1_2});\n\n    // Global variables\n    Currency internal currency0;\n    Currency internal currency1;\n    IPoolManager manager;\n    PoolModifyLiquidityTest modifyLiquidityRouter;\n    PoolModifyLiquidityTestNoChecks modifyLiquidityNoChecks;\n    SwapRouterNoChecks swapRouterNoChecks;\n    PoolSwapTest swapRouter;\n    PoolDonateTest donateRouter;\n    PoolTakeTest takeRouter;\n    ActionsRouter actionsRouter;\n\n    PoolClaimsTest claimsRouter;\n    PoolNestedActionsTest nestedActionRouter;\n    address feeController;\n\n    PoolKey key;\n    PoolKey nativeKey;\n    PoolKey uninitializedKey;\n    PoolKey uninitializedNativeKey;\n\n    // Update this value when you add a new hook flag.\n    uint160 hookPermissionCount = 14;\n    uint160 clearAllHookPermissionsMask = ~uint160(0) << (hookPermissionCount);\n\n    modifier noIsolate() {\n        if (msg.sender != address(this)) {\n            (bool success,) = address(this).call(msg.data);\n            require(success);\n        } else {\n            _;\n        }\n    }\n\n    function deployFreshManager() internal virtual {\n        manager = new PoolManager(address(this));\n    }\n\n    function deployFreshManagerAndRouters() internal {\n        deployFreshManager();\n        swapRouter = new PoolSwapTest(manager);\n        swapRouterNoChecks = new SwapRouterNoChecks(manager);\n        modifyLiquidityRouter = new PoolModifyLiquidityTest(manager);\n        modifyLiquidityNoChecks = new PoolModifyLiquidityTestNoChecks(manager);\n        donateRouter = new PoolDonateTest(manager);\n        takeRouter = new PoolTakeTest(manager);\n        claimsRouter = new PoolClaimsTest(manager);\n        nestedActionRouter = new PoolNestedActionsTest(manager);\n        feeController = makeAddr(\"feeController\");\n        actionsRouter = new ActionsRouter(manager);\n\n        manager.setProtocolFeeController(feeController);\n    }\n\n    // You must have first initialised the routers with deployFreshManagerAndRouters\n    // If you only need the currencies (and not approvals) call deployAndMint2Currencies\n    function deployMintAndApprove2Currencies() internal returns (Currency, Currency) {\n        Currency _currencyA = deployMintAndApproveCurrency();\n        Currency _currencyB = deployMintAndApproveCurrency();\n\n        (currency0, currency1) =\n            SortTokens.sort(MockERC20(Currency.unwrap(_currencyA)), MockERC20(Currency.unwrap(_currencyB)));\n        return (currency0, currency1);\n    }\n\n    function deployMintAndApproveCurrency() internal returns (Currency currency) {\n        MockERC20 token = deployTokens(1, 2 ** 255)[0];\n\n        address[9] memory toApprove = [\n            address(swapRouter),\n            address(swapRouterNoChecks),\n            address(modifyLiquidityRouter),\n            address(modifyLiquidityNoChecks),\n            address(donateRouter),\n            address(takeRouter),\n            address(claimsRouter),\n            address(nestedActionRouter.executor()),\n            address(actionsRouter)\n        ];\n\n        for (uint256 i = 0; i < toApprove.length; i++) {\n            token.approve(toApprove[i], Constants.MAX_UINT256);\n        }\n\n        return Currency.wrap(address(token));\n    }\n\n    function deployAndMint2Currencies() internal returns (Currency, Currency) {\n        MockERC20[] memory tokens = deployTokens(2, 2 ** 255);\n        return SortTokens.sort(tokens[0], tokens[1]);\n    }\n\n    function deployTokens(uint8 count, uint256 totalSupply) internal returns (MockERC20[] memory tokens) {\n        tokens = new MockERC20[](count);\n        for (uint8 i = 0; i < count; i++) {\n            tokens[i] = new MockERC20(\"TEST\", \"TEST\", 18);\n            tokens[i].mint(address(this), totalSupply);\n        }\n    }\n\n    function initPool(Currency _currency0, Currency _currency1, IHooks hooks, uint24 fee, uint160 sqrtPriceX96)\n        internal\n        returns (PoolKey memory _key, PoolId id)\n    {\n        _key = PoolKey(_currency0, _currency1, fee, fee.isDynamicFee() ? int24(60) : int24(fee / 100 * 2), hooks);\n        id = _key.toId();\n        manager.initialize(_key, sqrtPriceX96);\n    }\n\n    function initPool(\n        Currency _currency0,\n        Currency _currency1,\n        IHooks hooks,\n        uint24 fee,\n        int24 tickSpacing,\n        uint160 sqrtPriceX96\n    ) internal returns (PoolKey memory _key, PoolId id) {\n        _key = PoolKey(_currency0, _currency1, fee, tickSpacing, hooks);\n        id = _key.toId();\n        manager.initialize(_key, sqrtPriceX96);\n    }\n\n    function initPoolAndAddLiquidity(\n        Currency _currency0,\n        Currency _currency1,\n        IHooks hooks,\n        uint24 fee,\n        uint160 sqrtPriceX96\n    ) internal returns (PoolKey memory _key, PoolId id) {\n        (_key, id) = initPool(_currency0, _currency1, hooks, fee, sqrtPriceX96);\n        modifyLiquidityRouter.modifyLiquidity{value: msg.value}(_key, LIQUIDITY_PARAMS, ZERO_BYTES);\n    }\n\n    function initPoolAndAddLiquidityETH(\n        Currency _currency0,\n        Currency _currency1,\n        IHooks hooks,\n        uint24 fee,\n        uint160 sqrtPriceX96,\n        uint256 msgValue\n    ) internal returns (PoolKey memory _key, PoolId id) {\n        (_key, id) = initPool(_currency0, _currency1, hooks, fee, sqrtPriceX96);\n        modifyLiquidityRouter.modifyLiquidity{value: msgValue}(_key, LIQUIDITY_PARAMS, ZERO_BYTES);\n    }\n\n    // Deploys the manager, all test routers, and sets up 2 pools: with and without native\n    function initializeManagerRoutersAndPoolsWithLiq(IHooks hooks) internal {\n        deployFreshManagerAndRouters();\n        // sets the global currencies and key\n        deployMintAndApprove2Currencies();\n        (key,) = initPoolAndAddLiquidity(currency0, currency1, hooks, 3000, SQRT_PRICE_1_1);\n        nestedActionRouter.executor().setKey(key);\n        (nativeKey,) =\n            initPoolAndAddLiquidityETH(CurrencyLibrary.ADDRESS_ZERO, currency1, hooks, 3000, SQRT_PRICE_1_1, 1 ether);\n        uninitializedKey = key;\n        uninitializedNativeKey = nativeKey;\n        uninitializedKey.fee = 100;\n        uninitializedNativeKey.fee = 100;\n    }\n\n    /// @notice Helper function for a simple ERC20 swaps that allows for unlimited price impact\n    function swap(PoolKey memory _key, bool zeroForOne, int256 amountSpecified, bytes memory hookData)\n        internal\n        returns (BalanceDelta)\n    {\n        // allow native input for exact-input, guide users to the `swapNativeInput` function\n        bool isNativeInput = zeroForOne && _key.currency0.isAddressZero();\n        if (isNativeInput) require(0 > amountSpecified, \"Use swapNativeInput() for native-token exact-output swaps\");\n\n        uint256 value = isNativeInput ? uint256(-amountSpecified) : 0;\n\n        return swapRouter.swap{value: value}(\n            _key,\n            IPoolManager.SwapParams({\n                zeroForOne: zeroForOne,\n                amountSpecified: amountSpecified,\n                sqrtPriceLimitX96: zeroForOne ? MIN_PRICE_LIMIT : MAX_PRICE_LIMIT\n            }),\n            PoolSwapTest.TestSettings({takeClaims: false, settleUsingBurn: false}),\n            hookData\n        );\n    }\n\n    /// @notice Helper function to increase balance of pool manager.\n    /// Uses default LIQUIDITY_PARAMS range.\n    function seedMoreLiquidity(PoolKey memory _key, uint256 amount0, uint256 amount1) internal {\n        (uint160 sqrtPriceX96,,,) = manager.getSlot0(_key.toId());\n        uint128 liquidityDelta = LiquidityAmounts.getLiquidityForAmounts(\n            sqrtPriceX96,\n            TickMath.getSqrtPriceAtTick(LIQUIDITY_PARAMS.tickLower),\n            TickMath.getSqrtPriceAtTick(LIQUIDITY_PARAMS.tickUpper),\n            amount0,\n            amount1\n        );\n\n        IPoolManager.ModifyLiquidityParams memory params = IPoolManager.ModifyLiquidityParams({\n            tickLower: LIQUIDITY_PARAMS.tickLower,\n            tickUpper: LIQUIDITY_PARAMS.tickUpper,\n            liquidityDelta: int128(liquidityDelta),\n            salt: 0\n        });\n\n        modifyLiquidityRouter.modifyLiquidity(_key, params, ZERO_BYTES);\n    }\n\n    /// @notice Helper function for a simple Native-token swap that allows for unlimited price impact\n    function swapNativeInput(\n        PoolKey memory _key,\n        bool zeroForOne,\n        int256 amountSpecified,\n        bytes memory hookData,\n        uint256 msgValue\n    ) internal returns (BalanceDelta) {\n        require(_key.currency0.isAddressZero(), \"currency0 is not native. Use swap() instead\");\n        if (zeroForOne == false) require(msgValue == 0, \"msgValue must be 0 for oneForZero swaps\");\n\n        return swapRouter.swap{value: msgValue}(\n            _key,\n            IPoolManager.SwapParams({\n                zeroForOne: zeroForOne,\n                amountSpecified: amountSpecified,\n                sqrtPriceLimitX96: zeroForOne ? MIN_PRICE_LIMIT : MAX_PRICE_LIMIT\n            }),\n            PoolSwapTest.TestSettings({takeClaims: false, settleUsingBurn: false}),\n            hookData\n        );\n    }\n\n    // to receive refunds of spare eth from test helpers\n    receive() external payable {}\n}\n"},"lib/v4-periphery/lib/v4-core/test/utils/LiquidityAmounts.sol":{"content":"// SPDX-License-Identifier: UNLICENSED\npragma solidity ^0.8.20;\n\nimport \"../../src/libraries/FullMath.sol\";\nimport \"../../src/libraries/FixedPoint96.sol\";\n\n/// @title Liquidity amount functions\n/// @notice Provides functions for computing liquidity amounts from token amounts and prices\nlibrary LiquidityAmounts {\n    /// @notice Downcasts uint256 to uint128\n    /// @param x The uint258 to be downcasted\n    /// @return y The passed value, downcasted to uint128\n    function toUint128(uint256 x) private pure returns (uint128 y) {\n        require((y = uint128(x)) == x, \"liquidity overflow\");\n    }\n\n    /// @notice Computes the amount of liquidity received for a given amount of token0 and price range\n    /// @dev Calculates amount0 * (sqrt(upper) * sqrt(lower)) / (sqrt(upper) - sqrt(lower))\n    /// @param sqrtPriceAX96 A sqrt price representing the first tick boundary\n    /// @param sqrtPriceBX96 A sqrt price representing the second tick boundary\n    /// @param amount0 The amount0 being sent in\n    /// @return liquidity The amount of returned liquidity\n    function getLiquidityForAmount0(uint160 sqrtPriceAX96, uint160 sqrtPriceBX96, uint256 amount0)\n        internal\n        pure\n        returns (uint128 liquidity)\n    {\n        if (sqrtPriceAX96 > sqrtPriceBX96) (sqrtPriceAX96, sqrtPriceBX96) = (sqrtPriceBX96, sqrtPriceAX96);\n        uint256 intermediate = FullMath.mulDiv(sqrtPriceAX96, sqrtPriceBX96, FixedPoint96.Q96);\n        return toUint128(FullMath.mulDiv(amount0, intermediate, sqrtPriceBX96 - sqrtPriceAX96));\n    }\n\n    /// @notice Computes the amount of liquidity received for a given amount of token1 and price range\n    /// @dev Calculates amount1 / (sqrt(upper) - sqrt(lower)).\n    /// @param sqrtPriceAX96 A sqrt price representing the first tick boundary\n    /// @param sqrtPriceBX96 A sqrt price representing the second tick boundary\n    /// @param amount1 The amount1 being sent in\n    /// @return liquidity The amount of returned liquidity\n    function getLiquidityForAmount1(uint160 sqrtPriceAX96, uint160 sqrtPriceBX96, uint256 amount1)\n        internal\n        pure\n        returns (uint128 liquidity)\n    {\n        if (sqrtPriceAX96 > sqrtPriceBX96) (sqrtPriceAX96, sqrtPriceBX96) = (sqrtPriceBX96, sqrtPriceAX96);\n        return toUint128(FullMath.mulDiv(amount1, FixedPoint96.Q96, sqrtPriceBX96 - sqrtPriceAX96));\n    }\n\n    /// @notice Computes the maximum amount of liquidity received for a given amount of token0, token1, the current\n    /// pool prices and the prices at the tick boundaries\n    /// @param sqrtPriceX96 A sqrt price representing the current pool prices\n    /// @param sqrtPriceAX96 A sqrt price representing the first tick boundary\n    /// @param sqrtPriceBX96 A sqrt price representing the second tick boundary\n    /// @param amount0 The amount of token0 being sent in\n    /// @param amount1 The amount of token1 being sent in\n    /// @return liquidity The maximum amount of liquidity received\n    function getLiquidityForAmounts(\n        uint160 sqrtPriceX96,\n        uint160 sqrtPriceAX96,\n        uint160 sqrtPriceBX96,\n        uint256 amount0,\n        uint256 amount1\n    ) internal pure returns (uint128 liquidity) {\n        if (sqrtPriceAX96 > sqrtPriceBX96) (sqrtPriceAX96, sqrtPriceBX96) = (sqrtPriceBX96, sqrtPriceAX96);\n\n        if (sqrtPriceX96 <= sqrtPriceAX96) {\n            liquidity = getLiquidityForAmount0(sqrtPriceAX96, sqrtPriceBX96, amount0);\n        } else if (sqrtPriceX96 < sqrtPriceBX96) {\n            uint128 liquidity0 = getLiquidityForAmount0(sqrtPriceX96, sqrtPriceBX96, amount0);\n            uint128 liquidity1 = getLiquidityForAmount1(sqrtPriceAX96, sqrtPriceX96, amount1);\n\n            liquidity = liquidity0 < liquidity1 ? liquidity0 : liquidity1;\n        } else {\n            liquidity = getLiquidityForAmount1(sqrtPriceAX96, sqrtPriceBX96, amount1);\n        }\n    }\n\n    /// @notice Computes the amount of token0 for a given amount of liquidity and a price range\n    /// @param sqrtPriceAX96 A sqrt price representing the first tick boundary\n    /// @param sqrtPriceBX96 A sqrt price representing the second tick boundary\n    /// @param liquidity The liquidity being valued\n    /// @return amount0 The amount of token0\n    function getAmount0ForLiquidity(uint160 sqrtPriceAX96, uint160 sqrtPriceBX96, uint128 liquidity)\n        internal\n        pure\n        returns (uint256 amount0)\n    {\n        if (sqrtPriceAX96 > sqrtPriceBX96) (sqrtPriceAX96, sqrtPriceBX96) = (sqrtPriceBX96, sqrtPriceAX96);\n\n        return FullMath.mulDiv(\n            uint256(liquidity) << FixedPoint96.RESOLUTION, sqrtPriceBX96 - sqrtPriceAX96, sqrtPriceBX96\n        ) / sqrtPriceAX96;\n    }\n\n    /// @notice Computes the amount of token1 for a given amount of liquidity and a price range\n    /// @param sqrtPriceAX96 A sqrt price representing the first tick boundary\n    /// @param sqrtPriceBX96 A sqrt price representing the second tick boundary\n    /// @param liquidity The liquidity being valued\n    /// @return amount1 The amount of token1\n    function getAmount1ForLiquidity(uint160 sqrtPriceAX96, uint160 sqrtPriceBX96, uint128 liquidity)\n        internal\n        pure\n        returns (uint256 amount1)\n    {\n        if (sqrtPriceAX96 > sqrtPriceBX96) (sqrtPriceAX96, sqrtPriceBX96) = (sqrtPriceBX96, sqrtPriceAX96);\n\n        return FullMath.mulDiv(liquidity, sqrtPriceBX96 - sqrtPriceAX96, FixedPoint96.Q96);\n    }\n\n    /// @notice Computes the token0 and token1 value for a given amount of liquidity, the current\n    /// pool prices and the prices at the tick boundaries\n    /// @param sqrtPriceX96 A sqrt price representing the current pool prices\n    /// @param sqrtPriceAX96 A sqrt price representing the first tick boundary\n    /// @param sqrtPriceBX96 A sqrt price representing the second tick boundary\n    /// @param liquidity The liquidity being valued\n    /// @return amount0 The amount of token0\n    /// @return amount1 The amount of token1\n    function getAmountsForLiquidity(\n        uint160 sqrtPriceX96,\n        uint160 sqrtPriceAX96,\n        uint160 sqrtPriceBX96,\n        uint128 liquidity\n    ) internal pure returns (uint256 amount0, uint256 amount1) {\n        if (sqrtPriceAX96 > sqrtPriceBX96) (sqrtPriceAX96, sqrtPriceBX96) = (sqrtPriceBX96, sqrtPriceAX96);\n\n        if (sqrtPriceX96 <= sqrtPriceAX96) {\n            amount0 = getAmount0ForLiquidity(sqrtPriceAX96, sqrtPriceBX96, liquidity);\n        } else if (sqrtPriceX96 < sqrtPriceBX96) {\n            amount0 = getAmount0ForLiquidity(sqrtPriceX96, sqrtPriceBX96, liquidity);\n            amount1 = getAmount1ForLiquidity(sqrtPriceAX96, sqrtPriceX96, liquidity);\n        } else {\n            amount1 = getAmount1ForLiquidity(sqrtPriceAX96, sqrtPriceBX96, liquidity);\n        }\n    }\n}\n"},"lib/v4-periphery/lib/v4-core/test/utils/SortTokens.sol":{"content":"// SPDX-License-Identifier: UNLICENSED\npragma solidity ^0.8.20;\n\nimport {MockERC20} from \"solmate/src/test/utils/mocks/MockERC20.sol\";\nimport {Currency} from \"../../src/types/Currency.sol\";\n\nlibrary SortTokens {\n    function sort(MockERC20 tokenA, MockERC20 tokenB)\n        internal\n        pure\n        returns (Currency _currency0, Currency _currency1)\n    {\n        if (address(tokenA) < address(tokenB)) {\n            (_currency0, _currency1) = (Currency.wrap(address(tokenA)), Currency.wrap(address(tokenB)));\n        } else {\n            (_currency0, _currency1) = (Currency.wrap(address(tokenB)), Currency.wrap(address(tokenA)));\n        }\n    }\n}\n"},"lib/v4-periphery/src/PositionManager.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity 0.8.26;\n\nimport {IPoolManager} from \"@uniswap/v4-core/src/interfaces/IPoolManager.sol\";\nimport {PoolKey} from \"@uniswap/v4-core/src/types/PoolKey.sol\";\nimport {Currency, CurrencyLibrary} from \"@uniswap/v4-core/src/types/Currency.sol\";\nimport {BalanceDelta} from \"@uniswap/v4-core/src/types/BalanceDelta.sol\";\nimport {SafeCast} from \"@uniswap/v4-core/src/libraries/SafeCast.sol\";\nimport {Position} from \"@uniswap/v4-core/src/libraries/Position.sol\";\nimport {StateLibrary} from \"@uniswap/v4-core/src/libraries/StateLibrary.sol\";\nimport {TransientStateLibrary} from \"@uniswap/v4-core/src/libraries/TransientStateLibrary.sol\";\nimport {IAllowanceTransfer} from \"permit2/src/interfaces/IAllowanceTransfer.sol\";\nimport {TickMath} from \"@uniswap/v4-core/src/libraries/TickMath.sol\";\n\nimport {IPositionDescriptor} from \"./interfaces/IPositionDescriptor.sol\";\nimport {ERC721Permit_v4} from \"./base/ERC721Permit_v4.sol\";\nimport {ReentrancyLock} from \"./base/ReentrancyLock.sol\";\nimport {IPositionManager} from \"./interfaces/IPositionManager.sol\";\nimport {Multicall_v4} from \"./base/Multicall_v4.sol\";\nimport {PoolInitializer_v4} from \"./base/PoolInitializer_v4.sol\";\nimport {DeltaResolver} from \"./base/DeltaResolver.sol\";\nimport {BaseActionsRouter} from \"./base/BaseActionsRouter.sol\";\nimport {Actions} from \"./libraries/Actions.sol\";\nimport {Notifier} from \"./base/Notifier.sol\";\nimport {CalldataDecoder} from \"./libraries/CalldataDecoder.sol\";\nimport {Permit2Forwarder} from \"./base/Permit2Forwarder.sol\";\nimport {SlippageCheck} from \"./libraries/SlippageCheck.sol\";\nimport {PositionInfo, PositionInfoLibrary} from \"./libraries/PositionInfoLibrary.sol\";\nimport {LiquidityAmounts} from \"./libraries/LiquidityAmounts.sol\";\nimport {NativeWrapper} from \"./base/NativeWrapper.sol\";\nimport {IWETH9} from \"./interfaces/external/IWETH9.sol\";\n\n//                                           444444444\n//                                444444444444      444444\n//                              444              44     4444\n//                             44         4      44        444\n//                            44         44       44         44\n//                           44          44        44         44\n//                          44       444444          44        44\n//                         444          4444           4444    44\n//                         44             4444                 444444444444444444\n//                         44             44  4                44444           444444\n//        444444444444    44              4                444                      44\n//        44        44444444              4             444                         44\n//       444              44                          44                           444\n//        44               4  4444444444444444444444444           4444444444     4444\n//         44              44444444444444444444444444      444               44444\n//          444                                  44 44444444444444444444444444\n//           4444                             444444444444444444444444\n//              4444                      444444    444444444444444\n//                 44444              444444        44444444444444444444444\n//                     444444444444444    4           44444 44444444444444444444\n//                           444                          444444444444444444444444444\n//                           444                           44444  44444444444     44444444\n//                          444                               4   44444444444444   444444444\n//                         4444 444                               44 4444444444444     44444444\n//                         44  44444         44444444             44444444444444444444     44444\n//                        444 444444        4444  4444             444444444444444444     44  4444\n//                 4444   44  44444        44444444444             444444444444444444444    44444444\n//                     44444   4444        4444444444             444444444444444444444444     44444\n//                 44444 44444 444         444444                4444444444444444444444444       44444\n//                       4444 44         44                     4 44444444444444444444444444   444 44444\n//                   44444444 444  44   4    4         444444  4 44444444444444444444444444444   4444444\n//                        444444    44       44444444444       44444444444444 444444444444444      444444\n//                     444444 44   4444      44444       44     44444444444444444444444 4444444      44444\n//                   44    444444   44   444444444 444        4444444444444444444444444444444444   4444444\n//                       44  4444444444444    44  44  44       4444444444444444444444444444444       444444\n//                      44  44444444444444444444444444  4   44 4444444444444444444444444444444    4   444444\n//                     4    4444                     4    4 4444444444444444444444444              44 4444444\n//                          4444                          4444444444444444444444444    4   4444     44444444\n//                          4444                         444444444444444444444444  44444     44444 4444444444\n//                          44444  44                  444444444444444444444444444444444444444444444444444444\n//                          44444444444               4444444444444444444444444444444444444444444444444444444\n//                           4444444444444           44444444444444444444444444444444444444444444444444444444\n//                           444444444444444         444444444444444444444444444444444444444444444444444444444\n//                            44444444444444444     4444444444444444444444444444444444444444444444444444444444\n//                            44444444444444444     44444444444444444444444444444444444444444444444444444444\n//                            44444444444444444444  444444444444444444444444444444444444444444444444444444444\n//                            444444444444444444444 444444444444444444444444444444444444444444444444444444444\n//                              444444444444444444444 4444444444444444444444444444444444444444444444444444444\n//                              44444444444444444444444444444444444444444444444444444444444444444444444444444\n//                               444444444444444444444444444444444444444444444444444444444444444444444444444\n//                                44444444444444444444444444444444444444444444444444444444444444444444444444\n//                               44444444444444444444444444444444444444444444444444      444444444444444444\n//                             444444444444444444444444444444444444444444444444       44444444444444444444\n//                           444   444   444   44  444444444444444444444 4444      444444444444444444444\n//                           444  444    44    44  44444444 4444444444444       44444444444444444444444\n//                            444 444   4444   4444 4444444444444444         44444444444444444444444444\n//                      4444444444444444444444444444444444444444        44444444444444444444444444444\n//                       444        4444444444444444444444444       44444444444444444444444444444444\n//                          4444444       444444444444         4444444444444444444444444444444444\n//                             4444444444                 44444444444444444444444444444444444\n//                                444444444444444444444444444444444444444444444444444444\n//                                     44444444444444444444444444444444444444444\n//                                              4444444444444444444\n\n/// @notice The PositionManager (PosM) contract is responsible for creating liquidity positions on v4.\n/// PosM mints and manages ERC721 tokens associated with each position.\ncontract PositionManager is\n    IPositionManager,\n    ERC721Permit_v4,\n    PoolInitializer_v4,\n    Multicall_v4,\n    DeltaResolver,\n    ReentrancyLock,\n    BaseActionsRouter,\n    Notifier,\n    Permit2Forwarder,\n    NativeWrapper\n{\n    using StateLibrary for IPoolManager;\n    using TransientStateLibrary for IPoolManager;\n    using SafeCast for uint256;\n    using SafeCast for int256;\n    using CalldataDecoder for bytes;\n    using SlippageCheck for BalanceDelta;\n\n    /// @inheritdoc IPositionManager\n    /// @dev The ID of the next token that will be minted. Skips 0\n    uint256 public nextTokenId = 1;\n\n    IPositionDescriptor public immutable tokenDescriptor;\n\n    mapping(uint256 tokenId => PositionInfo info) public positionInfo;\n    mapping(bytes25 poolId => PoolKey poolKey) public poolKeys;\n\n    constructor(\n        IPoolManager _poolManager,\n        IAllowanceTransfer _permit2,\n        uint256 _unsubscribeGasLimit,\n        IPositionDescriptor _tokenDescriptor,\n        IWETH9 _weth9\n    )\n        BaseActionsRouter(_poolManager)\n        Permit2Forwarder(_permit2)\n        ERC721Permit_v4(\"Uniswap v4 Positions NFT\", \"UNI-V4-POSM\")\n        Notifier(_unsubscribeGasLimit)\n        NativeWrapper(_weth9)\n    {\n        tokenDescriptor = _tokenDescriptor;\n    }\n\n    /// @notice Reverts if the deadline has passed\n    /// @param deadline The timestamp at which the call is no longer valid, passed in by the caller\n    modifier checkDeadline(uint256 deadline) {\n        if (block.timestamp > deadline) revert DeadlinePassed(deadline);\n        _;\n    }\n\n    /// @notice Reverts if the caller is not the owner or approved for the ERC721 token\n    /// @param caller The address of the caller\n    /// @param tokenId the unique identifier of the ERC721 token\n    /// @dev either msg.sender or msgSender() is passed in as the caller\n    /// msgSender() should ONLY be used if this is called from within the unlockCallback, unless the codepath has reentrancy protection\n    modifier onlyIfApproved(address caller, uint256 tokenId) override {\n        if (!_isApprovedOrOwner(caller, tokenId)) revert NotApproved(caller);\n        _;\n    }\n\n    /// @notice Enforces that the PoolManager is locked.\n    modifier onlyIfPoolManagerLocked() override {\n        if (poolManager.isUnlocked()) revert PoolManagerMustBeLocked();\n        _;\n    }\n\n    function tokenURI(uint256 tokenId) public view override returns (string memory) {\n        return IPositionDescriptor(tokenDescriptor).tokenURI(this, tokenId);\n    }\n\n    /// @inheritdoc IPositionManager\n    function modifyLiquidities(bytes calldata unlockData, uint256 deadline)\n        external\n        payable\n        isNotLocked\n        checkDeadline(deadline)\n    {\n        _executeActions(unlockData);\n    }\n\n    /// @inheritdoc IPositionManager\n    function modifyLiquiditiesWithoutUnlock(bytes calldata actions, bytes[] calldata params)\n        external\n        payable\n        isNotLocked\n    {\n        _executeActionsWithoutUnlock(actions, params);\n    }\n\n    /// @inheritdoc BaseActionsRouter\n    function msgSender() public view override returns (address) {\n        return _getLocker();\n    }\n\n    function _handleAction(uint256 action, bytes calldata params) internal virtual override {\n        if (action < Actions.SETTLE) {\n            if (action == Actions.INCREASE_LIQUIDITY) {\n                (uint256 tokenId, uint256 liquidity, uint128 amount0Max, uint128 amount1Max, bytes calldata hookData) =\n                    params.decodeModifyLiquidityParams();\n                _increase(tokenId, liquidity, amount0Max, amount1Max, hookData);\n                return;\n            } else if (action == Actions.INCREASE_LIQUIDITY_FROM_DELTAS) {\n                (uint256 tokenId, uint128 amount0Max, uint128 amount1Max, bytes calldata hookData) =\n                    params.decodeIncreaseLiquidityFromDeltasParams();\n                _increaseFromDeltas(tokenId, amount0Max, amount1Max, hookData);\n                return;\n            } else if (action == Actions.DECREASE_LIQUIDITY) {\n                (uint256 tokenId, uint256 liquidity, uint128 amount0Min, uint128 amount1Min, bytes calldata hookData) =\n                    params.decodeModifyLiquidityParams();\n                _decrease(tokenId, liquidity, amount0Min, amount1Min, hookData);\n                return;\n            } else if (action == Actions.MINT_POSITION) {\n                (\n                    PoolKey calldata poolKey,\n                    int24 tickLower,\n                    int24 tickUpper,\n                    uint256 liquidity,\n                    uint128 amount0Max,\n                    uint128 amount1Max,\n                    address owner,\n                    bytes calldata hookData\n                ) = params.decodeMintParams();\n                _mint(poolKey, tickLower, tickUpper, liquidity, amount0Max, amount1Max, _mapRecipient(owner), hookData);\n                return;\n            } else if (action == Actions.MINT_POSITION_FROM_DELTAS) {\n                (\n                    PoolKey calldata poolKey,\n                    int24 tickLower,\n                    int24 tickUpper,\n                    uint128 amount0Max,\n                    uint128 amount1Max,\n                    address owner,\n                    bytes calldata hookData\n                ) = params.decodeMintFromDeltasParams();\n                _mintFromDeltas(poolKey, tickLower, tickUpper, amount0Max, amount1Max, _mapRecipient(owner), hookData);\n                return;\n            } else if (action == Actions.BURN_POSITION) {\n                // Will automatically decrease liquidity to 0 if the position is not already empty.\n                (uint256 tokenId, uint128 amount0Min, uint128 amount1Min, bytes calldata hookData) =\n                    params.decodeBurnParams();\n                _burn(tokenId, amount0Min, amount1Min, hookData);\n                return;\n            }\n        } else {\n            if (action == Actions.SETTLE_PAIR) {\n                (Currency currency0, Currency currency1) = params.decodeCurrencyPair();\n                _settlePair(currency0, currency1);\n                return;\n            } else if (action == Actions.TAKE_PAIR) {\n                (Currency currency0, Currency currency1, address recipient) = params.decodeCurrencyPairAndAddress();\n                _takePair(currency0, currency1, _mapRecipient(recipient));\n                return;\n            } else if (action == Actions.SETTLE) {\n                (Currency currency, uint256 amount, bool payerIsUser) = params.decodeCurrencyUint256AndBool();\n                _settle(currency, _mapPayer(payerIsUser), _mapSettleAmount(amount, currency));\n                return;\n            } else if (action == Actions.TAKE) {\n                (Currency currency, address recipient, uint256 amount) = params.decodeCurrencyAddressAndUint256();\n                _take(currency, _mapRecipient(recipient), _mapTakeAmount(amount, currency));\n                return;\n            } else if (action == Actions.CLOSE_CURRENCY) {\n                Currency currency = params.decodeCurrency();\n                _close(currency);\n                return;\n            } else if (action == Actions.CLEAR_OR_TAKE) {\n                (Currency currency, uint256 amountMax) = params.decodeCurrencyAndUint256();\n                _clearOrTake(currency, amountMax);\n                return;\n            } else if (action == Actions.SWEEP) {\n                (Currency currency, address to) = params.decodeCurrencyAndAddress();\n                _sweep(currency, _mapRecipient(to));\n                return;\n            } else if (action == Actions.WRAP) {\n                uint256 amount = params.decodeUint256();\n                _wrap(_mapWrapUnwrapAmount(CurrencyLibrary.ADDRESS_ZERO, amount, Currency.wrap(address(WETH9))));\n                return;\n            } else if (action == Actions.UNWRAP) {\n                uint256 amount = params.decodeUint256();\n                _unwrap(_mapWrapUnwrapAmount(Currency.wrap(address(WETH9)), amount, CurrencyLibrary.ADDRESS_ZERO));\n                return;\n            }\n        }\n        revert UnsupportedAction(action);\n    }\n\n    /// @dev Calling increase with 0 liquidity will credit the caller with any underlying fees of the position\n    function _increase(\n        uint256 tokenId,\n        uint256 liquidity,\n        uint128 amount0Max,\n        uint128 amount1Max,\n        bytes calldata hookData\n    ) internal onlyIfApproved(msgSender(), tokenId) {\n        (PoolKey memory poolKey, PositionInfo info) = getPoolAndPositionInfo(tokenId);\n\n        // Note: The tokenId is used as the salt for this position, so every minted position has unique storage in the pool manager.\n        (BalanceDelta liquidityDelta, BalanceDelta feesAccrued) =\n            _modifyLiquidity(info, poolKey, liquidity.toInt256(), bytes32(tokenId), hookData);\n        // Slippage checks should be done on the principal liquidityDelta which is the liquidityDelta - feesAccrued\n        (liquidityDelta - feesAccrued).validateMaxIn(amount0Max, amount1Max);\n    }\n\n    /// @dev The liquidity delta is derived from open deltas in the pool manager.\n    function _increaseFromDeltas(uint256 tokenId, uint128 amount0Max, uint128 amount1Max, bytes calldata hookData)\n        internal\n        onlyIfApproved(msgSender(), tokenId)\n    {\n        (PoolKey memory poolKey, PositionInfo info) = getPoolAndPositionInfo(tokenId);\n\n        uint256 liquidity;\n        {\n            (uint160 sqrtPriceX96,,,) = poolManager.getSlot0(poolKey.toId());\n\n            // Use the credit on the pool manager as the amounts for the mint.\n            liquidity = LiquidityAmounts.getLiquidityForAmounts(\n                sqrtPriceX96,\n                TickMath.getSqrtPriceAtTick(info.tickLower()),\n                TickMath.getSqrtPriceAtTick(info.tickUpper()),\n                _getFullCredit(poolKey.currency0),\n                _getFullCredit(poolKey.currency1)\n            );\n        }\n\n        // Note: The tokenId is used as the salt for this position, so every minted position has unique storage in the pool manager.\n        (BalanceDelta liquidityDelta, BalanceDelta feesAccrued) =\n            _modifyLiquidity(info, poolKey, liquidity.toInt256(), bytes32(tokenId), hookData);\n        // Slippage checks should be done on the principal liquidityDelta which is the liquidityDelta - feesAccrued\n        (liquidityDelta - feesAccrued).validateMaxIn(amount0Max, amount1Max);\n    }\n\n    /// @dev Calling decrease with 0 liquidity will credit the caller with any underlying fees of the position\n    function _decrease(\n        uint256 tokenId,\n        uint256 liquidity,\n        uint128 amount0Min,\n        uint128 amount1Min,\n        bytes calldata hookData\n    ) internal onlyIfApproved(msgSender(), tokenId) {\n        (PoolKey memory poolKey, PositionInfo info) = getPoolAndPositionInfo(tokenId);\n\n        // Note: the tokenId is used as the salt.\n        (BalanceDelta liquidityDelta, BalanceDelta feesAccrued) =\n            _modifyLiquidity(info, poolKey, -(liquidity.toInt256()), bytes32(tokenId), hookData);\n        // Slippage checks should be done on the principal liquidityDelta which is the liquidityDelta - feesAccrued\n        (liquidityDelta - feesAccrued).validateMinOut(amount0Min, amount1Min);\n    }\n\n    function _mint(\n        PoolKey calldata poolKey,\n        int24 tickLower,\n        int24 tickUpper,\n        uint256 liquidity,\n        uint128 amount0Max,\n        uint128 amount1Max,\n        address owner,\n        bytes calldata hookData\n    ) internal {\n        // mint receipt token\n        uint256 tokenId;\n        // tokenId is assigned to current nextTokenId before incrementing it\n        unchecked {\n            tokenId = nextTokenId++;\n        }\n        _mint(owner, tokenId);\n\n        // Initialize the position info\n        PositionInfo info = PositionInfoLibrary.initialize(poolKey, tickLower, tickUpper);\n        positionInfo[tokenId] = info;\n\n        // Store the poolKey if it is not already stored.\n        // On UniswapV4, the minimum tick spacing is 1, which means that if the tick spacing is 0, the pool key has not been set.\n        bytes25 poolId = info.poolId();\n        if (poolKeys[poolId].tickSpacing == 0) {\n            poolKeys[poolId] = poolKey;\n        }\n\n        // fee delta can be ignored as this is a new position\n        (BalanceDelta liquidityDelta,) =\n            _modifyLiquidity(info, poolKey, liquidity.toInt256(), bytes32(tokenId), hookData);\n        liquidityDelta.validateMaxIn(amount0Max, amount1Max);\n    }\n\n    function _mintFromDeltas(\n        PoolKey calldata poolKey,\n        int24 tickLower,\n        int24 tickUpper,\n        uint128 amount0Max,\n        uint128 amount1Max,\n        address owner,\n        bytes calldata hookData\n    ) internal {\n        (uint160 sqrtPriceX96,,,) = poolManager.getSlot0(poolKey.toId());\n\n        // Use the credit on the pool manager as the amounts for the mint.\n        uint256 liquidity = LiquidityAmounts.getLiquidityForAmounts(\n            sqrtPriceX96,\n            TickMath.getSqrtPriceAtTick(tickLower),\n            TickMath.getSqrtPriceAtTick(tickUpper),\n            _getFullCredit(poolKey.currency0),\n            _getFullCredit(poolKey.currency1)\n        );\n\n        _mint(poolKey, tickLower, tickUpper, liquidity, amount0Max, amount1Max, owner, hookData);\n    }\n\n    /// @dev this is overloaded with ERC721Permit_v4._burn\n    function _burn(uint256 tokenId, uint128 amount0Min, uint128 amount1Min, bytes calldata hookData)\n        internal\n        onlyIfApproved(msgSender(), tokenId)\n    {\n        (PoolKey memory poolKey, PositionInfo info) = getPoolAndPositionInfo(tokenId);\n\n        uint256 liquidity = uint256(_getLiquidity(tokenId, poolKey, info.tickLower(), info.tickUpper()));\n\n        address owner = ownerOf(tokenId);\n\n        // Clear the position info.\n        positionInfo[tokenId] = PositionInfoLibrary.EMPTY_POSITION_INFO;\n        // Burn the token.\n        _burn(tokenId);\n\n        // Can only call modify if there is non zero liquidity.\n        BalanceDelta feesAccrued;\n        if (liquidity > 0) {\n            BalanceDelta liquidityDelta;\n            // do not use _modifyLiquidity as we do not need to notify on modification for burns.\n            IPoolManager.ModifyLiquidityParams memory params = IPoolManager.ModifyLiquidityParams({\n                tickLower: info.tickLower(),\n                tickUpper: info.tickUpper(),\n                liquidityDelta: -(liquidity.toInt256()),\n                salt: bytes32(tokenId)\n            });\n            (liquidityDelta, feesAccrued) = poolManager.modifyLiquidity(poolKey, params, hookData);\n            // Slippage checks should be done on the principal liquidityDelta which is the liquidityDelta - feesAccrued\n            (liquidityDelta - feesAccrued).validateMinOut(amount0Min, amount1Min);\n        }\n\n        // deletes then notifies the subscriber\n        if (info.hasSubscriber()) _removeSubscriberAndNotifyBurn(tokenId, owner, info, liquidity, feesAccrued);\n    }\n\n    function _settlePair(Currency currency0, Currency currency1) internal {\n        // the locker is the payer when settling\n        address caller = msgSender();\n        _settle(currency0, caller, _getFullDebt(currency0));\n        _settle(currency1, caller, _getFullDebt(currency1));\n    }\n\n    function _takePair(Currency currency0, Currency currency1, address recipient) internal {\n        _take(currency0, recipient, _getFullCredit(currency0));\n        _take(currency1, recipient, _getFullCredit(currency1));\n    }\n\n    function _close(Currency currency) internal {\n        // this address has applied all deltas on behalf of the user/owner\n        // it is safe to close this entire delta because of slippage checks throughout the batched calls.\n        int256 currencyDelta = poolManager.currencyDelta(address(this), currency);\n\n        // the locker is the payer or receiver\n        address caller = msgSender();\n        if (currencyDelta < 0) {\n            // Casting is safe due to limits on the total supply of a pool\n            _settle(currency, caller, uint256(-currencyDelta));\n        } else {\n            _take(currency, caller, uint256(currencyDelta));\n        }\n    }\n\n    /// @dev integrators may elect to forfeit positive deltas with clear\n    /// if the forfeit amount exceeds the user-specified max, the amount is taken instead\n    /// if there is no credit, no call is made.\n    function _clearOrTake(Currency currency, uint256 amountMax) internal {\n        uint256 delta = _getFullCredit(currency);\n        if (delta == 0) return;\n\n        // forfeit the delta if its less than or equal to the user-specified limit\n        if (delta <= amountMax) {\n            poolManager.clear(currency, delta);\n        } else {\n            _take(currency, msgSender(), delta);\n        }\n    }\n\n    /// @notice Sweeps the entire contract balance of specified currency to the recipient\n    function _sweep(Currency currency, address to) internal {\n        uint256 balance = currency.balanceOfSelf();\n        if (balance > 0) currency.transfer(to, balance);\n    }\n\n    /// @dev if there is a subscriber attached to the position, this function will notify the subscriber\n    function _modifyLiquidity(\n        PositionInfo info,\n        PoolKey memory poolKey,\n        int256 liquidityChange,\n        bytes32 salt,\n        bytes calldata hookData\n    ) internal returns (BalanceDelta liquidityDelta, BalanceDelta feesAccrued) {\n        (liquidityDelta, feesAccrued) = poolManager.modifyLiquidity(\n            poolKey,\n            IPoolManager.ModifyLiquidityParams({\n                tickLower: info.tickLower(),\n                tickUpper: info.tickUpper(),\n                liquidityDelta: liquidityChange,\n                salt: salt\n            }),\n            hookData\n        );\n\n        if (info.hasSubscriber()) {\n            _notifyModifyLiquidity(uint256(salt), liquidityChange, feesAccrued);\n        }\n    }\n\n    // implementation of abstract function DeltaResolver._pay\n    function _pay(Currency currency, address payer, uint256 amount) internal override {\n        if (payer == address(this)) {\n            currency.transfer(address(poolManager), amount);\n        } else {\n            // Casting from uint256 to uint160 is safe due to limits on the total supply of a pool\n            permit2.transferFrom(payer, address(poolManager), uint160(amount), Currency.unwrap(currency));\n        }\n    }\n\n    /// @notice an internal helper used by Notifier\n    function _setSubscribed(uint256 tokenId) internal override {\n        positionInfo[tokenId] = positionInfo[tokenId].setSubscribe();\n    }\n\n    /// @notice an internal helper used by Notifier\n    function _setUnsubscribed(uint256 tokenId) internal override {\n        positionInfo[tokenId] = positionInfo[tokenId].setUnsubscribe();\n    }\n\n    /// @dev overrides solmate transferFrom in case a notification to subscribers is needed\n    /// @dev will revert if pool manager is locked\n    function transferFrom(address from, address to, uint256 id) public virtual override onlyIfPoolManagerLocked {\n        super.transferFrom(from, to, id);\n        if (positionInfo[id].hasSubscriber()) _unsubscribe(id);\n    }\n\n    /// @inheritdoc IPositionManager\n    function getPoolAndPositionInfo(uint256 tokenId) public view returns (PoolKey memory poolKey, PositionInfo info) {\n        info = positionInfo[tokenId];\n        poolKey = poolKeys[info.poolId()];\n    }\n\n    /// @inheritdoc IPositionManager\n    function getPositionLiquidity(uint256 tokenId) external view returns (uint128 liquidity) {\n        (PoolKey memory poolKey, PositionInfo info) = getPoolAndPositionInfo(tokenId);\n        liquidity = _getLiquidity(tokenId, poolKey, info.tickLower(), info.tickUpper());\n    }\n\n    function _getLiquidity(uint256 tokenId, PoolKey memory poolKey, int24 tickLower, int24 tickUpper)\n        internal\n        view\n        returns (uint128 liquidity)\n    {\n        bytes32 positionId = Position.calculatePositionKey(address(this), tickLower, tickUpper, bytes32(tokenId));\n        liquidity = poolManager.getPositionLiquidity(poolKey.toId(), positionId);\n    }\n}\n"},"lib/v4-periphery/src/base/BaseActionsRouter.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport {IPoolManager} from \"@uniswap/v4-core/src/interfaces/IPoolManager.sol\";\nimport {SafeCallback} from \"./SafeCallback.sol\";\nimport {CalldataDecoder} from \"../libraries/CalldataDecoder.sol\";\nimport {ActionConstants} from \"../libraries/ActionConstants.sol\";\n\n/// @notice Abstract contract for performing a combination of actions on Uniswap v4.\n/// @dev Suggested uint256 action values are defined in Actions.sol, however any definition can be used\nabstract contract BaseActionsRouter is SafeCallback {\n    using CalldataDecoder for bytes;\n\n    /// @notice emitted when different numbers of parameters and actions are provided\n    error InputLengthMismatch();\n\n    /// @notice emitted when an inheriting contract does not support an action\n    error UnsupportedAction(uint256 action);\n\n    constructor(IPoolManager _poolManager) SafeCallback(_poolManager) {}\n\n    /// @notice internal function that triggers the execution of a set of actions on v4\n    /// @dev inheriting contracts should call this function to trigger execution\n    function _executeActions(bytes calldata unlockData) internal {\n        poolManager.unlock(unlockData);\n    }\n\n    /// @notice function that is called by the PoolManager through the SafeCallback.unlockCallback\n    /// @param data Abi encoding of (bytes actions, bytes[] params)\n    /// where params[i] is the encoded parameters for actions[i]\n    function _unlockCallback(bytes calldata data) internal override returns (bytes memory) {\n        // abi.decode(data, (bytes, bytes[]));\n        (bytes calldata actions, bytes[] calldata params) = data.decodeActionsRouterParams();\n        _executeActionsWithoutUnlock(actions, params);\n        return \"\";\n    }\n\n    function _executeActionsWithoutUnlock(bytes calldata actions, bytes[] calldata params) internal {\n        uint256 numActions = actions.length;\n        if (numActions != params.length) revert InputLengthMismatch();\n\n        for (uint256 actionIndex = 0; actionIndex < numActions; actionIndex++) {\n            uint256 action = uint8(actions[actionIndex]);\n\n            _handleAction(action, params[actionIndex]);\n        }\n    }\n\n    /// @notice function to handle the parsing and execution of an action and its parameters\n    function _handleAction(uint256 action, bytes calldata params) internal virtual;\n\n    /// @notice function that returns address considered executor of the actions\n    /// @dev The other context functions, _msgData and _msgValue, are not supported by this contract\n    /// In many contracts this will be the address that calls the initial entry point that calls `_executeActions`\n    /// `msg.sender` shouldn't be used, as this will be the v4 pool manager contract that calls `unlockCallback`\n    /// If using ReentrancyLock.sol, this function can return _getLocker()\n    function msgSender() public view virtual returns (address);\n\n    /// @notice Calculates the address for a action\n    function _mapRecipient(address recipient) internal view returns (address) {\n        if (recipient == ActionConstants.MSG_SENDER) {\n            return msgSender();\n        } else if (recipient == ActionConstants.ADDRESS_THIS) {\n            return address(this);\n        } else {\n            return recipient;\n        }\n    }\n\n    /// @notice Calculates the payer for an action\n    function _mapPayer(bool payerIsUser) internal view returns (address) {\n        return payerIsUser ? msgSender() : address(this);\n    }\n}\n"},"lib/v4-periphery/src/base/DeltaResolver.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity ^0.8.24;\n\nimport {Currency} from \"@uniswap/v4-core/src/types/Currency.sol\";\nimport {TransientStateLibrary} from \"@uniswap/v4-core/src/libraries/TransientStateLibrary.sol\";\nimport {IPoolManager} from \"@uniswap/v4-core/src/interfaces/IPoolManager.sol\";\nimport {ImmutableState} from \"./ImmutableState.sol\";\nimport {ActionConstants} from \"../libraries/ActionConstants.sol\";\n\n/// @notice Abstract contract used to sync, send, and settle funds to the pool manager\n/// @dev Note that sync() is called before any erc-20 transfer in `settle`.\nabstract contract DeltaResolver is ImmutableState {\n    using TransientStateLibrary for IPoolManager;\n\n    /// @notice Emitted trying to settle a positive delta.\n    error DeltaNotPositive(Currency currency);\n    /// @notice Emitted trying to take a negative delta.\n    error DeltaNotNegative(Currency currency);\n    /// @notice Emitted when the contract does not have enough balance to wrap or unwrap.\n    error InsufficientBalance();\n\n    /// @notice Take an amount of currency out of the PoolManager\n    /// @param currency Currency to take\n    /// @param recipient Address to receive the currency\n    /// @param amount Amount to take\n    /// @dev Returns early if the amount is 0\n    function _take(Currency currency, address recipient, uint256 amount) internal {\n        if (amount == 0) return;\n        poolManager.take(currency, recipient, amount);\n    }\n\n    /// @notice Pay and settle a currency to the PoolManager\n    /// @dev The implementing contract must ensure that the `payer` is a secure address\n    /// @param currency Currency to settle\n    /// @param payer Address of the payer\n    /// @param amount Amount to send\n    /// @dev Returns early if the amount is 0\n    function _settle(Currency currency, address payer, uint256 amount) internal {\n        if (amount == 0) return;\n\n        poolManager.sync(currency);\n        if (currency.isAddressZero()) {\n            poolManager.settle{value: amount}();\n        } else {\n            _pay(currency, payer, amount);\n            poolManager.settle();\n        }\n    }\n\n    /// @notice Abstract function for contracts to implement paying tokens to the poolManager\n    /// @dev The recipient of the payment should be the poolManager\n    /// @param token The token to settle. This is known not to be the native currency\n    /// @param payer The address who should pay tokens\n    /// @param amount The number of tokens to send\n    function _pay(Currency token, address payer, uint256 amount) internal virtual;\n\n    /// @notice Obtain the full amount owed by this contract (negative delta)\n    /// @param currency Currency to get the delta for\n    /// @return amount The amount owed by this contract as a uint256\n    function _getFullDebt(Currency currency) internal view returns (uint256 amount) {\n        int256 _amount = poolManager.currencyDelta(address(this), currency);\n        // If the amount is positive, it should be taken not settled.\n        if (_amount > 0) revert DeltaNotNegative(currency);\n        // Casting is safe due to limits on the total supply of a pool\n        amount = uint256(-_amount);\n    }\n\n    /// @notice Obtain the full credit owed to this contract (positive delta)\n    /// @param currency Currency to get the delta for\n    /// @return amount The amount owed to this contract as a uint256\n    function _getFullCredit(Currency currency) internal view returns (uint256 amount) {\n        int256 _amount = poolManager.currencyDelta(address(this), currency);\n        // If the amount is negative, it should be settled not taken.\n        if (_amount < 0) revert DeltaNotPositive(currency);\n        amount = uint256(_amount);\n    }\n\n    /// @notice Calculates the amount for a settle action\n    function _mapSettleAmount(uint256 amount, Currency currency) internal view returns (uint256) {\n        if (amount == ActionConstants.CONTRACT_BALANCE) {\n            return currency.balanceOfSelf();\n        } else if (amount == ActionConstants.OPEN_DELTA) {\n            return _getFullDebt(currency);\n        } else {\n            return amount;\n        }\n    }\n\n    /// @notice Calculates the amount for a take action\n    function _mapTakeAmount(uint256 amount, Currency currency) internal view returns (uint256) {\n        if (amount == ActionConstants.OPEN_DELTA) {\n            return _getFullCredit(currency);\n        } else {\n            return amount;\n        }\n    }\n\n    /// @notice Calculates the sanitized amount before wrapping/unwrapping.\n    /// @param inputCurrency The currency, either native or wrapped native, that this contract holds\n    /// @param amount The amount to wrap or unwrap. Can be CONTRACT_BALANCE, OPEN_DELTA or a specific amount\n    /// @param outputCurrency The currency after the wrap/unwrap that the user may owe a balance in on the poolManager\n    function _mapWrapUnwrapAmount(Currency inputCurrency, uint256 amount, Currency outputCurrency)\n        internal\n        view\n        returns (uint256)\n    {\n        // if wrapping, the balance in this contract is in ETH\n        // if unwrapping, the balance in this contract is in WETH\n        uint256 balance = inputCurrency.balanceOf(address(this));\n        if (amount == ActionConstants.CONTRACT_BALANCE) {\n            // return early to avoid unnecessary balance check\n            return balance;\n        }\n        if (amount == ActionConstants.OPEN_DELTA) {\n            // if wrapping, the open currency on the PoolManager is WETH.\n            // if unwrapping, the open currency on the PoolManager is ETH.\n            // note that we use the DEBT amount. Positive deltas can be taken and then wrapped.\n            amount = _getFullDebt(outputCurrency);\n        }\n        if (amount > balance) revert InsufficientBalance();\n        return amount;\n    }\n}\n"},"lib/v4-periphery/src/base/EIP712_v4.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport {IEIP712_v4} from \"../interfaces/IEIP712_v4.sol\";\n\n/// @notice Generic EIP712 implementation\n/// @dev Maintains cross-chain replay protection in the event of a fork\n/// @dev Should not be delegatecall'd because DOMAIN_SEPARATOR returns the cached hash and does not recompute with the delegatecallers address\n/// @dev Reference: https://github.com/Uniswap/permit2/blob/3f17e8db813189a03950dc7fc8382524a095c053/src/EIP712.sol\n/// @dev Reference: https://github.com/OpenZeppelin/openzeppelin-contracts/blob/7bd2b2aaf68c21277097166a9a51eb72ae239b34/contracts/utils/cryptography/EIP712.sol\ncontract EIP712_v4 is IEIP712_v4 {\n    // Cache the domain separator as an immutable value, but also store the chain id that it\n    // corresponds to, in order to invalidate the cached domain separator if the chain id changes.\n    bytes32 private immutable _CACHED_DOMAIN_SEPARATOR;\n    uint256 private immutable _CACHED_CHAIN_ID;\n    bytes32 private immutable _HASHED_NAME;\n\n    bytes32 private constant _TYPE_HASH =\n        keccak256(\"EIP712Domain(string name,uint256 chainId,address verifyingContract)\");\n\n    constructor(string memory name) {\n        _HASHED_NAME = keccak256(bytes(name));\n\n        _CACHED_CHAIN_ID = block.chainid;\n        _CACHED_DOMAIN_SEPARATOR = _buildDomainSeparator();\n    }\n\n    /// @inheritdoc IEIP712_v4\n    function DOMAIN_SEPARATOR() public view returns (bytes32) {\n        // uses cached version if chainid is unchanged from construction\n        return block.chainid == _CACHED_CHAIN_ID ? _CACHED_DOMAIN_SEPARATOR : _buildDomainSeparator();\n    }\n\n    /// @notice Builds a domain separator using the current chainId and contract address.\n    function _buildDomainSeparator() private view returns (bytes32) {\n        return keccak256(abi.encode(_TYPE_HASH, _HASHED_NAME, block.chainid, address(this)));\n    }\n\n    /// @notice Creates an EIP-712 typed data hash\n    function _hashTypedData(bytes32 dataHash) internal view returns (bytes32 digest) {\n        // equal to keccak256(abi.encodePacked(\"\\x19\\x01\", DOMAIN_SEPARATOR(), dataHash));\n        bytes32 domainSeparator = DOMAIN_SEPARATOR();\n        assembly (\"memory-safe\") {\n            let fmp := mload(0x40)\n            mstore(fmp, hex\"1901\")\n            mstore(add(fmp, 0x02), domainSeparator)\n            mstore(add(fmp, 0x22), dataHash)\n            digest := keccak256(fmp, 0x42)\n\n            // now clean the memory we used\n            mstore(fmp, 0) // fmp held \"\\x19\\x01\", domainSeparator\n            mstore(add(fmp, 0x20), 0) // fmp+0x20 held domainSeparator, dataHash\n            mstore(add(fmp, 0x40), 0) // fmp+0x40 held dataHash\n        }\n    }\n}\n"},"lib/v4-periphery/src/base/ERC721Permit_v4.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport {ERC721} from \"solmate/src/tokens/ERC721.sol\";\nimport {EIP712_v4} from \"./EIP712_v4.sol\";\nimport {ERC721PermitHash} from \"../libraries/ERC721PermitHash.sol\";\nimport {SignatureVerification} from \"permit2/src/libraries/SignatureVerification.sol\";\n\nimport {IERC721Permit_v4} from \"../interfaces/IERC721Permit_v4.sol\";\nimport {UnorderedNonce} from \"./UnorderedNonce.sol\";\n\n/// @title ERC721 with permit\n/// @notice Nonfungible tokens that support an approve via signature, i.e. permit\nabstract contract ERC721Permit_v4 is ERC721, IERC721Permit_v4, EIP712_v4, UnorderedNonce {\n    using SignatureVerification for bytes;\n\n    /// @notice Computes the nameHash and versionHash\n    constructor(string memory name_, string memory symbol_) ERC721(name_, symbol_) EIP712_v4(name_) {}\n\n    /// @notice Checks if the block's timestamp is before a signature's deadline\n    modifier checkSignatureDeadline(uint256 deadline) {\n        if (block.timestamp > deadline) revert SignatureDeadlineExpired();\n        _;\n    }\n\n    /// @inheritdoc IERC721Permit_v4\n    function permit(address spender, uint256 tokenId, uint256 deadline, uint256 nonce, bytes calldata signature)\n        external\n        payable\n        checkSignatureDeadline(deadline)\n    {\n        // the .verify function checks the owner is non-0\n        address owner = _ownerOf[tokenId];\n\n        bytes32 digest = ERC721PermitHash.hashPermit(spender, tokenId, nonce, deadline);\n        signature.verify(_hashTypedData(digest), owner);\n\n        _useUnorderedNonce(owner, nonce);\n        _approve(owner, spender, tokenId);\n    }\n\n    /// @inheritdoc IERC721Permit_v4\n    function permitForAll(\n        address owner,\n        address operator,\n        bool approved,\n        uint256 deadline,\n        uint256 nonce,\n        bytes calldata signature\n    ) external payable checkSignatureDeadline(deadline) {\n        bytes32 digest = ERC721PermitHash.hashPermitForAll(operator, approved, nonce, deadline);\n        signature.verify(_hashTypedData(digest), owner);\n\n        _useUnorderedNonce(owner, nonce);\n        _approveForAll(owner, operator, approved);\n    }\n\n    /// @notice Enable or disable approval for a third party (\"operator\") to manage\n    /// all of `msg.sender`'s assets\n    /// @dev Emits the ApprovalForAll event. The contract MUST allow\n    /// multiple operators per owner.\n    /// @dev Override Solmate's ERC721 setApprovalForAll so setApprovalForAll() and permit() share the _approveForAll method\n    /// @param operator Address to add to the set of authorized operators\n    /// @param approved True if the operator is approved, false to revoke approval\n    function setApprovalForAll(address operator, bool approved) public override {\n        _approveForAll(msg.sender, operator, approved);\n    }\n\n    function _approveForAll(address owner, address operator, bool approved) internal {\n        isApprovedForAll[owner][operator] = approved;\n        emit ApprovalForAll(owner, operator, approved);\n    }\n\n    /// @notice Change or reaffirm the approved address for an NFT\n    /// @dev override Solmate's ERC721 approve so approve() and permit() share the _approve method\n    /// Passing a spender address of zero can be used to remove any outstanding approvals\n    /// Throws error unless `msg.sender` is the current NFT owner,\n    /// or an authorized operator of the current owner.\n    /// @param spender The new approved NFT controller\n    /// @param id The tokenId of the NFT to approve\n    function approve(address spender, uint256 id) public override {\n        address owner = _ownerOf[id];\n\n        if (msg.sender != owner && !isApprovedForAll[owner][msg.sender]) revert Unauthorized();\n\n        _approve(owner, spender, id);\n    }\n\n    function _approve(address owner, address spender, uint256 id) internal {\n        getApproved[id] = spender;\n        emit Approval(owner, spender, id);\n    }\n\n    function _isApprovedOrOwner(address spender, uint256 tokenId) internal view returns (bool) {\n        return spender == ownerOf(tokenId) || getApproved[tokenId] == spender\n            || isApprovedForAll[ownerOf(tokenId)][spender];\n    }\n}\n"},"lib/v4-periphery/src/base/ImmutableState.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport {IPoolManager} from \"@uniswap/v4-core/src/interfaces/IPoolManager.sol\";\nimport {IImmutableState} from \"../interfaces/IImmutableState.sol\";\n\n/// @title Immutable State\n/// @notice A collection of immutable state variables, commonly used across multiple contracts\ncontract ImmutableState is IImmutableState {\n    /// @inheritdoc IImmutableState\n    IPoolManager public immutable poolManager;\n\n    /// @notice Thrown when the caller is not PoolManager\n    error NotPoolManager();\n\n    /// @notice Only allow calls from the PoolManager contract\n    modifier onlyPoolManager() {\n        if (msg.sender != address(poolManager)) revert NotPoolManager();\n        _;\n    }\n\n    constructor(IPoolManager _poolManager) {\n        poolManager = _poolManager;\n    }\n}\n"},"lib/v4-periphery/src/base/Multicall_v4.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport {IMulticall_v4} from \"../interfaces/IMulticall_v4.sol\";\n\n/// @title Multicall_v4\n/// @notice Enables calling multiple methods in a single call to the contract\nabstract contract Multicall_v4 is IMulticall_v4 {\n    /// @inheritdoc IMulticall_v4\n    function multicall(bytes[] calldata data) external payable returns (bytes[] memory results) {\n        results = new bytes[](data.length);\n        for (uint256 i = 0; i < data.length; i++) {\n            (bool success, bytes memory result) = address(this).delegatecall(data[i]);\n\n            if (!success) {\n                // bubble up the revert reason\n                assembly {\n                    revert(add(result, 0x20), mload(result))\n                }\n            }\n\n            results[i] = result;\n        }\n    }\n}\n"},"lib/v4-periphery/src/base/NativeWrapper.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport {IWETH9} from \"../interfaces/external/IWETH9.sol\";\nimport {ActionConstants} from \"../libraries/ActionConstants.sol\";\nimport {ImmutableState} from \"./ImmutableState.sol\";\n\n/// @title Native Wrapper\n/// @notice Used for wrapping and unwrapping native\nabstract contract NativeWrapper is ImmutableState {\n    /// @notice The address for WETH9\n    IWETH9 public immutable WETH9;\n\n    /// @notice Thrown when an unexpected address sends ETH to this contract\n    error InvalidEthSender();\n\n    constructor(IWETH9 _weth9) {\n        WETH9 = _weth9;\n    }\n\n    /// @dev The amount should already be <= the current balance in this contract.\n    function _wrap(uint256 amount) internal {\n        if (amount > 0) WETH9.deposit{value: amount}();\n    }\n\n    /// @dev The amount should already be <= the current balance in this contract.\n    function _unwrap(uint256 amount) internal {\n        if (amount > 0) WETH9.withdraw(amount);\n    }\n\n    receive() external payable {\n        if (msg.sender != address(WETH9) && msg.sender != address(poolManager)) revert InvalidEthSender();\n    }\n}\n"},"lib/v4-periphery/src/base/Notifier.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport {ISubscriber} from \"../interfaces/ISubscriber.sol\";\nimport {INotifier} from \"../interfaces/INotifier.sol\";\nimport {CustomRevert} from \"@uniswap/v4-core/src/libraries/CustomRevert.sol\";\nimport {BalanceDelta} from \"@uniswap/v4-core/src/types/BalanceDelta.sol\";\nimport {PositionInfo} from \"../libraries/PositionInfoLibrary.sol\";\n\n/// @notice Notifier is used to opt in to sending updates to external contracts about position modifications or transfers\nabstract contract Notifier is INotifier {\n    using CustomRevert for *;\n\n    ISubscriber private constant NO_SUBSCRIBER = ISubscriber(address(0));\n\n    /// @inheritdoc INotifier\n    uint256 public immutable unsubscribeGasLimit;\n\n    /// @inheritdoc INotifier\n    mapping(uint256 tokenId => ISubscriber subscriber) public subscriber;\n\n    constructor(uint256 _unsubscribeGasLimit) {\n        unsubscribeGasLimit = _unsubscribeGasLimit;\n    }\n\n    /// @notice Only allow callers that are approved as spenders or operators of the tokenId\n    /// @dev to be implemented by the parent contract (PositionManager)\n    /// @param caller the address of the caller\n    /// @param tokenId the tokenId of the position\n    modifier onlyIfApproved(address caller, uint256 tokenId) virtual;\n\n    /// @notice Enforces that the PoolManager is locked.\n    modifier onlyIfPoolManagerLocked() virtual;\n\n    function _setUnsubscribed(uint256 tokenId) internal virtual;\n\n    function _setSubscribed(uint256 tokenId) internal virtual;\n\n    /// @inheritdoc INotifier\n    function subscribe(uint256 tokenId, address newSubscriber, bytes calldata data)\n        external\n        payable\n        onlyIfPoolManagerLocked\n        onlyIfApproved(msg.sender, tokenId)\n    {\n        ISubscriber _subscriber = subscriber[tokenId];\n\n        if (_subscriber != NO_SUBSCRIBER) revert AlreadySubscribed(tokenId, address(_subscriber));\n        _setSubscribed(tokenId);\n\n        subscriber[tokenId] = ISubscriber(newSubscriber);\n\n        bool success = _call(newSubscriber, abi.encodeCall(ISubscriber.notifySubscribe, (tokenId, data)));\n\n        if (!success) {\n            newSubscriber.bubbleUpAndRevertWith(ISubscriber.notifySubscribe.selector, SubscriptionReverted.selector);\n        }\n\n        emit Subscription(tokenId, newSubscriber);\n    }\n\n    /// @inheritdoc INotifier\n    function unsubscribe(uint256 tokenId)\n        external\n        payable\n        onlyIfPoolManagerLocked\n        onlyIfApproved(msg.sender, tokenId)\n    {\n        _unsubscribe(tokenId);\n    }\n\n    function _unsubscribe(uint256 tokenId) internal {\n        ISubscriber _subscriber = subscriber[tokenId];\n\n        if (_subscriber == NO_SUBSCRIBER) revert NotSubscribed();\n        _setUnsubscribed(tokenId);\n\n        delete subscriber[tokenId];\n\n        if (address(_subscriber).code.length > 0) {\n            // require that the remaining gas is sufficient to notify the subscriber\n            // otherwise, users can select a gas limit where .notifyUnsubscribe hits OutOfGas yet the\n            // transaction/unsubscription can still succeed\n            if (gasleft() < unsubscribeGasLimit) GasLimitTooLow.selector.revertWith();\n            try _subscriber.notifyUnsubscribe{gas: unsubscribeGasLimit}(tokenId) {} catch {}\n        }\n\n        emit Unsubscription(tokenId, address(_subscriber));\n    }\n\n    /// @dev note this function also deletes the subscriber address from the mapping\n    function _removeSubscriberAndNotifyBurn(\n        uint256 tokenId,\n        address owner,\n        PositionInfo info,\n        uint256 liquidity,\n        BalanceDelta feesAccrued\n    ) internal {\n        address _subscriber = address(subscriber[tokenId]);\n\n        // remove the subscriber\n        delete subscriber[tokenId];\n\n        bool success =\n            _call(_subscriber, abi.encodeCall(ISubscriber.notifyBurn, (tokenId, owner, info, liquidity, feesAccrued)));\n\n        if (!success) {\n            _subscriber.bubbleUpAndRevertWith(ISubscriber.notifyBurn.selector, BurnNotificationReverted.selector);\n        }\n    }\n\n    function _notifyModifyLiquidity(uint256 tokenId, int256 liquidityChange, BalanceDelta feesAccrued) internal {\n        address _subscriber = address(subscriber[tokenId]);\n\n        bool success = _call(\n            _subscriber, abi.encodeCall(ISubscriber.notifyModifyLiquidity, (tokenId, liquidityChange, feesAccrued))\n        );\n\n        if (!success) {\n            _subscriber.bubbleUpAndRevertWith(\n                ISubscriber.notifyModifyLiquidity.selector, ModifyLiquidityNotificationReverted.selector\n            );\n        }\n    }\n\n    function _call(address target, bytes memory encodedCall) internal returns (bool success) {\n        if (target.code.length == 0) NoCodeSubscriber.selector.revertWith();\n        assembly (\"memory-safe\") {\n            success := call(gas(), target, 0, add(encodedCall, 0x20), mload(encodedCall), 0, 0)\n        }\n    }\n}\n"},"lib/v4-periphery/src/base/Permit2Forwarder.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport {IPermit2Forwarder, IAllowanceTransfer} from \"../interfaces/IPermit2Forwarder.sol\";\n\n/// @notice Permit2Forwarder allows permitting this contract as a spender on permit2\n/// @dev This contract does not enforce the spender to be this contract, but that is the intended use case\ncontract Permit2Forwarder is IPermit2Forwarder {\n    /// @notice the Permit2 contract to forward approvals\n    IAllowanceTransfer public immutable permit2;\n\n    constructor(IAllowanceTransfer _permit2) {\n        permit2 = _permit2;\n    }\n\n    /// @inheritdoc IPermit2Forwarder\n    function permit(address owner, IAllowanceTransfer.PermitSingle calldata permitSingle, bytes calldata signature)\n        external\n        payable\n        returns (bytes memory err)\n    {\n        // use try/catch in case an actor front-runs the permit, which would DOS multicalls\n        try permit2.permit(owner, permitSingle, signature) {}\n        catch (bytes memory reason) {\n            err = reason;\n        }\n    }\n\n    /// @inheritdoc IPermit2Forwarder\n    function permitBatch(address owner, IAllowanceTransfer.PermitBatch calldata _permitBatch, bytes calldata signature)\n        external\n        payable\n        returns (bytes memory err)\n    {\n        // use try/catch in case an actor front-runs the permit, which would DOS multicalls\n        try permit2.permit(owner, _permitBatch, signature) {}\n        catch (bytes memory reason) {\n            err = reason;\n        }\n    }\n}\n"},"lib/v4-periphery/src/base/PoolInitializer_v4.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport {ImmutableState} from \"./ImmutableState.sol\";\nimport {PoolKey} from \"@uniswap/v4-core/src/types/PoolKey.sol\";\nimport {IPoolInitializer_v4} from \"../interfaces/IPoolInitializer_v4.sol\";\n\n/// @title Pool Initializer\n/// @notice Initializes a Uniswap v4 Pool\n/// @dev Enables create pool + mint liquidity in a single transaction with multicall\nabstract contract PoolInitializer_v4 is ImmutableState, IPoolInitializer_v4 {\n    /// @inheritdoc IPoolInitializer_v4\n    function initializePool(PoolKey calldata key, uint160 sqrtPriceX96) external payable returns (int24) {\n        try poolManager.initialize(key, sqrtPriceX96) returns (int24 tick) {\n            return tick;\n        } catch {\n            return type(int24).max;\n        }\n    }\n}\n"},"lib/v4-periphery/src/base/ReentrancyLock.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity ^0.8.24;\n\nimport {Locker} from \"../libraries/Locker.sol\";\n\n/// @notice A transient reentrancy lock, that stores the caller's address as the lock\ncontract ReentrancyLock {\n    error ContractLocked();\n\n    modifier isNotLocked() {\n        if (Locker.get() != address(0)) revert ContractLocked();\n        Locker.set(msg.sender);\n        _;\n        Locker.set(address(0));\n    }\n\n    function _getLocker() internal view returns (address) {\n        return Locker.get();\n    }\n}\n"},"lib/v4-periphery/src/base/SafeCallback.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport {IUnlockCallback} from \"@uniswap/v4-core/src/interfaces/callback/IUnlockCallback.sol\";\nimport {IPoolManager} from \"@uniswap/v4-core/src/interfaces/IPoolManager.sol\";\nimport {ImmutableState} from \"./ImmutableState.sol\";\n\n/// @title Safe Callback\n/// @notice A contract that only allows the Uniswap v4 PoolManager to call the unlockCallback\nabstract contract SafeCallback is ImmutableState, IUnlockCallback {\n    constructor(IPoolManager _poolManager) ImmutableState(_poolManager) {}\n\n    /// @inheritdoc IUnlockCallback\n    /// @dev We force the onlyPoolManager modifier by exposing a virtual function after the onlyPoolManager check.\n    function unlockCallback(bytes calldata data) external onlyPoolManager returns (bytes memory) {\n        return _unlockCallback(data);\n    }\n\n    /// @dev to be implemented by the child contract, to safely guarantee the logic is only executed by the PoolManager\n    function _unlockCallback(bytes calldata data) internal virtual returns (bytes memory);\n}\n"},"lib/v4-periphery/src/base/UnorderedNonce.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport {IUnorderedNonce} from \"../interfaces/IUnorderedNonce.sol\";\n\n/// @title Unordered Nonce\n/// @notice Contract state and methods for using unordered nonces in signatures\ncontract UnorderedNonce is IUnorderedNonce {\n    /// @inheritdoc IUnorderedNonce\n    mapping(address owner => mapping(uint256 word => uint256 bitmap)) public nonces;\n\n    /// @notice Consume a nonce, reverting if it has already been used\n    /// @param owner address, the owner/signer of the nonce\n    /// @param nonce uint256, the nonce to consume. The top 248 bits are the word, the bottom 8 bits indicate the bit position\n    function _useUnorderedNonce(address owner, uint256 nonce) internal {\n        uint256 wordPos = nonce >> 8;\n        uint256 bitPos = uint8(nonce);\n\n        uint256 bit = 1 << bitPos;\n        uint256 flipped = nonces[owner][wordPos] ^= bit;\n        if (flipped & bit == 0) revert NonceAlreadyUsed();\n    }\n\n    /// @inheritdoc IUnorderedNonce\n    function revokeNonce(uint256 nonce) external payable {\n        _useUnorderedNonce(msg.sender, nonce);\n    }\n}\n"},"lib/v4-periphery/src/interfaces/IEIP712_v4.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\n/// @title IEIP712_v4\n/// @notice Interface for the EIP712 contract\ninterface IEIP712_v4 {\n    /// @notice Returns the domain separator for the current chain.\n    /// @return bytes32 The domain separator\n    function DOMAIN_SEPARATOR() external view returns (bytes32);\n}\n"},"lib/v4-periphery/src/interfaces/IERC721Permit_v4.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\n/// @title IERC721Permit_v4\n/// @notice Interface for the ERC721Permit_v4 contract\ninterface IERC721Permit_v4 {\n    error SignatureDeadlineExpired();\n    error NoSelfPermit();\n    error Unauthorized();\n\n    /// @notice Approve of a specific token ID for spending by spender via signature\n    /// @param spender The account that is being approved\n    /// @param tokenId The ID of the token that is being approved for spending\n    /// @param deadline The deadline timestamp by which the call must be mined for the approve to work\n    /// @param nonce a unique value, for an owner, to prevent replay attacks; an unordered nonce where the top 248 bits correspond to a word and the bottom 8 bits calculate the bit position of the word\n    /// @param signature Concatenated data from a valid secp256k1 signature from the holder, i.e. abi.encodePacked(r, s, v)\n    /// @dev payable so it can be multicalled with NATIVE related actions\n    function permit(address spender, uint256 tokenId, uint256 deadline, uint256 nonce, bytes calldata signature)\n        external\n        payable;\n\n    /// @notice Set an operator with full permission to an owner's tokens via signature\n    /// @param owner The address that is setting the operator\n    /// @param operator The address that will be set as an operator for the owner\n    /// @param approved The permission to set on the operator\n    /// @param deadline The deadline timestamp by which the call must be mined for the approve to work\n    /// @param nonce a unique value, for an owner, to prevent replay attacks; an unordered nonce where the top 248 bits correspond to a word and the bottom 8 bits calculate the bit position of the word\n    /// @param signature Concatenated data from a valid secp256k1 signature from the holder, i.e. abi.encodePacked(r, s, v)\n    /// @dev payable so it can be multicalled with NATIVE related actions\n    function permitForAll(\n        address owner,\n        address operator,\n        bool approved,\n        uint256 deadline,\n        uint256 nonce,\n        bytes calldata signature\n    ) external payable;\n}\n"},"lib/v4-periphery/src/interfaces/IImmutableState.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport {IPoolManager} from \"@uniswap/v4-core/src/interfaces/IPoolManager.sol\";\n\n/// @title IImmutableState\n/// @notice Interface for the ImmutableState contract\ninterface IImmutableState {\n    /// @notice The Uniswap v4 PoolManager contract\n    function poolManager() external view returns (IPoolManager);\n}\n"},"lib/v4-periphery/src/interfaces/IMulticall_v4.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\n/// @title IMulticall_v4\n/// @notice Interface for the Multicall_v4 contract\ninterface IMulticall_v4 {\n    /// @notice Call multiple functions in the current contract and return the data from all of them if they all succeed\n    /// @dev The `msg.value` is passed onto all subcalls, even if a previous subcall has consumed the ether.\n    /// Subcalls can instead use `address(this).value` to see the available ETH, and consume it using {value: x}.\n    /// @param data The encoded function data for each of the calls to make to this contract\n    /// @return results The results from each of the calls passed in via data\n    function multicall(bytes[] calldata data) external payable returns (bytes[] memory results);\n}\n"},"lib/v4-periphery/src/interfaces/INotifier.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport {ISubscriber} from \"./ISubscriber.sol\";\n\n/// @title INotifier\n/// @notice Interface for the Notifier contract\ninterface INotifier {\n    /// @notice Thrown when unsubscribing without a subscriber\n    error NotSubscribed();\n    /// @notice Thrown when a subscriber does not have code\n    error NoCodeSubscriber();\n    /// @notice Thrown when a user specifies a gas limit too low to avoid valid unsubscribe notifications\n    error GasLimitTooLow();\n    /// @notice Wraps the revert message of the subscriber contract on a reverting subscription\n    error SubscriptionReverted(address subscriber, bytes reason);\n    /// @notice Wraps the revert message of the subscriber contract on a reverting modify liquidity notification\n    error ModifyLiquidityNotificationReverted(address subscriber, bytes reason);\n    /// @notice Wraps the revert message of the subscriber contract on a reverting burn notification\n    error BurnNotificationReverted(address subscriber, bytes reason);\n    /// @notice Thrown when a tokenId already has a subscriber\n    error AlreadySubscribed(uint256 tokenId, address subscriber);\n\n    /// @notice Emitted on a successful call to subscribe\n    event Subscription(uint256 indexed tokenId, address indexed subscriber);\n    /// @notice Emitted on a successful call to unsubscribe\n    event Unsubscription(uint256 indexed tokenId, address indexed subscriber);\n\n    /// @notice Returns the subscriber for a respective position\n    /// @param tokenId the ERC721 tokenId\n    /// @return subscriber the subscriber contract\n    function subscriber(uint256 tokenId) external view returns (ISubscriber subscriber);\n\n    /// @notice Enables the subscriber to receive notifications for a respective position\n    /// @param tokenId the ERC721 tokenId\n    /// @param newSubscriber the address of the subscriber contract\n    /// @param data caller-provided data that's forwarded to the subscriber contract\n    /// @dev Calling subscribe when a position is already subscribed will revert\n    /// @dev payable so it can be multicalled with NATIVE related actions\n    /// @dev will revert if pool manager is locked\n    function subscribe(uint256 tokenId, address newSubscriber, bytes calldata data) external payable;\n\n    /// @notice Removes the subscriber from receiving notifications for a respective position\n    /// @param tokenId the ERC721 tokenId\n    /// @dev Callers must specify a high gas limit (remaining gas should be higher than unsubscriberGasLimit) such that the subscriber can be notified\n    /// @dev payable so it can be multicalled with NATIVE related actions\n    /// @dev Must always allow a user to unsubscribe. In the case of a malicious subscriber, a user can always unsubscribe safely, ensuring liquidity is always modifiable.\n    /// @dev will revert if pool manager is locked\n    function unsubscribe(uint256 tokenId) external payable;\n\n    /// @notice Returns and determines the maximum allowable gas-used for notifying unsubscribe\n    /// @return uint256 the maximum gas limit when notifying a subscriber's `notifyUnsubscribe` function\n    function unsubscribeGasLimit() external view returns (uint256);\n}\n"},"lib/v4-periphery/src/interfaces/IPermit2Forwarder.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport {IAllowanceTransfer} from \"permit2/src/interfaces/IAllowanceTransfer.sol\";\n\n/// @title IPermit2Forwarder\n/// @notice Interface for the Permit2Forwarder contract\ninterface IPermit2Forwarder {\n    /// @notice allows forwarding a single permit to permit2\n    /// @dev this function is payable to allow multicall with NATIVE based actions\n    /// @param owner the owner of the tokens\n    /// @param permitSingle the permit data\n    /// @param signature the signature of the permit; abi.encodePacked(r, s, v)\n    /// @return err the error returned by a reverting permit call, empty if successful\n    function permit(address owner, IAllowanceTransfer.PermitSingle calldata permitSingle, bytes calldata signature)\n        external\n        payable\n        returns (bytes memory err);\n\n    /// @notice allows forwarding batch permits to permit2\n    /// @dev this function is payable to allow multicall with NATIVE based actions\n    /// @param owner the owner of the tokens\n    /// @param _permitBatch a batch of approvals\n    /// @param signature the signature of the permit; abi.encodePacked(r, s, v)\n    /// @return err the error returned by a reverting permit call, empty if successful\n    function permitBatch(address owner, IAllowanceTransfer.PermitBatch calldata _permitBatch, bytes calldata signature)\n        external\n        payable\n        returns (bytes memory err);\n}\n"},"lib/v4-periphery/src/interfaces/IPoolInitializer_v4.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport {PoolKey} from \"@uniswap/v4-core/src/types/PoolKey.sol\";\n\n/// @title IPoolInitializer_v4\n/// @notice Interface for the PoolInitializer_v4 contract\ninterface IPoolInitializer_v4 {\n    /// @notice Initialize a Uniswap v4 Pool\n    /// @dev If the pool is already initialized, this function will not revert and just return type(int24).max\n    /// @param key The PoolKey of the pool to initialize\n    /// @param sqrtPriceX96 The initial starting price of the pool, expressed as a sqrtPriceX96\n    /// @return The current tick of the pool, or type(int24).max if the pool creation failed, or the pool already existed\n    function initializePool(PoolKey calldata key, uint160 sqrtPriceX96) external payable returns (int24);\n}\n"},"lib/v4-periphery/src/interfaces/IPositionDescriptor.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity ^0.8.24;\n\nimport \"./IPositionManager.sol\";\nimport {IPoolManager} from \"@uniswap/v4-core/src/interfaces/IPoolManager.sol\";\n\n/// @title IPositionDescriptor\n/// @notice Interface for the PositionDescriptor contract\ninterface IPositionDescriptor {\n    error InvalidTokenId(uint256 tokenId);\n\n    /// @notice Produces the URI describing a particular token ID\n    /// @dev Note this URI may be a data: URI with the JSON contents directly inlined\n    /// @param positionManager The position manager for which to describe the token\n    /// @param tokenId The ID of the token for which to produce a description, which may not be valid\n    /// @return The URI of the ERC721-compliant metadata\n    function tokenURI(IPositionManager positionManager, uint256 tokenId) external view returns (string memory);\n\n    /// @notice Returns true if currency0 has higher priority than currency1\n    /// @param currency0 The first currency address\n    /// @param currency1 The second currency address\n    /// @return True if currency0 has higher priority than currency1\n    function flipRatio(address currency0, address currency1) external view returns (bool);\n\n    /// @notice Returns the priority of a currency.\n    /// For certain currencies on mainnet, the smaller the currency, the higher the priority\n    /// And those with the higher priority values (more positive values) will be in the numerator of the price ratio\n    /// @param currency The currency address\n    /// @return The priority of the currency\n    function currencyRatioPriority(address currency) external view returns (int256);\n\n    /// @return The wrapped native token for this descriptor\n    function wrappedNative() external view returns (address);\n\n    /// @return The native currency label for this descriptor\n    function nativeCurrencyLabel() external view returns (string memory);\n\n    /// @return The pool manager for this descriptor\n    function poolManager() external view returns (IPoolManager);\n}\n"},"lib/v4-periphery/src/interfaces/IPositionManager.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport {PoolKey} from \"@uniswap/v4-core/src/types/PoolKey.sol\";\nimport {PositionInfo} from \"../libraries/PositionInfoLibrary.sol\";\n\nimport {INotifier} from \"./INotifier.sol\";\nimport {IImmutableState} from \"./IImmutableState.sol\";\nimport {IERC721Permit_v4} from \"./IERC721Permit_v4.sol\";\nimport {IEIP712_v4} from \"./IEIP712_v4.sol\";\nimport {IMulticall_v4} from \"./IMulticall_v4.sol\";\nimport {IPoolInitializer_v4} from \"./IPoolInitializer_v4.sol\";\nimport {IUnorderedNonce} from \"./IUnorderedNonce.sol\";\nimport {IPermit2Forwarder} from \"./IPermit2Forwarder.sol\";\n\n/// @title IPositionManager\n/// @notice Interface for the PositionManager contract\ninterface IPositionManager is\n    INotifier,\n    IImmutableState,\n    IERC721Permit_v4,\n    IEIP712_v4,\n    IMulticall_v4,\n    IPoolInitializer_v4,\n    IUnorderedNonce,\n    IPermit2Forwarder\n{\n    /// @notice Thrown when the caller is not approved to modify a position\n    error NotApproved(address caller);\n    /// @notice Thrown when the block.timestamp exceeds the user-provided deadline\n    error DeadlinePassed(uint256 deadline);\n    /// @notice Thrown when calling transfer, subscribe, or unsubscribe when the PoolManager is unlocked.\n    /// @dev This is to prevent hooks from being able to trigger notifications at the same time the position is being modified.\n    error PoolManagerMustBeLocked();\n\n    /// @notice Unlocks Uniswap v4 PoolManager and batches actions for modifying liquidity\n    /// @dev This is the standard entrypoint for the PositionManager\n    /// @param unlockData is an encoding of actions, and parameters for those actions\n    /// @param deadline is the deadline for the batched actions to be executed\n    function modifyLiquidities(bytes calldata unlockData, uint256 deadline) external payable;\n\n    /// @notice Batches actions for modifying liquidity without unlocking v4 PoolManager\n    /// @dev This must be called by a contract that has already unlocked the v4 PoolManager\n    /// @param actions the actions to perform\n    /// @param params the parameters to provide for the actions\n    function modifyLiquiditiesWithoutUnlock(bytes calldata actions, bytes[] calldata params) external payable;\n\n    /// @notice Used to get the ID that will be used for the next minted liquidity position\n    /// @return uint256 The next token ID\n    function nextTokenId() external view returns (uint256);\n\n    /// @notice Returns the liquidity of a position\n    /// @param tokenId the ERC721 tokenId\n    /// @return liquidity the position's liquidity, as a liquidityAmount\n    /// @dev this value can be processed as an amount0 and amount1 by using the LiquidityAmounts library\n    function getPositionLiquidity(uint256 tokenId) external view returns (uint128 liquidity);\n\n    /// @notice Returns the pool key and position info of a position\n    /// @param tokenId the ERC721 tokenId\n    /// @return poolKey the pool key of the position\n    /// @return PositionInfo a uint256 packed value holding information about the position including the range (tickLower, tickUpper)\n    function getPoolAndPositionInfo(uint256 tokenId) external view returns (PoolKey memory, PositionInfo);\n\n    /// @notice Returns the position info of a position\n    /// @param tokenId the ERC721 tokenId\n    /// @return a uint256 packed value holding information about the position including the range (tickLower, tickUpper)\n    function positionInfo(uint256 tokenId) external view returns (PositionInfo);\n}\n"},"lib/v4-periphery/src/interfaces/ISubscriber.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport {BalanceDelta} from \"@uniswap/v4-core/src/types/BalanceDelta.sol\";\nimport {PositionInfo} from \"../libraries/PositionInfoLibrary.sol\";\n\n/// @title ISubscriber\n/// @notice Interface that a Subscriber contract should implement to receive updates from the v4 position manager\ninterface ISubscriber {\n    /// @notice Called when a position subscribes to this subscriber contract\n    /// @param tokenId the token ID of the position\n    /// @param data additional data passed in by the caller\n    function notifySubscribe(uint256 tokenId, bytes memory data) external;\n\n    /// @notice Called when a position unsubscribes from the subscriber\n    /// @dev This call's gas is capped at `unsubscribeGasLimit` (set at deployment)\n    /// @dev Because of EIP-150, solidity may only allocate 63/64 of gasleft()\n    /// @param tokenId the token ID of the position\n    function notifyUnsubscribe(uint256 tokenId) external;\n\n    /// @notice Called when a position is burned\n    /// @param tokenId the token ID of the position\n    /// @param owner the current owner of the tokenId\n    /// @param info information about the position\n    /// @param liquidity the amount of liquidity decreased in the position, may be 0\n    /// @param feesAccrued the fees accrued by the position if liquidity was decreased\n    function notifyBurn(uint256 tokenId, address owner, PositionInfo info, uint256 liquidity, BalanceDelta feesAccrued)\n        external;\n\n    /// @notice Called when a position modifies its liquidity or collects fees\n    /// @param tokenId the token ID of the position\n    /// @param liquidityChange the change in liquidity on the underlying position\n    /// @param feesAccrued the fees to be collected from the position as a result of the modifyLiquidity call\n    /// @dev Note that feesAccrued can be artificially inflated by a malicious user\n    /// Pools with a single liquidity position can inflate feeGrowthGlobal (and consequently feesAccrued) by donating to themselves;\n    /// atomically donating and collecting fees within the same unlockCallback may further inflate feeGrowthGlobal/feesAccrued\n    function notifyModifyLiquidity(uint256 tokenId, int256 liquidityChange, BalanceDelta feesAccrued) external;\n}\n"},"lib/v4-periphery/src/interfaces/IUnorderedNonce.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\n/// @title IUnorderedNonce\n/// @notice Interface for the UnorderedNonce contract\ninterface IUnorderedNonce {\n    error NonceAlreadyUsed();\n\n    /// @notice mapping of nonces consumed by each address, where a nonce is a single bit on the 256-bit bitmap\n    /// @dev word is at most type(uint248).max\n    function nonces(address owner, uint256 word) external view returns (uint256);\n\n    /// @notice Revoke a nonce by spending it, preventing it from being used again\n    /// @dev Used in cases where a valid nonce has not been broadcasted onchain, and the owner wants to revoke the validity of the nonce\n    /// @dev payable so it can be multicalled with native-token related actions\n    function revokeNonce(uint256 nonce) external payable;\n}\n"},"lib/v4-periphery/src/interfaces/IV4Router.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport {PoolKey} from \"@uniswap/v4-core/src/types/PoolKey.sol\";\nimport {Currency} from \"@uniswap/v4-core/src/types/Currency.sol\";\nimport {PathKey} from \"../libraries/PathKey.sol\";\nimport {IImmutableState} from \"./IImmutableState.sol\";\n\n/// @title IV4Router\n/// @notice Interface for the V4Router contract\ninterface IV4Router is IImmutableState {\n    /// @notice Emitted when an exactInput swap does not receive its minAmountOut\n    error V4TooLittleReceived(uint256 minAmountOutReceived, uint256 amountReceived);\n    /// @notice Emitted when an exactOutput is asked for more than its maxAmountIn\n    error V4TooMuchRequested(uint256 maxAmountInRequested, uint256 amountRequested);\n\n    /// @notice Parameters for a single-hop exact-input swap\n    struct ExactInputSingleParams {\n        PoolKey poolKey;\n        bool zeroForOne;\n        uint128 amountIn;\n        uint128 amountOutMinimum;\n        bytes hookData;\n    }\n\n    /// @notice Parameters for a multi-hop exact-input swap\n    struct ExactInputParams {\n        Currency currencyIn;\n        PathKey[] path;\n        uint128 amountIn;\n        uint128 amountOutMinimum;\n    }\n\n    /// @notice Parameters for a single-hop exact-output swap\n    struct ExactOutputSingleParams {\n        PoolKey poolKey;\n        bool zeroForOne;\n        uint128 amountOut;\n        uint128 amountInMaximum;\n        bytes hookData;\n    }\n\n    /// @notice Parameters for a multi-hop exact-output swap\n    struct ExactOutputParams {\n        Currency currencyOut;\n        PathKey[] path;\n        uint128 amountOut;\n        uint128 amountInMaximum;\n    }\n}\n"},"lib/v4-periphery/src/interfaces/external/IWETH9.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport {IERC20} from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\n\n/// @title IWETH9\ninterface IWETH9 is IERC20 {\n    /// @notice Deposit ether to get wrapped ether\n    function deposit() external payable;\n\n    /// @notice Withdraw wrapped ether to get ether\n    function withdraw(uint256) external;\n}\n"},"lib/v4-periphery/src/libraries/ActionConstants.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\n/// @title Action Constants\n/// @notice Common constants used in actions\n/// @dev Constants are gas efficient alternatives to their literal values\nlibrary ActionConstants {\n    /// @notice used to signal that an action should use the input value of the open delta on the pool manager\n    /// or of the balance that the contract holds\n    uint128 internal constant OPEN_DELTA = 0;\n    /// @notice used to signal that an action should use the contract's entire balance of a currency\n    /// This value is equivalent to 1<<255, i.e. a singular 1 in the most significant bit.\n    uint256 internal constant CONTRACT_BALANCE = 0x8000000000000000000000000000000000000000000000000000000000000000;\n\n    /// @notice used to signal that the recipient of an action should be the msgSender\n    address internal constant MSG_SENDER = address(1);\n\n    /// @notice used to signal that the recipient of an action should be the address(this)\n    address internal constant ADDRESS_THIS = address(2);\n}\n"},"lib/v4-periphery/src/libraries/Actions.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\n/// @notice Library to define different pool actions.\n/// @dev These are suggested common commands, however additional commands should be defined as required\n/// Some of these actions are not supported in the Router contracts or Position Manager contracts, but are left as they may be helpful commands for other peripheral contracts.\nlibrary Actions {\n    // pool actions\n    // liquidity actions\n    uint256 internal constant INCREASE_LIQUIDITY = 0x00;\n    uint256 internal constant DECREASE_LIQUIDITY = 0x01;\n    uint256 internal constant MINT_POSITION = 0x02;\n    uint256 internal constant BURN_POSITION = 0x03;\n    uint256 internal constant INCREASE_LIQUIDITY_FROM_DELTAS = 0x04;\n    uint256 internal constant MINT_POSITION_FROM_DELTAS = 0x05;\n\n    // swapping\n    uint256 internal constant SWAP_EXACT_IN_SINGLE = 0x06;\n    uint256 internal constant SWAP_EXACT_IN = 0x07;\n    uint256 internal constant SWAP_EXACT_OUT_SINGLE = 0x08;\n    uint256 internal constant SWAP_EXACT_OUT = 0x09;\n\n    // donate\n    // note this is not supported in the position manager or router\n    uint256 internal constant DONATE = 0x0a;\n\n    // closing deltas on the pool manager\n    // settling\n    uint256 internal constant SETTLE = 0x0b;\n    uint256 internal constant SETTLE_ALL = 0x0c;\n    uint256 internal constant SETTLE_PAIR = 0x0d;\n    // taking\n    uint256 internal constant TAKE = 0x0e;\n    uint256 internal constant TAKE_ALL = 0x0f;\n    uint256 internal constant TAKE_PORTION = 0x10;\n    uint256 internal constant TAKE_PAIR = 0x11;\n\n    uint256 internal constant CLOSE_CURRENCY = 0x12;\n    uint256 internal constant CLEAR_OR_TAKE = 0x13;\n    uint256 internal constant SWEEP = 0x14;\n\n    uint256 internal constant WRAP = 0x15;\n    uint256 internal constant UNWRAP = 0x16;\n\n    // minting/burning 6909s to close deltas\n    // note this is not supported in the position manager or router\n    uint256 internal constant MINT_6909 = 0x17;\n    uint256 internal constant BURN_6909 = 0x18;\n}\n"},"lib/v4-periphery/src/libraries/CalldataDecoder.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport {Currency} from \"@uniswap/v4-core/src/types/Currency.sol\";\nimport {IV4Router} from \"../interfaces/IV4Router.sol\";\nimport {PoolKey} from \"@uniswap/v4-core/src/types/PoolKey.sol\";\n\n/// @title Library for abi decoding in calldata\nlibrary CalldataDecoder {\n    using CalldataDecoder for bytes;\n\n    error SliceOutOfBounds();\n\n    /// @notice mask used for offsets and lengths to ensure no overflow\n    /// @dev no sane abi encoding will pass in an offset or length greater than type(uint32).max\n    ///      (note that this does deviate from standard solidity behavior and offsets/lengths will\n    ///      be interpreted as mod type(uint32).max which will only impact malicious/buggy callers)\n    uint256 constant OFFSET_OR_LENGTH_MASK = 0xffffffff;\n    uint256 constant OFFSET_OR_LENGTH_MASK_AND_WORD_ALIGN = 0xffffffe0;\n\n    /// @notice equivalent to SliceOutOfBounds.selector, stored in least-significant bits\n    uint256 constant SLICE_ERROR_SELECTOR = 0x3b99b53d;\n\n    /// @dev equivalent to: abi.decode(params, (bytes, bytes[])) in calldata (requires strict abi encoding)\n    function decodeActionsRouterParams(bytes calldata _bytes)\n        internal\n        pure\n        returns (bytes calldata actions, bytes[] calldata params)\n    {\n        assembly (\"memory-safe\") {\n            // Strict encoding requires that the data begin with:\n            // 0x00: 0x40 (offset to `actions.length`)\n            // 0x20: 0x60 + actions.length (offset to `params.length`)\n            // 0x40: `actions.length`\n            // 0x60: beginning of actions\n\n            // Verify actions offset matches strict encoding\n            let invalidData := xor(calldataload(_bytes.offset), 0x40)\n            actions.offset := add(_bytes.offset, 0x60)\n            actions.length := and(calldataload(add(_bytes.offset, 0x40)), OFFSET_OR_LENGTH_MASK)\n\n            // Round actions length up to be word-aligned, and add 0x60 (for the first 3 words of encoding)\n            let paramsLengthOffset := add(and(add(actions.length, 0x1f), OFFSET_OR_LENGTH_MASK_AND_WORD_ALIGN), 0x60)\n            // Verify params offset matches strict encoding\n            invalidData := or(invalidData, xor(calldataload(add(_bytes.offset, 0x20)), paramsLengthOffset))\n            let paramsLengthPointer := add(_bytes.offset, paramsLengthOffset)\n            params.length := and(calldataload(paramsLengthPointer), OFFSET_OR_LENGTH_MASK)\n            params.offset := add(paramsLengthPointer, 0x20)\n\n            // Expected offset for `params[0]` is params.length * 32\n            // As the first `params.length` slots are pointers to each of the array element lengths\n            let tailOffset := shl(5, params.length)\n            let expectedOffset := tailOffset\n\n            for { let offset := 0 } lt(offset, tailOffset) { offset := add(offset, 32) } {\n                let itemLengthOffset := calldataload(add(params.offset, offset))\n                // Verify that the offset matches the expected offset from strict encoding\n                invalidData := or(invalidData, xor(itemLengthOffset, expectedOffset))\n                let itemLengthPointer := add(params.offset, itemLengthOffset)\n                let length :=\n                    add(and(add(calldataload(itemLengthPointer), 0x1f), OFFSET_OR_LENGTH_MASK_AND_WORD_ALIGN), 0x20)\n                expectedOffset := add(expectedOffset, length)\n            }\n\n            // if the data encoding was invalid, or the provided bytes string isnt as long as the encoding says, revert\n            if or(invalidData, lt(add(_bytes.length, _bytes.offset), add(params.offset, expectedOffset))) {\n                mstore(0, SLICE_ERROR_SELECTOR)\n                revert(0x1c, 4)\n            }\n        }\n    }\n\n    /// @dev equivalent to: abi.decode(params, (uint256, uint256, uint128, uint128, bytes)) in calldata\n    function decodeModifyLiquidityParams(bytes calldata params)\n        internal\n        pure\n        returns (uint256 tokenId, uint256 liquidity, uint128 amount0, uint128 amount1, bytes calldata hookData)\n    {\n        // no length check performed, as there is a length check in `toBytes`\n        assembly (\"memory-safe\") {\n            tokenId := calldataload(params.offset)\n            liquidity := calldataload(add(params.offset, 0x20))\n            amount0 := calldataload(add(params.offset, 0x40))\n            amount1 := calldataload(add(params.offset, 0x60))\n        }\n\n        hookData = params.toBytes(4);\n    }\n\n    /// @dev equivalent to: abi.decode(params, (uint256, uint128, uint128, bytes)) in calldata\n    function decodeIncreaseLiquidityFromDeltasParams(bytes calldata params)\n        internal\n        pure\n        returns (uint256 tokenId, uint128 amount0Max, uint128 amount1Max, bytes calldata hookData)\n    {\n        // no length check performed, as there is a length check in `toBytes`\n        assembly (\"memory-safe\") {\n            tokenId := calldataload(params.offset)\n            amount0Max := calldataload(add(params.offset, 0x20))\n            amount1Max := calldataload(add(params.offset, 0x40))\n        }\n\n        hookData = params.toBytes(3);\n    }\n\n    /// @dev equivalent to: abi.decode(params, (PoolKey, int24, int24, uint256, uint128, uint128, address, bytes)) in calldata\n    function decodeMintParams(bytes calldata params)\n        internal\n        pure\n        returns (\n            PoolKey calldata poolKey,\n            int24 tickLower,\n            int24 tickUpper,\n            uint256 liquidity,\n            uint128 amount0Max,\n            uint128 amount1Max,\n            address owner,\n            bytes calldata hookData\n        )\n    {\n        // no length check performed, as there is a length check in `toBytes`\n        assembly (\"memory-safe\") {\n            poolKey := params.offset\n            tickLower := calldataload(add(params.offset, 0xa0))\n            tickUpper := calldataload(add(params.offset, 0xc0))\n            liquidity := calldataload(add(params.offset, 0xe0))\n            amount0Max := calldataload(add(params.offset, 0x100))\n            amount1Max := calldataload(add(params.offset, 0x120))\n            owner := calldataload(add(params.offset, 0x140))\n        }\n        hookData = params.toBytes(11);\n    }\n\n    /// @dev equivalent to: abi.decode(params, (PoolKey, int24, int24, uint128, uint128, address, bytes)) in calldata\n    function decodeMintFromDeltasParams(bytes calldata params)\n        internal\n        pure\n        returns (\n            PoolKey calldata poolKey,\n            int24 tickLower,\n            int24 tickUpper,\n            uint128 amount0Max,\n            uint128 amount1Max,\n            address owner,\n            bytes calldata hookData\n        )\n    {\n        // no length check performed, as there is a length check in `toBytes`\n        assembly (\"memory-safe\") {\n            poolKey := params.offset\n            tickLower := calldataload(add(params.offset, 0xa0))\n            tickUpper := calldataload(add(params.offset, 0xc0))\n            amount0Max := calldataload(add(params.offset, 0xe0))\n            amount1Max := calldataload(add(params.offset, 0x100))\n            owner := calldataload(add(params.offset, 0x120))\n        }\n\n        hookData = params.toBytes(10);\n    }\n\n    /// @dev equivalent to: abi.decode(params, (uint256, uint128, uint128, bytes)) in calldata\n    function decodeBurnParams(bytes calldata params)\n        internal\n        pure\n        returns (uint256 tokenId, uint128 amount0Min, uint128 amount1Min, bytes calldata hookData)\n    {\n        // no length check performed, as there is a length check in `toBytes`\n        assembly (\"memory-safe\") {\n            tokenId := calldataload(params.offset)\n            amount0Min := calldataload(add(params.offset, 0x20))\n            amount1Min := calldataload(add(params.offset, 0x40))\n        }\n\n        hookData = params.toBytes(3);\n    }\n\n    /// @dev equivalent to: abi.decode(params, (IV4Router.ExactInputParams))\n    function decodeSwapExactInParams(bytes calldata params)\n        internal\n        pure\n        returns (IV4Router.ExactInputParams calldata swapParams)\n    {\n        // ExactInputParams is a variable length struct so we just have to look up its location\n        assembly (\"memory-safe\") {\n            // only safety checks for the minimum length, where path is empty\n            // 0xa0 = 5 * 0x20 -> 3 elements, path offset, and path length 0\n            if lt(params.length, 0xa0) {\n                mstore(0, SLICE_ERROR_SELECTOR)\n                revert(0x1c, 4)\n            }\n            swapParams := add(params.offset, calldataload(params.offset))\n        }\n    }\n\n    /// @dev equivalent to: abi.decode(params, (IV4Router.ExactInputSingleParams))\n    function decodeSwapExactInSingleParams(bytes calldata params)\n        internal\n        pure\n        returns (IV4Router.ExactInputSingleParams calldata swapParams)\n    {\n        // ExactInputSingleParams is a variable length struct so we just have to look up its location\n        assembly (\"memory-safe\") {\n            // only safety checks for the minimum length, where hookData is empty\n            // 0x140 = 10 * 0x20 -> 8 elements, bytes offset, and bytes length 0\n            if lt(params.length, 0x140) {\n                mstore(0, SLICE_ERROR_SELECTOR)\n                revert(0x1c, 4)\n            }\n            swapParams := add(params.offset, calldataload(params.offset))\n        }\n    }\n\n    /// @dev equivalent to: abi.decode(params, (IV4Router.ExactOutputParams))\n    function decodeSwapExactOutParams(bytes calldata params)\n        internal\n        pure\n        returns (IV4Router.ExactOutputParams calldata swapParams)\n    {\n        // ExactOutputParams is a variable length struct so we just have to look up its location\n        assembly (\"memory-safe\") {\n            // only safety checks for the minimum length, where path is empty\n            // 0xa0 = 5 * 0x20 -> 3 elements, path offset, and path length 0\n            if lt(params.length, 0xa0) {\n                mstore(0, SLICE_ERROR_SELECTOR)\n                revert(0x1c, 4)\n            }\n            swapParams := add(params.offset, calldataload(params.offset))\n        }\n    }\n\n    /// @dev equivalent to: abi.decode(params, (IV4Router.ExactOutputSingleParams))\n    function decodeSwapExactOutSingleParams(bytes calldata params)\n        internal\n        pure\n        returns (IV4Router.ExactOutputSingleParams calldata swapParams)\n    {\n        // ExactOutputSingleParams is a variable length struct so we just have to look up its location\n        assembly (\"memory-safe\") {\n            // only safety checks for the minimum length, where hookData is empty\n            // 0x140 = 10 * 0x20 -> 8 elements, bytes offset, and bytes length 0\n            if lt(params.length, 0x140) {\n                mstore(0, SLICE_ERROR_SELECTOR)\n                revert(0x1c, 4)\n            }\n            swapParams := add(params.offset, calldataload(params.offset))\n        }\n    }\n\n    /// @dev equivalent to: abi.decode(params, (Currency)) in calldata\n    function decodeCurrency(bytes calldata params) internal pure returns (Currency currency) {\n        assembly (\"memory-safe\") {\n            if lt(params.length, 0x20) {\n                mstore(0, SLICE_ERROR_SELECTOR)\n                revert(0x1c, 4)\n            }\n            currency := calldataload(params.offset)\n        }\n    }\n\n    /// @dev equivalent to: abi.decode(params, (Currency, Currency)) in calldata\n    function decodeCurrencyPair(bytes calldata params) internal pure returns (Currency currency0, Currency currency1) {\n        assembly (\"memory-safe\") {\n            if lt(params.length, 0x40) {\n                mstore(0, SLICE_ERROR_SELECTOR)\n                revert(0x1c, 4)\n            }\n            currency0 := calldataload(params.offset)\n            currency1 := calldataload(add(params.offset, 0x20))\n        }\n    }\n\n    /// @dev equivalent to: abi.decode(params, (Currency, Currency, address)) in calldata\n    function decodeCurrencyPairAndAddress(bytes calldata params)\n        internal\n        pure\n        returns (Currency currency0, Currency currency1, address _address)\n    {\n        assembly (\"memory-safe\") {\n            if lt(params.length, 0x60) {\n                mstore(0, SLICE_ERROR_SELECTOR)\n                revert(0x1c, 4)\n            }\n            currency0 := calldataload(params.offset)\n            currency1 := calldataload(add(params.offset, 0x20))\n            _address := calldataload(add(params.offset, 0x40))\n        }\n    }\n\n    /// @dev equivalent to: abi.decode(params, (Currency, address)) in calldata\n    function decodeCurrencyAndAddress(bytes calldata params)\n        internal\n        pure\n        returns (Currency currency, address _address)\n    {\n        assembly (\"memory-safe\") {\n            if lt(params.length, 0x40) {\n                mstore(0, SLICE_ERROR_SELECTOR)\n                revert(0x1c, 4)\n            }\n            currency := calldataload(params.offset)\n            _address := calldataload(add(params.offset, 0x20))\n        }\n    }\n\n    /// @dev equivalent to: abi.decode(params, (Currency, address, uint256)) in calldata\n    function decodeCurrencyAddressAndUint256(bytes calldata params)\n        internal\n        pure\n        returns (Currency currency, address _address, uint256 amount)\n    {\n        assembly (\"memory-safe\") {\n            if lt(params.length, 0x60) {\n                mstore(0, SLICE_ERROR_SELECTOR)\n                revert(0x1c, 4)\n            }\n            currency := calldataload(params.offset)\n            _address := calldataload(add(params.offset, 0x20))\n            amount := calldataload(add(params.offset, 0x40))\n        }\n    }\n\n    /// @dev equivalent to: abi.decode(params, (Currency, uint256)) in calldata\n    function decodeCurrencyAndUint256(bytes calldata params)\n        internal\n        pure\n        returns (Currency currency, uint256 amount)\n    {\n        assembly (\"memory-safe\") {\n            if lt(params.length, 0x40) {\n                mstore(0, SLICE_ERROR_SELECTOR)\n                revert(0x1c, 4)\n            }\n            currency := calldataload(params.offset)\n            amount := calldataload(add(params.offset, 0x20))\n        }\n    }\n\n    /// @dev equivalent to: abi.decode(params, (uint256)) in calldata\n    function decodeUint256(bytes calldata params) internal pure returns (uint256 amount) {\n        assembly (\"memory-safe\") {\n            if lt(params.length, 0x20) {\n                mstore(0, SLICE_ERROR_SELECTOR)\n                revert(0x1c, 4)\n            }\n            amount := calldataload(params.offset)\n        }\n    }\n\n    /// @dev equivalent to: abi.decode(params, (Currency, uint256, bool)) in calldata\n    function decodeCurrencyUint256AndBool(bytes calldata params)\n        internal\n        pure\n        returns (Currency currency, uint256 amount, bool boolean)\n    {\n        assembly (\"memory-safe\") {\n            if lt(params.length, 0x60) {\n                mstore(0, SLICE_ERROR_SELECTOR)\n                revert(0x1c, 4)\n            }\n            currency := calldataload(params.offset)\n            amount := calldataload(add(params.offset, 0x20))\n            boolean := calldataload(add(params.offset, 0x40))\n        }\n    }\n\n    /// @notice Decode the `_arg`-th element in `_bytes` as `bytes`\n    /// @param _bytes The input bytes string to extract a bytes string from\n    /// @param _arg The index of the argument to extract\n    function toBytes(bytes calldata _bytes, uint256 _arg) internal pure returns (bytes calldata res) {\n        uint256 length;\n        assembly (\"memory-safe\") {\n            // The offset of the `_arg`-th element is `32 * arg`, which stores the offset of the length pointer.\n            // shl(5, x) is equivalent to mul(32, x)\n            let lengthPtr :=\n                add(_bytes.offset, and(calldataload(add(_bytes.offset, shl(5, _arg))), OFFSET_OR_LENGTH_MASK))\n            // the number of bytes in the bytes string\n            length := and(calldataload(lengthPtr), OFFSET_OR_LENGTH_MASK)\n            // the offset where the bytes string begins\n            let offset := add(lengthPtr, 0x20)\n            // assign the return parameters\n            res.length := length\n            res.offset := offset\n\n            // if the provided bytes string isnt as long as the encoding says, revert\n            if lt(add(_bytes.length, _bytes.offset), add(length, offset)) {\n                mstore(0, SLICE_ERROR_SELECTOR)\n                revert(0x1c, 4)\n            }\n        }\n    }\n}\n"},"lib/v4-periphery/src/libraries/ERC721PermitHash.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nlibrary ERC721PermitHash {\n    /// @dev Value is equal to keccak256(\"Permit(address spender,uint256 tokenId,uint256 nonce,uint256 deadline)\");\n    bytes32 constant PERMIT_TYPEHASH = 0x49ecf333e5b8c95c40fdafc95c1ad136e8914a8fb55e9dc8bb01eaa83a2df9ad;\n\n    /// @dev Value is equal to keccak256(\"PermitForAll(address operator,bool approved,uint256 nonce,uint256 deadline)\");\n    bytes32 constant PERMIT_FOR_ALL_TYPEHASH = 0x6673cb397ee2a50b6b8401653d3638b4ac8b3db9c28aa6870ffceb7574ec2f76;\n\n    /// @notice Hashes the data that will be signed for IERC721Permit_v4.permit()\n    /// @param spender The address which may spend the tokenId\n    /// @param tokenId The tokenId of the owner, which may be spent by spender\n    /// @param nonce A unique non-ordered value for each signature to prevent replay attacks\n    /// @param deadline The time at which the signature expires\n    /// @return digest The hash of the data to be signed; the equivalent to keccak256(abi.encode(PERMIT_TYPEHASH, spender, tokenId, nonce, deadline));\n    function hashPermit(address spender, uint256 tokenId, uint256 nonce, uint256 deadline)\n        internal\n        pure\n        returns (bytes32 digest)\n    {\n        // equivalent to: keccak256(abi.encode(PERMIT_TYPEHASH, spender, tokenId, nonce, deadline));\n        assembly (\"memory-safe\") {\n            let fmp := mload(0x40)\n            mstore(fmp, PERMIT_TYPEHASH)\n            mstore(add(fmp, 0x20), and(spender, 0xffffffffffffffffffffffffffffffffffffffff))\n            mstore(add(fmp, 0x40), tokenId)\n            mstore(add(fmp, 0x60), nonce)\n            mstore(add(fmp, 0x80), deadline)\n            digest := keccak256(fmp, 0xa0)\n\n            // now clean the memory we used\n            mstore(fmp, 0) // fmp held PERMIT_TYPEHASH\n            mstore(add(fmp, 0x20), 0) // fmp+0x20 held spender\n            mstore(add(fmp, 0x40), 0) // fmp+0x40 held tokenId\n            mstore(add(fmp, 0x60), 0) // fmp+0x60 held nonce\n            mstore(add(fmp, 0x80), 0) // fmp+0x80 held deadline\n        }\n    }\n\n    /// @notice Hashes the data that will be signed for IERC721Permit_v4.permit()\n    /// @param operator The address which may spend any of the owner's tokenIds\n    /// @param approved true if the operator is to have full permission over the owner's tokenIds; false otherwise\n    /// @param nonce A unique non-ordered value for each signature to prevent replay attacks\n    /// @param deadline The time at which the signature expires\n    /// @return digest The hash of the data to be signed; the equivalent to keccak256(abi.encode(PERMIT_FOR_ALL_TYPEHASH, operator, approved, nonce, deadline));\n    function hashPermitForAll(address operator, bool approved, uint256 nonce, uint256 deadline)\n        internal\n        pure\n        returns (bytes32 digest)\n    {\n        // equivalent to: keccak256(abi.encode(PERMIT_FOR_ALL_TYPEHASH, operator, approved, nonce, deadline));\n        assembly (\"memory-safe\") {\n            let fmp := mload(0x40)\n            mstore(fmp, PERMIT_FOR_ALL_TYPEHASH)\n            mstore(add(fmp, 0x20), and(operator, 0xffffffffffffffffffffffffffffffffffffffff))\n            mstore(add(fmp, 0x40), and(approved, 0x1))\n            mstore(add(fmp, 0x60), nonce)\n            mstore(add(fmp, 0x80), deadline)\n            digest := keccak256(fmp, 0xa0)\n\n            // now clean the memory we used\n            mstore(fmp, 0) // fmp held PERMIT_FOR_ALL_TYPEHASH\n            mstore(add(fmp, 0x20), 0) // fmp+0x20 held operator\n            mstore(add(fmp, 0x40), 0) // fmp+0x40 held approved\n            mstore(add(fmp, 0x60), 0) // fmp+0x60 held nonce\n            mstore(add(fmp, 0x80), 0) // fmp+0x80 held deadline\n        }\n    }\n}\n"},"lib/v4-periphery/src/libraries/LiquidityAmounts.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport {FullMath} from \"@uniswap/v4-core/src/libraries/FullMath.sol\";\nimport {FixedPoint96} from \"@uniswap/v4-core/src/libraries/FixedPoint96.sol\";\nimport {SafeCast} from \"@uniswap/v4-core/src/libraries/SafeCast.sol\";\n\n/// @notice Provides functions for computing liquidity amounts from token amounts and prices\nlibrary LiquidityAmounts {\n    using SafeCast for uint256;\n\n    /// @notice Computes the amount of liquidity received for a given amount of token0 and price range\n    /// @dev Calculates amount0 * (sqrt(upper) * sqrt(lower)) / (sqrt(upper) - sqrt(lower))\n    /// @param sqrtPriceAX96 A sqrt price representing the first tick boundary\n    /// @param sqrtPriceBX96 A sqrt price representing the second tick boundary\n    /// @param amount0 The amount0 being sent in\n    /// @return liquidity The amount of returned liquidity\n    function getLiquidityForAmount0(uint160 sqrtPriceAX96, uint160 sqrtPriceBX96, uint256 amount0)\n        internal\n        pure\n        returns (uint128 liquidity)\n    {\n        unchecked {\n            if (sqrtPriceAX96 > sqrtPriceBX96) (sqrtPriceAX96, sqrtPriceBX96) = (sqrtPriceBX96, sqrtPriceAX96);\n            uint256 intermediate = FullMath.mulDiv(sqrtPriceAX96, sqrtPriceBX96, FixedPoint96.Q96);\n            return FullMath.mulDiv(amount0, intermediate, sqrtPriceBX96 - sqrtPriceAX96).toUint128();\n        }\n    }\n\n    /// @notice Computes the amount of liquidity received for a given amount of token1 and price range\n    /// @dev Calculates amount1 / (sqrt(upper) - sqrt(lower)).\n    /// @param sqrtPriceAX96 A sqrt price representing the first tick boundary\n    /// @param sqrtPriceBX96 A sqrt price representing the second tick boundary\n    /// @param amount1 The amount1 being sent in\n    /// @return liquidity The amount of returned liquidity\n    function getLiquidityForAmount1(uint160 sqrtPriceAX96, uint160 sqrtPriceBX96, uint256 amount1)\n        internal\n        pure\n        returns (uint128 liquidity)\n    {\n        unchecked {\n            if (sqrtPriceAX96 > sqrtPriceBX96) (sqrtPriceAX96, sqrtPriceBX96) = (sqrtPriceBX96, sqrtPriceAX96);\n            return FullMath.mulDiv(amount1, FixedPoint96.Q96, sqrtPriceBX96 - sqrtPriceAX96).toUint128();\n        }\n    }\n\n    /// @notice Computes the maximum amount of liquidity received for a given amount of token0, token1, the current\n    /// pool prices and the prices at the tick boundaries\n    /// @param sqrtPriceX96 A sqrt price representing the current pool prices\n    /// @param sqrtPriceAX96 A sqrt price representing the first tick boundary\n    /// @param sqrtPriceBX96 A sqrt price representing the second tick boundary\n    /// @param amount0 The amount of token0 being sent in\n    /// @param amount1 The amount of token1 being sent in\n    /// @return liquidity The maximum amount of liquidity received\n    function getLiquidityForAmounts(\n        uint160 sqrtPriceX96,\n        uint160 sqrtPriceAX96,\n        uint160 sqrtPriceBX96,\n        uint256 amount0,\n        uint256 amount1\n    ) internal pure returns (uint128 liquidity) {\n        if (sqrtPriceAX96 > sqrtPriceBX96) (sqrtPriceAX96, sqrtPriceBX96) = (sqrtPriceBX96, sqrtPriceAX96);\n\n        if (sqrtPriceX96 <= sqrtPriceAX96) {\n            liquidity = getLiquidityForAmount0(sqrtPriceAX96, sqrtPriceBX96, amount0);\n        } else if (sqrtPriceX96 < sqrtPriceBX96) {\n            uint128 liquidity0 = getLiquidityForAmount0(sqrtPriceX96, sqrtPriceBX96, amount0);\n            uint128 liquidity1 = getLiquidityForAmount1(sqrtPriceAX96, sqrtPriceX96, amount1);\n\n            liquidity = liquidity0 < liquidity1 ? liquidity0 : liquidity1;\n        } else {\n            liquidity = getLiquidityForAmount1(sqrtPriceAX96, sqrtPriceBX96, amount1);\n        }\n    }\n}\n"},"lib/v4-periphery/src/libraries/Locker.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity ^0.8.24;\n\n/// @notice This is a temporary library that allows us to use transient storage (tstore/tload)\n/// TODO: This library can be deleted when we have the transient keyword support in solidity.\nlibrary Locker {\n    // The slot holding the locker state, transiently. bytes32(uint256(keccak256(\"LockedBy\")) - 1)\n    bytes32 constant LOCKED_BY_SLOT = 0x0aedd6bde10e3aa2adec092b02a3e3e805795516cda41f27aa145b8f300af87a;\n\n    function set(address locker) internal {\n        assembly {\n            tstore(LOCKED_BY_SLOT, locker)\n        }\n    }\n\n    function get() internal view returns (address locker) {\n        assembly {\n            locker := tload(LOCKED_BY_SLOT)\n        }\n    }\n}\n"},"lib/v4-periphery/src/libraries/PathKey.sol":{"content":"//SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport {Currency} from \"@uniswap/v4-core/src/types/Currency.sol\";\nimport {IHooks} from \"@uniswap/v4-core/src/interfaces/IHooks.sol\";\nimport {PoolKey} from \"@uniswap/v4-core/src/types/PoolKey.sol\";\n\nstruct PathKey {\n    Currency intermediateCurrency;\n    uint24 fee;\n    int24 tickSpacing;\n    IHooks hooks;\n    bytes hookData;\n}\n\nusing PathKeyLibrary for PathKey global;\n\n/// @title PathKey Library\n/// @notice Functions for working with PathKeys\nlibrary PathKeyLibrary {\n    /// @notice Get the pool and swap direction for a given PathKey\n    /// @param params the given PathKey\n    /// @param currencyIn the input currency\n    /// @return poolKey the pool key of the swap\n    /// @return zeroForOne the direction of the swap, true if currency0 is being swapped for currency1\n    function getPoolAndSwapDirection(PathKey calldata params, Currency currencyIn)\n        internal\n        pure\n        returns (PoolKey memory poolKey, bool zeroForOne)\n    {\n        Currency currencyOut = params.intermediateCurrency;\n        (Currency currency0, Currency currency1) =\n            currencyIn < currencyOut ? (currencyIn, currencyOut) : (currencyOut, currencyIn);\n\n        zeroForOne = currencyIn == currency0;\n        poolKey = PoolKey(currency0, currency1, params.fee, params.tickSpacing, params.hooks);\n    }\n}\n"},"lib/v4-periphery/src/libraries/PositionInfoLibrary.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity ^0.8.24;\n\nimport {PoolKey} from \"@uniswap/v4-core/src/types/PoolKey.sol\";\nimport {PoolId} from \"@uniswap/v4-core/src/types/PoolId.sol\";\n\n/**\n * @dev PositionInfo is a packed version of solidity structure.\n * Using the packaged version saves gas and memory by not storing the structure fields in memory slots.\n *\n * Layout:\n * 200 bits poolId | 24 bits tickUpper | 24 bits tickLower | 8 bits hasSubscriber\n *\n * Fields in the direction from the least significant bit:\n *\n * A flag to know if the tokenId is subscribed to an address\n * uint8 hasSubscriber;\n *\n * The tickUpper of the position\n * int24 tickUpper;\n *\n * The tickLower of the position\n * int24 tickLower;\n *\n * The truncated poolId. Truncates a bytes32 value so the most signifcant (highest) 200 bits are used.\n * bytes25 poolId;\n *\n * Note: If more bits are needed, hasSubscriber can be a single bit.\n *\n */\ntype PositionInfo is uint256;\n\nusing PositionInfoLibrary for PositionInfo global;\n\nlibrary PositionInfoLibrary {\n    PositionInfo internal constant EMPTY_POSITION_INFO = PositionInfo.wrap(0);\n\n    uint256 internal constant MASK_UPPER_200_BITS = 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF00000000000000;\n    uint256 internal constant MASK_8_BITS = 0xFF;\n    uint24 internal constant MASK_24_BITS = 0xFFFFFF;\n    uint256 internal constant SET_UNSUBSCRIBE = 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF00;\n    uint256 internal constant SET_SUBSCRIBE = 0x01;\n    uint8 internal constant TICK_LOWER_OFFSET = 8;\n    uint8 internal constant TICK_UPPER_OFFSET = 32;\n\n    /// @dev This poolId is NOT compatible with the poolId used in UniswapV4 core. It is truncated to 25 bytes, and just used to lookup PoolKey in the poolKeys mapping.\n    function poolId(PositionInfo info) internal pure returns (bytes25 _poolId) {\n        assembly (\"memory-safe\") {\n            _poolId := and(MASK_UPPER_200_BITS, info)\n        }\n    }\n\n    function tickLower(PositionInfo info) internal pure returns (int24 _tickLower) {\n        assembly (\"memory-safe\") {\n            _tickLower := signextend(2, shr(TICK_LOWER_OFFSET, info))\n        }\n    }\n\n    function tickUpper(PositionInfo info) internal pure returns (int24 _tickUpper) {\n        assembly (\"memory-safe\") {\n            _tickUpper := signextend(2, shr(TICK_UPPER_OFFSET, info))\n        }\n    }\n\n    function hasSubscriber(PositionInfo info) internal pure returns (bool _hasSubscriber) {\n        assembly (\"memory-safe\") {\n            _hasSubscriber := and(MASK_8_BITS, info)\n        }\n    }\n\n    /// @dev this does not actually set any storage\n    function setSubscribe(PositionInfo info) internal pure returns (PositionInfo _info) {\n        assembly (\"memory-safe\") {\n            _info := or(info, SET_SUBSCRIBE)\n        }\n    }\n\n    /// @dev this does not actually set any storage\n    function setUnsubscribe(PositionInfo info) internal pure returns (PositionInfo _info) {\n        assembly (\"memory-safe\") {\n            _info := and(info, SET_UNSUBSCRIBE)\n        }\n    }\n\n    /// @notice Creates the default PositionInfo struct\n    /// @dev Called when minting a new position\n    /// @param _poolKey the pool key of the position\n    /// @param _tickLower the lower tick of the position\n    /// @param _tickUpper the upper tick of the position\n    /// @return info packed position info, with the truncated poolId and the hasSubscriber flag set to false\n    function initialize(PoolKey memory _poolKey, int24 _tickLower, int24 _tickUpper)\n        internal\n        pure\n        returns (PositionInfo info)\n    {\n        bytes25 _poolId = bytes25(PoolId.unwrap(_poolKey.toId()));\n        assembly {\n            info :=\n                or(\n                    or(and(MASK_UPPER_200_BITS, _poolId), shl(TICK_UPPER_OFFSET, and(MASK_24_BITS, _tickUpper))),\n                    shl(TICK_LOWER_OFFSET, and(MASK_24_BITS, _tickLower))\n                )\n        }\n    }\n}\n"},"lib/v4-periphery/src/libraries/SlippageCheck.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport {BalanceDelta} from \"@uniswap/v4-core/src/types/BalanceDelta.sol\";\nimport {SafeCast} from \"@uniswap/v4-core/src/libraries/SafeCast.sol\";\n\n/// @title Slippage Check Library\n/// @notice a library for checking if a delta exceeds a maximum ceiling or fails to meet a minimum floor\nlibrary SlippageCheck {\n    using SafeCast for int128;\n\n    error MaximumAmountExceeded(uint128 maximumAmount, uint128 amountRequested);\n    error MinimumAmountInsufficient(uint128 minimumAmount, uint128 amountReceived);\n\n    /// @notice Revert if one or both deltas does not meet a minimum output\n    /// @param delta The principal amount of tokens to be removed, does not include any fees accrued\n    /// @param amount0Min The minimum amount of token0 to receive\n    /// @param amount1Min The minimum amount of token1 to receive\n    /// @dev This should be called when removing liquidity (burn or decrease)\n    function validateMinOut(BalanceDelta delta, uint128 amount0Min, uint128 amount1Min) internal pure {\n        // Called on burn or decrease, where we expect the returned delta to be positive.\n        // However, on pools where hooks can return deltas on modify liquidity, it is possible for a returned delta to be negative.\n        // Because we use SafeCast, this will revert in those cases when the delta is negative.\n        // This means this contract will NOT support pools where the hook returns a negative delta on burn/decrease.\n        if (delta.amount0().toUint128() < amount0Min) {\n            revert MinimumAmountInsufficient(amount0Min, delta.amount0().toUint128());\n        }\n        if (delta.amount1().toUint128() < amount1Min) {\n            revert MinimumAmountInsufficient(amount1Min, delta.amount1().toUint128());\n        }\n    }\n\n    /// @notice Revert if one or both deltas exceeds a maximum input\n    /// @param delta The principal amount of tokens to be added, does not include any fees accrued (which is possible on increase)\n    /// @param amount0Max The maximum amount of token0 to spend\n    /// @param amount1Max The maximum amount of token1 to spend\n    /// @dev This should be called when adding liquidity (mint or increase)\n    function validateMaxIn(BalanceDelta delta, uint128 amount0Max, uint128 amount1Max) internal pure {\n        // Called on mint or increase, where we expect the returned delta to be negative.\n        // However, on pools where hooks can return deltas on modify liquidity, it is possible for a returned delta to be positive (even after discounting fees accrued).\n        // Thus, we only cast the delta if it is guaranteed to be negative.\n        // And we do NOT revert in the positive delta case. Since a positive delta means the hook is crediting tokens to the user for minting/increasing liquidity, we do not check slippage.\n        // This means this contract will NOT support _positive_ slippage checks (minAmountOut checks) on pools where the hook returns a positive delta on mint/increase.\n        int256 amount0 = delta.amount0();\n        int256 amount1 = delta.amount1();\n        if (amount0 < 0 && amount0Max < uint128(uint256(-amount0))) {\n            revert MaximumAmountExceeded(amount0Max, uint128(uint256(-amount0)));\n        }\n        if (amount1 < 0 && amount1Max < uint128(uint256(-amount1))) {\n            revert MaximumAmountExceeded(amount1Max, uint128(uint256(-amount1)));\n        }\n    }\n}\n"},"lib/v4-periphery/src/utils/BaseHook.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport {Hooks} from \"@uniswap/v4-core/src/libraries/Hooks.sol\";\nimport {IPoolManager} from \"@uniswap/v4-core/src/interfaces/IPoolManager.sol\";\nimport {IHooks} from \"@uniswap/v4-core/src/interfaces/IHooks.sol\";\nimport {BalanceDelta} from \"@uniswap/v4-core/src/types/BalanceDelta.sol\";\nimport {PoolKey} from \"@uniswap/v4-core/src/types/PoolKey.sol\";\nimport {BeforeSwapDelta} from \"@uniswap/v4-core/src/types/BeforeSwapDelta.sol\";\nimport {ImmutableState} from \"../base/ImmutableState.sol\";\n\n/// @title Base Hook\n/// @notice abstract contract for hook implementations\nabstract contract BaseHook is IHooks, ImmutableState {\n    error HookNotImplemented();\n\n    constructor(IPoolManager _manager) ImmutableState(_manager) {\n        validateHookAddress(this);\n    }\n\n    /// @notice Returns a struct of permissions to signal which hook functions are to be implemented\n    /// @dev Used at deployment to validate the address correctly represents the expected permissions\n    function getHookPermissions() public pure virtual returns (Hooks.Permissions memory);\n\n    /// @notice Validates the deployed hook address agrees with the expected permissions of the hook\n    /// @dev this function is virtual so that we can override it during testing,\n    /// which allows us to deploy an implementation to any address\n    /// and then etch the bytecode into the correct address\n    function validateHookAddress(BaseHook _this) internal pure virtual {\n        Hooks.validateHookPermissions(_this, getHookPermissions());\n    }\n\n    /// @inheritdoc IHooks\n    function beforeInitialize(address sender, PoolKey calldata key, uint160 sqrtPriceX96)\n        external\n        onlyPoolManager\n        returns (bytes4)\n    {\n        return _beforeInitialize(sender, key, sqrtPriceX96);\n    }\n\n    function _beforeInitialize(address, PoolKey calldata, uint160) internal virtual returns (bytes4) {\n        revert HookNotImplemented();\n    }\n\n    /// @inheritdoc IHooks\n    function afterInitialize(address sender, PoolKey calldata key, uint160 sqrtPriceX96, int24 tick)\n        external\n        onlyPoolManager\n        returns (bytes4)\n    {\n        return _afterInitialize(sender, key, sqrtPriceX96, tick);\n    }\n\n    function _afterInitialize(address, PoolKey calldata, uint160, int24) internal virtual returns (bytes4) {\n        revert HookNotImplemented();\n    }\n\n    /// @inheritdoc IHooks\n    function beforeAddLiquidity(\n        address sender,\n        PoolKey calldata key,\n        IPoolManager.ModifyLiquidityParams calldata params,\n        bytes calldata hookData\n    ) external onlyPoolManager returns (bytes4) {\n        return _beforeAddLiquidity(sender, key, params, hookData);\n    }\n\n    function _beforeAddLiquidity(address, PoolKey calldata, IPoolManager.ModifyLiquidityParams calldata, bytes calldata)\n        internal\n        virtual\n        returns (bytes4)\n    {\n        revert HookNotImplemented();\n    }\n\n    /// @inheritdoc IHooks\n    function beforeRemoveLiquidity(\n        address sender,\n        PoolKey calldata key,\n        IPoolManager.ModifyLiquidityParams calldata params,\n        bytes calldata hookData\n    ) external onlyPoolManager returns (bytes4) {\n        return _beforeRemoveLiquidity(sender, key, params, hookData);\n    }\n\n    function _beforeRemoveLiquidity(\n        address,\n        PoolKey calldata,\n        IPoolManager.ModifyLiquidityParams calldata,\n        bytes calldata\n    ) internal virtual returns (bytes4) {\n        revert HookNotImplemented();\n    }\n\n    /// @inheritdoc IHooks\n    function afterAddLiquidity(\n        address sender,\n        PoolKey calldata key,\n        IPoolManager.ModifyLiquidityParams calldata params,\n        BalanceDelta delta,\n        BalanceDelta feesAccrued,\n        bytes calldata hookData\n    ) external onlyPoolManager returns (bytes4, BalanceDelta) {\n        return _afterAddLiquidity(sender, key, params, delta, feesAccrued, hookData);\n    }\n\n    function _afterAddLiquidity(\n        address,\n        PoolKey calldata,\n        IPoolManager.ModifyLiquidityParams calldata,\n        BalanceDelta,\n        BalanceDelta,\n        bytes calldata\n    ) internal virtual returns (bytes4, BalanceDelta) {\n        revert HookNotImplemented();\n    }\n\n    /// @inheritdoc IHooks\n    function afterRemoveLiquidity(\n        address sender,\n        PoolKey calldata key,\n        IPoolManager.ModifyLiquidityParams calldata params,\n        BalanceDelta delta,\n        BalanceDelta feesAccrued,\n        bytes calldata hookData\n    ) external onlyPoolManager returns (bytes4, BalanceDelta) {\n        return _afterRemoveLiquidity(sender, key, params, delta, feesAccrued, hookData);\n    }\n\n    function _afterRemoveLiquidity(\n        address,\n        PoolKey calldata,\n        IPoolManager.ModifyLiquidityParams calldata,\n        BalanceDelta,\n        BalanceDelta,\n        bytes calldata\n    ) internal virtual returns (bytes4, BalanceDelta) {\n        revert HookNotImplemented();\n    }\n\n    /// @inheritdoc IHooks\n    function beforeSwap(\n        address sender,\n        PoolKey calldata key,\n        IPoolManager.SwapParams calldata params,\n        bytes calldata hookData\n    ) external onlyPoolManager returns (bytes4, BeforeSwapDelta, uint24) {\n        return _beforeSwap(sender, key, params, hookData);\n    }\n\n    function _beforeSwap(address, PoolKey calldata, IPoolManager.SwapParams calldata, bytes calldata)\n        internal\n        virtual\n        returns (bytes4, BeforeSwapDelta, uint24)\n    {\n        revert HookNotImplemented();\n    }\n\n    /// @inheritdoc IHooks\n    function afterSwap(\n        address sender,\n        PoolKey calldata key,\n        IPoolManager.SwapParams calldata params,\n        BalanceDelta delta,\n        bytes calldata hookData\n    ) external onlyPoolManager returns (bytes4, int128) {\n        return _afterSwap(sender, key, params, delta, hookData);\n    }\n\n    function _afterSwap(address, PoolKey calldata, IPoolManager.SwapParams calldata, BalanceDelta, bytes calldata)\n        internal\n        virtual\n        returns (bytes4, int128)\n    {\n        revert HookNotImplemented();\n    }\n\n    /// @inheritdoc IHooks\n    function beforeDonate(\n        address sender,\n        PoolKey calldata key,\n        uint256 amount0,\n        uint256 amount1,\n        bytes calldata hookData\n    ) external onlyPoolManager returns (bytes4) {\n        return _beforeDonate(sender, key, amount0, amount1, hookData);\n    }\n\n    function _beforeDonate(address, PoolKey calldata, uint256, uint256, bytes calldata)\n        internal\n        virtual\n        returns (bytes4)\n    {\n        revert HookNotImplemented();\n    }\n\n    /// @inheritdoc IHooks\n    function afterDonate(\n        address sender,\n        PoolKey calldata key,\n        uint256 amount0,\n        uint256 amount1,\n        bytes calldata hookData\n    ) external onlyPoolManager returns (bytes4) {\n        return _afterDonate(sender, key, amount0, amount1, hookData);\n    }\n\n    function _afterDonate(address, PoolKey calldata, uint256, uint256, bytes calldata)\n        internal\n        virtual\n        returns (bytes4)\n    {\n        revert HookNotImplemented();\n    }\n}\n"},"src/SuperDCAGauge.sol":{"content":"// SPDX-License-Identifier: Apache-2.0\npragma solidity ^0.8.22;\n\nimport {BaseHook} from \"v4-periphery/utils/BaseHook.sol\";\nimport {Hooks, IHooks} from \"@uniswap/v4-core/src/libraries/Hooks.sol\";\nimport {IPoolManager} from \"@uniswap/v4-core/src/interfaces/IPoolManager.sol\";\nimport {PoolKey} from \"@uniswap/v4-core/src/types/PoolKey.sol\";\nimport {Currency} from \"@uniswap/v4-core/src/types/Currency.sol\";\nimport {PoolId, PoolIdLibrary} from \"@uniswap/v4-core/src/types/PoolId.sol\";\nimport {StateLibrary} from \"@uniswap/v4-core/src/libraries/StateLibrary.sol\";\nimport {IERC20} from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport {ISuperchainERC20} from \"./interfaces/ISuperchainERC20.sol\";\nimport {IMsgSender} from \"./interfaces/IMsgSender.sol\";\nimport {ISuperDCAStaking} from \"./interfaces/ISuperDCAStaking.sol\";\nimport {AccessControl} from \"@openzeppelin/contracts/access/AccessControl.sol\";\nimport {LPFeeLibrary} from \"@uniswap/v4-core/src/libraries/LPFeeLibrary.sol\";\nimport {BeforeSwapDelta, BeforeSwapDeltaLibrary} from \"@uniswap/v4-core/src/types/BeforeSwapDelta.sol\";\nimport {IPositionManager} from \"lib/v4-periphery/src/interfaces/IPositionManager.sol\";\nimport {ISuperDCAListing} from \"./interfaces/ISuperDCAListing.sol\";\n\n/**\n * @title SuperDCAGauge\n * @notice A Uniswap V4 pool hook that implements dynamic fee management, keeper mechanisms, and reward distribution.\n * @dev This contract serves as a central hook for DCA (Dollar Cost Averaging) pools, providing:\n *      - Dynamic fee structure based on user type (internal, external, keeper)\n *      - Keeper deposit system with king-of-the-hill replacement mechanism\n *      - Integration with external staking contract for reward distribution\n *      - Pool validation to ensure only SuperDCAToken pairs are used\n *      - Fee revenue distribution between community (via pool donations) and developer\n *\n * Architecture:\n * - Hook Integration: Implements Uniswap V4 hooks for beforeInitialize, afterInitialize,\n *   beforeAddLiquidity, beforeRemoveLiquidity, and beforeSwap\n * - Fee Management: Three-tier fee structure (internal: 0%, keeper: 0.10%, external: 0.50%)\n * - Keeper System: Users can deposit DCA tokens to become keeper and get reduced fees\n * - Reward Distribution: 50/50 split between community pool donations and developer payments\n * - Access Control: Role-based permissions for admin operations and fee management\n *\n * Security Features:\n * - Pool validation ensures only SuperDCAToken pairs can use this hook\n * - Dynamic fee enforcement prevents bypassing fee structure\n * - Safe minting with failure handling to prevent DoS attacks\n * - Proper settlement and sync patterns for Uniswap V4 integration\n */\ncontract SuperDCAGauge is BaseHook, AccessControl {\n    using LPFeeLibrary for uint24;\n    using PoolIdLibrary for PoolKey;\n    using StateLibrary for IPoolManager;\n\n    IPositionManager public positionManagerV4; // The Uniswap V4 position manager for managing positions\n    ISuperDCAListing public listing; // External listing module\n\n    // Constants\n    uint24 public constant INTERNAL_POOL_FEE = 0; // 0%\n    uint24 public constant KEEPER_POOL_FEE = 1000; // 0.10%\n    uint24 public constant EXTERNAL_POOL_FEE = 5000; // 0.50%\n    bytes32 public constant MANAGER_ROLE = keccak256(\"MANAGER_ROLE\");\n\n    /**\n     * @notice Enum defining the three types of fees charged to different user categories.\n     * @dev Used in setFee function to specify which fee type to update.\n     */\n    enum FeeType {\n        INTERNAL, // Fee for whitelisted internal addresses (typically 0%)\n        EXTERNAL, // Fee for regular external users (typically 0.50%)\n        KEEPER // Fee for the current keeper (typically 0.10%)\n\n    }\n\n    /**\n     * @notice Structure for holding token addresses and amounts in DCA operations.\n     * @dev Used internally for organizing token data during transactions.\n     */\n    struct TokenAmounts {\n        address token0; // First token in the pair\n        address token1; // Second token in the pair\n        address dcaToken; // The DCA token address\n        uint256 dcaAmount; // Amount of DCA tokens\n        uint256 tokAmount; // Amount of the other token\n    }\n    // ============ State Variables ============\n\n    /// @notice The address of the SuperDCA token contract.\n    /// @dev This token must be one of the currencies in any pool using this hook.\n    address public superDCAToken;\n\n    /// @notice The address that receives developer fees from reward distributions.\n    /// @dev Set during construction and can be updated via access control.\n    address public developerAddress;\n\n    /// @notice Fee charged to whitelisted internal addresses (in basis points).\n    /// @dev Typically set to 0 to incentivize internal usage.\n    uint24 public internalFee;\n\n    /// @notice Fee charged to external users (in basis points).\n    /// @dev Default is 5000 (0.50%) for regular users.\n    uint24 public externalFee;\n\n    /// @notice Fee charged to the current keeper (in basis points).\n    /// @dev Default is 1000 (0.10%) as an incentive for keeper services.\n    uint24 public keeperFee;\n\n    /// @notice Mapping to track which addresses are marked as internal for fee purposes.\n    /// @dev Internal addresses pay reduced fees to encourage platform usage.\n    mapping(address => bool) public isInternalAddress;\n\n    /// @notice The current keeper address who has deposited the highest amount.\n    /// @dev Keeper gets reduced fees and can be replaced by higher deposits.\n    address public keeper;\n\n    /// @notice The amount of DCA tokens deposited by the current keeper.\n    /// @dev Used in the king-of-the-hill mechanism for keeper replacement.\n    uint256 public keeperDeposit;\n\n    /// @notice External staking contract that manages reward calculations and distributions.\n    /// @dev Called during liquidity operations to accrue and distribute rewards.\n    ISuperDCAStaking public staking;\n\n    // ============ Events ============\n\n    /// @notice Emitted when an address's internal status is updated.\n    /// @param user The address whose status was changed.\n    /// @param isInternal True if the address is now internal, false otherwise.\n    event InternalAddressUpdated(address indexed user, bool isInternal);\n\n    /// @notice Emitted when a fee type is updated by the manager.\n    /// @param feeType The type of fee that was updated (INTERNAL, EXTERNAL, or KEEPER).\n    /// @param oldFee The previous fee value in basis points.\n    /// @param newFee The new fee value in basis points.\n    event FeeUpdated(FeeType indexed feeType, uint24 oldFee, uint24 newFee);\n\n    /// @notice Emitted when SuperDCA token ownership is transferred back to admin.\n    /// @param newOwner The address that received ownership of the SuperDCA token.\n    event SuperDCATokenOwnershipReturned(address indexed newOwner);\n\n    /// @notice Emitted when the keeper changes through the deposit mechanism.\n    /// @param oldKeeper The address of the previous keeper (zero address if none).\n    /// @param newKeeper The address of the new keeper.\n    /// @param deposit The amount of DCA tokens deposited by the new keeper.\n    event KeeperChanged(address indexed oldKeeper, address indexed newKeeper, uint256 deposit);\n\n    /// @notice Emitted when the staking contract address is updated.\n    /// @param oldStaking The address of the previous staking contract.\n    /// @param newStaking The address of the new staking contract.\n    event StakingUpdated(address indexed oldStaking, address indexed newStaking);\n\n    /// @notice Emitted when the listing contract address is updated.\n    /// @param oldListing The address of the previous listing contract.\n    /// @param newListing The address of the new listing contract.\n    event ListingUpdated(address indexed oldListing, address indexed newListing);\n\n    // ============ Custom Errors ============\n\n    /// @notice Thrown when a pool is not configured with dynamic fees.\n    error SuperDCAGauge__NotDynamicFee();\n\n    /// @notice Thrown when a keeper deposit amount is insufficient to replace current keeper.\n    error SuperDCAGauge__InsufficientBalance();\n\n    /// @notice Thrown when a zero amount is provided where a positive amount is required.\n    error SuperDCAGauge__ZeroAmount();\n\n    /// @notice Thrown when an invalid pool fee configuration is detected.\n    error SuperDCAGauge__InvalidPoolFee();\n\n    /// @notice Thrown when a pool doesn't include the SuperDCA token as one of its currencies.\n    error SuperDCAGauge__PoolMustIncludeSuperDCAToken();\n\n    /// @notice Thrown when the Uniswap token address is not properly set.\n    error SuperDCAGauge__UniswapTokenNotSet();\n\n    /// @notice Thrown when caller is not the expected owner.\n    error SuperDCAGauge__NotTheOwner();\n\n    /// @notice Thrown when an invalid address is provided.\n    error SuperDCAGauge__InvalidAddress();\n\n    /// @notice Thrown when a zero address is provided where a valid address is required.\n    error SuperDCAGauge__ZeroAddress();\n\n    /**\n     * @notice Initializes the SuperDCAGauge hook with core addresses and default fee structure.\n     * @dev Sets up access control roles and default fee values. The developer address receives\n     *      both DEFAULT_ADMIN_ROLE and MANAGER_ROLE permissions.\n     * @param _poolManager The Uniswap V4 pool manager contract.\n     * @param _superDCAToken The address of the SuperDCA token contract.\n     * @param _developerAddress The address that will receive developer fees and admin permissions.\n     * @param _positionManagerV4 The Uniswap V4 position manager for handling positions.\n     */\n    constructor(\n        IPoolManager _poolManager,\n        address _superDCAToken,\n        address _developerAddress,\n        IPositionManager _positionManagerV4\n    ) BaseHook(_poolManager) {\n        superDCAToken = _superDCAToken;\n        developerAddress = _developerAddress;\n        internalFee = INTERNAL_POOL_FEE;\n        externalFee = EXTERNAL_POOL_FEE;\n        keeperFee = KEEPER_POOL_FEE;\n        positionManagerV4 = _positionManagerV4;\n\n        _grantRole(DEFAULT_ADMIN_ROLE, _developerAddress);\n        // Grant the developer the manager role to control the mint rate and fees\n        _grantRole(MANAGER_ROLE, _developerAddress);\n    }\n\n    /**\n     * @notice Sets the external staking contract address for reward calculations.\n     * @dev Only callable by DEFAULT_ADMIN_ROLE. The staking contract handles reward\n     *      accrual calculations and distribution logic.\n     * @param stakingAddr The address of the deployed staking contract.\n     */\n    function setStaking(address stakingAddr) external onlyRole(DEFAULT_ADMIN_ROLE) {\n        if (stakingAddr == address(0)) revert SuperDCAGauge__ZeroAddress();\n        address oldStaking = address(staking);\n        staking = ISuperDCAStaking(stakingAddr);\n        emit StakingUpdated(oldStaking, stakingAddr);\n    }\n\n    /**\n     * @notice Sets the external listing contract used for token listing queries.\n     * @dev Only callable by DEFAULT_ADMIN_ROLE. The listing contract determines\n     *      which tokens are approved for DCA operations.\n     * @param _listing The address of the listing contract.\n     */\n    function setListing(address _listing) external onlyRole(DEFAULT_ADMIN_ROLE) {\n        address oldListing = address(listing);\n        listing = ISuperDCAListing(_listing);\n        emit ListingUpdated(oldListing, _listing);\n    }\n\n    /**\n     * @notice Checks if a token is approved for DCA operations via the listing contract.\n     * @dev Returns false if no listing contract is set. Used by external contracts\n     *      to validate token eligibility before operations.\n     * @param token The token address to check.\n     * @return True if the token is listed and approved for DCA, false otherwise.\n     */\n    function isTokenListed(address token) external view returns (bool) {\n        if (address(listing) == address(0)) return false;\n        return listing.isTokenListed(token);\n    }\n\n    /**\n     * @notice Returns the hook permissions required by this contract.\n     * @dev Enables beforeInitialize, afterInitialize, beforeAddLiquidity,\n     *      beforeRemoveLiquidity, and beforeSwap hooks. These are necessary for:\n     *      - Pool validation during initialization\n     *      - Dynamic fee enforcement\n     *      - Reward distribution during liquidity operations\n     * @return Hooks.Permissions struct with enabled hook flags.\n     */\n    function getHookPermissions() public pure override returns (Hooks.Permissions memory) {\n        return Hooks.Permissions({\n            beforeInitialize: true,\n            afterInitialize: true,\n            beforeAddLiquidity: true,\n            afterAddLiquidity: false,\n            beforeRemoveLiquidity: true,\n            afterRemoveLiquidity: false,\n            beforeSwap: true,\n            afterSwap: false,\n            beforeDonate: false,\n            afterDonate: false,\n            beforeSwapReturnDelta: false,\n            afterSwapReturnDelta: false,\n            afterAddLiquidityReturnDelta: false,\n            afterRemoveLiquidityReturnDelta: false\n        });\n    }\n\n    /**\n     * @notice Validates that pools using this hook include the SuperDCA token.\n     * @dev Called before pool initialization to ensure only valid DCA pools use this hook.\n     *      Prevents misconfiguration by requiring one currency to be the SuperDCA token.\n     * @param key The pool key containing currency pair and fee information.\n     * @return The function selector to confirm successful validation.\n     */\n    function _beforeInitialize(address, /* sender */ PoolKey calldata key, uint160 /* sqrtPriceX96 */ )\n        internal\n        view\n        override\n        returns (bytes4)\n    {\n        if (superDCAToken != Currency.unwrap(key.currency0) && superDCAToken != Currency.unwrap(key.currency1)) {\n            revert SuperDCAGauge__PoolMustIncludeSuperDCAToken();\n        }\n        return BaseHook.beforeInitialize.selector;\n    }\n\n    /**\n     * @notice Ensures the pool is configured with dynamic fees after initialization.\n     * @dev Called after pool initialization to verify the pool supports dynamic fee changes.\n     *      This is required for the hook to properly adjust fees based on user type.\n     * @param key The pool key containing currency pair and fee information.\n     * @return The function selector to confirm successful validation.\n     */\n    function _afterInitialize(address, /* sender */ PoolKey calldata key, uint160, /* sqrtPriceX96 */ int24 /* tick */ )\n        internal\n        pure\n        override\n        returns (bytes4)\n    {\n        if (!key.fee.isDynamicFee()) revert SuperDCAGauge__NotDynamicFee();\n        return this.afterInitialize.selector;\n    }\n\n    /**\n     * @notice Handles reward accrual and distribution during liquidity operations.\n     * @dev This function implements the core reward distribution logic:\n     *      1. Syncs the pool manager with the SuperDCA token state\n     *      2. Identifies the non-DCA token for reward calculation\n     *      3. Accrues rewards via the external staking contract\n     *      4. Distributes rewards 50/50 between developer and community\n     *      5. Donates community share to the pool if liquidity exists\n     *\n     *      If no pool liquidity exists, all rewards go to developer to prevent\n     *      donation failures. Minting failures are handled gracefully to prevent DoS.\n     * @param key The pool key identifying the Uniswap V4 pool.\n     * @param hookData Additional data passed to the hook for donation operations.\n     */\n    function _handleDistributionAndSettlement(PoolKey calldata key, bytes calldata hookData) internal {\n        // Must sync the pool manager to the token before distributing tokens\n        poolManager.sync(Currency.wrap(superDCAToken));\n\n        // Derive the non-DCA token for accrual calculation\n        // The staking contract uses this to determine reward amounts\n        address otherToken = superDCAToken == Currency.unwrap(key.currency0)\n            ? Currency.unwrap(key.currency1)\n            : Currency.unwrap(key.currency0);\n\n        // Calculate pending rewards from the external staking contract\n        uint256 rewardAmount = staking.accrueReward(otherToken);\n        if (rewardAmount == 0) return;\n\n        // Check if pool has liquidity before proceeding with donation\n        uint128 liquidity = IPoolManager(msg.sender).getLiquidity(key.toId());\n        if (liquidity == 0) {\n            //@audit-q, what happens if a malicious user creates another pool with an \"used\" token but with another tickSpacing and uses this hook to mint rewards only to himself? \n            //(he would be the only one to have deposited liquidity in that pool, subtracting rewards to community)\n            // If no liquidity, try sending everything to developer (do not revert if mint fails)\n            _tryMint(developerAddress, rewardAmount);\n            return;\n        }\n\n        // Split the mint amount between developer and community (50/50)\n        uint256 developerShare = rewardAmount / 2;\n        uint256 communityShare = rewardAmount - developerShare;\n\n        // Mint developer share (ignore failure)\n        _tryMint(developerAddress, developerShare);\n\n        // Mint community share and donate to pool only if mint succeeds\n        // This prevents donation of tokens that don't exist\n        if (_tryMint(address(poolManager), communityShare)) {\n            // Donate community share to pool\n            if (superDCAToken == Currency.unwrap(key.currency0)) {\n                IPoolManager(msg.sender).donate(key, communityShare, 0, hookData);\n            } else {\n                IPoolManager(msg.sender).donate(key, 0, communityShare, hookData);\n            }\n\n            // Settle the donation to complete the transaction\n            poolManager.settle();\n        }\n\n        /// @dev: At this point, there are DCA tokens left in the hook for the other pools.\n    }\n\n    /**\n     * @notice Hook called before liquidity is added to a pool.\n     * @dev Triggers reward distribution before the liquidity operation to ensure\n     *      accurate reward calculations based on current pool state.\n     * @param key The pool key for the liquidity operation.\n     * @param hookData Additional data passed to the hook.\n     * @return The function selector to confirm successful execution.\n     */\n    function _beforeAddLiquidity(\n        address, // sender\n        PoolKey calldata key,\n        IPoolManager.ModifyLiquidityParams calldata, // params\n        bytes calldata hookData\n    ) internal override returns (bytes4) {\n        _handleDistributionAndSettlement(key, hookData);\n        return BaseHook.beforeAddLiquidity.selector;\n    }\n\n    /**\n     * @notice Hook called before liquidity is removed from a pool.\n     * @dev Triggers reward distribution before the liquidity operation to ensure\n     *      rewards are properly allocated before pool state changes.\n     * @param key The pool key for the liquidity operation.\n     * @param hookData Additional data passed to the hook.\n     * @return The function selector to confirm successful execution.\n     */\n    function _beforeRemoveLiquidity(\n        address, // sender\n        PoolKey calldata key,\n        IPoolManager.ModifyLiquidityParams calldata, // params\n        bytes calldata hookData\n    ) internal override returns (bytes4) {\n        _handleDistributionAndSettlement(key, hookData);\n        return BaseHook.beforeRemoveLiquidity.selector;\n    }\n\n    /**\n     * @notice Hook called before each swap to determine the appropriate fee.\n     * @dev Implements a three-tier fee structure based on the swapper's status:\n     *      - Internal addresses: Pay internalFee (typically 0%)\n     *      - Current keeper: Pays keeperFee (typically 0.10%)\n     *      - External users: Pay externalFee (typically 0.50%)\n     *\n     *      The function uses IMsgSender to get the actual message sender when called\n     *      through intermediary contracts like routers or position managers.\n     * @param sender The address that initiated the swap (may be a router/manager).\n     * @return selector The function selector for successful execution.\n     * @return delta Zero delta as this hook doesn't modify swap amounts.\n     * @return fee The calculated fee with override flag set.\n     */\n    function _beforeSwap(\n        address sender,\n        PoolKey calldata, /* key */\n        IPoolManager.SwapParams calldata, /* params */\n        bytes calldata /* hookData */\n    ) internal view override returns (bytes4, BeforeSwapDelta, uint24) {\n        // Get the actual message sender (may differ from 'sender' when using routers)\n        address swapper = IMsgSender(sender).msgSender();\n        uint24 fee;\n\n        // Determine fee tier based on swapper status\n        if (isInternalAddress[swapper]) {\n            fee = internalFee; // Typically 0% for internal addresses\n        } else if (swapper == keeper) {\n            fee = keeperFee; // Typically 0.10% for keeper\n        } else {\n            fee = externalFee; // Typically 0.50% for external users\n        }\n\n        // Return with override flag to ensure our fee is used\n        return (IHooks.beforeSwap.selector, BeforeSwapDeltaLibrary.ZERO_DELTA, fee | LPFeeLibrary.OVERRIDE_FEE_FLAG);\n    }\n\n    /**\n     * @notice Allows users to become the keeper by depositing more DCA tokens than the current keeper\n     * @dev Implements king-of-the-hill mechanism where higher deposits replace current keeper\n     * @dev This function is protected against reentrancy by the order of operations:\n     *      1. Validate inputs and transfer new deposit first\n     *      2. Refund previous keeper (external call)\n     *      3. Update state variables\n     * @param amount The amount of DCA tokens to deposit to become keeper\n     */\n    function becomeKeeper(uint256 amount) external {\n        if (amount == 0) revert SuperDCAGauge__ZeroAmount();\n        if (amount <= keeperDeposit) revert SuperDCAGauge__InsufficientBalance();\n\n        address oldKeeper = keeper;\n        uint256 oldDeposit = keeperDeposit;\n        // Transfer new deposit from user\n        IERC20(superDCAToken).transferFrom(msg.sender, address(this), amount);\n\n        // Refund previous keeper if one exists\n        if (oldKeeper != address(0) && oldDeposit > 0) {\n            IERC20(superDCAToken).transfer(oldKeeper, oldDeposit);\n        }\n\n        // Set new keeper\n        keeper = msg.sender;\n        keeperDeposit = amount;\n\n        emit KeeperChanged(oldKeeper, msg.sender, amount);\n    }\n\n    /**\n     * @notice Returns the current keeper information\n     * @return currentKeeper The address of the current keeper\n     * @return currentDeposit The amount deposited by the current keeper\n     */\n    function getKeeperInfo() external view returns (address currentKeeper, uint256 currentDeposit) {\n        return (keeper, keeperDeposit);\n    }\n\n    /**\n     * @notice Updates the manager role by revoking from old address and granting to new address.\n     * @dev Only callable by DEFAULT_ADMIN_ROLE. The manager role allows setting fees and\n     *      internal address designations.\n     * @param oldManager The address of the current manager to revoke the role from.\n     * @param newManager The address of the new manager to grant the role to.\n     */\n    function updateManager(address oldManager, address newManager) external onlyRole(DEFAULT_ADMIN_ROLE) {\n        revokeRole(MANAGER_ROLE, oldManager);\n        grantRole(MANAGER_ROLE, newManager);\n    }\n\n    /**\n     * @notice Updates one of the three fee types (internal, external, or keeper).\n     * @dev Only callable by MANAGER_ROLE. Fees are specified in basis points\n     *      (e.g., 5000 = 0.50%). Emits FeeUpdated event with old and new values.\n     * @param _feeType The type of fee to update (INTERNAL, EXTERNAL, or KEEPER).\n     * @param _newFee The new fee value in basis points.\n     */\n    function setFee(FeeType _feeType, uint24 _newFee) external onlyRole(MANAGER_ROLE) {\n        uint24 oldFee;\n        if (_feeType == FeeType.INTERNAL) {\n            oldFee = internalFee;\n            internalFee = _newFee;\n        } else if (_feeType == FeeType.EXTERNAL) {\n            oldFee = externalFee;\n            externalFee = _newFee;\n        } else if (_feeType == FeeType.KEEPER) {\n            oldFee = keeperFee;\n            keeperFee = _newFee;\n        }\n        emit FeeUpdated(_feeType, oldFee, _newFee);\n    }\n\n    /**\n     * @notice Marks or unmarks an address as internal for fee calculation purposes.\n     * @dev Only callable by MANAGER_ROLE. Internal addresses typically pay reduced\n     *      or zero fees to incentivize platform usage. Reverts on zero address.\n     * @param _user The address to update.\n     * @param _isInternal True to mark as internal, false to unmark.\n     */\n    function setInternalAddress(address _user, bool _isInternal) external onlyRole(MANAGER_ROLE) {\n        if (_user == address(0)) revert SuperDCAGauge__ZeroAddress();\n        isInternalAddress[_user] = _isInternal;\n        emit InternalAddressUpdated(_user, _isInternal);\n    }\n\n    /**\n     * @notice Transfers ownership of the SuperDCA token back to the caller.\n     * @dev Only callable by DEFAULT_ADMIN_ROLE. Used when the gauge contract initially\n     *      owns the SuperDCA token but ownership needs to be returned to the admin for\n     *      configuration or other administrative purposes.\n     */\n    function returnSuperDCATokenOwnership() external onlyRole(DEFAULT_ADMIN_ROLE) {\n        ISuperchainERC20(superDCAToken).transferOwnership(msg.sender);\n        emit SuperDCATokenOwnershipReturned(msg.sender);\n    }\n\n    /**\n     * @notice Safely attempts to mint tokens, returning false if the call reverts.\n     * @param to The address to mint tokens to.\n     * @param amount The amount of tokens to mint.\n     * @return success True if minting succeeded, false otherwise.\n     */\n    function _tryMint(address to, uint256 amount) internal returns (bool success) {\n        if (amount == 0) return true;\n        try ISuperchainERC20(superDCAToken).mint(to, amount) {\n            return true;\n        } catch {\n            return false;\n        }\n    }\n}\n"},"src/SuperDCAListing.sol":{"content":"// SPDX-License-Identifier: Apache-2.0\npragma solidity ^0.8.22;\n\nimport {Ownable2Step} from \"@openzeppelin/contracts/access/Ownable2Step.sol\";\nimport {Ownable} from \"@openzeppelin/contracts/access/Ownable.sol\";\nimport {IERC721} from \"@openzeppelin/contracts/token/ERC721/IERC721.sol\";\nimport {IERC20} from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\n\nimport {IPoolManager} from \"@uniswap/v4-core/src/interfaces/IPoolManager.sol\";\nimport {PoolKey} from \"@uniswap/v4-core/src/types/PoolKey.sol\";\nimport {PoolId, PoolIdLibrary} from \"@uniswap/v4-core/src/types/PoolId.sol\";\nimport {Currency} from \"@uniswap/v4-core/src/types/Currency.sol\";\nimport {IHooks} from \"@uniswap/v4-core/src/interfaces/IHooks.sol\";\nimport {StateLibrary} from \"@uniswap/v4-core/src/libraries/StateLibrary.sol\";\nimport {TickMath} from \"lib/v4-core/src/libraries/TickMath.sol\";\nimport {LiquidityAmounts} from \"lib/v4-core/test/utils/LiquidityAmounts.sol\";\n\nimport {IPositionManager} from \"lib/v4-periphery/src/interfaces/IPositionManager.sol\";\nimport {PositionInfo} from \"lib/v4-periphery/src/libraries/PositionInfoLibrary.sol\";\n\nimport {ISuperDCAListing} from \"./interfaces/ISuperDCAListing.sol\";\nimport {Actions} from \"lib/v4-periphery/src/libraries/Actions.sol\";\n\n/**\n * @title SuperDCAListing\n * @notice Manages token listing for Super DCA by validating and taking custody of Uniswap V4 NFT positions.\n * @dev This contract implements a token listing system where tokens become eligible for DCA operations\n *      by depositing qualifying Uniswap V4 NFT positions. The contract enforces strict validation:\n *\n *      Listing Requirements:\n *      - Position must be full-range (min to max usable ticks)\n *      - Pool must pair the target token with SUPER_DCA_TOKEN\n *      - Pool must use the configured gauge hook (SuperDCAGauge)\n *      - SuperDCA token liquidity must meet minimum threshold\n *      - Token cannot already be listed\n *\n *      Architecture:\n *      - Uses Ownable2Step for secure ownership transfers\n *      - Integrates with Uniswap V4 PoolManager and PositionManager\n *      - Validates pool configuration and position parameters\n *      - Enables fee collection for deposited positions\n *\n *      Security Features:\n *      - Pool key validation prevents manipulation\n *      - Hook address enforcement ensures gauge integration\n *      - Full-range requirement prevents partial liquidity gaming\n *      - Minimum liquidity threshold ensures meaningful listings\n */\ncontract SuperDCAListing is ISuperDCAListing, Ownable2Step {\n    using PoolIdLibrary for PoolKey;\n    using StateLibrary for IPoolManager;\n\n    // ============ Immutable Configuration ============\n\n    /// @notice The Uniswap V4 pool manager contract for pool state queries and validation.\n    /// @dev Used to retrieve pool information and validate pool states.\n    IPoolManager public immutable POOL_MANAGER;\n\n    /// @notice The Uniswap V4 position manager contract for NFT position operations.\n    /// @dev Used to query position details, transfer custody, and collect fees.\n    IPositionManager public immutable POSITION_MANAGER_V4;\n\n    /// @notice The SuperDCA token that must be paired in all listed pools.\n    /// @dev Every listed token must have a pool that pairs with this token.\n    address public immutable SUPER_DCA_TOKEN;\n\n    // ============ Mutable Configuration ============\n\n    /// @notice The required hook address that must be present in listed pools.\n    /// @dev Typically set to the SuperDCAGauge address to ensure proper integration.\n    IHooks public expectedHooks;\n\n    /// @notice The minimum SuperDCA token liquidity required for listing eligibility.\n    /// @dev Prevents spam listings with insignificant liquidity amounts.\n    uint256 public minLiquidity = 1000 * 10 ** 18;\n\n    // ============ Listing State ============\n\n    /// @notice Tracks which tokens have been successfully listed for DCA operations.\n    /// @dev Maps token address to listing status (true = listed, false = not listed).\n    mapping(address token => bool listed) public override isTokenListed;\n\n    /// @notice Maps NFT position IDs to their corresponding listed token addresses.\n    /// @dev Used to track which positions are held by this contract for each token.\n    mapping(uint256 nfpId => address token) public override tokenOfNfp;\n\n    // ============ Events ============\n\n    /// @notice Emitted when a token is successfully listed through NFT position deposit.\n    /// @param token The token address that was listed for DCA operations.\n    /// @param nftId The Uniswap V4 NFT position ID that was deposited.\n    /// @param key The complete pool key for the position (currencies, fee, tickSpacing, hooks).\n    event TokenListed(address indexed token, uint256 indexed nftId, PoolKey key);\n\n    /// @notice Emitted when the minimum liquidity requirement is updated by the owner.\n    /// @param oldMin The previous minimum liquidity requirement.\n    /// @param newMin The new minimum liquidity requirement.\n    event MinimumLiquidityUpdated(uint256 oldMin, uint256 newMin);\n\n    /// @notice Emitted when the expected hook address is updated by the owner.\n    /// @param oldHook The previous hook address.\n    /// @param newHook The new required hook address for listings.\n    event HookAddressSet(address indexed oldHook, address indexed newHook);\n\n    /// @notice Emitted when fees are collected from a listed position.\n    /// @param recipient The address that received the collected fees.\n    /// @param token0 The first token in the pool pair.\n    /// @param token1 The second token in the pool pair.\n    /// @param amount0 The amount of token0 fees collected.\n    /// @param amount1 The amount of token1 fees collected.\n    event FeesCollected(\n        address indexed recipient, address indexed token0, address indexed token1, uint256 amount0, uint256 amount1\n    );\n\n    // ============ Custom Errors ============\n\n    /// @notice Thrown when an NFT ID is zero or when required addresses are not properly set.\n    error SuperDCAListing__UniswapTokenNotSet();\n\n    /// @notice Thrown when the pool's hook address doesn't match the required gauge hook.\n    error SuperDCAListing__IncorrectHookAddress();\n\n    /// @notice Thrown when the SuperDCA token liquidity is below the minimum requirement.\n    error SuperDCAListing__LowLiquidity();\n\n    /// @notice Thrown when the NFT position is not full-range for the pool's tick spacing.\n    error SuperDCAListing__NotFullRangePosition();\n\n    /// @notice Thrown when attempting to list a token that has already been listed.\n    error SuperDCAListing__TokenAlreadyListed();\n\n    /// @notice Thrown when a zero address is provided where a valid address is required.\n    error SuperDCAListing__ZeroAddress();\n\n    /// @notice Thrown when an invalid address is provided for operations requiring valid addresses.\n    error SuperDCAListing__InvalidAddress();\n\n    /// @notice Thrown when the provided pool key doesn't match the NFT position's actual key.\n    error SuperDCAListing__MismatchedPoolKey();\n\n    /**\n     * @notice Initializes the SuperDCAListing contract with core addresses and configuration.\n     * @dev Sets up the contract with immutable addresses and transfers ownership to the admin.\n     *      The expected hooks address can be updated later by the owner.\n     * @param _superDCAToken The address of the SuperDCA ERC20 token that must be in all listed pools.\n     * @param _poolManager The Uniswap V4 pool manager contract address.\n     * @param _positionManagerV4 The Uniswap V4 position manager contract address.\n     * @param _admin The address that will become the owner of this contract.\n     * @param _expectedHooks The initial hook address required for valid pool listings.\n     */\n    constructor(\n        address _superDCAToken,\n        IPoolManager _poolManager,\n        IPositionManager _positionManagerV4,\n        address _admin,\n        IHooks _expectedHooks\n    ) Ownable(_admin) {\n        if (_superDCAToken == address(0)) revert SuperDCAListing__ZeroAddress();\n        SUPER_DCA_TOKEN = _superDCAToken;\n        POOL_MANAGER = _poolManager;\n        POSITION_MANAGER_V4 = _positionManagerV4;\n        expectedHooks = _expectedHooks;\n    }\n\n    /**\n     * @notice Updates the required hook address for new token listings.\n     * @dev Only callable by the contract owner. This allows updating the gauge address\n     *      if needed without redeploying the listing contract.\n     * @param _newHook The new hook address that must be present in listed pools.\n     */\n    function setHookAddress(IHooks _newHook) external {\n        _checkOwner();\n        emit HookAddressSet(address(expectedHooks), address(_newHook));\n        expectedHooks = _newHook;\n    }\n\n    /**\n     * @notice Updates the minimum SuperDCA token liquidity required for token listings.\n     * @dev Only callable by the contract owner. Used to adjust listing requirements\n     *      based on market conditions or policy changes.\n     * @param _minLiquidity The new minimum liquidity threshold in SuperDCA tokens.\n     */\n    function setMinimumLiquidity(uint256 _minLiquidity) external override {\n        _checkOwner();\n        uint256 old = minLiquidity;\n        minLiquidity = _minLiquidity;\n        emit MinimumLiquidityUpdated(old, _minLiquidity);\n    }\n\n    /**\n     * @notice Lists a token for DCA operations by validating and taking custody of a Uniswap V4 NFT position.\n     * @dev On successful validation, transfers NFT custody to this contract and marks\n     *      the token as listed for DCA operations.\n     * @param nftId The Uniswap V4 NFT position ID to use for listing.\n     * @param providedKey The pool key that must match the position's actual configuration.\n     */\n     //@audit-q, is normal that nfts are lost if this function is called?\n    function list(uint256 nftId, PoolKey calldata providedKey) external override {\n        // Verify NFT ID is non-zero\n        if (nftId == 0) revert SuperDCAListing__UniswapTokenNotSet();\n\n        // Retrieve actual pool key from position manager and validate it matches\n        // the caller's provided key to prevent manipulation or misconfiguration\n        (PoolKey memory key,) = POSITION_MANAGER_V4.getPoolAndPositionInfo(nftId);\n        if (\n            Currency.unwrap(key.currency0) != Currency.unwrap(providedKey.currency0)\n                || Currency.unwrap(key.currency1) != Currency.unwrap(providedKey.currency1) || key.fee != providedKey.fee\n                || key.tickSpacing != providedKey.tickSpacing || address(key.hooks) != address(providedKey.hooks)\n        ) {\n            revert SuperDCAListing__MismatchedPoolKey();\n        }\n\n        // Confirm pool uses the required hook address\n        // This ensures proper integration with the DCA system\n        if (address(key.hooks) != address(expectedHooks)) revert SuperDCAListing__IncorrectHookAddress();\n\n        // Ensure position is full-range (min to max usable ticks)\n        // This prevents gaming with partial liquidity ranges\n        {\n            PositionInfo _pi = POSITION_MANAGER_V4.positionInfo(nftId);\n            int24 _tickLower = _pi.tickLower();\n            int24 _tickUpper = _pi.tickUpper();\n\n            if (\n                _tickLower != TickMath.minUsableTick(key.tickSpacing)\n                    || _tickUpper != TickMath.maxUsableTick(key.tickSpacing)\n            ) {\n                revert SuperDCAListing__NotFullRangePosition();\n            }\n\n            // Calculate token amounts from the position's liquidity\n            uint128 _liquidity = POSITION_MANAGER_V4.getPositionLiquidity(nftId);\n            (uint256 amount0, uint256 amount1) = _getAmountsForKey(key, _tickLower, _tickUpper, _liquidity);\n\n            // Determine which token is being listed and validate SuperDCA liquidity amount\n            address listedToken;\n            uint256 dcaAmount;\n            if (Currency.unwrap(key.currency0) == SUPER_DCA_TOKEN) {\n                listedToken = Currency.unwrap(key.currency1);\n                dcaAmount = amount0;\n            } else {\n                listedToken = Currency.unwrap(key.currency0);\n                dcaAmount = amount1;\n            }\n\n            // Check that the non-DCA token isn't already listed\n            if (isTokenListed[listedToken]) revert SuperDCAListing__TokenAlreadyListed();\n\n            // Validate SuperDCA token liquidity meets minimum requirement\n            if (dcaAmount < minLiquidity) revert SuperDCAListing__LowLiquidity();\n\n            // Update listing state\n            isTokenListed[listedToken] = true;\n            tokenOfNfp[nftId] = listedToken;\n        }\n\n        // Transfer NFT custody to this contract\n        IERC721(address(POSITION_MANAGER_V4)).transferFrom(msg.sender, address(this), nftId);\n        emit TokenListed(tokenOfNfp[nftId], nftId, key);\n    }\n\n    /**\n     * @notice Calculates token amounts for a liquidity position based on current pool price.\n     * @dev Uses Uniswap V4's standard math libraries to convert liquidity to token amounts.\n     *      The calculation depends on the current pool price (sqrtPriceX96) and the\n     *      position's tick range. For full-range positions, this gives the exact\n     *      token amounts that would be withdrawn if the position were closed.\n     * @param key The pool key containing currency and fee information.\n     * @param tickLower The lower tick of the position (should be min usable tick).\n     * @param tickUpper The upper tick of the position (should be max usable tick).\n     * @param liquidity The position's liquidity amount.\n     * @return amount0 The calculated amount of currency0 in the position.\n     * @return amount1 The calculated amount of currency1 in the position.\n     */\n    function _getAmountsForKey(PoolKey memory key, int24 tickLower, int24 tickUpper, uint128 liquidity)\n        internal\n        view\n        returns (uint256 amount0, uint256 amount1)\n    {\n        (uint160 sqrtPriceX96,,,) = POOL_MANAGER.getSlot0(key.toId());\n        uint160 sqrtPriceAX96 = TickMath.getSqrtPriceAtTick(tickLower);\n        uint160 sqrtPriceBX96 = TickMath.getSqrtPriceAtTick(tickUpper);\n        return (LiquidityAmounts.getAmountsForLiquidity(sqrtPriceX96, sqrtPriceAX96, sqrtPriceBX96, liquidity));\n    }\n\n    /**\n     * @notice Collects accumulated fees from a listed NFT position and transfers them to a recipient.\n     * @dev Only callable by the contract owner. Uses Uniswap V4's DECREASE_LIQUIDITY and TAKE_PAIR\n     *      actions with zero liquidity to collect fees without removing position liquidity.\n     * @param nfpId The NFT position ID to collect fees from.\n     * @param recipient The address that will receive the collected fees.\n     */\n    function collectFees(uint256 nfpId, address recipient) external override {\n        _checkOwner();\n\n        // Validate the NFT ID and recipient address\n        if (nfpId == 0) revert SuperDCAListing__UniswapTokenNotSet();\n        if (recipient == address(0)) revert SuperDCAListing__InvalidAddress();\n\n        // Retrieve the position's pool information\n        (PoolKey memory key,) = POSITION_MANAGER_V4.getPoolAndPositionInfo(nfpId);\n        Currency token0 = key.currency0;\n        Currency token1 = key.currency1;\n\n        // Record token balances before fee collection\n        uint256 balance0Before = IERC20(Currency.unwrap(token0)).balanceOf(recipient);\n        uint256 balance1Before = IERC20(Currency.unwrap(token1)).balanceOf(recipient);\n\n        // Prepare actions: DECREASE_LIQUIDITY (with 0 liquidity) + TAKE_PAIR\n        // This collects fees without removing any actual liquidity\n        bytes memory actions = abi.encodePacked(uint8(Actions.DECREASE_LIQUIDITY), uint8(Actions.TAKE_PAIR));\n\n        bytes[] memory params = new bytes[](2);\n        // DECREASE_LIQUIDITY params: (tokenId, liquidity128Delta, amount0Min, amount1Min, hookData)\n        params[0] = abi.encode(nfpId, uint256(0), uint128(0), uint128(0), bytes(\"\"));\n        // TAKE_PAIR params: (currency0, currency1, recipient)\n        params[1] = abi.encode(token0, token1, recipient);\n\n        // Execute fee collection with short deadline\n        uint256 deadline = block.timestamp + 60;\n        POSITION_MANAGER_V4.modifyLiquidities(abi.encode(actions, params), deadline);\n\n        // Calculate and emit the collected amounts\n        uint256 balance0After = IERC20(Currency.unwrap(token0)).balanceOf(recipient);\n        uint256 balance1After = IERC20(Currency.unwrap(token1)).balanceOf(recipient);\n\n        uint256 collectedAmount0 = balance0After - balance0Before;\n        uint256 collectedAmount1 = balance1After - balance1Before;\n\n        emit FeesCollected(\n            recipient, Currency.unwrap(token0), Currency.unwrap(token1), collectedAmount0, collectedAmount1\n        );\n    }\n}\n"},"src/SuperDCAStaking.sol":{"content":"// SPDX-License-Identifier: Apache-2.0\npragma solidity ^0.8.22;\n\nimport {ISuperDCAStaking} from \"./interfaces/ISuperDCAStaking.sol\";\nimport {ISuperDCAGauge} from \"./interfaces/ISuperDCAGauge.sol\";\nimport {IERC20} from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport {EnumerableSet} from \"@openzeppelin/contracts/utils/structs/EnumerableSet.sol\";\nimport {Math} from \"@openzeppelin/contracts/utils/math/Math.sol\";\nimport {Ownable2Step} from \"@openzeppelin/contracts/access/Ownable2Step.sol\";\nimport {Ownable} from \"@openzeppelin/contracts/access/Ownable.sol\";\n\n/**\n * @title SuperDCAStaking\n * @notice Manages staking mechanics and reward calculations for SuperDCA token holders.\n * @dev This contract implements a sophisticated staking system with time-based reward accrual:\n *\n *      Core Mechanics:\n *      - Users stake SuperDCA tokens into specific token \"buckets\" (non-DCA tokens)\n *      - Global reward index grows continuously based on time and mint rate\n *      - Individual rewards calculated as: staked_amount * (current_index - user_last_index)\n *      - Only listed tokens (verified via gauge) can receive stakes\n *\n *      Integration Architecture:\n *      - Isolated from Uniswap V4 hook for clean separation of concerns\n *      - Gauge contract calls accrueReward() during hook events\n *      - This contract handles accounting; gauge handles minting and distribution\n *      - Owner/gauge can update mint rate for dynamic reward adjustment\n *\n *      Security Features:\n *      - Token listing verification prevents staking in unlisted tokens\n *      - Per-user token set tracking for efficient queries\n *      - Authorized gauge pattern prevents unauthorized reward accrual\n *      - Mathematical precision with 1e18 scaling for reward calculations\n */\ncontract SuperDCAStaking is ISuperDCAStaking, Ownable2Step {\n    using EnumerableSet for EnumerableSet.AddressSet;\n\n    // ============ Immutable Configuration ============\n\n    /// @notice The SuperDCA token contract address used for all staking operations.\n    /// @dev This token is staked by users and used for reward calculations.\n    address public immutable DCA_TOKEN;\n\n    // ============ Mutable Configuration ============\n\n    /// @notice The authorized gauge contract address that can trigger reward accruals.\n    /// @dev Only this address can call accrueReward() to maintain reward distribution integrity.\n    address public gauge;\n\n    // ============ Reward State Variables ============\n\n    /// @notice The current mint rate used for reward index growth (tokens per second).\n    /// @dev Higher mint rate means faster reward accumulation for stakers.\n    uint256 public override mintRate;\n\n    /// @notice The timestamp when the global reward index was last updated.\n    /// @dev Used to calculate elapsed time for reward index growth.\n    uint256 public override lastMinted;\n\n    /// @notice The global reward index scaled by 1e18 for mathematical precision.\n    /// @dev Continuously grows based on time elapsed and mint rate.\n    uint256 public override rewardIndex;\n\n    /// @notice The total amount of SuperDCA tokens currently staked across all token buckets.\n    /// @dev Used as denominator in reward index calculations.\n    uint256 public totalStakedAmount;\n\n    // ============ Token and User Accounting ============\n\n    /// @notice Maps token addresses to their reward accounting information.\n    /// @dev Private mapping accessed via public view functions.\n    mapping(address => TokenRewardInfo) private tokenRewardInfoOf;\n\n    /// @notice Maps user addresses to their staked amounts per token bucket.\n    /// @dev Tracks how much each user has staked in each token's bucket.\n    mapping(address user => mapping(address token => uint256 amount)) public userStakes;\n\n    /// @notice Maps user addresses to sets of tokens they have staked in.\n    /// @dev Used for efficient enumeration of user's active stakes.\n    mapping(address user => EnumerableSet.AddressSet) private userTokenSet;\n\n    // ============ Events ============\n\n    /// @notice Emitted when the authorized gauge address is updated.\n    /// @param gauge The new gauge address that can call accrueReward.\n    event GaugeSet(address indexed gauge);\n\n    /// @notice Emitted when the global reward index is updated.\n    /// @param newIndex The new global reward index value (scaled by 1e18).\n    event RewardIndexUpdated(uint256 newIndex);\n\n    /// @notice Emitted when a user stakes SuperDCA tokens into a token bucket.\n    /// @param token The token bucket that received the stake.\n    /// @param user The user who staked the tokens.\n    /// @param amount The amount of SuperDCA tokens staked.\n    event Staked(address indexed token, address indexed user, uint256 amount);\n\n    /// @notice Emitted when a user unstakes SuperDCA tokens from a token bucket.\n    /// @param token The token bucket from which tokens were unstaked.\n    /// @param user The user who unstaked the tokens.\n    /// @param amount The amount of SuperDCA tokens unstaked.\n    event Unstaked(address indexed token, address indexed user, uint256 amount);\n\n    /// @notice Emitted when the mint rate is updated by owner or gauge.\n    /// @param newRate The new mint rate in tokens per second.\n    event MintRateUpdated(uint256 newRate);\n\n    // ============ Custom Errors ============\n\n    /// @notice Thrown when a zero amount is provided where a positive amount is required.\n    error SuperDCAStaking__ZeroAmount();\n\n    /// @notice Thrown when attempting to unstake more than the available balance.\n    error SuperDCAStaking__InsufficientBalance();\n\n    /// @notice Thrown when a non-gauge address attempts to call gauge-only functions.\n    error SuperDCAStaking__NotGauge();\n\n    /// @notice Thrown when a zero address is provided where a valid address is required.\n    error SuperDCAStaking__ZeroAddress();\n\n    /// @notice Thrown when an unauthorized address attempts to perform admin actions.\n    error SuperDCAStaking__NotAuthorized();\n\n    /// @notice Thrown when attempting to stake in a token that hasn't been listed.\n    error SuperDCAStaking__TokenNotListed();\n\n    /// @notice Restricts function access to the authorized gauge contract only.\n    /// @dev Used to ensure only the gauge can trigger reward accruals.\n    modifier onlyGauge() {\n        if (msg.sender != gauge) revert SuperDCAStaking__NotGauge();\n        _;\n    }\n\n    /**\n     * @notice Initializes the SuperDCAStaking contract with core configuration.\n     * @dev Sets up the contract with the SuperDCA token address and initial mint rate.\n     *      The lastMinted timestamp is set to current block time to start reward accrual.\n     * @param _superDCAToken The ERC20 SuperDCA token address used for staking operations.\n     * @param _mintRate The initial mint rate in tokens per second for reward calculations.\n     * @param _owner The address that will own this contract and can perform admin functions.\n     */\n    constructor(address _superDCAToken, uint256 _mintRate, address _owner) Ownable(_owner) {\n        if (_superDCAToken == address(0)) revert SuperDCAStaking__ZeroAddress();\n        DCA_TOKEN = _superDCAToken;\n        mintRate = _mintRate;\n        lastMinted = block.timestamp;\n    }\n\n    /**\n     * @notice Sets the authorized gauge contract address.\n     * @dev Only callable by the contract owner. The gauge is the only address\n     *      permitted to call accrueReward() for reward distribution integration.\n     * @param _gauge The gauge contract address to authorize.\n     */\n    function setGauge(address _gauge) external override {\n        _checkOwner();\n        if (_gauge == address(0)) revert SuperDCAStaking__ZeroAddress();\n        gauge = _gauge;\n        emit GaugeSet(_gauge);\n    }\n\n    /**\n     * @notice Updates the mint rate used for global reward index growth.\n     * @dev Callable by either the contract owner or the authorized gauge for operational\n     *      flexibility. Higher mint rates increase reward accumulation speed for all stakers.\n     * @param newMintRate The new mint rate in tokens per second.\n     */\n    function setMintRate(uint256 newMintRate) external override {\n        if (msg.sender != owner() && msg.sender != gauge) revert SuperDCAStaking__NotAuthorized();\n        mintRate = newMintRate;\n        emit MintRateUpdated(newMintRate);\n    }\n\n    // ============ Internal Accounting Functions ============\n\n    /**\n     * @notice Updates the global reward index based on elapsed time and total staked amount.\n     * @dev The 1e18 scaling factor provides mathematical precision for fractional rewards.\n     */\n    function _updateRewardIndex() internal {\n        // Return early if no stakes exist or no time has passed\n        if (totalStakedAmount == 0) return;\n        uint256 elapsed = block.timestamp - lastMinted;\n        if (elapsed == 0) return;\n        // Calculate mint amount based on elapsed time and mint rate\n        uint256 mintAmount = elapsed * mintRate;\n\n        // Update global index: previous_index + (mint_amount * 1e18 / total_staked)\n    \n        rewardIndex += Math.mulDiv(mintAmount, 1e18, totalStakedAmount);\n        lastMinted = block.timestamp;\n        emit RewardIndexUpdated(rewardIndex);\n    }\n\n    // ============ User Staking Functions ============\n\n    /**\n     * @notice Stakes SuperDCA tokens into a specific token bucket to earn rewards.\n     * @dev Stakes earn rewards proportional to time staked and total pool activity.\n     * @param token The non-DCA token identifying which bucket to stake into.\n     * @param amount The amount of SuperDCA tokens to stake.\n     */\n    function stake(address token, uint256 amount) external override {\n        // Validate amount is non-zero and gauge is set\n        if (amount == 0) revert SuperDCAStaking__ZeroAmount();\n        if (gauge == address(0)) revert SuperDCAStaking__ZeroAddress();\n\n        // Verify the token is listed via gauge contract\n        if (!ISuperDCAGauge(gauge).isTokenListed(token)) revert SuperDCAStaking__TokenNotListed();\n\n        // Update global reward index to current time\n        _updateRewardIndex();\n\n        // Transfer SuperDCA tokens from user to contract\n        IERC20(DCA_TOKEN).transferFrom(msg.sender, address(this), amount);\n\n        // Update token bucket accounting and user stakes\n        TokenRewardInfo storage info = tokenRewardInfoOf[token];\n        info.stakedAmount += amount;\n        info.lastRewardIndex = rewardIndex;\n\n        totalStakedAmount += amount;\n        userStakes[msg.sender][token] += amount;\n\n        // Add token to user's active token set if new\n        //@audit-q (maximum severity expectation: low), looking at EnumerableSet, only one value can be added to the msg.sender mapping,\n        //so what would happens if the user stakes twice with different tokens?\n        userTokenSet[msg.sender].add(token);\n\n        emit Staked(token, msg.sender, amount);\n    }\n\n    /**\n     * @notice Unstakes SuperDCA tokens from a specific token bucket.\n     * @param token The non-DCA token identifying which bucket to unstake from.\n     * @param amount The amount of SuperDCA tokens to unstake.\n     */\n    function unstake(address token, uint256 amount) external override {\n        // Validate amount is non-zero and available\n        if (amount == 0) revert SuperDCAStaking__ZeroAmount();\n\n        // Check both token bucket and user balances are sufficient\n        TokenRewardInfo storage info = tokenRewardInfoOf[token];\n        if (info.stakedAmount < amount) revert SuperDCAStaking__InsufficientBalance();\n        if (userStakes[msg.sender][token] < amount) revert SuperDCAStaking__InsufficientBalance();\n\n        // Update global reward index to current time\n        _updateRewardIndex();\n\n        // Update token bucket accounting and user stakes\n        info.stakedAmount -= amount;\n        info.lastRewardIndex = rewardIndex;\n\n        totalStakedAmount -= amount;\n        userStakes[msg.sender][token] -= amount;\n\n        // Remove token from user's set if balance reaches zero\n        if (userStakes[msg.sender][token] == 0) {\n            userTokenSet[msg.sender].remove(token);\n        }\n\n        // Transfer SuperDCA tokens back to user\n        IERC20(DCA_TOKEN).transfer(msg.sender, amount);\n        emit Unstaked(token, msg.sender, amount);\n    }\n\n    // ============ Gauge Integration Functions ============\n\n    /**\n     * @notice Calculates and returns the reward amount for a specific token bucket since last accrual.\n     * @dev Only callable by the authorized gauge during Uniswap V4 hook events.\n     *      The returned amount represents the portion of global rewards attributed to\n     *      stakers in this specific token bucket based on their staked amounts.\n     * @param token The non-DCA token bucket to calculate rewards for.\n     * @return rewardAmount The amount of rewards attributed to this token bucket.\n     */\n    function accrueReward(address token) external override onlyGauge returns (uint256 rewardAmount) {\n        // Always update the global reward index to current time\n        _updateRewardIndex();\n\n        TokenRewardInfo storage info = tokenRewardInfoOf[token];\n        if (info.stakedAmount == 0) return 0;\n\n        // Calculate reward delta for the specific token bucket\n        uint256 delta = rewardIndex - info.lastRewardIndex;\n        if (delta == 0) return 0;\n\n        // Compute and return reward amount for distribution\n        \n        rewardAmount = Math.mulDiv(info.stakedAmount, delta, 1e18);\n\n        // Update the token's last reward index to current index\n        info.lastRewardIndex = rewardIndex;\n        return rewardAmount;\n    }\n\n    // ============ View Functions ============\n\n    /**\n     * @notice Previews pending rewards for a token bucket without updating state.\n     * @dev Simulates reward accrual by calculating what the reward would be if\n     *      accrueReward() were called at the current block timestamp. This allows\n     *      users and interfaces to preview rewards before actual accrual.\n     * @param token The non-DCA token bucket to preview rewards for.\n     * @return The calculated pending reward amount for the token bucket.\n     */\n    function previewPending(address token) external view override returns (uint256) {\n        TokenRewardInfo storage info = tokenRewardInfoOf[token];\n        if (info.stakedAmount == 0 || totalStakedAmount == 0) return 0;\n\n        uint256 currentIndex = rewardIndex;\n        uint256 elapsed = block.timestamp - lastMinted;\n        if (elapsed > 0) {\n            uint256 mintAmount = elapsed * mintRate;\n            currentIndex += Math.mulDiv(mintAmount, 1e18, totalStakedAmount);\n        }\n        return Math.mulDiv(info.stakedAmount, currentIndex - info.lastRewardIndex, 1e18);\n    }\n\n    /**\n     * @notice Returns the amount of SuperDCA tokens a user has staked in a specific token bucket.\n     * @param user The user address to query.\n     * @param token The token bucket to check.\n     * @return The amount of SuperDCA tokens staked by the user in the specified bucket.\n     */\n    function getUserStake(address user, address token) external view override returns (uint256) {\n        return userStakes[user][token];\n    }\n\n    /**\n     * @notice Returns all token buckets where a user has active stakes.\n     * @dev Uses EnumerableSet for efficient tracking of user's active token buckets.\n     * @param user The user address to query.\n     * @return An array of token addresses where the user has non-zero stakes.\n     */\n    function getUserStakedTokens(address user) external view override returns (address[] memory) {\n        return userTokenSet[user].values();\n    }\n\n    /**\n     * @notice Returns the reward accounting information for a specific token bucket.\n     * @dev Provides access to the private tokenRewardInfoOf mapping for external queries.\n     * @param token The token bucket to query.\n     * @return stakedAmount The total amount of SuperDCA tokens staked in this bucket.\n     * @return lastRewardIndex_ The reward index when this bucket was last updated.\n     */\n    function tokenRewardInfos(address token)\n        external\n        view\n        override\n        returns (uint256 stakedAmount, uint256 lastRewardIndex_)\n    {\n        TokenRewardInfo storage info = tokenRewardInfoOf[token];\n        return (info.stakedAmount, info.lastRewardIndex);\n    }\n}\n"},"src/interfaces/IMsgSender.sol":{"content":"// SPDX-License-Identifier: Apache-2.0\npragma solidity ^0.8.22;\n\ninterface IMsgSender {\n    function msgSender() external view returns (address);\n}\n"},"src/interfaces/ISuperDCAGauge.sol":{"content":"// SPDX-License-Identifier: Apache-2.0\npragma solidity ^0.8.22;\n\ninterface ISuperDCAGauge {\n    function isTokenListed(address token) external view returns (bool);\n}\n"},"src/interfaces/ISuperDCAListing.sol":{"content":"// SPDX-License-Identifier: Apache-2.0\npragma solidity ^0.8.22;\n\nimport {PoolKey} from \"@uniswap/v4-core/src/types/PoolKey.sol\";\n\ninterface ISuperDCAListing {\n    function isTokenListed(address token) external view returns (bool);\n    function tokenOfNfp(uint256 nfpId) external view returns (address);\n    function list(uint256 nftId, PoolKey calldata key) external;\n    function setMinimumLiquidity(uint256 _minLiquidity) external;\n    function collectFees(uint256 nfpId, address recipient) external;\n}\n"},"src/interfaces/ISuperDCAStaking.sol":{"content":"// SPDX-License-Identifier: Apache-2.0\npragma solidity ^0.8.22;\n\ninterface ISuperDCAStaking {\n    struct TokenRewardInfo {\n        uint256 stakedAmount;\n        uint256 lastRewardIndex;\n    }\n\n    // User actions\n    function stake(address token, uint256 amount) external;\n    function unstake(address token, uint256 amount) external;\n\n    // Called by gauge on hook events\n    function accrueReward(address token) external returns (uint256 rewardAmount);\n\n    // Views\n    function previewPending(address token) external view returns (uint256);\n    function getUserStake(address user, address token) external view returns (uint256);\n    function getUserStakedTokens(address user) external view returns (address[] memory);\n\n    function totalStakedAmount() external view returns (uint256);\n    function rewardIndex() external view returns (uint256);\n    function mintRate() external view returns (uint256);\n    function lastMinted() external view returns (uint256);\n\n    function tokenRewardInfos(address token) external view returns (uint256 stakedAmount, uint256 lastRewardIndex);\n\n    // Admin\n    function setGauge(address _gauge) external;\n    function setMintRate(uint256 newMintRate) external;\n}\n"},"src/interfaces/ISuperchainERC20.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\n/// @notice This includes only the functions needed by the SuperDCAGauge\ninterface ISuperchainERC20 {\n    /**\n     * @notice Mints tokens to a specified address\n     * @param to_ The address to mint tokens to\n     * @param amount_ The amount of tokens to mint\n     */\n    function mint(address to_, uint256 amount_) external;\n\n    // TODO: This is for the Superchain DCA token (DCA v2)\n    // /**\n    //  * @notice Grants a role to an account\n    //  * @param role The role being granted\n    //  * @param account The account receiving the role\n    //  */\n    // function grantRole(bytes32 role, address account) external;\n\n    // TODO: This is for the non-Superchain DCA token (DCA v1)\n    // Add owner function\n    function owner() external view returns (address);\n\n    // Add function for transferring ownership (Ownable)\n    function transferOwnership(address newOwner) external;\n}\n"},"test/AuditTest/MaliciousUserCanObtainSoloRewards.t.sol":{"content":"// SPDX-License-Identifier: Apache-2.0\npragma solidity ^0.8.22;\n\nimport \"forge-std/Test.sol\";\nimport \"forge-std/console.sol\";\nimport {Actions} from \"lib/v4-periphery/src/libraries/Actions.sol\";\nimport {Hooks, IHooks} from \"@uniswap/v4-core/src/libraries/Hooks.sol\";\nimport {IPoolManager} from \"@uniswap/v4-core/src/interfaces/IPoolManager.sol\";\nimport {PoolKey} from \"@uniswap/v4-core/src/types/PoolKey.sol\";\nimport {PoolId, PoolIdLibrary} from \"@uniswap/v4-core/src/types/PoolId.sol\";\nimport {Currency, CurrencyLibrary} from \"@uniswap/v4-core/src/types/Currency.sol\";\nimport {SuperDCAGauge} from \"../../src/SuperDCAGauge.sol\";\nimport {SuperDCAStaking} from \"../../src/SuperDCAStaking.sol\";\nimport {SuperDCAListing} from \"../../src/SuperDCAListing.sol\";\nimport {Deployers} from \"@uniswap/v4-core/test/utils/Deployers.sol\";\nimport {IHooks} from \"@uniswap/v4-core/src/interfaces/IHooks.sol\";\nimport {TickMath} from \"@uniswap/v4-core/src/libraries/TickMath.sol\";\nimport {Test} from \"forge-std/Test.sol\";\nimport {MockERC20Token} from \"../mocks/MockERC20Token.sol\";\nimport {FeesCollectionMock} from \"../mocks/FeesCollectionMock.sol\";\nimport {BalanceDelta} from \"@uniswap/v4-core/src/types/BalanceDelta.sol\";\nimport {SafeCast} from \"@uniswap/v4-core/src/libraries/SafeCast.sol\";\nimport {LPFeeLibrary} from \"@uniswap/v4-core/src/libraries/LPFeeLibrary.sol\";\nimport {TransientStateLibrary} from \"@uniswap/v4-core/src/libraries/TransientStateLibrary.sol\";\nimport {PositionManager} from \"lib/v4-periphery/src/PositionManager.sol\";\nimport {IPositionManager} from \"lib/v4-periphery/src/interfaces/IPositionManager.sol\";\nimport {IERC20} from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport {IAllowanceTransfer} from \"permit2/src/interfaces/IAllowanceTransfer.sol\";\nimport {IPositionDescriptor} from \"lib/v4-periphery/src/interfaces/IPositionDescriptor.sol\";\nimport {IWETH9} from \"lib/v4-periphery/src/interfaces/external/IWETH9.sol\";\nimport {IAccessControl} from \"@openzeppelin/contracts/access/IAccessControl.sol\";\nimport {IERC20} from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\n\n//      sudo forge test --match-path test/AuditTest/MaliciousUserCanObtainSoloRewards.t.sol --fork-url https://arb-mainnet.g.alchemy.com/v2/Z4iZqIYn02E4azjwQ6-utMqyFgY6ZSUX\ncontract MaliciousUserCanObtainSoloRewards is Test, Deployers {\n    using PoolIdLibrary for PoolKey;\n    using CurrencyLibrary for Currency;\n    using LPFeeLibrary for uint24;\n\n    SuperDCAGauge hook;\n    SuperDCAStaking public staking;\n    SuperDCAListing public listing; \n    MockERC20Token public dcaToken;\n    PoolId poolId;\n    address developer = makeAddr(\"developerAddress\");\n    IPositionManager positionManager = IPositionManager(0x360E68faCcca8cA495c1B759Fd9EEe466db9FB32); \n    address poolManager = 0x360E68faCcca8cA495c1B759Fd9EEe466db9FB32; \n    address public constant weth = 0x82aF49447D8a07e3bd95BD0d56f35241523fBab1;\n    IAllowanceTransfer public constant PERMIT2 = IAllowanceTransfer(0x000000000022D473030F116dDEE9F6B43aC78BA3); // Real Permit2 address\n    uint256 public constant UNSUBSCRIBE_LIMIT = 5000;\n    IPositionDescriptor public tokenDescriptor;\n    PositionManager public posM;\n\n    function setUp() public {\n        vm.startPrank(developer); \n        dcaToken = new MockERC20Token(\"Super DCA Token\", \"SDCA\", 18);\n       \n        address flags = address(\n            uint160(\n                Hooks.BEFORE_INITIALIZE_FLAG | Hooks.BEFORE_ADD_LIQUIDITY_FLAG | Hooks.BEFORE_REMOVE_LIQUIDITY_FLAG\n                    | Hooks.BEFORE_SWAP_FLAG | Hooks.AFTER_INITIALIZE_FLAG\n            ) ^ (0x4242 << 144)\n        );\n        bytes memory constructorArgs = abi.encode(IPoolManager(poolManager), dcaToken, developer, positionManager);\n\n        deployCodeTo(\"SuperDCAGauge.sol:SuperDCAGauge\", constructorArgs, flags);\n        hook = SuperDCAGauge(flags);\n        listing = new SuperDCAListing(address(dcaToken), IPoolManager(poolManager), IPositionManager(positionManager), developer, IHooks(address(hook)));\n        staking = new SuperDCAStaking(address(dcaToken), 100, developer); \n\n        hook.setStaking(address(staking)); \n        hook.setListing(address(listing)); \n\n        listing.setHookAddress(IHooks(hook));\n\n        staking.setGauge(address(hook)); \n\n        dcaToken.transferOwnership(address(hook));\n        vm.stopPrank(); \n\n\n    }\n\n\n    function test_maliciousUserCanObtainSoloRewardsByCreatingIndividualPools() public {\n\n        address tokenA = address(dcaToken);\n        address tokenB = address(weth);\n\n        uint160 sqrtPriceX96 = 79228162514264337593543950336; // casual sqrt price\n\n        vm.startPrank(developer); \n        //  The developer creates a legit pool with ETH / DCA assigning the hook, with a tick spacing of 60. \n        int24 tickSpacingLegitPool = 60;\n\n        PoolKey memory legitKey = _createPoolKey(tokenA, tokenB, LPFeeLibrary.DYNAMIC_FEE_FLAG, tickSpacingLegitPool);   \n\n        IPoolManager(poolManager).initialize(legitKey, sqrtPriceX96);\n        vm.stopPrank(); \n\n\n        address maliciousUser = makeAddr(\"maliciousUser\"); \n        vm.startPrank(maliciousUser); \n        //A malicious user is able to create a pool with ETH / DCA and the same hook, but with a tick spacing of 80. \n        //This allows him to utilize his solo pool to obtain solo rewards when \"_beforeAddLiquidity\" is called in the Gauge contract\n        int24 tickSpacingMaliciousPool = 80; \n    \n        PoolKey memory maliciousKey = _createPoolKey(tokenA, tokenB, LPFeeLibrary.DYNAMIC_FEE_FLAG, tickSpacingMaliciousPool);   \n\n        IPoolManager(poolManager).initialize(maliciousKey, sqrtPriceX96);\n        vm.stopPrank();\n    }\n\n       \n    function _createPoolKey(address tokenA, address tokenB, uint24 fee, int24 tickSpacing) internal view returns (PoolKey memory key) {\n        \n        return tokenA < tokenB\n            ? PoolKey({\n                currency0: Currency.wrap(tokenA),\n                currency1: Currency.wrap(tokenB),\n                fee: fee,\n                tickSpacing: tickSpacing, \n                hooks: IHooks(hook)\n            })\n            : PoolKey({\n                currency0: Currency.wrap(tokenB),\n                currency1: Currency.wrap(tokenA),\n                fee: fee,\n                tickSpacing: tickSpacing,\n                hooks: IHooks(hook)\n            });\n    }\n\n\n}"},"test/mocks/FeesCollectionMock.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport {Test} from \"forge-std/Test.sol\";\nimport {MockERC20Token} from \"./MockERC20Token.sol\";\n\ncontract FeesCollectionMock is Test {\n    address public token0;\n    address public token1;\n    address public recipient;\n    uint256 public fee0Amount;\n    uint256 public fee1Amount;\n\n    constructor(address _token0, address _token1, address _recipient, uint256 _fee0Amount, uint256 _fee1Amount) {\n        token0 = _token0;\n        token1 = _token1;\n        recipient = _recipient;\n        fee0Amount = _fee0Amount;\n        fee1Amount = _fee1Amount;\n    }\n\n    function modifyLiquidities(bytes calldata, uint256) external returns (bytes4) {\n        // Simulate fee collection by directly giving tokens to recipient using deal\n        deal(token0, recipient, MockERC20Token(token0).balanceOf(recipient) + fee0Amount);\n        deal(token1, recipient, MockERC20Token(token1).balanceOf(recipient) + fee1Amount);\n        return bytes4(0x43dc74a4); // Return expected selector\n    }\n}\n"},"test/mocks/MockERC20Token.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity ^0.8.22;\n\ncontract MockERC20Token {\n    string public name;\n    string public symbol;\n    uint8 public decimals;\n    uint256 public totalSupply;\n\n    // ----------------------------------\n    // Ownership (Ownable lite)\n    // ----------------------------------\n    address public owner;\n\n    modifier onlyOwner() {\n        require(msg.sender == owner, \"MockERC20Token: caller is not the owner\");\n        _;\n    }\n\n    mapping(address => uint256) public balanceOf;\n    mapping(address => mapping(address => uint256)) public allowance;\n\n    address public lastParam__transfer_to;\n    uint256 public lastParam__transfer_amount;\n    bool public shouldRevertOnNextCall;\n\n    constructor(string memory _name, string memory _symbol, uint8 _decimals) {\n        name = _name;\n        symbol = _symbol;\n        decimals = _decimals;\n\n        owner = msg.sender;\n    }\n\n    function __setShouldRevertOnNextCall(bool _shouldRevert) external {\n        shouldRevertOnNextCall = _shouldRevert;\n    }\n\n    function approve(address spender, uint256 amount) external returns (bool) {\n        allowance[msg.sender][spender] = amount;\n        return true;\n    }\n\n    function transfer(address _to, uint256 _amount) external returns (bool) {\n        require(!shouldRevertOnNextCall, \"MockERC20Token: Revert Requested\");\n        require(balanceOf[msg.sender] >= _amount, \"MockERC20Token: Insufficient balance\");\n\n        balanceOf[msg.sender] -= _amount;\n        balanceOf[_to] += _amount;\n\n        lastParam__transfer_amount = _amount;\n        lastParam__transfer_to = _to;\n        return true;\n    }\n\n    function transferFrom(address from, address to, uint256 amount) external returns (bool) {\n        require(!shouldRevertOnNextCall, \"MockERC20Token: Revert Requested\");\n        require(balanceOf[from] >= amount, \"MockERC20Token: Insufficient balance\");\n        require(allowance[from][msg.sender] >= amount, \"MockERC20Token: Insufficient allowance\");\n\n        allowance[from][msg.sender] -= amount;\n        balanceOf[from] -= amount;\n        balanceOf[to] += amount;\n        return true;\n    }\n\n    function mint(address to, uint256 amount) external {\n        // Only the owner can mint new tokens\n        require(msg.sender == owner, \"MockERC20Token: caller is not the owner\");\n\n        totalSupply += amount;\n        balanceOf[to] += amount;\n    }\n\n    function transferOwnership(address newOwner) external onlyOwner {\n        require(newOwner != address(0), \"MockERC20Token: new owner is the zero address\");\n        owner = newOwner;\n    }\n}\n"}},"settings":{"remappings":["@openzeppelin/contracts/=lib/openzeppelin-contracts/contracts/","v4-core/=lib/v4-core/src/","v4-periphery/=lib/v4-periphery/src/","@ensdomains/=lib/v4-core/node_modules/@ensdomains/","@openzeppelin/contracts-upgradeable/=lib/openzeppelin-contracts-upgradeable/contracts/","@uniswap/v4-core/=lib/v4-periphery/lib/v4-core/","ds-test/=lib/v4-core/lib/forge-std/lib/ds-test/src/","erc4626-tests/=lib/openzeppelin-contracts-upgradeable/lib/erc4626-tests/","forge-gas-snapshot/=lib/v4-periphery/lib/permit2/lib/forge-gas-snapshot/src/","forge-std/=lib/forge-std/src/","halmos-cheatcodes/=lib/openzeppelin-contracts-upgradeable/lib/halmos-cheatcodes/src/","hardhat/=lib/v4-core/node_modules/hardhat/","openzeppelin-contracts-upgradeable/=lib/openzeppelin-contracts-upgradeable/","openzeppelin-contracts/=lib/openzeppelin-contracts/","openzeppelin-foundry-upgrades/=lib/openzeppelin-foundry-upgrades/src/","permit2/=lib/v4-periphery/lib/permit2/","solmate/=lib/v4-core/lib/solmate/"],"optimizer":{"enabled":false,"runs":200},"metadata":{"useLiteralContent":false,"bytecodeHash":"ipfs","appendCBOR":true},"outputSelection":{"lib/forge-std/src/Base.sol":{"*":[]},"lib/forge-std/src/StdAssertions.sol":{"*":[]},"lib/forge-std/src/StdChains.sol":{"*":[]},"lib/forge-std/src/StdCheats.sol":{"*":[]},"lib/forge-std/src/StdError.sol":{"*":[]},"lib/forge-std/src/StdInvariant.sol":{"*":[]},"lib/forge-std/src/StdJson.sol":{"*":[]},"lib/forge-std/src/StdMath.sol":{"*":[]},"lib/forge-std/src/StdStorage.sol":{"*":[]},"lib/forge-std/src/StdStyle.sol":{"*":[]},"lib/forge-std/src/StdToml.sol":{"*":[]},"lib/forge-std/src/StdUtils.sol":{"*":[]},"lib/forge-std/src/Test.sol":{"*":[]},"lib/forge-std/src/Vm.sol":{"*":[]},"lib/forge-std/src/console.sol":{"*":[]},"lib/forge-std/src/console2.sol":{"*":[]},"lib/forge-std/src/interfaces/IMulticall3.sol":{"*":[]},"lib/forge-std/src/safeconsole.sol":{"*":[]},"lib/openzeppelin-contracts/contracts/access/AccessControl.sol":{"*":[]},"lib/openzeppelin-contracts/contracts/access/IAccessControl.sol":{"*":[]},"lib/openzeppelin-contracts/contracts/access/Ownable.sol":{"*":[]},"lib/openzeppelin-contracts/contracts/access/Ownable2Step.sol":{"*":[]},"lib/openzeppelin-contracts/contracts/token/ERC20/IERC20.sol":{"*":[]},"lib/openzeppelin-contracts/contracts/token/ERC721/IERC721.sol":{"*":[]},"lib/openzeppelin-contracts/contracts/utils/Context.sol":{"*":[]},"lib/openzeppelin-contracts/contracts/utils/Panic.sol":{"*":[]},"lib/openzeppelin-contracts/contracts/utils/introspection/ERC165.sol":{"*":[]},"lib/openzeppelin-contracts/contracts/utils/introspection/IERC165.sol":{"*":[]},"lib/openzeppelin-contracts/contracts/utils/math/Math.sol":{"*":[]},"lib/openzeppelin-contracts/contracts/utils/math/SafeCast.sol":{"*":[]},"lib/openzeppelin-contracts/contracts/utils/structs/EnumerableSet.sol":{"*":[]},"lib/v4-core/lib/solmate/src/auth/Owned.sol":{"*":[]},"lib/v4-core/lib/solmate/src/test/utils/mocks/MockERC20.sol":{"*":[]},"lib/v4-core/lib/solmate/src/tokens/ERC20.sol":{"*":[]},"lib/v4-core/lib/solmate/src/tokens/ERC721.sol":{"*":[]},"lib/v4-core/src/libraries/BitMath.sol":{"*":[]},"lib/v4-core/src/libraries/CustomRevert.sol":{"*":[]},"lib/v4-core/src/libraries/FixedPoint96.sol":{"*":[]},"lib/v4-core/src/libraries/FullMath.sol":{"*":[]},"lib/v4-core/src/libraries/TickMath.sol":{"*":[]},"lib/v4-core/test/utils/LiquidityAmounts.sol":{"*":[]},"lib/v4-periphery/lib/permit2/src/interfaces/IAllowanceTransfer.sol":{"*":[]},"lib/v4-periphery/lib/permit2/src/interfaces/IEIP712.sol":{"*":[]},"lib/v4-periphery/lib/permit2/src/interfaces/IERC1271.sol":{"*":[]},"lib/v4-periphery/lib/permit2/src/libraries/SignatureVerification.sol":{"*":[]},"lib/v4-periphery/lib/v4-core/src/ERC6909.sol":{"*":[]},"lib/v4-periphery/lib/v4-core/src/ERC6909Claims.sol":{"*":[]},"lib/v4-periphery/lib/v4-core/src/Extsload.sol":{"*":[]},"lib/v4-periphery/lib/v4-core/src/Exttload.sol":{"*":[]},"lib/v4-periphery/lib/v4-core/src/NoDelegateCall.sol":{"*":[]},"lib/v4-periphery/lib/v4-core/src/PoolManager.sol":{"*":[]},"lib/v4-periphery/lib/v4-core/src/ProtocolFees.sol":{"*":[]},"lib/v4-periphery/lib/v4-core/src/interfaces/IExtsload.sol":{"*":[]},"lib/v4-periphery/lib/v4-core/src/interfaces/IExttload.sol":{"*":[]},"lib/v4-periphery/lib/v4-core/src/interfaces/IHooks.sol":{"*":[]},"lib/v4-periphery/lib/v4-core/src/interfaces/IPoolManager.sol":{"*":[]},"lib/v4-periphery/lib/v4-core/src/interfaces/IProtocolFees.sol":{"*":[]},"lib/v4-periphery/lib/v4-core/src/interfaces/callback/IUnlockCallback.sol":{"*":[]},"lib/v4-periphery/lib/v4-core/src/interfaces/external/IERC20Minimal.sol":{"*":[]},"lib/v4-periphery/lib/v4-core/src/interfaces/external/IERC6909Claims.sol":{"*":[]},"lib/v4-periphery/lib/v4-core/src/libraries/BitMath.sol":{"*":[]},"lib/v4-periphery/lib/v4-core/src/libraries/CurrencyDelta.sol":{"*":[]},"lib/v4-periphery/lib/v4-core/src/libraries/CurrencyReserves.sol":{"*":[]},"lib/v4-periphery/lib/v4-core/src/libraries/CustomRevert.sol":{"*":[]},"lib/v4-periphery/lib/v4-core/src/libraries/FixedPoint128.sol":{"*":[]},"lib/v4-periphery/lib/v4-core/src/libraries/FixedPoint96.sol":{"*":[]},"lib/v4-periphery/lib/v4-core/src/libraries/FullMath.sol":{"*":[]},"lib/v4-periphery/lib/v4-core/src/libraries/Hooks.sol":{"*":[]},"lib/v4-periphery/lib/v4-core/src/libraries/LPFeeLibrary.sol":{"*":[]},"lib/v4-periphery/lib/v4-core/src/libraries/LiquidityMath.sol":{"*":[]},"lib/v4-periphery/lib/v4-core/src/libraries/Lock.sol":{"*":[]},"lib/v4-periphery/lib/v4-core/src/libraries/NonzeroDeltaCount.sol":{"*":[]},"lib/v4-periphery/lib/v4-core/src/libraries/ParseBytes.sol":{"*":[]},"lib/v4-periphery/lib/v4-core/src/libraries/Pool.sol":{"*":[]},"lib/v4-periphery/lib/v4-core/src/libraries/Position.sol":{"*":[]},"lib/v4-periphery/lib/v4-core/src/libraries/ProtocolFeeLibrary.sol":{"*":[]},"lib/v4-periphery/lib/v4-core/src/libraries/SafeCast.sol":{"*":[]},"lib/v4-periphery/lib/v4-core/src/libraries/SqrtPriceMath.sol":{"*":[]},"lib/v4-periphery/lib/v4-core/src/libraries/StateLibrary.sol":{"*":[]},"lib/v4-periphery/lib/v4-core/src/libraries/SwapMath.sol":{"*":[]},"lib/v4-periphery/lib/v4-core/src/libraries/TickBitmap.sol":{"*":[]},"lib/v4-periphery/lib/v4-core/src/libraries/TickMath.sol":{"*":[]},"lib/v4-periphery/lib/v4-core/src/libraries/TransientStateLibrary.sol":{"*":[]},"lib/v4-periphery/lib/v4-core/src/libraries/UnsafeMath.sol":{"*":[]},"lib/v4-periphery/lib/v4-core/src/test/ActionsRouter.sol":{"*":[]},"lib/v4-periphery/lib/v4-core/src/test/PoolClaimsTest.sol":{"*":[]},"lib/v4-periphery/lib/v4-core/src/test/PoolDonateTest.sol":{"*":[]},"lib/v4-periphery/lib/v4-core/src/test/PoolModifyLiquidityTest.sol":{"*":[]},"lib/v4-periphery/lib/v4-core/src/test/PoolModifyLiquidityTestNoChecks.sol":{"*":[]},"lib/v4-periphery/lib/v4-core/src/test/PoolNestedActionsTest.sol":{"*":[]},"lib/v4-periphery/lib/v4-core/src/test/PoolSwapTest.sol":{"*":[]},"lib/v4-periphery/lib/v4-core/src/test/PoolTakeTest.sol":{"*":[]},"lib/v4-periphery/lib/v4-core/src/test/PoolTestBase.sol":{"*":[]},"lib/v4-periphery/lib/v4-core/src/test/SwapRouterNoChecks.sol":{"*":[]},"lib/v4-periphery/lib/v4-core/src/types/BalanceDelta.sol":{"*":[]},"lib/v4-periphery/lib/v4-core/src/types/BeforeSwapDelta.sol":{"*":[]},"lib/v4-periphery/lib/v4-core/src/types/Currency.sol":{"*":[]},"lib/v4-periphery/lib/v4-core/src/types/PoolId.sol":{"*":[]},"lib/v4-periphery/lib/v4-core/src/types/PoolKey.sol":{"*":[]},"lib/v4-periphery/lib/v4-core/src/types/Slot0.sol":{"*":[]},"lib/v4-periphery/lib/v4-core/test/utils/Constants.sol":{"*":[]},"lib/v4-periphery/lib/v4-core/test/utils/CurrencySettler.sol":{"*":[]},"lib/v4-periphery/lib/v4-core/test/utils/Deployers.sol":{"*":[]},"lib/v4-periphery/lib/v4-core/test/utils/LiquidityAmounts.sol":{"*":[]},"lib/v4-periphery/lib/v4-core/test/utils/SortTokens.sol":{"*":[]},"lib/v4-periphery/src/PositionManager.sol":{"*":[]},"lib/v4-periphery/src/base/BaseActionsRouter.sol":{"*":[]},"lib/v4-periphery/src/base/DeltaResolver.sol":{"*":[]},"lib/v4-periphery/src/base/EIP712_v4.sol":{"*":[]},"lib/v4-periphery/src/base/ERC721Permit_v4.sol":{"*":[]},"lib/v4-periphery/src/base/ImmutableState.sol":{"*":[]},"lib/v4-periphery/src/base/Multicall_v4.sol":{"*":[]},"lib/v4-periphery/src/base/NativeWrapper.sol":{"*":[]},"lib/v4-periphery/src/base/Notifier.sol":{"*":[]},"lib/v4-periphery/src/base/Permit2Forwarder.sol":{"*":[]},"lib/v4-periphery/src/base/PoolInitializer_v4.sol":{"*":[]},"lib/v4-periphery/src/base/ReentrancyLock.sol":{"*":[]},"lib/v4-periphery/src/base/SafeCallback.sol":{"*":[]},"lib/v4-periphery/src/base/UnorderedNonce.sol":{"*":[]},"lib/v4-periphery/src/interfaces/IEIP712_v4.sol":{"*":[]},"lib/v4-periphery/src/interfaces/IERC721Permit_v4.sol":{"*":[]},"lib/v4-periphery/src/interfaces/IImmutableState.sol":{"*":[]},"lib/v4-periphery/src/interfaces/IMulticall_v4.sol":{"*":[]},"lib/v4-periphery/src/interfaces/INotifier.sol":{"*":[]},"lib/v4-periphery/src/interfaces/IPermit2Forwarder.sol":{"*":[]},"lib/v4-periphery/src/interfaces/IPoolInitializer_v4.sol":{"*":[]},"lib/v4-periphery/src/interfaces/IPositionDescriptor.sol":{"*":[]},"lib/v4-periphery/src/interfaces/IPositionManager.sol":{"*":[]},"lib/v4-periphery/src/interfaces/ISubscriber.sol":{"*":[]},"lib/v4-periphery/src/interfaces/IUnorderedNonce.sol":{"*":[]},"lib/v4-periphery/src/interfaces/IV4Router.sol":{"*":[]},"lib/v4-periphery/src/interfaces/external/IWETH9.sol":{"*":[]},"lib/v4-periphery/src/libraries/ActionConstants.sol":{"*":[]},"lib/v4-periphery/src/libraries/Actions.sol":{"*":[]},"lib/v4-periphery/src/libraries/CalldataDecoder.sol":{"*":[]},"lib/v4-periphery/src/libraries/ERC721PermitHash.sol":{"*":[]},"lib/v4-periphery/src/libraries/LiquidityAmounts.sol":{"*":[]},"lib/v4-periphery/src/libraries/Locker.sol":{"*":[]},"lib/v4-periphery/src/libraries/PathKey.sol":{"*":[]},"lib/v4-periphery/src/libraries/PositionInfoLibrary.sol":{"*":[]},"lib/v4-periphery/src/libraries/SlippageCheck.sol":{"*":[]},"lib/v4-periphery/src/utils/BaseHook.sol":{"*":[]},"src/SuperDCAGauge.sol":{"*":[]},"src/SuperDCAListing.sol":{"*":[]},"src/SuperDCAStaking.sol":{"*":[]},"src/interfaces/IMsgSender.sol":{"*":[]},"src/interfaces/ISuperDCAGauge.sol":{"*":[]},"src/interfaces/ISuperDCAListing.sol":{"*":[]},"src/interfaces/ISuperDCAStaking.sol":{"*":[]},"src/interfaces/ISuperchainERC20.sol":{"*":[]},"test/AuditTest/MaliciousUserCanObtainSoloRewards.t.sol":{"":["ast"],"*":["abi","evm.bytecode.object","evm.bytecode.sourceMap","evm.bytecode.linkReferences","evm.deployedBytecode.object","evm.deployedBytecode.sourceMap","evm.deployedBytecode.linkReferences","evm.deployedBytecode.immutableReferences","evm.methodIdentifiers","metadata","storageLayout"]},"test/mocks/FeesCollectionMock.sol":{"*":[]},"test/mocks/MockERC20Token.sol":{"*":[]}},"evmVersion":"cancun","viaIR":false,"libraries":{}},"allowPaths":["/Users/daniel/Desktop/competitive-audits/sherlock-audits/2025-09-super-dca-0xdanielvigo/super-dca-gauge","/Users/daniel/Desktop/competitive-audits/sherlock-audits/2025-09-super-dca-0xdanielvigo/super-dca-gauge/lib"],"basePath":"/Users/daniel/Desktop/competitive-audits/sherlock-audits/2025-09-super-dca-0xdanielvigo/super-dca-gauge","includePaths":["/Users/daniel/Desktop/competitive-audits/sherlock-audits/2025-09-super-dca-0xdanielvigo/super-dca-gauge"]},"output":{"errors":[{"sourceLocation":{"file":"lib/v4-periphery/lib/v4-core/src/libraries/CurrencyReserves.sol","start":805,"end":811},"type":"Warning","component":"general","severity":"warning","errorCode":"2394","message":"Transient storage as defined by EIP-1153 can break the composability of smart contracts: Since transient storage is cleared only at the end of the transaction and not at the end of the outermost call frame to the contract within a transaction, your contract may unintentionally misbehave when invoked multiple times in a complex transaction. To avoid this, be sure to clear all transient storage at the end of any call to your contract. The use of transient storage for reentrancy guards that are cleared at the end of the call is safe.","formattedMessage":"Warning: Transient storage as defined by EIP-1153 can break the composability of smart contracts: Since transient storage is cleared only at the end of the transaction and not at the end of the outermost call frame to the contract within a transaction, your contract may unintentionally misbehave when invoked multiple times in a complex transaction. To avoid this, be sure to clear all transient storage at the end of any call to your contract. The use of transient storage for reentrancy guards that are cleared at the end of the call is safe.\n  --> lib/v4-periphery/lib/v4-core/src/libraries/CurrencyReserves.sol:23:13:\n   |\n23 |             tstore(CURRENCY_SLOT, 0)\n   |             ^^^^^^\n\n"},{"sourceLocation":{"file":"lib/v4-periphery/lib/v4-core/src/PoolManager.sol","start":4714,"end":17614},"type":"Warning","component":"general","severity":"warning","errorCode":"5574","message":"Contract code size is 34623 bytes and exceeds 24576 bytes (a limit introduced in Spurious Dragon). This contract may not be deployable on Mainnet. Consider enabling the optimizer (with a low \"runs\" value!), turning off revert strings, or using libraries.","formattedMessage":"Warning: Contract code size is 34623 bytes and exceeds 24576 bytes (a limit introduced in Spurious Dragon). This contract may not be deployable on Mainnet. Consider enabling the optimizer (with a low \"runs\" value!), turning off revert strings, or using libraries.\n  --> lib/v4-periphery/lib/v4-core/src/PoolManager.sol:79:1:\n   |\n79 | contract PoolManager is IPoolManager, ProtocolFees, NoDelegateCall, ERC6909Claims, Extsload, Exttload {\n   | ^ (Relevant source part starts here and spans across multiple lines).\n\n"},{"sourceLocation":{"file":"lib/v4-periphery/src/PositionManager.sol","start":7946,"end":28040},"type":"Warning","component":"general","severity":"warning","errorCode":"5574","message":"Contract code size is 35831 bytes and exceeds 24576 bytes (a limit introduced in Spurious Dragon). This contract may not be deployable on Mainnet. Consider enabling the optimizer (with a low \"runs\" value!), turning off revert strings, or using libraries.","formattedMessage":"Warning: Contract code size is 35831 bytes and exceeds 24576 bytes (a limit introduced in Spurious Dragon). This contract may not be deployable on Mainnet. Consider enabling the optimizer (with a low \"runs\" value!), turning off revert strings, or using libraries.\n  --> lib/v4-periphery/src/PositionManager.sol:99:1:\n   |\n99 | contract PositionManager is\n   | ^ (Relevant source part starts here and spans across multiple lines).\n\n"},{"sourceLocation":{"file":"test/AuditTest/MaliciousUserCanObtainSoloRewards.t.sol","start":2257,"end":6309},"type":"Warning","component":"general","severity":"warning","errorCode":"5574","message":"Contract code size is 41841 bytes and exceeds 24576 bytes (a limit introduced in Spurious Dragon). This contract may not be deployable on Mainnet. Consider enabling the optimizer (with a low \"runs\" value!), turning off revert strings, or using libraries.","formattedMessage":"Warning: Contract code size is 41841 bytes and exceeds 24576 bytes (a limit introduced in Spurious Dragon). This contract may not be deployable on Mainnet. Consider enabling the optimizer (with a low \"runs\" value!), turning off revert strings, or using libraries.\n  --> test/AuditTest/MaliciousUserCanObtainSoloRewards.t.sol:35:1:\n   |\n35 | contract MaliciousUserCanObtainSoloRewards is Test, Deployers {\n   | ^ (Relevant source part starts here and spans across multiple lines).\n\n"}],"contracts":{"test/AuditTest/MaliciousUserCanObtainSoloRewards.t.sol":{"MaliciousUserCanObtainSoloRewards":{"abi":[{"type":"receive","stateMutability":"payable"},{"type":"function","name":"IS_TEST","inputs":[],"outputs":[{"name":"","type":"bool","internalType":"bool"}],"stateMutability":"view"},{"type":"function","name":"LIQUIDITY_PARAMS","inputs":[],"outputs":[{"name":"tickLower","type":"int24","internalType":"int24"},{"name":"tickUpper","type":"int24","internalType":"int24"},{"name":"liquidityDelta","type":"int256","internalType":"int256"},{"name":"salt","type":"bytes32","internalType":"bytes32"}],"stateMutability":"view"},{"type":"function","name":"MAX_PRICE_LIMIT","inputs":[],"outputs":[{"name":"","type":"uint160","internalType":"uint160"}],"stateMutability":"view"},{"type":"function","name":"MIN_PRICE_LIMIT","inputs":[],"outputs":[{"name":"","type":"uint160","internalType":"uint160"}],"stateMutability":"view"},{"type":"function","name":"PERMIT2","inputs":[],"outputs":[{"name":"","type":"address","internalType":"contract IAllowanceTransfer"}],"stateMutability":"view"},{"type":"function","name":"REMOVE_LIQUIDITY_PARAMS","inputs":[],"outputs":[{"name":"tickLower","type":"int24","internalType":"int24"},{"name":"tickUpper","type":"int24","internalType":"int24"},{"name":"liquidityDelta","type":"int256","internalType":"int256"},{"name":"salt","type":"bytes32","internalType":"bytes32"}],"stateMutability":"view"},{"type":"function","name":"SWAP_PARAMS","inputs":[],"outputs":[{"name":"zeroForOne","type":"bool","internalType":"bool"},{"name":"amountSpecified","type":"int256","internalType":"int256"},{"name":"sqrtPriceLimitX96","type":"uint160","internalType":"uint160"}],"stateMutability":"view"},{"type":"function","name":"UNSUBSCRIBE_LIMIT","inputs":[],"outputs":[{"name":"","type":"uint256","internalType":"uint256"}],"stateMutability":"view"},{"type":"function","name":"dcaToken","inputs":[],"outputs":[{"name":"","type":"address","internalType":"contract MockERC20Token"}],"stateMutability":"view"},{"type":"function","name":"excludeArtifacts","inputs":[],"outputs":[{"name":"excludedArtifacts_","type":"string[]","internalType":"string[]"}],"stateMutability":"view"},{"type":"function","name":"excludeContracts","inputs":[],"outputs":[{"name":"excludedContracts_","type":"address[]","internalType":"address[]"}],"stateMutability":"view"},{"type":"function","name":"excludeSelectors","inputs":[],"outputs":[{"name":"excludedSelectors_","type":"tuple[]","internalType":"struct StdInvariant.FuzzSelector[]","components":[{"name":"addr","type":"address","internalType":"address"},{"name":"selectors","type":"bytes4[]","internalType":"bytes4[]"}]}],"stateMutability":"view"},{"type":"function","name":"excludeSenders","inputs":[],"outputs":[{"name":"excludedSenders_","type":"address[]","internalType":"address[]"}],"stateMutability":"view"},{"type":"function","name":"failed","inputs":[],"outputs":[{"name":"","type":"bool","internalType":"bool"}],"stateMutability":"view"},{"type":"function","name":"listing","inputs":[],"outputs":[{"name":"","type":"address","internalType":"contract SuperDCAListing"}],"stateMutability":"view"},{"type":"function","name":"posM","inputs":[],"outputs":[{"name":"","type":"address","internalType":"contract PositionManager"}],"stateMutability":"view"},{"type":"function","name":"setUp","inputs":[],"outputs":[],"stateMutability":"nonpayable"},{"type":"function","name":"staking","inputs":[],"outputs":[{"name":"","type":"address","internalType":"contract SuperDCAStaking"}],"stateMutability":"view"},{"type":"function","name":"targetArtifactSelectors","inputs":[],"outputs":[{"name":"targetedArtifactSelectors_","type":"tuple[]","internalType":"struct StdInvariant.FuzzArtifactSelector[]","components":[{"name":"artifact","type":"string","internalType":"string"},{"name":"selectors","type":"bytes4[]","internalType":"bytes4[]"}]}],"stateMutability":"view"},{"type":"function","name":"targetArtifacts","inputs":[],"outputs":[{"name":"targetedArtifacts_","type":"string[]","internalType":"string[]"}],"stateMutability":"view"},{"type":"function","name":"targetContracts","inputs":[],"outputs":[{"name":"targetedContracts_","type":"address[]","internalType":"address[]"}],"stateMutability":"view"},{"type":"function","name":"targetInterfaces","inputs":[],"outputs":[{"name":"targetedInterfaces_","type":"tuple[]","internalType":"struct StdInvariant.FuzzInterface[]","components":[{"name":"addr","type":"address","internalType":"address"},{"name":"artifacts","type":"string[]","internalType":"string[]"}]}],"stateMutability":"view"},{"type":"function","name":"targetSelectors","inputs":[],"outputs":[{"name":"targetedSelectors_","type":"tuple[]","internalType":"struct StdInvariant.FuzzSelector[]","components":[{"name":"addr","type":"address","internalType":"address"},{"name":"selectors","type":"bytes4[]","internalType":"bytes4[]"}]}],"stateMutability":"view"},{"type":"function","name":"targetSenders","inputs":[],"outputs":[{"name":"targetedSenders_","type":"address[]","internalType":"address[]"}],"stateMutability":"view"},{"type":"function","name":"test_maliciousUserCanObtainSoloRewardsByCreatingIndividualPools","inputs":[],"outputs":[],"stateMutability":"nonpayable"},{"type":"function","name":"tokenDescriptor","inputs":[],"outputs":[{"name":"","type":"address","internalType":"contract IPositionDescriptor"}],"stateMutability":"view"},{"type":"function","name":"weth","inputs":[],"outputs":[{"name":"","type":"address","internalType":"address"}],"stateMutability":"view"},{"type":"event","name":"log","inputs":[{"name":"","type":"string","indexed":false,"internalType":"string"}],"anonymous":false},{"type":"event","name":"log_address","inputs":[{"name":"","type":"address","indexed":false,"internalType":"address"}],"anonymous":false},{"type":"event","name":"log_array","inputs":[{"name":"val","type":"uint256[]","indexed":false,"internalType":"uint256[]"}],"anonymous":false},{"type":"event","name":"log_array","inputs":[{"name":"val","type":"int256[]","indexed":false,"internalType":"int256[]"}],"anonymous":false},{"type":"event","name":"log_array","inputs":[{"name":"val","type":"address[]","indexed":false,"internalType":"address[]"}],"anonymous":false},{"type":"event","name":"log_bytes","inputs":[{"name":"","type":"bytes","indexed":false,"internalType":"bytes"}],"anonymous":false},{"type":"event","name":"log_bytes32","inputs":[{"name":"","type":"bytes32","indexed":false,"internalType":"bytes32"}],"anonymous":false},{"type":"event","name":"log_int","inputs":[{"name":"","type":"int256","indexed":false,"internalType":"int256"}],"anonymous":false},{"type":"event","name":"log_named_address","inputs":[{"name":"key","type":"string","indexed":false,"internalType":"string"},{"name":"val","type":"address","indexed":false,"internalType":"address"}],"anonymous":false},{"type":"event","name":"log_named_array","inputs":[{"name":"key","type":"string","indexed":false,"internalType":"string"},{"name":"val","type":"uint256[]","indexed":false,"internalType":"uint256[]"}],"anonymous":false},{"type":"event","name":"log_named_array","inputs":[{"name":"key","type":"string","indexed":false,"internalType":"string"},{"name":"val","type":"int256[]","indexed":false,"internalType":"int256[]"}],"anonymous":false},{"type":"event","name":"log_named_array","inputs":[{"name":"key","type":"string","indexed":false,"internalType":"string"},{"name":"val","type":"address[]","indexed":false,"internalType":"address[]"}],"anonymous":false},{"type":"event","name":"log_named_bytes","inputs":[{"name":"key","type":"string","indexed":false,"internalType":"string"},{"name":"val","type":"bytes","indexed":false,"internalType":"bytes"}],"anonymous":false},{"type":"event","name":"log_named_bytes32","inputs":[{"name":"key","type":"string","indexed":false,"internalType":"string"},{"name":"val","type":"bytes32","indexed":false,"internalType":"bytes32"}],"anonymous":false},{"type":"event","name":"log_named_decimal_int","inputs":[{"name":"key","type":"string","indexed":false,"internalType":"string"},{"name":"val","type":"int256","indexed":false,"internalType":"int256"},{"name":"decimals","type":"uint256","indexed":false,"internalType":"uint256"}],"anonymous":false},{"type":"event","name":"log_named_decimal_uint","inputs":[{"name":"key","type":"string","indexed":false,"internalType":"string"},{"name":"val","type":"uint256","indexed":false,"internalType":"uint256"},{"name":"decimals","type":"uint256","indexed":false,"internalType":"uint256"}],"anonymous":false},{"type":"event","name":"log_named_int","inputs":[{"name":"key","type":"string","indexed":false,"internalType":"string"},{"name":"val","type":"int256","indexed":false,"internalType":"int256"}],"anonymous":false},{"type":"event","name":"log_named_string","inputs":[{"name":"key","type":"string","indexed":false,"internalType":"string"},{"name":"val","type":"string","indexed":false,"internalType":"string"}],"anonymous":false},{"type":"event","name":"log_named_uint","inputs":[{"name":"key","type":"string","indexed":false,"internalType":"string"},{"name":"val","type":"uint256","indexed":false,"internalType":"uint256"}],"anonymous":false},{"type":"event","name":"log_string","inputs":[{"name":"","type":"string","indexed":false,"internalType":"string"}],"anonymous":false},{"type":"event","name":"log_uint","inputs":[{"name":"","type":"uint256","indexed":false,"internalType":"uint256"}],"anonymous":false},{"type":"event","name":"logs","inputs":[{"name":"","type":"bytes","indexed":false,"internalType":"bytes"}],"anonymous":false}],"metadata":"{\"compiler\":{\"version\":\"0.8.26+commit.8a97fa7a\"},\"language\":\"Solidity\",\"output\":{\"abi\":[{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"name\":\"log\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"log_address\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256[]\",\"name\":\"val\",\"type\":\"uint256[]\"}],\"name\":\"log_array\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"int256[]\",\"name\":\"val\",\"type\":\"int256[]\"}],\"name\":\"log_array\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address[]\",\"name\":\"val\",\"type\":\"address[]\"}],\"name\":\"log_array\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"bytes\",\"name\":\"\",\"type\":\"bytes\"}],\"name\":\"log_bytes\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"name\":\"log_bytes32\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"int256\",\"name\":\"\",\"type\":\"int256\"}],\"name\":\"log_int\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"string\",\"name\":\"key\",\"type\":\"string\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"val\",\"type\":\"address\"}],\"name\":\"log_named_address\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"string\",\"name\":\"key\",\"type\":\"string\"},{\"indexed\":false,\"internalType\":\"uint256[]\",\"name\":\"val\",\"type\":\"uint256[]\"}],\"name\":\"log_named_array\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"string\",\"name\":\"key\",\"type\":\"string\"},{\"indexed\":false,\"internalType\":\"int256[]\",\"name\":\"val\",\"type\":\"int256[]\"}],\"name\":\"log_named_array\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"string\",\"name\":\"key\",\"type\":\"string\"},{\"indexed\":false,\"internalType\":\"address[]\",\"name\":\"val\",\"type\":\"address[]\"}],\"name\":\"log_named_array\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"string\",\"name\":\"key\",\"type\":\"string\"},{\"indexed\":false,\"internalType\":\"bytes\",\"name\":\"val\",\"type\":\"bytes\"}],\"name\":\"log_named_bytes\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"string\",\"name\":\"key\",\"type\":\"string\"},{\"indexed\":false,\"internalType\":\"bytes32\",\"name\":\"val\",\"type\":\"bytes32\"}],\"name\":\"log_named_bytes32\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"string\",\"name\":\"key\",\"type\":\"string\"},{\"indexed\":false,\"internalType\":\"int256\",\"name\":\"val\",\"type\":\"int256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"decimals\",\"type\":\"uint256\"}],\"name\":\"log_named_decimal_int\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"string\",\"name\":\"key\",\"type\":\"string\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"val\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"decimals\",\"type\":\"uint256\"}],\"name\":\"log_named_decimal_uint\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"string\",\"name\":\"key\",\"type\":\"string\"},{\"indexed\":false,\"internalType\":\"int256\",\"name\":\"val\",\"type\":\"int256\"}],\"name\":\"log_named_int\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"string\",\"name\":\"key\",\"type\":\"string\"},{\"indexed\":false,\"internalType\":\"string\",\"name\":\"val\",\"type\":\"string\"}],\"name\":\"log_named_string\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"string\",\"name\":\"key\",\"type\":\"string\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"val\",\"type\":\"uint256\"}],\"name\":\"log_named_uint\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"name\":\"log_string\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"log_uint\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"bytes\",\"name\":\"\",\"type\":\"bytes\"}],\"name\":\"logs\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"IS_TEST\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"LIQUIDITY_PARAMS\",\"outputs\":[{\"internalType\":\"int24\",\"name\":\"tickLower\",\"type\":\"int24\"},{\"internalType\":\"int24\",\"name\":\"tickUpper\",\"type\":\"int24\"},{\"internalType\":\"int256\",\"name\":\"liquidityDelta\",\"type\":\"int256\"},{\"internalType\":\"bytes32\",\"name\":\"salt\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"MAX_PRICE_LIMIT\",\"outputs\":[{\"internalType\":\"uint160\",\"name\":\"\",\"type\":\"uint160\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"MIN_PRICE_LIMIT\",\"outputs\":[{\"internalType\":\"uint160\",\"name\":\"\",\"type\":\"uint160\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"PERMIT2\",\"outputs\":[{\"internalType\":\"contract IAllowanceTransfer\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"REMOVE_LIQUIDITY_PARAMS\",\"outputs\":[{\"internalType\":\"int24\",\"name\":\"tickLower\",\"type\":\"int24\"},{\"internalType\":\"int24\",\"name\":\"tickUpper\",\"type\":\"int24\"},{\"internalType\":\"int256\",\"name\":\"liquidityDelta\",\"type\":\"int256\"},{\"internalType\":\"bytes32\",\"name\":\"salt\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"SWAP_PARAMS\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"zeroForOne\",\"type\":\"bool\"},{\"internalType\":\"int256\",\"name\":\"amountSpecified\",\"type\":\"int256\"},{\"internalType\":\"uint160\",\"name\":\"sqrtPriceLimitX96\",\"type\":\"uint160\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"UNSUBSCRIBE_LIMIT\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"dcaToken\",\"outputs\":[{\"internalType\":\"contract MockERC20Token\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"excludeArtifacts\",\"outputs\":[{\"internalType\":\"string[]\",\"name\":\"excludedArtifacts_\",\"type\":\"string[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"excludeContracts\",\"outputs\":[{\"internalType\":\"address[]\",\"name\":\"excludedContracts_\",\"type\":\"address[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"excludeSelectors\",\"outputs\":[{\"components\":[{\"internalType\":\"address\",\"name\":\"addr\",\"type\":\"address\"},{\"internalType\":\"bytes4[]\",\"name\":\"selectors\",\"type\":\"bytes4[]\"}],\"internalType\":\"struct StdInvariant.FuzzSelector[]\",\"name\":\"excludedSelectors_\",\"type\":\"tuple[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"excludeSenders\",\"outputs\":[{\"internalType\":\"address[]\",\"name\":\"excludedSenders_\",\"type\":\"address[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"failed\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"listing\",\"outputs\":[{\"internalType\":\"contract SuperDCAListing\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"posM\",\"outputs\":[{\"internalType\":\"contract PositionManager\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"setUp\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"staking\",\"outputs\":[{\"internalType\":\"contract SuperDCAStaking\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"targetArtifactSelectors\",\"outputs\":[{\"components\":[{\"internalType\":\"string\",\"name\":\"artifact\",\"type\":\"string\"},{\"internalType\":\"bytes4[]\",\"name\":\"selectors\",\"type\":\"bytes4[]\"}],\"internalType\":\"struct StdInvariant.FuzzArtifactSelector[]\",\"name\":\"targetedArtifactSelectors_\",\"type\":\"tuple[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"targetArtifacts\",\"outputs\":[{\"internalType\":\"string[]\",\"name\":\"targetedArtifacts_\",\"type\":\"string[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"targetContracts\",\"outputs\":[{\"internalType\":\"address[]\",\"name\":\"targetedContracts_\",\"type\":\"address[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"targetInterfaces\",\"outputs\":[{\"components\":[{\"internalType\":\"address\",\"name\":\"addr\",\"type\":\"address\"},{\"internalType\":\"string[]\",\"name\":\"artifacts\",\"type\":\"string[]\"}],\"internalType\":\"struct StdInvariant.FuzzInterface[]\",\"name\":\"targetedInterfaces_\",\"type\":\"tuple[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"targetSelectors\",\"outputs\":[{\"components\":[{\"internalType\":\"address\",\"name\":\"addr\",\"type\":\"address\"},{\"internalType\":\"bytes4[]\",\"name\":\"selectors\",\"type\":\"bytes4[]\"}],\"internalType\":\"struct StdInvariant.FuzzSelector[]\",\"name\":\"targetedSelectors_\",\"type\":\"tuple[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"targetSenders\",\"outputs\":[{\"internalType\":\"address[]\",\"name\":\"targetedSenders_\",\"type\":\"address[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"test_maliciousUserCanObtainSoloRewardsByCreatingIndividualPools\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"tokenDescriptor\",\"outputs\":[{\"internalType\":\"contract IPositionDescriptor\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"weth\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"stateMutability\":\"payable\",\"type\":\"receive\"}],\"devdoc\":{\"kind\":\"dev\",\"methods\":{},\"version\":1},\"userdoc\":{\"kind\":\"user\",\"methods\":{},\"version\":1}},\"settings\":{\"compilationTarget\":{\"test/AuditTest/MaliciousUserCanObtainSoloRewards.t.sol\":\"MaliciousUserCanObtainSoloRewards\"},\"evmVersion\":\"cancun\",\"libraries\":{},\"metadata\":{\"bytecodeHash\":\"ipfs\"},\"optimizer\":{\"enabled\":false,\"runs\":200},\"remappings\":[\":@ensdomains/=lib/v4-core/node_modules/@ensdomains/\",\":@openzeppelin/contracts-upgradeable/=lib/openzeppelin-contracts-upgradeable/contracts/\",\":@openzeppelin/contracts/=lib/openzeppelin-contracts/contracts/\",\":@uniswap/v4-core/=lib/v4-periphery/lib/v4-core/\",\":ds-test/=lib/v4-core/lib/forge-std/lib/ds-test/src/\",\":erc4626-tests/=lib/openzeppelin-contracts-upgradeable/lib/erc4626-tests/\",\":forge-gas-snapshot/=lib/v4-periphery/lib/permit2/lib/forge-gas-snapshot/src/\",\":forge-std/=lib/forge-std/src/\",\":halmos-cheatcodes/=lib/openzeppelin-contracts-upgradeable/lib/halmos-cheatcodes/src/\",\":hardhat/=lib/v4-core/node_modules/hardhat/\",\":openzeppelin-contracts-upgradeable/=lib/openzeppelin-contracts-upgradeable/\",\":openzeppelin-contracts/=lib/openzeppelin-contracts/\",\":openzeppelin-foundry-upgrades/=lib/openzeppelin-foundry-upgrades/src/\",\":permit2/=lib/v4-periphery/lib/permit2/\",\":solmate/=lib/v4-core/lib/solmate/\",\":v4-core/=lib/v4-core/src/\",\":v4-periphery/=lib/v4-periphery/src/\"]},\"sources\":{\"lib/forge-std/src/Base.sol\":{\"keccak256\":\"0x4ff1a785311017d1eedb1b4737956fa383067ad34eb439abfec1d989754dde1c\",\"license\":\"MIT\",\"urls\":[\"bzz-raw://f553622969b9fdb930246704a4c10dfaee6b1a4468c142fa7eb9dc292a438224\",\"dweb:/ipfs/QmcxqHnqdQsMVtgsfH9VNLmZ3g7GhgNagfq7yvNCDcCHFK\"]},\"lib/forge-std/src/StdAssertions.sol\":{\"keccak256\":\"0x4584f551c3a875c26423c1e50a77179bc2f9c9c1ee6d0f0c6be0f89ca5ee8270\",\"license\":\"MIT\",\"urls\":[\"bzz-raw://ef118876a862b60ba8a6612b8b3f3a6c226e11a0071a2e9695f021586d1bfdbe\",\"dweb:/ipfs/QmXd2vD91PkvoFWasFkgbDi89PctmgsHVxGvGNyhjmRK2b\"]},\"lib/forge-std/src/StdChains.sol\":{\"keccak256\":\"0xcd3e64ec9ffa19a2c0715bbdaf7ddf28887cc418e079bec4373fd6a3f9961a7b\",\"license\":\"MIT\",\"urls\":[\"bzz-raw://e981a2ab738590928e9efa5f3d95a408c718eb12d73a113d7675f3ed55a026a1\",\"dweb:/ipfs/QmTgSEkWWsBRy32goRCaUkraSgpZHtgbZoKC3iEFNz5RDc\"]},\"lib/forge-std/src/StdCheats.sol\":{\"keccak256\":\"0x0fa6ec03602648b62cce41aab2096e6b7e052f2846075d967b6958dd586db746\",\"license\":\"MIT\",\"urls\":[\"bzz-raw://cd84e2ca9c1eaed6b76768cc12bb8c1af8289170ea8b7706f58d516460d79c41\",\"dweb:/ipfs/QmQ7BK7co6DE4eWUqMyv11s5eHYkS1tyx8tDSZGZVtf2aK\"]},\"lib/forge-std/src/StdError.sol\":{\"keccak256\":\"0xbf477b11a42d7611696956546bcfaa29317d1166bf65e402344599c05943fc77\",\"license\":\"MIT\",\"urls\":[\"bzz-raw://bc2e117d1135e030862b96a6526a43feb38d396cc79857f1fb696d4eff0e5fd6\",\"dweb:/ipfs/QmdSuQ5RrQudTLsNmWXGEeVJX8gR5U9XPm6m4dwwuQnJrj\"]},\"lib/forge-std/src/StdInvariant.sol\":{\"keccak256\":\"0x4dab3021edfa9511bbdd80c48f060ef62eaf457f99eaf841f561fc2557d9a08d\",\"license\":\"MIT\",\"urls\":[\"bzz-raw://07668628673174cf8f27f8f4e1f862bab775013ec247eb34f698c5005f229391\",\"dweb:/ipfs/QmPJsiiYwmCZXMsHmQv5tg8VF3CAhNdat7WnKLTWZZH2v5\"]},\"lib/forge-std/src/StdJson.sol\":{\"keccak256\":\"0xbc0132abe1c2accc2867c0f03667afffdf92f3e95a581bb03c9557eaa38ea500\",\"license\":\"MIT\",\"urls\":[\"bzz-raw://eb6fab37dc73c219cfbb7b4f4998bcf7677ca5397a867e850f40232192073974\",\"dweb:/ipfs/QmUHsbVdp9SKmgek7ZfPcLTKrpZFXpqaqt4sVejzxGEQL3\"]},\"lib/forge-std/src/StdMath.sol\":{\"keccak256\":\"0xd90ad4fd8aeaeb8929964e686e769fdedd5eded3fc3815df194a0ab9f91a3fb2\",\"license\":\"MIT\",\"urls\":[\"bzz-raw://7919b70f636c7b805223992f28ad1ad0145d6c1385b5931a3589aface5fe6c92\",\"dweb:/ipfs/QmY7FRaULwoGgFteF8GawjQJRfasNgpWnU2aiMsFrYpuTC\"]},\"lib/forge-std/src/StdStorage.sol\":{\"keccak256\":\"0xb91ab24383a5872b894fc93325eef1add6cbbf981628f18e860068bf88bb7dcc\",\"license\":\"MIT\",\"urls\":[\"bzz-raw://2651e33b9ac8fc5803ed0a43078c1bf4fa90a0b0347aafd95776b02daccdcc57\",\"dweb:/ipfs/QmbdRyPuGJdZgnCuMnp7c1WsBo1Spf7j1KMmws1Z5rd4BQ\"]},\"lib/forge-std/src/StdStyle.sol\":{\"keccak256\":\"0x43e2a8a9b9c2574dabe74f11adf6f782df218f463540e3b5b563609fe108597d\",\"license\":\"MIT\",\"urls\":[\"bzz-raw://51363ca97404cf4128e1141428949768c31929e75e014b02c85e887fbbb4f1b8\",\"dweb:/ipfs/QmVhtbQc2fU4rRmbcfBtz34mAgG4BAZBsbna1Ca4SkoPsK\"]},\"lib/forge-std/src/StdToml.sol\":{\"keccak256\":\"0x58a72c765ed3f7ff6b105509689658795b8a3739b8931772a497155878381861\",\"license\":\"MIT\",\"urls\":[\"bzz-raw://b4a3746f4fabaeb980bd77d9e091d3904ee38a6c0e191bfa8ba6874c6f8558a3\",\"dweb:/ipfs/QmUfFDMEn461FgGEXt5HicyGD54sc28sLaQ9JRWDMBKed8\"]},\"lib/forge-std/src/StdUtils.sol\":{\"keccak256\":\"0x7274081e11c05164fd8eadde4de8305c033e58a43008dea58065f3170ccf0737\",\"license\":\"MIT\",\"urls\":[\"bzz-raw://e9801614b6c9d3e472982e6cc68f5f1ad03682f84eafb686be65633c7132d138\",\"dweb:/ipfs/QmcQSUcrm2A7XuektnxJjvYGmZtBeA6LKPxCXRqdXBX776\"]},\"lib/forge-std/src/Test.sol\":{\"keccak256\":\"0x3b4bb409a156dee9ce261458117fe9f81080ca844a8a26c07c857c46d155effe\",\"license\":\"MIT\",\"urls\":[\"bzz-raw://5792c69fe24bdc063a14e08fe68275007fdb1e5e7e343840a77938cb7e95a64e\",\"dweb:/ipfs/QmcAMhaurUwzhytJFYix4vRNeZeV8g27b8LnV3t7dvYtiK\"]},\"lib/forge-std/src/Vm.sol\":{\"keccak256\":\"0x44bfadcf5a89b8058f80258f2259585c740f9cc45669a0579f4f2753ff2c6354\",\"license\":\"MIT OR Apache-2.0\",\"urls\":[\"bzz-raw://bbc366c8b3499d5030e3b2e45bac23770531f2f5243a0e80e3d5a66b6f9a312c\",\"dweb:/ipfs/QmNxDEB3BaVnKzNaWedtdMshhvCEddB1AsdJZcsQx6jdtC\"]},\"lib/forge-std/src/console.sol\":{\"keccak256\":\"0x4bbf47eb762cef93729d6ef15e78789957147039b113e5d4df48e3d3fd16d0f5\",\"license\":\"MIT\",\"urls\":[\"bzz-raw://af9e3a7c3d82fb5b10b57ca4d1a82f2acbef80c077f6f6ef0cc0187c7bfd9f57\",\"dweb:/ipfs/QmR9VzmnBDJpgiDP6CHT6truehukF9HpYvuP6kRiJbDwPP\"]},\"lib/forge-std/src/console2.sol\":{\"keccak256\":\"0x3b8fe79f48f065a4e4d35362171304a33784c3a90febae5f2787805a438de12f\",\"license\":\"MIT\",\"urls\":[\"bzz-raw://61de63af08803549299e68b6e6e88d40f3c5afac450e4ee0a228c66a61ba003d\",\"dweb:/ipfs/QmWVoQ5rrVxnczD4ZZoPbD4PC9Z3uExJtzjD4awTqd14MZ\"]},\"lib/forge-std/src/interfaces/IMulticall3.sol\":{\"keccak256\":\"0x7aac1389150499a922d1f9ef5749c908cef127cb2075b92fa17e9cb611263d0a\",\"license\":\"MIT\",\"urls\":[\"bzz-raw://d95ebb7c7c463e08ebc12dab639945752fb2480acfc6e86da32f72732a7fd0c0\",\"dweb:/ipfs/QmNXK8P8oPWwajsQHvAHw3JPyQidPLCGQN3hWu1Lk6PBL2\"]},\"lib/forge-std/src/safeconsole.sol\":{\"keccak256\":\"0xbef9786cb49d3eade757bad87568c49c8c8f35721f0193c95ffb055d9e466e11\",\"license\":\"MIT\",\"urls\":[\"bzz-raw://3bafd2b0b2d28068d329f95ea8a1fbce3719c257fcb863fc01abcbafd8d531ab\",\"dweb:/ipfs/QmUeaFjKWTVDBsHVfSob4mwt6A5hTnKDz22HaUXeZhypa3\"]},\"lib/openzeppelin-contracts/contracts/access/AccessControl.sol\":{\"keccak256\":\"0xa0e92d42942f4f57c5be50568dac11e9d00c93efcb458026e18d2d9b9b2e7308\",\"license\":\"MIT\",\"urls\":[\"bzz-raw://46326c0bb1e296b67185e81c918e0b40501b8b6386165855df0a3f3c634b6a80\",\"dweb:/ipfs/QmTwyrDYtsxsk6pymJTK94PnEpzsmkpUxFuzEiakDopy4Z\"]},\"lib/openzeppelin-contracts/contracts/access/IAccessControl.sol\":{\"keccak256\":\"0xc1c2a7f1563b77050dc6d507db9f4ada5d042c1f6a9ddbffdc49c77cdc0a1606\",\"license\":\"MIT\",\"urls\":[\"bzz-raw://fd54abb96a6156d9a761f6fdad1d3004bc48d2d4fce47f40a3f91a7ae83fc3a1\",\"dweb:/ipfs/QmUrFSGkTDJ7WaZ6qPVVe3Gn5uN2viPb7x7QQ35UX4DofX\"]},\"lib/openzeppelin-contracts/contracts/access/Ownable.sol\":{\"keccak256\":\"0xff6d0bb2e285473e5311d9d3caacb525ae3538a80758c10649a4d61029b017bb\",\"license\":\"MIT\",\"urls\":[\"bzz-raw://8ed324d3920bb545059d66ab97d43e43ee85fd3bd52e03e401f020afb0b120f6\",\"dweb:/ipfs/QmfEckWLmZkDDcoWrkEvMWhms66xwTLff9DDhegYpvHo1a\"]},\"lib/openzeppelin-contracts/contracts/access/Ownable2Step.sol\":{\"keccak256\":\"0xdcad8898fda432696597752e8ec361b87d85c82cb258115427af006dacf7128c\",\"license\":\"MIT\",\"urls\":[\"bzz-raw://e2c9d517f0c136d54bd00cd57959d25681d4d6273f5bbbc263afe228303772f0\",\"dweb:/ipfs/QmReNFjXBiufByiAAzfSQ2SM5r3qeUErn46BmN3yVRvrek\"]},\"lib/openzeppelin-contracts/contracts/token/ERC20/IERC20.sol\":{\"keccak256\":\"0xe06a3f08a987af6ad2e1c1e774405d4fe08f1694b67517438b467cecf0da0ef7\",\"license\":\"MIT\",\"urls\":[\"bzz-raw://df6f0c459663c9858b6cba2cda1d14a7d05a985bed6d2de72bd8e78c25ee79db\",\"dweb:/ipfs/QmeTTxZ7qVk9rjEv2R4CpCwdf8UMCcRqDNMvzNxHc3Fnn9\"]},\"lib/openzeppelin-contracts/contracts/token/ERC721/IERC721.sol\":{\"keccak256\":\"0x5dc63d1c6a12fe1b17793e1745877b2fcbe1964c3edfd0a482fac21ca8f18261\",\"license\":\"MIT\",\"urls\":[\"bzz-raw://6b7f97c5960a50fd1822cb298551ffc908e37b7893a68d6d08bce18a11cb0f11\",\"dweb:/ipfs/QmQQvxBytoY1eBt3pRQDmvH2hZ2yjhs12YqVfzGm7KSURq\"]},\"lib/openzeppelin-contracts/contracts/utils/Context.sol\":{\"keccak256\":\"0x493033a8d1b176a037b2cc6a04dad01a5c157722049bbecf632ca876224dd4b2\",\"license\":\"MIT\",\"urls\":[\"bzz-raw://6a708e8a5bdb1011c2c381c9a5cfd8a9a956d7d0a9dc1bd8bcdaf52f76ef2f12\",\"dweb:/ipfs/Qmax9WHBnVsZP46ZxEMNRQpLQnrdE4dK8LehML1Py8FowF\"]},\"lib/openzeppelin-contracts/contracts/utils/Panic.sol\":{\"keccak256\":\"0xf7fe324703a64fc51702311dc51562d5cb1497734f074e4f483bfb6717572d7a\",\"license\":\"MIT\",\"urls\":[\"bzz-raw://c6a5ff4f9fd8649b7ee20800b7fa387d3465bd77cf20c2d1068cd5c98e1ed57a\",\"dweb:/ipfs/QmVSaVJf9FXFhdYEYeCEfjMVHrxDh5qL4CGkxdMWpQCrqG\"]},\"lib/openzeppelin-contracts/contracts/utils/introspection/ERC165.sol\":{\"keccak256\":\"0xddce8e17e3d3f9ed818b4f4c4478a8262aab8b11ed322f1bf5ed705bb4bd97fa\",\"license\":\"MIT\",\"urls\":[\"bzz-raw://8084aa71a4cc7d2980972412a88fe4f114869faea3fefa5436431644eb5c0287\",\"dweb:/ipfs/Qmbqfs5dRdPvHVKY8kTaeyc65NdqXRQwRK7h9s5UJEhD1p\"]},\"lib/openzeppelin-contracts/contracts/utils/introspection/IERC165.sol\":{\"keccak256\":\"0x79796192ec90263f21b464d5bc90b777a525971d3de8232be80d9c4f9fb353b8\",\"license\":\"MIT\",\"urls\":[\"bzz-raw://f6fda447a62815e8064f47eff0dd1cf58d9207ad69b5d32280f8d7ed1d1e4621\",\"dweb:/ipfs/QmfDRc7pxfaXB2Dh9np5Uf29Na3pQ7tafRS684wd3GLjVL\"]},\"lib/openzeppelin-contracts/contracts/utils/math/Math.sol\":{\"keccak256\":\"0xa00be322d7db5786750ce0ac7e2f5b633ac30a5ed5fa1ced1e74acfc19acecea\",\"license\":\"MIT\",\"urls\":[\"bzz-raw://6c84e822f87cbdc4082533b626667b6928715bb2b1e8e7eb96954cebb9e38c8d\",\"dweb:/ipfs/QmZmy9dgxLTerBAQDuuHqbL6EpgRxddqgv5KmwpXYVbKz1\"]},\"lib/openzeppelin-contracts/contracts/utils/math/SafeCast.sol\":{\"keccak256\":\"0x195533c86d0ef72bcc06456a4f66a9b941f38eb403739b00f21fd7c1abd1ae54\",\"license\":\"MIT\",\"urls\":[\"bzz-raw://b1d578337048cad08c1c03041cca5978eff5428aa130c781b271ad9e5566e1f8\",\"dweb:/ipfs/QmPFKL2r9CBsMwmUqqdcFPfHZB2qcs9g1HDrPxzWSxomvy\"]},\"lib/openzeppelin-contracts/contracts/utils/structs/EnumerableSet.sol\":{\"keccak256\":\"0x9b161e97b8967d4bc0c08d25741889a30692cdda4b71910bf1b0e315f1962212\",\"license\":\"MIT\",\"urls\":[\"bzz-raw://821500c39d095eaa25b06f46e65f1d0e97c4c96b39227f79077dee7d9e84051f\",\"dweb:/ipfs/QmSTeGorKzSWF6HAmxo32uCZiEuKNvreQdUiX1AaYtUMTz\"]},\"lib/v4-core/lib/solmate/src/auth/Owned.sol\":{\"keccak256\":\"0xfedb27d14c508342c33eb067c9a02eabcdb0f9dcf93b04ded1001f580d12d0ea\",\"license\":\"AGPL-3.0-only\",\"urls\":[\"bzz-raw://1ff52bbee698b9cf9e4574615e6550be0887ccf355f6571e23d6f25b332e79b4\",\"dweb:/ipfs/QmVorA2apojVRStzS7h8aFccR3Uv32G6HVtBtFHZrE7YXx\"]},\"lib/v4-core/lib/solmate/src/test/utils/mocks/MockERC20.sol\":{\"keccak256\":\"0x525129ccb4103c9ecb8f235618d2ff4a8ffde4b8654f7c17766ad175d10ef466\",\"license\":\"AGPL-3.0-only\",\"urls\":[\"bzz-raw://45692a21807ba815c0cf0bfc7d633a14a6cb9ba863ab53f18fc639375a72125e\",\"dweb:/ipfs/QmSrqxyodjDtSU1Dc6G3ScnNc9CFjMnAeHpK8a8guM3nJu\"]},\"lib/v4-core/lib/solmate/src/tokens/ERC20.sol\":{\"keccak256\":\"0xcdfd8db76b2a3415620e4d18cc5545f3d50de792dbf2c3dd5adb40cbe6f94b10\",\"license\":\"AGPL-3.0-only\",\"urls\":[\"bzz-raw://57b3ab70cde374af1cf2c9888636e8de6cf660f087b1c9abd805e9271e19fa35\",\"dweb:/ipfs/QmNrLDBAHYFjpjSd12jerm1AdBkDqEYUUaXgnT854BUZ97\"]},\"lib/v4-core/lib/solmate/src/tokens/ERC721.sol\":{\"keccak256\":\"0x04af19f16f00ba65ae168d6d10da5210dc18da6bcec6974dccf984ba388aa22d\",\"license\":\"AGPL-3.0-only\",\"urls\":[\"bzz-raw://098e69f22b67da6927e03203c12ebfda5b0490518f6d9cce7853001ac5ad8403\",\"dweb:/ipfs/QmYyzfurQe88PsVjRNfutV3gS7Vi68f7zgtVZVtLfd4ViK\"]},\"lib/v4-core/src/libraries/BitMath.sol\":{\"keccak256\":\"0x51b9be4f5c4fd3e80cbc9631a65244a2eb2be250b6b7f128a2035080e18aee8d\",\"license\":\"MIT\",\"urls\":[\"bzz-raw://fe98bbd5498e912146b9319827fc63621eb66ff55d5baae0fa02a7a972ab8d1e\",\"dweb:/ipfs/QmY5hCuyrtgsJtk4AavrxcvBkRrChfr4N6ZnhdC8roPpNi\"]},\"lib/v4-core/src/libraries/CustomRevert.sol\":{\"keccak256\":\"0x111ed3031b6990c80a93ae35dde6b6ac0b7e6af471388fdd7461e91edda9b7de\",\"license\":\"MIT\",\"urls\":[\"bzz-raw://c9ea883c98d6ae1829160d0977bb5195761cfd5bc81692d0a941f45717f594cd\",\"dweb:/ipfs/QmZPwxzaeMNv536wzrAMrMswu7vMHuqPVpjcqL3YvCMoxt\"]},\"lib/v4-core/src/libraries/FixedPoint96.sol\":{\"keccak256\":\"0xef5c3fd41aee26bb12aa1c32873cfee88e67eddfe7c2b32283786265ac669741\",\"license\":\"MIT\",\"urls\":[\"bzz-raw://4de298d02f662a1c36c7be0a150f18c2a161408a5d3e48432e707efd01fac9a4\",\"dweb:/ipfs/QmSiM4oeMmLVKmAtJXz2feYkv4R9ZcyBpkTRW5Nhw5KDyJ\"]},\"lib/v4-core/src/libraries/FullMath.sol\":{\"keccak256\":\"0x4fc73a00817193fd3cac1cc03d8167d21af97d75f1815a070ee31a90c702b4c2\",\"license\":\"MIT\",\"urls\":[\"bzz-raw://c3b2d66d36b1ad56b1ab6e2eb8a816740877b40b461c93f125e88621c8378e52\",\"dweb:/ipfs/QmPGvMZzKQvNiWKd8aRzzdW7oAizwrMgcMtnaworDkVHFC\"]},\"lib/v4-core/src/libraries/TickMath.sol\":{\"keccak256\":\"0x4e1a11e154eb06106cb1c4598f06cca5f5ca16eaa33494ba2f0e74981123eca8\",\"license\":\"MIT\",\"urls\":[\"bzz-raw://a79a57f7b240783b045168d1c4f774ac1812caf8f9a83cb6959a86b0b07b6c70\",\"dweb:/ipfs/QmTb5kvxwDNW8jDuQaqdJ445cCFejNkUqEB17Bjo8UBiva\"]},\"lib/v4-core/test/utils/LiquidityAmounts.sol\":{\"keccak256\":\"0x3ec40b1ddf34a1b33fe3934a2f1e4f66dbcf4378a4c672d0d6ce845ccf8bcae2\",\"license\":\"UNLICENSED\",\"urls\":[\"bzz-raw://6fc4a4688f272d4b55c1d0440ee5ebdc951e5299ff23ae79a4b52cc83e978b8a\",\"dweb:/ipfs/QmYJogZFeyaVeSFbYLCMdwEZtL8sWB8Ndx5AuepWdHsHGY\"]},\"lib/v4-periphery/lib/permit2/src/interfaces/IAllowanceTransfer.sol\":{\"keccak256\":\"0x37f0ac203b6ef605c9533e1a739477e8e9dcea90710b40e645a367f8a21ace29\",\"license\":\"MIT\",\"urls\":[\"bzz-raw://e0104d72aeaec1cd66cc232e7de7b7ead08608efcc179491b8a66387614670b0\",\"dweb:/ipfs/QmfAZDyuNC9FXXbnJUwqHNwmAK6uRrXxtWEytLsxjskPsN\"]},\"lib/v4-periphery/lib/permit2/src/interfaces/IEIP712.sol\":{\"keccak256\":\"0xfdccf2b9639070803cd0e4198427fb0df3cc452ca59bd3b8a0d957a9a4254138\",\"license\":\"MIT\",\"urls\":[\"bzz-raw://f7c936ac42ce89e827db905a1544397f8bdf46db34cdb6aa1b90dea42fdb4c72\",\"dweb:/ipfs/QmVgurxo1N31qZqkPBirw9Z7S9tLYmv6jSwQp8R8ur2cBk\"]},\"lib/v4-periphery/lib/permit2/src/interfaces/IERC1271.sol\":{\"keccak256\":\"0x0a546b8535127fb4a49d36d5f306fd5a8bbe6125a1852f935b9bb85a04c1acef\",\"license\":\"MIT\",\"urls\":[\"bzz-raw://4b99651e2df98e283a97c46d8d1ac4eff0d6a3618e25f7f85294472a670b541c\",\"dweb:/ipfs/QmYRy5G8fXE8BfmyvGEbESEYZPPg3zJEFxHzR5GJZEMMTk\"]},\"lib/v4-periphery/lib/permit2/src/libraries/SignatureVerification.sol\":{\"keccak256\":\"0x99f437ffe99aa1ff7885aec8b971f48efac00c6ebc59c02eec78c9ca850a5e30\",\"license\":\"MIT\",\"urls\":[\"bzz-raw://9365414bdb67813d4ef6c89fa152dff05fc2a64992a1a4f212fa414dbdee3eab\",\"dweb:/ipfs/QmfJxSszF1rjmMoNXW5oQMo9gARMHAXYTu68fkZvdEu58i\"]},\"lib/v4-periphery/lib/v4-core/src/ERC6909.sol\":{\"keccak256\":\"0x22476a1c183be1b547a509b3e6906abaccb6408375f798fce805ff7877aca09f\",\"license\":\"MIT\",\"urls\":[\"bzz-raw://e85580e1563ea0556705132fb6bd038ca4aa355749039923853ebcb76b7c84e6\",\"dweb:/ipfs/QmVoxPrbagRKpFdRWoaCSKmStYLZrhNFuedcuyGycSGR7q\"]},\"lib/v4-periphery/lib/v4-core/src/ERC6909Claims.sol\":{\"keccak256\":\"0xf496ef3a5a9bf4f4aa2eec951dbeff09a01ef058bb9f64b1664cf46c9e85cd49\",\"license\":\"MIT\",\"urls\":[\"bzz-raw://2a0a97c359a7a4c526ba9fc4ceb20af8050f9cf7886ea7e1f38c9c10b4a3750c\",\"dweb:/ipfs/QmPy6pCQbvzCdJRqG1thHRSwEZoLBAaLo3KQnueL3wxb8i\"]},\"lib/v4-periphery/lib/v4-core/src/Extsload.sol\":{\"keccak256\":\"0x784074bd04a1541c7c6ace074e30245746133fd37c3ba16b025dce394db986ce\",\"license\":\"MIT\",\"urls\":[\"bzz-raw://35f1f4fb306bf01e98b7eca012b85f3ab978b39fa5136193363e2519c4435e51\",\"dweb:/ipfs/QmeGrjGMt71dJymVhkEadh5CuCW5GxRqNEZLi5AJxvC5tU\"]},\"lib/v4-periphery/lib/v4-core/src/Exttload.sol\":{\"keccak256\":\"0x769ee2733a08112c652274f4b972c45fb56cc46109f233b9a30f81561b15dd54\",\"license\":\"MIT\",\"urls\":[\"bzz-raw://dd19e88d50ae77c1ed5581baca1c75b3fb828d0b58cded90188d55c4e336266c\",\"dweb:/ipfs/Qmc8YM6Tfpwwa4qivHHzRxNdhZzdzGiD7VexWsDvkaQTxG\"]},\"lib/v4-periphery/lib/v4-core/src/NoDelegateCall.sol\":{\"keccak256\":\"0xacb81aecb7c74c86650a035462dae38c313b4b7b5842e14b645f864f61da2b51\",\"license\":\"MIT\",\"urls\":[\"bzz-raw://363a0e15fc30ea68a5d52a78772facecde6433ea156e3ec2ce25068c97cd5ad6\",\"dweb:/ipfs/QmYhWaF3wH71SDx5TZr9qEXXQf5FYQvdjoo3B2qWiAbm18\"]},\"lib/v4-periphery/lib/v4-core/src/PoolManager.sol\":{\"keccak256\":\"0xaa234912d8bc3a54c80f3973b34823cfac88d01fe9481765b7a5925dccbc9b79\",\"license\":\"BUSL-1.1\",\"urls\":[\"bzz-raw://6faf4019cd6cfcaa434631e2f9709389abd8ab339d51096f404f260cc255b5e1\",\"dweb:/ipfs/QmZ8aLGm3b2L4UuzrerGmpyB2f32cUcNUL6qvzNBqop45k\"]},\"lib/v4-periphery/lib/v4-core/src/ProtocolFees.sol\":{\"keccak256\":\"0x81362ef1d19670b41cefc2b6f2dc0333b6743fe39a1929edd36bd9b6a1111755\",\"license\":\"MIT\",\"urls\":[\"bzz-raw://de483bbd8bf9a53b9644d7f9a6a6fe77ae527b755cf29e1db8725de89e70c7aa\",\"dweb:/ipfs/Qmex3PcgJGbYsuDNaMXc8mg5fW1DNaPGiNToPpAAzz6GEq\"]},\"lib/v4-periphery/lib/v4-core/src/interfaces/IExtsload.sol\":{\"keccak256\":\"0x80b53ca4907d6f0088c3b931f2b72cad1dc4615a95094d96bd0fb8dff8d5ba43\",\"license\":\"MIT\",\"urls\":[\"bzz-raw://375c69148622aab7a3537d5fd37d373a8e9731022c8d87bdaee46233b0a99fe1\",\"dweb:/ipfs/QmXFjdoYRxsA5B1kyuxEXgNf3FBoL1zPvy26Qy8EtpdFRN\"]},\"lib/v4-periphery/lib/v4-core/src/interfaces/IExttload.sol\":{\"keccak256\":\"0xc6b68283ebd8d1c789df536756726eed51c589134bb20821b236a0d22a135937\",\"license\":\"MIT\",\"urls\":[\"bzz-raw://294394f72dfc219689209f4130d85601dfd0d63c8d47578050d312db70f9b6c8\",\"dweb:/ipfs/QmTDMQ3oxCGHgEBU48a3Lp4S1rRjc8vVCxkhE5ZNej1bsY\"]},\"lib/v4-periphery/lib/v4-core/src/interfaces/IHooks.sol\":{\"keccak256\":\"0x4c9571aed0c2b6ef11832545554fc11ffdb03746daaf5c73683c00600bfc7ec0\",\"license\":\"MIT\",\"urls\":[\"bzz-raw://e78b34b58ce9de91b91943b4f3cc3ce121d0b151e123e8a600ac5ef64d91db6c\",\"dweb:/ipfs/QmRkaQnPCYwLrXgbpGujJTx32PaZK63KSPJJV1XmnQuCMb\"]},\"lib/v4-periphery/lib/v4-core/src/interfaces/IPoolManager.sol\":{\"keccak256\":\"0xb29607eefac17cb3b0a6f7ca1225a4f5a4baf4873fd1689c770e1fa0b3465399\",\"license\":\"MIT\",\"urls\":[\"bzz-raw://d1c9d83b6910d2cbd8b711438072b57f7feffcc18321330c0d83e73159c9c828\",\"dweb:/ipfs/QmZfkdqayzYHAiGXrXLXYNaiS6JXSQmKyJLDQHvaXYi5Y2\"]},\"lib/v4-periphery/lib/v4-core/src/interfaces/IProtocolFees.sol\":{\"keccak256\":\"0x32a666e588a2f66334430357bb1e2424fe7eebeb98a3364b1dd16eb6ccca9848\",\"license\":\"MIT\",\"urls\":[\"bzz-raw://85751d302125881f72e5f8af051c2d5d9b1f606ebaea8ca7d04fccdd27cc252d\",\"dweb:/ipfs/QmeRwomeh9NWm6A6fgNA4KZPQZHPpdKsPQyYsHSFmvud7J\"]},\"lib/v4-periphery/lib/v4-core/src/interfaces/callback/IUnlockCallback.sol\":{\"keccak256\":\"0x58c82f2bd9d7c097ed09bd0991fedc403b0ec270eb3d0158bfb095c06a03d719\",\"license\":\"MIT\",\"urls\":[\"bzz-raw://91168ca26a10980df2cdc3fbfe8ddf372c002b7ef19e3c59a0c9870d64198f1b\",\"dweb:/ipfs/QmUSpaM825vd1SwvF38esgbdLgYiPwefKaFERTWvUi6uSK\"]},\"lib/v4-periphery/lib/v4-core/src/interfaces/external/IERC20Minimal.sol\":{\"keccak256\":\"0xeccadf1bf69ba2eb51f2fe4fa511bc7bb05bbd6b9f9a3cb8e5d83d9582613e0f\",\"license\":\"MIT\",\"urls\":[\"bzz-raw://118757369892687b99ef46ce28d6861f62c098285bd7687a4f17f7e44e5f81de\",\"dweb:/ipfs/QmUxqbYqQtcEwwFbb9e6BBMePEaSgN8C45v6RKubD4ib8d\"]},\"lib/v4-periphery/lib/v4-core/src/interfaces/external/IERC6909Claims.sol\":{\"keccak256\":\"0xa586f345739e52b0488a0fe40b6e375cce67fdd25758408b0efcb5133ad96a48\",\"license\":\"MIT\",\"urls\":[\"bzz-raw://e8c557b7e52abdbbd82e415a1acc27921446a7fd090b7d4877e52be72619547f\",\"dweb:/ipfs/QmXE2KNPbXmGX8BQF3ei6zhzRTnhoTQg39XmqMnkhbr6QK\"]},\"lib/v4-periphery/lib/v4-core/src/libraries/BitMath.sol\":{\"keccak256\":\"0x51b9be4f5c4fd3e80cbc9631a65244a2eb2be250b6b7f128a2035080e18aee8d\",\"license\":\"MIT\",\"urls\":[\"bzz-raw://fe98bbd5498e912146b9319827fc63621eb66ff55d5baae0fa02a7a972ab8d1e\",\"dweb:/ipfs/QmY5hCuyrtgsJtk4AavrxcvBkRrChfr4N6ZnhdC8roPpNi\"]},\"lib/v4-periphery/lib/v4-core/src/libraries/CurrencyDelta.sol\":{\"keccak256\":\"0x80dbd898cf0f90c5c27192689b16c34edc765d6ab21b8358e3bb792c7fef238c\",\"license\":\"BUSL-1.1\",\"urls\":[\"bzz-raw://107698da024313f132d9fe28deb920b5c03d14624889c3ce5720e588f03635bb\",\"dweb:/ipfs/QmQteUbhj5SsWbvSF6U8niBUSrETqVbEwULc8E7vS4Kbnn\"]},\"lib/v4-periphery/lib/v4-core/src/libraries/CurrencyReserves.sol\":{\"keccak256\":\"0x1576616129933fcdf3b684cea33cffd9c95e18fafbd2832a8c48ac3d8526d4c3\",\"license\":\"BUSL-1.1\",\"urls\":[\"bzz-raw://33b050efb9b81803b18f562271e7cca2ec5362c4d505860d6419b4a345636725\",\"dweb:/ipfs/QmQtFtTwKZ5pFVGD2ENDUXvp7ECFvzqeCuJ1miJcUHdmiX\"]},\"lib/v4-periphery/lib/v4-core/src/libraries/CustomRevert.sol\":{\"keccak256\":\"0x111ed3031b6990c80a93ae35dde6b6ac0b7e6af471388fdd7461e91edda9b7de\",\"license\":\"MIT\",\"urls\":[\"bzz-raw://c9ea883c98d6ae1829160d0977bb5195761cfd5bc81692d0a941f45717f594cd\",\"dweb:/ipfs/QmZPwxzaeMNv536wzrAMrMswu7vMHuqPVpjcqL3YvCMoxt\"]},\"lib/v4-periphery/lib/v4-core/src/libraries/FixedPoint128.sol\":{\"keccak256\":\"0xad236e10853f4b4b20a35a9bb52b857c4fc79874846b7e444e06ead7f2630542\",\"license\":\"MIT\",\"urls\":[\"bzz-raw://0de1f9a06520b1a689660943faa14fc0b8344ab41fab9e6012ea34bff4b9b3eb\",\"dweb:/ipfs/QmRNMPTyko7W6d6KxuTsnDBa9oZgDK4xiwRRq3H9ASTbwy\"]},\"lib/v4-periphery/lib/v4-core/src/libraries/FixedPoint96.sol\":{\"keccak256\":\"0xef5c3fd41aee26bb12aa1c32873cfee88e67eddfe7c2b32283786265ac669741\",\"license\":\"MIT\",\"urls\":[\"bzz-raw://4de298d02f662a1c36c7be0a150f18c2a161408a5d3e48432e707efd01fac9a4\",\"dweb:/ipfs/QmSiM4oeMmLVKmAtJXz2feYkv4R9ZcyBpkTRW5Nhw5KDyJ\"]},\"lib/v4-periphery/lib/v4-core/src/libraries/FullMath.sol\":{\"keccak256\":\"0x4fc73a00817193fd3cac1cc03d8167d21af97d75f1815a070ee31a90c702b4c2\",\"license\":\"MIT\",\"urls\":[\"bzz-raw://c3b2d66d36b1ad56b1ab6e2eb8a816740877b40b461c93f125e88621c8378e52\",\"dweb:/ipfs/QmPGvMZzKQvNiWKd8aRzzdW7oAizwrMgcMtnaworDkVHFC\"]},\"lib/v4-periphery/lib/v4-core/src/libraries/Hooks.sol\":{\"keccak256\":\"0x27b1c3b8aa3d07d8e3123970695745929315685a5ffaa7342c3ba3582f37fecb\",\"license\":\"MIT\",\"urls\":[\"bzz-raw://fa3bb092dc205eaa1b9defc93e9bbad5f4c5c44e1c4aa531dfca2574c2aba9ba\",\"dweb:/ipfs/QmR1soxkepHNkbGxAMaK4XqhQ4VxWn69dewzGkQJNx5byM\"]},\"lib/v4-periphery/lib/v4-core/src/libraries/LPFeeLibrary.sol\":{\"keccak256\":\"0xbf6914e01014e7c1044111feb7df7a3d96bb503b3da827ad8464b1955580d13b\",\"license\":\"MIT\",\"urls\":[\"bzz-raw://33823c20a91882c9aacdcbb02f0558c05209f4d5954aa6dd4fa17c95664db475\",\"dweb:/ipfs/QmR7owkFgpfztpp1QUg3ut3nw9iPVQqLGP4hzgmZtRUQ2J\"]},\"lib/v4-periphery/lib/v4-core/src/libraries/LiquidityMath.sol\":{\"keccak256\":\"0x000ef2eadcc1eb7b2c18a77655f94e76e0e860f605783484657ef65fd6eda353\",\"license\":\"MIT\",\"urls\":[\"bzz-raw://a766b620a7a22798b43c6c1f23b5c6cff0ebf588deb89842bad05208d448cd99\",\"dweb:/ipfs/QmVKjaFJdzkqA3ey2Byum8iTCMssWVD8MmVC8rw62Tj5WD\"]},\"lib/v4-periphery/lib/v4-core/src/libraries/Lock.sol\":{\"keccak256\":\"0x9338be4b5695f1da5f3d3f7a3eeaf7a356c1045458289586ac0cbe9cef77c6d5\",\"license\":\"BUSL-1.1\",\"urls\":[\"bzz-raw://485ec42ed6155469d612a9a0c18068ebfbad74448792a338a435503de3ef1b2c\",\"dweb:/ipfs/QmVnnv5u74MYatfRmBgrcfFYQcsMAJMG9jQ6ju8UiydKNF\"]},\"lib/v4-periphery/lib/v4-core/src/libraries/NonzeroDeltaCount.sol\":{\"keccak256\":\"0x0666ebd5d3528d7d52c48538296367a4cff97a578cf13365c51983fae3219b87\",\"license\":\"BUSL-1.1\",\"urls\":[\"bzz-raw://d27f1be3bd09d85c53d3e6a539dd6529ddd8b2b764ccb47fd7765fc81f9add59\",\"dweb:/ipfs/QmQdZujNXhKEXQBkKtF5jbdvo1yXMqPDUoBBaF9S5u3Kpm\"]},\"lib/v4-periphery/lib/v4-core/src/libraries/ParseBytes.sol\":{\"keccak256\":\"0x7533b13f53ee2c2c55500100b22ffd6e37e7523c27874edc98663d53a8672b15\",\"license\":\"MIT\",\"urls\":[\"bzz-raw://82449058634fde28a085f3c59a6a5f412550c02181590593fd84c3e8b329aa17\",\"dweb:/ipfs/Qmev4E9Au6SsE4wsArChCwfg94KhHc5gYsEsZUnjF5sRLa\"]},\"lib/v4-periphery/lib/v4-core/src/libraries/Pool.sol\":{\"keccak256\":\"0x53cd1b8791274c3599ed62fb8d2eb428bfad6cefa2002b5e684250b89e681371\",\"license\":\"BUSL-1.1\",\"urls\":[\"bzz-raw://469124e41971bbd78107099961aaef5c6cb8035d236647f9e6ce2b0d9e1318cf\",\"dweb:/ipfs/QmWjfugsTJa8jB15dm6acpixXLgDoEMa1me9tMeEXxsazU\"]},\"lib/v4-periphery/lib/v4-core/src/libraries/Position.sol\":{\"keccak256\":\"0xddab2a831f1befb6abf5567e77c4582169ca8156cf69eb4f22d8e87f7226a3f9\",\"license\":\"BUSL-1.1\",\"urls\":[\"bzz-raw://c79fe61b50f3b70cff503abfa6f5643fcbefb9b794855bee1019b1e6d9c083b2\",\"dweb:/ipfs/QmbKmYNQesaMz8bo1b7TMHQcAwaDd3eDPrE5pAdPPZTtk5\"]},\"lib/v4-periphery/lib/v4-core/src/libraries/ProtocolFeeLibrary.sol\":{\"keccak256\":\"0xf483001899229ab10f5a626fe1c5866134d9e965b48ce6cf55ce0d7f74f7d8ec\",\"license\":\"MIT\",\"urls\":[\"bzz-raw://6ba9211a7f69bbb44649c35211eb29d193c09032ec600064ef9d04b4625dd8ba\",\"dweb:/ipfs/QmQSjQvtguYgMJSkkKRhHjxasfX9xfTbrbcZ1QmjUVb787\"]},\"lib/v4-periphery/lib/v4-core/src/libraries/SafeCast.sol\":{\"keccak256\":\"0x42c4a24f996a14d358be397b71f7ec9d7daf666aaec78002c63315a6ee67aa86\",\"license\":\"MIT\",\"urls\":[\"bzz-raw://c3db86e2ba3679105fc32edec656c70282e1fede6cab11217702443f6c26fa59\",\"dweb:/ipfs/QmX4yaaSPdKQzYNRsezjTvZKsubzS8JRTEGFD3fPpTTCcj\"]},\"lib/v4-periphery/lib/v4-core/src/libraries/SqrtPriceMath.sol\":{\"keccak256\":\"0xf8079fe6e3460db495451d06b1705e18f1c4075c1af96a31ad313545f7082982\",\"license\":\"MIT\",\"urls\":[\"bzz-raw://582fc51546723a0a8acccf782f69b530bacf9b3ef929458e82569b7121f0b138\",\"dweb:/ipfs/QmSBXcmqZdFsM7M4sRaiyQAxykCeMNFKyKgBcwSMTw1bcF\"]},\"lib/v4-periphery/lib/v4-core/src/libraries/StateLibrary.sol\":{\"keccak256\":\"0x4bbb1e816dd67fd4e958518ef50d216fcdab19912ab98c28d4c5279890c48c2c\",\"license\":\"MIT\",\"urls\":[\"bzz-raw://eab2611adf69904cb0f326dbd82cdd6d1a09630dacace7f741e29c76836e41e8\",\"dweb:/ipfs/QmcCR78dZ8C7pF3DSDoWyYobX7aXkBNxbCmgenkqpgRrbT\"]},\"lib/v4-periphery/lib/v4-core/src/libraries/SwapMath.sol\":{\"keccak256\":\"0x6baa782ae523269c079cc763639a9b91a25fcfa1743c049c76e43741ef494bd9\",\"license\":\"MIT\",\"urls\":[\"bzz-raw://035c337e62e05262a5bd5d3bc85bc9a383c1013001216b429f49cf1e129a0812\",\"dweb:/ipfs/QmU7s4h58Fh2A6mM8yeorZ2ygwEJMQw8zdZLLkHeDoSWxD\"]},\"lib/v4-periphery/lib/v4-core/src/libraries/TickBitmap.sol\":{\"keccak256\":\"0x6779f89e28a0b4af6e09d518caf014b7e8fc627400f5561f86fed11635b1458a\",\"license\":\"MIT\",\"urls\":[\"bzz-raw://a64dee983106de3be3f968be94368c1e37592f5418aa2a39e8dd358d5a962b0d\",\"dweb:/ipfs/QmYuECZTiEeQVxDLYx6pBSSnVrg56Apw75bugQiM3FmGwy\"]},\"lib/v4-periphery/lib/v4-core/src/libraries/TickMath.sol\":{\"keccak256\":\"0x4e1a11e154eb06106cb1c4598f06cca5f5ca16eaa33494ba2f0e74981123eca8\",\"license\":\"MIT\",\"urls\":[\"bzz-raw://a79a57f7b240783b045168d1c4f774ac1812caf8f9a83cb6959a86b0b07b6c70\",\"dweb:/ipfs/QmTb5kvxwDNW8jDuQaqdJ445cCFejNkUqEB17Bjo8UBiva\"]},\"lib/v4-periphery/lib/v4-core/src/libraries/TransientStateLibrary.sol\":{\"keccak256\":\"0x7d1e0875747bd89b32c25f1a48da2766e5f4aff1f671ad5f3c0c07ebbbcb946a\",\"license\":\"MIT\",\"urls\":[\"bzz-raw://d76cfeb1cb60595b41ecc51c8a12fb4bf63a7fc733d0b1a2e3adb55abeb1f9d5\",\"dweb:/ipfs/Qmb8oX7DtsRpw3tTtdWZwGhauj1evq43d3PLwe4nSDAKkV\"]},\"lib/v4-periphery/lib/v4-core/src/libraries/UnsafeMath.sol\":{\"keccak256\":\"0xa6e55e0a43a15df2df471d9972cd48f613d07c663ecb8bbeaf7623f6f99bcce4\",\"license\":\"MIT\",\"urls\":[\"bzz-raw://02ea6e13879fc5a5f35149a2f1cd8af3a1f0877ff69101dad53841d16f515572\",\"dweb:/ipfs/QmcpL4gdG6hL2w1wqs2Vw4J1EFCwBs9T1Qd4p16CtECQkn\"]},\"lib/v4-periphery/lib/v4-core/src/test/ActionsRouter.sol\":{\"keccak256\":\"0x14dee9e42a1df016ee93959efbff2989c0f5fc3be2583cc7f220e8c99bc1ca52\",\"license\":\"UNLICENSED\",\"urls\":[\"bzz-raw://cede28a88b18e6506407d4f35787fb2891a6023a363b15beb5c3af3d57ceaeef\",\"dweb:/ipfs/QmbwcWHBnD9615BPSpPZ7hTuCCXG9BWHdHQS67KRtfrEqR\"]},\"lib/v4-periphery/lib/v4-core/src/test/PoolClaimsTest.sol\":{\"keccak256\":\"0x12833a6562b06737ebb1b08a8a8ef233314f0b9e03129cff3550d9fd4c184986\",\"license\":\"UNLICENSED\",\"urls\":[\"bzz-raw://09d31189420ccd828f8e529782c9e1e31b0ce3f07f59efb6db5a8848395e7887\",\"dweb:/ipfs/Qmb4rosxr2DLxUAH6qUDfqVbj1CfnzrDwxfLLjpneMSwRW\"]},\"lib/v4-periphery/lib/v4-core/src/test/PoolDonateTest.sol\":{\"keccak256\":\"0x5e517fea38336bb86419f7280d5f80b26fe8cab9eac1cf400e27f87562d3d105\",\"license\":\"UNLICENSED\",\"urls\":[\"bzz-raw://5528c6a97eefbb94607d1a2aa07b1ec6f9c9b955b5f4a123ee88beabf6a03deb\",\"dweb:/ipfs/QmYfcaX1vkzjb1s389Rj7VsvCttB5wdarP17vyHWiejbqq\"]},\"lib/v4-periphery/lib/v4-core/src/test/PoolModifyLiquidityTest.sol\":{\"keccak256\":\"0xa6c1e0f95486e5e331c0c60ba7861ce86783a53e265575a54805be67e215163d\",\"license\":\"UNLICENSED\",\"urls\":[\"bzz-raw://3f1a7f4c06d6a36070a694d79d0a9c2e95f3891f00f757587a902e90a017d8ed\",\"dweb:/ipfs/QmexrSMxktmzT1cd6ScRet4uYK5UGdgrUY1sfR5uNyuuXQ\"]},\"lib/v4-periphery/lib/v4-core/src/test/PoolModifyLiquidityTestNoChecks.sol\":{\"keccak256\":\"0x5997a54ba786ed94de58835b830adf5a315c08e4170f810007f93e2d70b59656\",\"license\":\"UNLICENSED\",\"urls\":[\"bzz-raw://1b7918c857e034dfaff5e5d0b47beeaa53790ee8c30829d34c8ed1587bf2d046\",\"dweb:/ipfs/QmcU2ztu1Mvguh6N8P2D5sj3kL2sEWveB5cyRaCGbi6irE\"]},\"lib/v4-periphery/lib/v4-core/src/test/PoolNestedActionsTest.sol\":{\"keccak256\":\"0x60ce17c092024ff0bc177c9af01c8e09ce88bf67754e32b9bdb7ec2e8fcc071e\",\"license\":\"UNLICENSED\",\"urls\":[\"bzz-raw://f1d925ae50bb7a46fb8f5d2d6c1bd08e2f6dc879ec7185a3feb61b913857601c\",\"dweb:/ipfs/QmcHV9PBT2ugUfsMH2cB1jRj5sUX8Bi8qH6wSR4fLrHg3G\"]},\"lib/v4-periphery/lib/v4-core/src/test/PoolSwapTest.sol\":{\"keccak256\":\"0xda44325f85ef237195c629bade552b0827001ba80f87786468d532748b307974\",\"license\":\"UNLICENSED\",\"urls\":[\"bzz-raw://f8c19b061b824a5222899b1a19c238eee3f6ccea902a0131e7b0f14e635701df\",\"dweb:/ipfs/QmYvQx6vxnFQH52NL9HDRGHAgrVgXfrmYAYk62fPn2Q9jr\"]},\"lib/v4-periphery/lib/v4-core/src/test/PoolTakeTest.sol\":{\"keccak256\":\"0xcdc76eb93c349a5f5c30abff0438d5599427ac6f6892e0abf8d0346c46244368\",\"license\":\"UNLICENSED\",\"urls\":[\"bzz-raw://5d005b6672e38d7c673677be08e041e32670a4a64bd3b92dc07e29d1609c5193\",\"dweb:/ipfs/QmZVqyEz1BgYNmyAPooef5c77yjj4A2e9ooWfrJ2SducJ2\"]},\"lib/v4-periphery/lib/v4-core/src/test/PoolTestBase.sol\":{\"keccak256\":\"0xc3b1c46487231f8416d053652cfb3c773d728705a6a1a542ea48e8d1cca44962\",\"license\":\"UNLICENSED\",\"urls\":[\"bzz-raw://c2229b5915fcf17c58253b81cd4bbff62f7fbc6df8c370188c771fc40febf15a\",\"dweb:/ipfs/QmRu2Qb341KpA9k9prYH8buJek6vZiE7bxnyC9UkjVGBxV\"]},\"lib/v4-periphery/lib/v4-core/src/test/SwapRouterNoChecks.sol\":{\"keccak256\":\"0x5ee38cb5b0330ffff9f51659eda85c15c35dc8ade2b3a87a8053ca0c9399fa7f\",\"license\":\"UNLICENSED\",\"urls\":[\"bzz-raw://7503296ed1a3c41d567dd55d8fc3b700b04441b2b2d75739761a7d4295ae0a20\",\"dweb:/ipfs/QmSk8wh26D4c47HdCGA4QGp2rjobfCztbMr51941unqPeQ\"]},\"lib/v4-periphery/lib/v4-core/src/types/BalanceDelta.sol\":{\"keccak256\":\"0xa719c8fe51e0a9524280178f19f6851bcc3b3b60e73618f3d60905d35ae5569f\",\"license\":\"MIT\",\"urls\":[\"bzz-raw://7436928dc9de35c6c7c5c636cb51adaf295cfd590da83b19a004ae33cbec9ef9\",\"dweb:/ipfs/QmRJ9yZkUpzk4433GX3LgVVL8jwpbSYSUwXcucKisf3v4H\"]},\"lib/v4-periphery/lib/v4-core/src/types/BeforeSwapDelta.sol\":{\"keccak256\":\"0x2a774312d91285313d569da1a718c909655da5432310417692097a1d4dc83a78\",\"license\":\"MIT\",\"urls\":[\"bzz-raw://a2c7a0379955cff9c17ab9e61f95e42909aa5947c22740f86ce940d09856f782\",\"dweb:/ipfs/QmaAuo8UBYXsGrVuKh8iRoAAdqwtg1jDq515cW1ZRP5m9K\"]},\"lib/v4-periphery/lib/v4-core/src/types/Currency.sol\":{\"keccak256\":\"0x4a0b84b282577ff6f8acf13ec9f4d32dbb9348748b49611d00e68bee96609c93\",\"license\":\"MIT\",\"urls\":[\"bzz-raw://45f9d62ab3d51b52957279e353853ba1547c3182c9a1e3d1846ada4a90263b01\",\"dweb:/ipfs/QmS8NG84ccQS1yXVD8cv3eKX7J1UKxuJhbUfHTQR2opKF5\"]},\"lib/v4-periphery/lib/v4-core/src/types/PoolId.sol\":{\"keccak256\":\"0x308311916ea0f5c2fd878b6a2751eb223d170a69e33f601fae56dfe3c5d392af\",\"license\":\"MIT\",\"urls\":[\"bzz-raw://669c2cd7ac17690b5d8831e0bda72822376c3a04b36afed6d31df4d75fe60918\",\"dweb:/ipfs/QmT6EpkxqU8VF3WsgrZ66F3s1cCQRffR95z1HDYZz7ph6y\"]},\"lib/v4-periphery/lib/v4-core/src/types/PoolKey.sol\":{\"keccak256\":\"0xf89856e0580d7a4856d3187a76858377ccee9d59702d230c338d84388221b786\",\"license\":\"MIT\",\"urls\":[\"bzz-raw://6f3118fa189025695c37fdf0bdd1190f085ad097484d3c88cf4c56d1db65f639\",\"dweb:/ipfs/QmamXpgtB8GV1CaFLvqefPWSoikLDhMk1yU4heBnVzU8gi\"]},\"lib/v4-periphery/lib/v4-core/src/types/Slot0.sol\":{\"keccak256\":\"0x8b4912fac7e25ea680056748121113f902d56f8b2640f421d5c38d438db11c1b\",\"license\":\"MIT\",\"urls\":[\"bzz-raw://c19b1ff5b951fb54129268d2be37d82c8bb3ea6e29ac9bc78a8a37794fc082b8\",\"dweb:/ipfs/QmTAQ2mUoiT77hoWJAfn9pyoGy47qaevn45QHrbyovGt2C\"]},\"lib/v4-periphery/lib/v4-core/test/utils/Constants.sol\":{\"keccak256\":\"0x19c8d60baec46e1d43fa26f852718d4955154e844be14971e0597a63c22a9d43\",\"license\":\"UNLICENSED\",\"urls\":[\"bzz-raw://9bebdabeab512f3ca999c856641e3fa0d7b86082a01cf826f8647e188e0b35d3\",\"dweb:/ipfs/QmWLFXaTz4Wejd3ZHcyTMDEW8mqUzCfQahQxuVtryxM5Na\"]},\"lib/v4-periphery/lib/v4-core/test/utils/CurrencySettler.sol\":{\"keccak256\":\"0x2569dc02a637111de76e8e8c65f27510e7608273c19652fe6d31d76c983c19b6\",\"license\":\"MIT\",\"urls\":[\"bzz-raw://e9fbc9085e011e7208505c8ff7d402e4dba13b5105b25a24eac85b4a5921de58\",\"dweb:/ipfs/QmPyBSC5JvZrePDjdt2AiNt3EEUXgxX1orvTX1JZidz9PP\"]},\"lib/v4-periphery/lib/v4-core/test/utils/Deployers.sol\":{\"keccak256\":\"0xca85386e54e71e80be104ef8a6019ed72154d97c933993da2a3976609cbf998c\",\"license\":\"UNLICENSED\",\"urls\":[\"bzz-raw://4419e2d89afb9b0a5bf9b380ad540addc8f68352b5e5631838ef9abddf8ab1e5\",\"dweb:/ipfs/QmYn62Y4yUSDaUzTiiDvAvNwW4ay9LZywhYuX4KfNCaXEj\"]},\"lib/v4-periphery/lib/v4-core/test/utils/LiquidityAmounts.sol\":{\"keccak256\":\"0x3ec40b1ddf34a1b33fe3934a2f1e4f66dbcf4378a4c672d0d6ce845ccf8bcae2\",\"license\":\"UNLICENSED\",\"urls\":[\"bzz-raw://6fc4a4688f272d4b55c1d0440ee5ebdc951e5299ff23ae79a4b52cc83e978b8a\",\"dweb:/ipfs/QmYJogZFeyaVeSFbYLCMdwEZtL8sWB8Ndx5AuepWdHsHGY\"]},\"lib/v4-periphery/lib/v4-core/test/utils/SortTokens.sol\":{\"keccak256\":\"0xdc74b25e20e04e5e4f3cf0bda4c81f70fac35562a74a47df56ef650fc7e3c844\",\"license\":\"UNLICENSED\",\"urls\":[\"bzz-raw://324616a6154688bc9bd2d07777592df5a1fbdcc32acaa66bc7b0daa07f14e3f0\",\"dweb:/ipfs/QmPK8dG1LDkm67Qn89h51ExwEfsVJEcs33dL8dSDeZ4ChD\"]},\"lib/v4-periphery/src/PositionManager.sol\":{\"keccak256\":\"0x6996866c77410da122d307535083b01746eef470a914b12baedd0721ffd96a24\",\"license\":\"MIT\",\"urls\":[\"bzz-raw://18d8f752af824da84d3dd826ac4f18a70ea1c94831473c2813825bdc271b0c20\",\"dweb:/ipfs/QmcyGxdkB2gFinYaKt9H9PdTcQoKZyo1hXjtaJ3krf5fPQ\"]},\"lib/v4-periphery/src/base/BaseActionsRouter.sol\":{\"keccak256\":\"0xca1ee500f88951ad351d18ba2adfb5fe23abef6d502f234ce5748a3497674a4c\",\"license\":\"MIT\",\"urls\":[\"bzz-raw://1f03ab458be27c29cef1b7ace5b11517d3fef8bf6131af7dd80d6297c224cf71\",\"dweb:/ipfs/QmYoH6o8yeRzbeLoaMG9TjS8q2Fw7T1h4vXvvMnp3XfsUa\"]},\"lib/v4-periphery/src/base/DeltaResolver.sol\":{\"keccak256\":\"0x94a2da2be5c924df65a8e1e29f585bbe4c37777fedd43b45989c66d509a4a83c\",\"license\":\"MIT\",\"urls\":[\"bzz-raw://42bba590f6e817fd56328b74ae99bfdc4df57386d0a69ee22b9108341953ed36\",\"dweb:/ipfs/QmdusastK7FWYouLz9gvV5J3z8MQbNKLJNNHTrc1vi7DWw\"]},\"lib/v4-periphery/src/base/EIP712_v4.sol\":{\"keccak256\":\"0x151e85890822c1b0fe85ec3c021826cb42f615e2b9d6fcdd79019681a6ee5588\",\"license\":\"MIT\",\"urls\":[\"bzz-raw://c5df84221ba4fe59c8223e94bec954b7f7602d4ad81d2f0c046a67c21c1d24be\",\"dweb:/ipfs/QmbTUqqHxRxEDyrMPApozbC6DEYMZGa27dWu3KodNACiLy\"]},\"lib/v4-periphery/src/base/ERC721Permit_v4.sol\":{\"keccak256\":\"0xb1c3d4cc1fa0c7f9562674917d9ffdd119a1ccdb3adca44b2832d5c91c068125\",\"license\":\"MIT\",\"urls\":[\"bzz-raw://752a8a679a9cc9e56a8e95fc1fa1d8c39a951a479b6c0b1109238f73520045df\",\"dweb:/ipfs/QmRzLo9KRcJH38Fx2xvweVmvMbTRKzyDR7R7Fui4Ca9cma\"]},\"lib/v4-periphery/src/base/ImmutableState.sol\":{\"keccak256\":\"0x1867c9fa2f9b4fa73bab0fcdc9d19ccef4eeac552273d8b84a170cd1cc90350a\",\"license\":\"MIT\",\"urls\":[\"bzz-raw://af2d699b439e13b599632fddfe82718aebd41055fba7c075f186675c588d1337\",\"dweb:/ipfs/Qmc111gckSKb9aESn3wRFLeLiS4KGujaUcaYJgRnCRfwQU\"]},\"lib/v4-periphery/src/base/Multicall_v4.sol\":{\"keccak256\":\"0x654c6e65bd9bbf12b2cc393f8523db04e85ec45e829200de3895709479d6d569\",\"license\":\"MIT\",\"urls\":[\"bzz-raw://d7ee5441ed14cdad5328f8e844403c2969fe2ecd9d110d7b80954bfa41f52d69\",\"dweb:/ipfs/QmQ1r1qmGyg1JXUgmjzi3WxjAmkLtMpUVsRWfYJsRRo3sP\"]},\"lib/v4-periphery/src/base/NativeWrapper.sol\":{\"keccak256\":\"0xfb756bc69e401d621f615746d881cfef7e98f3f563775905a1eca79a074a35ca\",\"license\":\"MIT\",\"urls\":[\"bzz-raw://507c9b3ddf79ec34b8ae472dfc4d6840343a9a172d7c6f33eec290e0078e9254\",\"dweb:/ipfs/QmWhGck33w1s343mtojttgisJcsdwDf6Ah6oTpjgsWcQWh\"]},\"lib/v4-periphery/src/base/Notifier.sol\":{\"keccak256\":\"0x5f2a29b2a528269643d026bf4698e6520eeb1e5fc773f9d5059b3e279a488bf6\",\"license\":\"MIT\",\"urls\":[\"bzz-raw://63d5c541039f37ae89533a15fc311e3fec3d143fa11bac42e73964bdf74b3d06\",\"dweb:/ipfs/QmUrvqNYEYwEu1zRWLFVDUW2zEajbkNYxiNqUpc5aWx5ui\"]},\"lib/v4-periphery/src/base/Permit2Forwarder.sol\":{\"keccak256\":\"0xcdf793e6732cdf0c386f89573384032314b0893bf208b3d75ac71d3002674a3b\",\"license\":\"MIT\",\"urls\":[\"bzz-raw://4f18d0be711c1d586854e2a78113bf84765e7158c9568b2c73f8750511a22ce7\",\"dweb:/ipfs/QmSe3zz9jvDZo2MqPgCpfNs3yA4xAWPB1deZBoRFzeZiN1\"]},\"lib/v4-periphery/src/base/PoolInitializer_v4.sol\":{\"keccak256\":\"0x068c85032e50ef6374958ff3e7dcc143527f669de1bbba831e552d033344a1e3\",\"license\":\"MIT\",\"urls\":[\"bzz-raw://674c29491faef627b52cb81495bf3747cd7f7613e2ddcabb1dd258f93f966006\",\"dweb:/ipfs/Qmc1D31ubNDRdxVS6pxDzn7z8disSw7UScHu8rgfpxCAsz\"]},\"lib/v4-periphery/src/base/ReentrancyLock.sol\":{\"keccak256\":\"0x66dd19f8eb40b7a86afea0e5b1dcada6268041027b0dfc493b80ca1f66af217d\",\"license\":\"MIT\",\"urls\":[\"bzz-raw://ac6d34517e2dd2c9cd03e16c5333defd003c134a4bff52ad95b673a5e8804609\",\"dweb:/ipfs/QmPSRdswfajCZCchH9j8rC7U3GLJ4w24gK35gxRVY3Qxz4\"]},\"lib/v4-periphery/src/base/SafeCallback.sol\":{\"keccak256\":\"0xd78b583df1b9ee06d58e83b84fc9f08971389b34dd34bc13db072e0c13c710da\",\"license\":\"MIT\",\"urls\":[\"bzz-raw://c0a47f4bcd6060c4462153b9a7c52a60a460ace91acb6ddd5492eab28ec26173\",\"dweb:/ipfs/QmdRCTRS1dhFjWEy6z577j4xz9J5HPfHBwcNzAic8G59oT\"]},\"lib/v4-periphery/src/base/UnorderedNonce.sol\":{\"keccak256\":\"0x0ec175bf2213d75606ebb770227e8622ae9666fbde8ff2d1682d85890b81676e\",\"license\":\"MIT\",\"urls\":[\"bzz-raw://079952902a4be56b5e963585349988fcbea853bf8271a5cb88e7629cafb06bcf\",\"dweb:/ipfs/Qmere81cd2Wq9Vq4rL5G1nW4Jv54YJeMr1oaej7468xrgi\"]},\"lib/v4-periphery/src/interfaces/IEIP712_v4.sol\":{\"keccak256\":\"0xd7f7115476e307a0bfc32a0f0a0f5434e9e5ca62a6c5af1e18b75e48161bb408\",\"license\":\"MIT\",\"urls\":[\"bzz-raw://b1600b953556da38a7adc5ad2a2925ec5fb138fecf8eec48743646543195b736\",\"dweb:/ipfs/QmarZi2aiLVAfHXgnDWV1cCFiZk2DdPW7KJnWHqzuRChJR\"]},\"lib/v4-periphery/src/interfaces/IERC721Permit_v4.sol\":{\"keccak256\":\"0x103adbba724ef536abc536fe8a4d7dc12880724c562109b69f2adce4a91fa017\",\"license\":\"MIT\",\"urls\":[\"bzz-raw://06f51b5a5a218e0bc866a83e7821be53c9db9de0ca921f16abd3d13ea0eab69d\",\"dweb:/ipfs/QmbnhLy992hpQZyphTkj7fpr6jKKVva2AzfmLiDZEuqHAk\"]},\"lib/v4-periphery/src/interfaces/IImmutableState.sol\":{\"keccak256\":\"0x36ab3100e87457ecf04887f4f540e34fd7f21d8e3b83880cb679239e60b7b06b\",\"license\":\"MIT\",\"urls\":[\"bzz-raw://7f290c7ce8e4832608d637a51b13dff95abecf6549485448e647a11c8ed01341\",\"dweb:/ipfs/QmfD1R6mTp8j4EjQXmQZW3vCh11EYFjnvoaw8rXRP27mMq\"]},\"lib/v4-periphery/src/interfaces/IMulticall_v4.sol\":{\"keccak256\":\"0x336bec303f7ff86497d2679464c5adad5040f412b3d0769ce5e1d2a42f7e2c08\",\"license\":\"MIT\",\"urls\":[\"bzz-raw://7734f047d98d331c8abc51ad9f358ceee0a6dcae8d89ac49084b84de0d2d42e7\",\"dweb:/ipfs/QmWij2h7mU36LsXhb9P6pkYXrSCua4ixeWaVFSrsEcEmPQ\"]},\"lib/v4-periphery/src/interfaces/INotifier.sol\":{\"keccak256\":\"0xfdc5187a98240a1691aae98b7dd2444d4c2bfb4746f3c34de9f3d18399c17c5e\",\"license\":\"MIT\",\"urls\":[\"bzz-raw://683af56401ec4f8817e8dfe150e7b3febaf0baaf40efe8d0d0475f735275f746\",\"dweb:/ipfs/QmRQ6S3nFnSc2jjDcQTvUJdTf4xKPojmvCkpvgyr6qTuVV\"]},\"lib/v4-periphery/src/interfaces/IPermit2Forwarder.sol\":{\"keccak256\":\"0xfad472937280e861125ff12aa6f9c2cf7440fbb20a2cc29485c24662ad4279c5\",\"license\":\"MIT\",\"urls\":[\"bzz-raw://31bfbc331f5972fc373d9469fd1ca1d14818db3275f21b7b590f20820cb4439d\",\"dweb:/ipfs/QmX3Bv9wfYpAFZKBcxKsQSXUrSC8mqNBdzh6XVMS72aNx9\"]},\"lib/v4-periphery/src/interfaces/IPoolInitializer_v4.sol\":{\"keccak256\":\"0x2e4feda94650a2642039e0309ffdec480ee050bc40864bf5e1dba42bb4dc9e98\",\"license\":\"MIT\",\"urls\":[\"bzz-raw://964c178b4da8bab9ef898b94bb26d7c17cc44c5cf20485f55dcf5e9c7e1b1d92\",\"dweb:/ipfs/QmVd2c3SYteyr5xZgUS4sDAiZF43dLwVAEKdCfvQbkZpRJ\"]},\"lib/v4-periphery/src/interfaces/IPositionDescriptor.sol\":{\"keccak256\":\"0x5a4327e608b35ba2d3451c267b609336efbd780912080dbb1a21563db25c9768\",\"license\":\"MIT\",\"urls\":[\"bzz-raw://c783c7a4834d610586ef6caf79806f4e339ad488046766d03fe3d014d11093e4\",\"dweb:/ipfs/QmcQWiNQz1hAcJRwFfw5NnSz6zcgAE5HytdVL8MAQJUrv4\"]},\"lib/v4-periphery/src/interfaces/IPositionManager.sol\":{\"keccak256\":\"0x62dfa0cbee8314ee7e6787db8bc1d364245c340f940875ac7ff11e89d074fc7e\",\"license\":\"MIT\",\"urls\":[\"bzz-raw://26f560c77d8a187bf93a710b827e3167eab3446922192fa8f92f208da2103834\",\"dweb:/ipfs/Qmbzp5gSYdTpMBF9aAb2GraxMEQZb5LRJCyg8VaRUyjTFc\"]},\"lib/v4-periphery/src/interfaces/ISubscriber.sol\":{\"keccak256\":\"0x34ceadec4a63019680e543fe73197f198a55c825d86e18f327840354760b57e7\",\"license\":\"MIT\",\"urls\":[\"bzz-raw://31734feafe1fe162a0702ddf862fcc3bd97505931afb3c685033c0185d898051\",\"dweb:/ipfs/QmQEANYVyaXTNzXKcjUVfPhLU71Bix5vxQH75BpPWMkWgw\"]},\"lib/v4-periphery/src/interfaces/IUnorderedNonce.sol\":{\"keccak256\":\"0xd7f32fee74dc7d1a3b078ca1263961baccaa6bf434c79e8fe0e092e30c3e0ec3\",\"license\":\"MIT\",\"urls\":[\"bzz-raw://e7d1e92d89d5f49c84aa82f3b259678c2c97a4473b22d753ca4411a6b0cec36d\",\"dweb:/ipfs/QmNZoQyminStaAdaLqoDLoWaBU5QWrWjXFjmBm4aFhzL8i\"]},\"lib/v4-periphery/src/interfaces/IV4Router.sol\":{\"keccak256\":\"0xc4133fae25e61cc2447d7331729f6035322d7c1fe26b39b225422bf98cc63459\",\"license\":\"MIT\",\"urls\":[\"bzz-raw://3c24ff8428504e973e947a059f96289a66c520cd7f8ef47a3224f9cb6abdaf25\",\"dweb:/ipfs/QmVqxYnngWXXcCiuTC143vTEJrjZK5NXWB92pjvVbuJBQ5\"]},\"lib/v4-periphery/src/interfaces/external/IWETH9.sol\":{\"keccak256\":\"0xe88abf12501ac275619aec0687240a07d26968aecbbcdfea88ba8bbd5d6e5e14\",\"license\":\"MIT\",\"urls\":[\"bzz-raw://7097065d4492b4eccb1a73f99af1e5bec45404c6b973b8f5965c4c91403f5f92\",\"dweb:/ipfs/QmZK8oEqmjmTqhBoh3D3fBpyKGkUEFnptY8xwH9xpNjDm2\"]},\"lib/v4-periphery/src/libraries/ActionConstants.sol\":{\"keccak256\":\"0x3d6f0e5b4a7b1e60bad93e73dce5db67fb66bebef11c31ed8355014a79aa03b3\",\"license\":\"MIT\",\"urls\":[\"bzz-raw://6dfa42e24b1b5c7f66e75304ab034fbb6768518eb2410ccfff8b3defdd1658f2\",\"dweb:/ipfs/QmQQ7fud9mmv7PEWPAQiNzeZhNkWf28Z6nCHc2e6WJFfa7\"]},\"lib/v4-periphery/src/libraries/Actions.sol\":{\"keccak256\":\"0x8efd4b8b289177ee27e557d9d0a5a9f973d66fe1eb1ef8959d316b11987ca830\",\"license\":\"MIT\",\"urls\":[\"bzz-raw://07fe35f194eb99465028f0546359befea574d844da53767d32f22b233c3bcc98\",\"dweb:/ipfs/Qmc19631uFxABTHAbGrDrroexi9GdyxWntaum1v8npPYz5\"]},\"lib/v4-periphery/src/libraries/CalldataDecoder.sol\":{\"keccak256\":\"0x26df49e13fb5410fd4db253cca877dfdfb3a1ba03e394d054c0e0514a88a56e5\",\"license\":\"MIT\",\"urls\":[\"bzz-raw://72a0c98c52171708f332f83d517deeb97fdd50ecf28f2510e1866e54593a6ff8\",\"dweb:/ipfs/QmY4LiDUfSKGj86nML7B6a8euiPciUqwYehasAyAVnMCHq\"]},\"lib/v4-periphery/src/libraries/ERC721PermitHash.sol\":{\"keccak256\":\"0xd8024f516738a1f968169875efd4ba803049c933cf6ea5e36189df9915f4e3f2\",\"license\":\"MIT\",\"urls\":[\"bzz-raw://58b45295f87c31f516a727a2a40ba2f34ac57ebd5520c42ea59946d2ffc0f5df\",\"dweb:/ipfs/QmW8xC2xS18r4yhGbhSJTN1DfCgPT6oKHxwwszutn2sPuz\"]},\"lib/v4-periphery/src/libraries/LiquidityAmounts.sol\":{\"keccak256\":\"0x8ea74b89831877ffe657f8461164a01a6f3c7e46f415410854fca8d28a8cab53\",\"license\":\"MIT\",\"urls\":[\"bzz-raw://f4015f62e5e8aa154baa555dc39ce36b498e6d875a53f793d62b8556e6b97ccb\",\"dweb:/ipfs/QmUVHyEe3hZZZQum5ct6yDY8qduj62Ta7f7x5Kw95LpQbg\"]},\"lib/v4-periphery/src/libraries/Locker.sol\":{\"keccak256\":\"0x5c0859290a277fbfba8579b506426d3fc4b2ff7d8b691c03dd23aa85797fdae1\",\"license\":\"MIT\",\"urls\":[\"bzz-raw://18ad9effea8da74b9988373dddddd6669f11701fc954f77d2cb58beb9a9cc3ad\",\"dweb:/ipfs/QmQdBMoXdVACo6k6rumWj15UPDCqGpWNSPvQbejxKuV9RJ\"]},\"lib/v4-periphery/src/libraries/PathKey.sol\":{\"keccak256\":\"0xbbd79ffefe045f025263e389539021266fb4d371463aefba405e1ff1d3fcf9bc\",\"license\":\"MIT\",\"urls\":[\"bzz-raw://2d1c47b81a01218be46ee79f0a8837095479b94dc5cfd18abbf2006709f0ea89\",\"dweb:/ipfs/QmRb6CQ13Zp7f3WF5jbZtsF2szhxpPgcuWs9mjwQXxzqtg\"]},\"lib/v4-periphery/src/libraries/PositionInfoLibrary.sol\":{\"keccak256\":\"0xc5ddf96bd088bc87ea50a20f907fc932fb28397a42682a301b268a11b7f34078\",\"license\":\"MIT\",\"urls\":[\"bzz-raw://7dfeb4dc747537240f8167243e8066b6f5f08057386fb8bda93f82973fc18ad6\",\"dweb:/ipfs/Qmby9DAAaHj8hjsMUnqY3vjqCHKGAKrT5EULMmeGcjbbGx\"]},\"lib/v4-periphery/src/libraries/SlippageCheck.sol\":{\"keccak256\":\"0x9b7872e403b417dfbcf9835b16109f80f7abed702652a9817e28f07189983b4b\",\"license\":\"MIT\",\"urls\":[\"bzz-raw://911974b8e37b3be02150090b64d841fcc1153277d20f75315b3b8eb02c111e66\",\"dweb:/ipfs/QmRYe4UAYG5TNqB2ygM3n7e3GFMhJmW1c29WZjGDfGQyxQ\"]},\"lib/v4-periphery/src/utils/BaseHook.sol\":{\"keccak256\":\"0x6b718be2a15f6dbcd9845cc2ca2a0c97aaae35bfe0d463f9168811df0b558a71\",\"license\":\"MIT\",\"urls\":[\"bzz-raw://66fec478fe91bf9ee98bd2f138fb46441ec3f9a899db416b104f23e1135da1bb\",\"dweb:/ipfs/QmZZ2KkasnVTJkosXfYJUCytwXQJ4eBhiy1gqEJVrccTYf\"]},\"src/SuperDCAGauge.sol\":{\"keccak256\":\"0x60c8b1c526d356d4ba9bc1f199b146b0602c5ff48248d5b497849741b1cbdce5\",\"license\":\"Apache-2.0\",\"urls\":[\"bzz-raw://369542322aa3353ca969d1f742ec77f8b854f3888d77b0ef01ca54ed7d7e5326\",\"dweb:/ipfs/QmXtJ4ptEY6BvVj42UisTaFv8FvSPdLShnPnVQpvUyZ1qw\"]},\"src/SuperDCAListing.sol\":{\"keccak256\":\"0x75ef535b19abb0e8a61621f44b65c110b37f47230a3e0f889163a89ad1c90951\",\"license\":\"Apache-2.0\",\"urls\":[\"bzz-raw://cc99ec4814658a84180c7a2a064b1ff9b5ff7d5a4941803f96ab917ba94ff841\",\"dweb:/ipfs/QmWz1MMGtr1XkJT4CPPdGT1grBFv8oGhdCNH3KEJ1xSneY\"]},\"src/SuperDCAStaking.sol\":{\"keccak256\":\"0x7c1f6c16a46c40a34d524b809bf3ce9cb8fd1ccfb423cb9269641450eecd264f\",\"license\":\"Apache-2.0\",\"urls\":[\"bzz-raw://033fb0c113c411e950d4aefe863d8c3eee70a23c33f4ba798c20e3db5aa85ddc\",\"dweb:/ipfs/Qmf179a3gxayYDv9uDeZ4c8ioJZ1CYzY4cKDpUZi2xNXN1\"]},\"src/interfaces/IMsgSender.sol\":{\"keccak256\":\"0xd17788a5776c00d8f77a294f79bf1e346a17568aeac8f1f84763c3b585879242\",\"license\":\"Apache-2.0\",\"urls\":[\"bzz-raw://78977b4752c5d42ee977cb8de2cf87606954e03413902ff66ee8515c31388d20\",\"dweb:/ipfs/QmSKN9xDa9GP2emrE82NWdbs7TuD7S1hBp4ga14C2W86VJ\"]},\"src/interfaces/ISuperDCAGauge.sol\":{\"keccak256\":\"0x09ad89a30eda870fc2dd11e01c57c87d346335496919789b9cc0345e7edcc4eb\",\"license\":\"Apache-2.0\",\"urls\":[\"bzz-raw://f12731abdbd913ffc2f5a3dc14aff15740f54228f910785fcb45e46a193d9b9c\",\"dweb:/ipfs/QmXcWZDEY9jAmUEmUXPLXWNKRHLLLjsKQXLj8YsAFjSHjT\"]},\"src/interfaces/ISuperDCAListing.sol\":{\"keccak256\":\"0x5f746b709508c5b348b87a0c2af55bbe443a6749f2ba7d2093a071c5d27d7414\",\"license\":\"Apache-2.0\",\"urls\":[\"bzz-raw://e4fd9705efba6553e1cb06083837048f457f401c6d11d7618c5c7fc3020400cf\",\"dweb:/ipfs/QmRPU4Y7xCmky2Hoptuv4uYnp4S7PyvWT4otfE3rCqhAUv\"]},\"src/interfaces/ISuperDCAStaking.sol\":{\"keccak256\":\"0xf2dc6fcab246e5842f1af978d170020d7173a0c68c0bc52f288834e28795484c\",\"license\":\"Apache-2.0\",\"urls\":[\"bzz-raw://25e003d9b4a740cbe4e7cfc3f6d4990e6e178e2c9ec1ef84351e3b9d0c5cb5be\",\"dweb:/ipfs/QmZNbsxwcH4xLVRaQzZ7WS8jHJ1tU2PQL9wzaFZTdrrpEH\"]},\"src/interfaces/ISuperchainERC20.sol\":{\"keccak256\":\"0xe2d4f0b3d0d9af76641c3b745d7d5db8d272a89fb5e39966592014f1a059aabe\",\"license\":\"MIT\",\"urls\":[\"bzz-raw://a8f0f3eb8491d6f7b5dfdeb6b590d5570ace8d2723f5eddc8d1edd72f895c516\",\"dweb:/ipfs/QmbbuPDVCtJaWiMnuxPEqPoiyMUgczariXYE4Bskfv7Vry\"]},\"test/AuditTest/MaliciousUserCanObtainSoloRewards.t.sol\":{\"keccak256\":\"0x9eb24b7207a33bde7a2b138cf2c285dcda5267d7fb56e3ddb33519cf220560df\",\"license\":\"Apache-2.0\",\"urls\":[\"bzz-raw://76435d1dcf4b2f11c9b09de489e3f14ad3e860bd09e8b342e65fb82f916b04e4\",\"dweb:/ipfs/QmZEczpV9tifx4ZoK9ApkeW1yQnzfVXcEyMGxTJAHrseCx\"]},\"test/mocks/FeesCollectionMock.sol\":{\"keccak256\":\"0xa354eed982dff295d6a0d01b46825f7d86c5b8390fdd59e6269c6c833ddc1278\",\"license\":\"MIT\",\"urls\":[\"bzz-raw://aff4a2f27659e1ada99a6839f82f58e5f09798bd36da526c1af5d9aa4eed7673\",\"dweb:/ipfs/QmV1hu96Hv7woe8pe8AqiwLnH2ddEBUHpsuZxKgPtqktnU\"]},\"test/mocks/MockERC20Token.sol\":{\"keccak256\":\"0x1ad99b1edcd949f3f1cdae66309fcecb64977b29a4803867b0ade41eb04afbb7\",\"license\":\"MIT\",\"urls\":[\"bzz-raw://d02ca07376e242c0fa172dc20b2eb5ffa699934cf7c7dba965dc5ff3d8a24b21\",\"dweb:/ipfs/QmdqoVUsnwDXGKqaNDvdcrr2Kp1FwqUuUt71PFuEvCGxp5\"]}},\"version\":1}","userdoc":{},"devdoc":{},"storageLayout":{"storage":[{"astId":61,"contract":"test/AuditTest/MaliciousUserCanObtainSoloRewards.t.sol:MaliciousUserCanObtainSoloRewards","label":"stdstore","offset":0,"slot":"0","type":"t_struct(StdStorage)8017_storage"},{"astId":218,"contract":"test/AuditTest/MaliciousUserCanObtainSoloRewards.t.sol:MaliciousUserCanObtainSoloRewards","label":"_failed","offset":0,"slot":"8","type":"t_bool"},{"astId":2719,"contract":"test/AuditTest/MaliciousUserCanObtainSoloRewards.t.sol:MaliciousUserCanObtainSoloRewards","label":"stdChainsInitialized","offset":1,"slot":"8","type":"t_bool"},{"astId":2740,"contract":"test/AuditTest/MaliciousUserCanObtainSoloRewards.t.sol:MaliciousUserCanObtainSoloRewards","label":"chains","offset":0,"slot":"9","type":"t_mapping(t_string_memory_ptr,t_struct(Chain)2735_storage)"},{"astId":2744,"contract":"test/AuditTest/MaliciousUserCanObtainSoloRewards.t.sol:MaliciousUserCanObtainSoloRewards","label":"defaultRpcUrls","offset":0,"slot":"10","type":"t_mapping(t_string_memory_ptr,t_string_storage)"},{"astId":2748,"contract":"test/AuditTest/MaliciousUserCanObtainSoloRewards.t.sol:MaliciousUserCanObtainSoloRewards","label":"idToAlias","offset":0,"slot":"11","type":"t_mapping(t_uint256,t_string_storage)"},{"astId":2751,"contract":"test/AuditTest/MaliciousUserCanObtainSoloRewards.t.sol:MaliciousUserCanObtainSoloRewards","label":"fallbackToDefaultRpcUrls","offset":0,"slot":"12","type":"t_bool"},{"astId":3680,"contract":"test/AuditTest/MaliciousUserCanObtainSoloRewards.t.sol:MaliciousUserCanObtainSoloRewards","label":"gasMeteringOff","offset":1,"slot":"12","type":"t_bool"},{"astId":5747,"contract":"test/AuditTest/MaliciousUserCanObtainSoloRewards.t.sol:MaliciousUserCanObtainSoloRewards","label":"stdstore","offset":0,"slot":"13","type":"t_struct(StdStorage)8017_storage"},{"astId":6623,"contract":"test/AuditTest/MaliciousUserCanObtainSoloRewards.t.sol:MaliciousUserCanObtainSoloRewards","label":"_excludedContracts","offset":0,"slot":"21","type":"t_array(t_address)dyn_storage"},{"astId":6626,"contract":"test/AuditTest/MaliciousUserCanObtainSoloRewards.t.sol:MaliciousUserCanObtainSoloRewards","label":"_excludedSenders","offset":0,"slot":"22","type":"t_array(t_address)dyn_storage"},{"astId":6629,"contract":"test/AuditTest/MaliciousUserCanObtainSoloRewards.t.sol:MaliciousUserCanObtainSoloRewards","label":"_targetedContracts","offset":0,"slot":"23","type":"t_array(t_address)dyn_storage"},{"astId":6632,"contract":"test/AuditTest/MaliciousUserCanObtainSoloRewards.t.sol:MaliciousUserCanObtainSoloRewards","label":"_targetedSenders","offset":0,"slot":"24","type":"t_array(t_address)dyn_storage"},{"astId":6635,"contract":"test/AuditTest/MaliciousUserCanObtainSoloRewards.t.sol:MaliciousUserCanObtainSoloRewards","label":"_excludedArtifacts","offset":0,"slot":"25","type":"t_array(t_string_storage)dyn_storage"},{"astId":6638,"contract":"test/AuditTest/MaliciousUserCanObtainSoloRewards.t.sol:MaliciousUserCanObtainSoloRewards","label":"_targetedArtifacts","offset":0,"slot":"26","type":"t_array(t_string_storage)dyn_storage"},{"astId":6642,"contract":"test/AuditTest/MaliciousUserCanObtainSoloRewards.t.sol:MaliciousUserCanObtainSoloRewards","label":"_targetedArtifactSelectors","offset":0,"slot":"27","type":"t_array(t_struct(FuzzArtifactSelector)6614_storage)dyn_storage"},{"astId":6646,"contract":"test/AuditTest/MaliciousUserCanObtainSoloRewards.t.sol:MaliciousUserCanObtainSoloRewards","label":"_excludedSelectors","offset":0,"slot":"28","type":"t_array(t_struct(FuzzSelector)6608_storage)dyn_storage"},{"astId":6650,"contract":"test/AuditTest/MaliciousUserCanObtainSoloRewards.t.sol:MaliciousUserCanObtainSoloRewards","label":"_targetedSelectors","offset":0,"slot":"29","type":"t_array(t_struct(FuzzSelector)6608_storage)dyn_storage"},{"astId":6654,"contract":"test/AuditTest/MaliciousUserCanObtainSoloRewards.t.sol:MaliciousUserCanObtainSoloRewards","label":"_targetedInterfaces","offset":0,"slot":"30","type":"t_array(t_struct(FuzzInterface)6620_storage)dyn_storage"},{"astId":12907,"contract":"test/AuditTest/MaliciousUserCanObtainSoloRewards.t.sol:MaliciousUserCanObtainSoloRewards","label":"IS_TEST","offset":0,"slot":"31","type":"t_bool"},{"astId":60906,"contract":"test/AuditTest/MaliciousUserCanObtainSoloRewards.t.sol:MaliciousUserCanObtainSoloRewards","label":"LIQUIDITY_PARAMS","offset":0,"slot":"32","type":"t_struct(ModifyLiquidityParams)48993_storage"},{"astId":60918,"contract":"test/AuditTest/MaliciousUserCanObtainSoloRewards.t.sol:MaliciousUserCanObtainSoloRewards","label":"REMOVE_LIQUIDITY_PARAMS","offset":0,"slot":"35","type":"t_struct(ModifyLiquidityParams)48993_storage"},{"astId":60928,"contract":"test/AuditTest/MaliciousUserCanObtainSoloRewards.t.sol:MaliciousUserCanObtainSoloRewards","label":"SWAP_PARAMS","offset":0,"slot":"38","type":"t_struct(SwapParams)49021_storage"},{"astId":60931,"contract":"test/AuditTest/MaliciousUserCanObtainSoloRewards.t.sol:MaliciousUserCanObtainSoloRewards","label":"currency0","offset":0,"slot":"41","type":"t_userDefinedValueType(Currency)60107"},{"astId":60934,"contract":"test/AuditTest/MaliciousUserCanObtainSoloRewards.t.sol:MaliciousUserCanObtainSoloRewards","label":"currency1","offset":0,"slot":"42","type":"t_userDefinedValueType(Currency)60107"},{"astId":60937,"contract":"test/AuditTest/MaliciousUserCanObtainSoloRewards.t.sol:MaliciousUserCanObtainSoloRewards","label":"manager","offset":0,"slot":"43","type":"t_contract(IPoolManager)49123"},{"astId":60940,"contract":"test/AuditTest/MaliciousUserCanObtainSoloRewards.t.sol:MaliciousUserCanObtainSoloRewards","label":"modifyLiquidityRouter","offset":0,"slot":"44","type":"t_contract(PoolModifyLiquidityTest)57392"},{"astId":60943,"contract":"test/AuditTest/MaliciousUserCanObtainSoloRewards.t.sol:MaliciousUserCanObtainSoloRewards","label":"modifyLiquidityNoChecks","offset":0,"slot":"45","type":"t_contract(PoolModifyLiquidityTestNoChecks)57690"},{"astId":60946,"contract":"test/AuditTest/MaliciousUserCanObtainSoloRewards.t.sol:MaliciousUserCanObtainSoloRewards","label":"swapRouterNoChecks","offset":0,"slot":"46","type":"t_contract(SwapRouterNoChecks)59887"},{"astId":60949,"contract":"test/AuditTest/MaliciousUserCanObtainSoloRewards.t.sol:MaliciousUserCanObtainSoloRewards","label":"swapRouter","offset":0,"slot":"47","type":"t_contract(PoolSwapTest)59366"},{"astId":60952,"contract":"test/AuditTest/MaliciousUserCanObtainSoloRewards.t.sol:MaliciousUserCanObtainSoloRewards","label":"donateRouter","offset":0,"slot":"48","type":"t_contract(PoolDonateTest)56951"},{"astId":60955,"contract":"test/AuditTest/MaliciousUserCanObtainSoloRewards.t.sol:MaliciousUserCanObtainSoloRewards","label":"takeRouter","offset":0,"slot":"49","type":"t_contract(PoolTakeTest)59593"},{"astId":60958,"contract":"test/AuditTest/MaliciousUserCanObtainSoloRewards.t.sol:MaliciousUserCanObtainSoloRewards","label":"actionsRouter","offset":0,"slot":"50","type":"t_contract(ActionsRouter)56418"},{"astId":60961,"contract":"test/AuditTest/MaliciousUserCanObtainSoloRewards.t.sol:MaliciousUserCanObtainSoloRewards","label":"claimsRouter","offset":0,"slot":"51","type":"t_contract(PoolClaimsTest)56610"},{"astId":60964,"contract":"test/AuditTest/MaliciousUserCanObtainSoloRewards.t.sol:MaliciousUserCanObtainSoloRewards","label":"nestedActionRouter","offset":0,"slot":"52","type":"t_contract(PoolNestedActionsTest)57873"},{"astId":60966,"contract":"test/AuditTest/MaliciousUserCanObtainSoloRewards.t.sol:MaliciousUserCanObtainSoloRewards","label":"feeController","offset":0,"slot":"53","type":"t_address"},{"astId":60969,"contract":"test/AuditTest/MaliciousUserCanObtainSoloRewards.t.sol:MaliciousUserCanObtainSoloRewards","label":"key","offset":0,"slot":"54","type":"t_struct(PoolKey)60453_storage"},{"astId":60972,"contract":"test/AuditTest/MaliciousUserCanObtainSoloRewards.t.sol:MaliciousUserCanObtainSoloRewards","label":"nativeKey","offset":0,"slot":"57","type":"t_struct(PoolKey)60453_storage"},{"astId":60975,"contract":"test/AuditTest/MaliciousUserCanObtainSoloRewards.t.sol:MaliciousUserCanObtainSoloRewards","label":"uninitializedKey","offset":0,"slot":"60","type":"t_struct(PoolKey)60453_storage"},{"astId":60978,"contract":"test/AuditTest/MaliciousUserCanObtainSoloRewards.t.sol:MaliciousUserCanObtainSoloRewards","label":"uninitializedNativeKey","offset":0,"slot":"63","type":"t_struct(PoolKey)60453_storage"},{"astId":60981,"contract":"test/AuditTest/MaliciousUserCanObtainSoloRewards.t.sol:MaliciousUserCanObtainSoloRewards","label":"hookPermissionCount","offset":0,"slot":"66","type":"t_uint160"},{"astId":60991,"contract":"test/AuditTest/MaliciousUserCanObtainSoloRewards.t.sol:MaliciousUserCanObtainSoloRewards","label":"clearAllHookPermissionsMask","offset":0,"slot":"67","type":"t_uint160"},{"astId":70434,"contract":"test/AuditTest/MaliciousUserCanObtainSoloRewards.t.sol:MaliciousUserCanObtainSoloRewards","label":"hook","offset":0,"slot":"68","type":"t_contract(SuperDCAGauge)68777"},{"astId":70437,"contract":"test/AuditTest/MaliciousUserCanObtainSoloRewards.t.sol:MaliciousUserCanObtainSoloRewards","label":"staking","offset":0,"slot":"69","type":"t_contract(SuperDCAStaking)70184"},{"astId":70440,"contract":"test/AuditTest/MaliciousUserCanObtainSoloRewards.t.sol:MaliciousUserCanObtainSoloRewards","label":"listing","offset":0,"slot":"70","type":"t_contract(SuperDCAListing)69515"},{"astId":70443,"contract":"test/AuditTest/MaliciousUserCanObtainSoloRewards.t.sol:MaliciousUserCanObtainSoloRewards","label":"dcaToken","offset":0,"slot":"71","type":"t_contract(MockERC20Token)71135"},{"astId":70446,"contract":"test/AuditTest/MaliciousUserCanObtainSoloRewards.t.sol:MaliciousUserCanObtainSoloRewards","label":"poolId","offset":0,"slot":"72","type":"t_userDefinedValueType(PoolId)60407"},{"astId":70451,"contract":"test/AuditTest/MaliciousUserCanObtainSoloRewards.t.sol:MaliciousUserCanObtainSoloRewards","label":"developer","offset":0,"slot":"73","type":"t_address"},{"astId":70457,"contract":"test/AuditTest/MaliciousUserCanObtainSoloRewards.t.sol:MaliciousUserCanObtainSoloRewards","label":"positionManager","offset":0,"slot":"74","type":"t_contract(IPositionManager)66026"},{"astId":70460,"contract":"test/AuditTest/MaliciousUserCanObtainSoloRewards.t.sol:MaliciousUserCanObtainSoloRewards","label":"poolManager","offset":0,"slot":"75","type":"t_address"},{"astId":70475,"contract":"test/AuditTest/MaliciousUserCanObtainSoloRewards.t.sol:MaliciousUserCanObtainSoloRewards","label":"tokenDescriptor","offset":0,"slot":"76","type":"t_contract(IPositionDescriptor)65921"},{"astId":70478,"contract":"test/AuditTest/MaliciousUserCanObtainSoloRewards.t.sol:MaliciousUserCanObtainSoloRewards","label":"posM","offset":0,"slot":"77","type":"t_contract(PositionManager)63890"}],"types":{"t_address":{"encoding":"inplace","label":"address","numberOfBytes":"20"},"t_array(t_address)dyn_storage":{"encoding":"dynamic_array","label":"address[]","numberOfBytes":"32","base":"t_address"},"t_array(t_bytes32)dyn_storage":{"encoding":"dynamic_array","label":"bytes32[]","numberOfBytes":"32","base":"t_bytes32"},"t_array(t_bytes4)dyn_storage":{"encoding":"dynamic_array","label":"bytes4[]","numberOfBytes":"32","base":"t_bytes4"},"t_array(t_string_storage)dyn_storage":{"encoding":"dynamic_array","label":"string[]","numberOfBytes":"32","base":"t_string_storage"},"t_array(t_struct(FuzzArtifactSelector)6614_storage)dyn_storage":{"encoding":"dynamic_array","label":"struct StdInvariant.FuzzArtifactSelector[]","numberOfBytes":"32","base":"t_struct(FuzzArtifactSelector)6614_storage"},"t_array(t_struct(FuzzInterface)6620_storage)dyn_storage":{"encoding":"dynamic_array","label":"struct StdInvariant.FuzzInterface[]","numberOfBytes":"32","base":"t_struct(FuzzInterface)6620_storage"},"t_array(t_struct(FuzzSelector)6608_storage)dyn_storage":{"encoding":"dynamic_array","label":"struct StdInvariant.FuzzSelector[]","numberOfBytes":"32","base":"t_struct(FuzzSelector)6608_storage"},"t_bool":{"encoding":"inplace","label":"bool","numberOfBytes":"1"},"t_bytes32":{"encoding":"inplace","label":"bytes32","numberOfBytes":"32"},"t_bytes4":{"encoding":"inplace","label":"bytes4","numberOfBytes":"4"},"t_bytes_storage":{"encoding":"bytes","label":"bytes","numberOfBytes":"32"},"t_contract(ActionsRouter)56418":{"encoding":"inplace","label":"contract ActionsRouter","numberOfBytes":"20"},"t_contract(IHooks)48824":{"encoding":"inplace","label":"contract IHooks","numberOfBytes":"20"},"t_contract(IPoolManager)49123":{"encoding":"inplace","label":"contract IPoolManager","numberOfBytes":"20"},"t_contract(IPositionDescriptor)65921":{"encoding":"inplace","label":"contract IPositionDescriptor","numberOfBytes":"20"},"t_contract(IPositionManager)66026":{"encoding":"inplace","label":"contract IPositionManager","numberOfBytes":"20"},"t_contract(MockERC20Token)71135":{"encoding":"inplace","label":"contract MockERC20Token","numberOfBytes":"20"},"t_contract(PoolClaimsTest)56610":{"encoding":"inplace","label":"contract PoolClaimsTest","numberOfBytes":"20"},"t_contract(PoolDonateTest)56951":{"encoding":"inplace","label":"contract PoolDonateTest","numberOfBytes":"20"},"t_contract(PoolModifyLiquidityTest)57392":{"encoding":"inplace","label":"contract PoolModifyLiquidityTest","numberOfBytes":"20"},"t_contract(PoolModifyLiquidityTestNoChecks)57690":{"encoding":"inplace","label":"contract PoolModifyLiquidityTestNoChecks","numberOfBytes":"20"},"t_contract(PoolNestedActionsTest)57873":{"encoding":"inplace","label":"contract PoolNestedActionsTest","numberOfBytes":"20"},"t_contract(PoolSwapTest)59366":{"encoding":"inplace","label":"contract PoolSwapTest","numberOfBytes":"20"},"t_contract(PoolTakeTest)59593":{"encoding":"inplace","label":"contract PoolTakeTest","numberOfBytes":"20"},"t_contract(PositionManager)63890":{"encoding":"inplace","label":"contract PositionManager","numberOfBytes":"20"},"t_contract(SuperDCAGauge)68777":{"encoding":"inplace","label":"contract SuperDCAGauge","numberOfBytes":"20"},"t_contract(SuperDCAListing)69515":{"encoding":"inplace","label":"contract SuperDCAListing","numberOfBytes":"20"},"t_contract(SuperDCAStaking)70184":{"encoding":"inplace","label":"contract SuperDCAStaking","numberOfBytes":"20"},"t_contract(SwapRouterNoChecks)59887":{"encoding":"inplace","label":"contract SwapRouterNoChecks","numberOfBytes":"20"},"t_int24":{"encoding":"inplace","label":"int24","numberOfBytes":"3"},"t_int256":{"encoding":"inplace","label":"int256","numberOfBytes":"32"},"t_mapping(t_address,t_mapping(t_bytes4,t_mapping(t_bytes32,t_struct(FindData)7992_storage)))":{"encoding":"mapping","key":"t_address","label":"mapping(address => mapping(bytes4 => mapping(bytes32 => struct FindData)))","numberOfBytes":"32","value":"t_mapping(t_bytes4,t_mapping(t_bytes32,t_struct(FindData)7992_storage))"},"t_mapping(t_bytes32,t_struct(FindData)7992_storage)":{"encoding":"mapping","key":"t_bytes32","label":"mapping(bytes32 => struct FindData)","numberOfBytes":"32","value":"t_struct(FindData)7992_storage"},"t_mapping(t_bytes4,t_mapping(t_bytes32,t_struct(FindData)7992_storage))":{"encoding":"mapping","key":"t_bytes4","label":"mapping(bytes4 => mapping(bytes32 => struct FindData))","numberOfBytes":"32","value":"t_mapping(t_bytes32,t_struct(FindData)7992_storage)"},"t_mapping(t_string_memory_ptr,t_string_storage)":{"encoding":"mapping","key":"t_string_memory_ptr","label":"mapping(string => string)","numberOfBytes":"32","value":"t_string_storage"},"t_mapping(t_string_memory_ptr,t_struct(Chain)2735_storage)":{"encoding":"mapping","key":"t_string_memory_ptr","label":"mapping(string => struct StdChains.Chain)","numberOfBytes":"32","value":"t_struct(Chain)2735_storage"},"t_mapping(t_uint256,t_string_storage)":{"encoding":"mapping","key":"t_uint256","label":"mapping(uint256 => string)","numberOfBytes":"32","value":"t_string_storage"},"t_string_memory_ptr":{"encoding":"bytes","label":"string","numberOfBytes":"32"},"t_string_storage":{"encoding":"bytes","label":"string","numberOfBytes":"32"},"t_struct(Chain)2735_storage":{"encoding":"inplace","label":"struct StdChains.Chain","numberOfBytes":"128","members":[{"astId":2728,"contract":"test/AuditTest/MaliciousUserCanObtainSoloRewards.t.sol:MaliciousUserCanObtainSoloRewards","label":"name","offset":0,"slot":"0","type":"t_string_storage"},{"astId":2730,"contract":"test/AuditTest/MaliciousUserCanObtainSoloRewards.t.sol:MaliciousUserCanObtainSoloRewards","label":"chainId","offset":0,"slot":"1","type":"t_uint256"},{"astId":2732,"contract":"test/AuditTest/MaliciousUserCanObtainSoloRewards.t.sol:MaliciousUserCanObtainSoloRewards","label":"chainAlias","offset":0,"slot":"2","type":"t_string_storage"},{"astId":2734,"contract":"test/AuditTest/MaliciousUserCanObtainSoloRewards.t.sol:MaliciousUserCanObtainSoloRewards","label":"rpcUrl","offset":0,"slot":"3","type":"t_string_storage"}]},"t_struct(FindData)7992_storage":{"encoding":"inplace","label":"struct FindData","numberOfBytes":"128","members":[{"astId":7985,"contract":"test/AuditTest/MaliciousUserCanObtainSoloRewards.t.sol:MaliciousUserCanObtainSoloRewards","label":"slot","offset":0,"slot":"0","type":"t_uint256"},{"astId":7987,"contract":"test/AuditTest/MaliciousUserCanObtainSoloRewards.t.sol:MaliciousUserCanObtainSoloRewards","label":"offsetLeft","offset":0,"slot":"1","type":"t_uint256"},{"astId":7989,"contract":"test/AuditTest/MaliciousUserCanObtainSoloRewards.t.sol:MaliciousUserCanObtainSoloRewards","label":"offsetRight","offset":0,"slot":"2","type":"t_uint256"},{"astId":7991,"contract":"test/AuditTest/MaliciousUserCanObtainSoloRewards.t.sol:MaliciousUserCanObtainSoloRewards","label":"found","offset":0,"slot":"3","type":"t_bool"}]},"t_struct(FuzzArtifactSelector)6614_storage":{"encoding":"inplace","label":"struct StdInvariant.FuzzArtifactSelector","numberOfBytes":"64","members":[{"astId":6610,"contract":"test/AuditTest/MaliciousUserCanObtainSoloRewards.t.sol:MaliciousUserCanObtainSoloRewards","label":"artifact","offset":0,"slot":"0","type":"t_string_storage"},{"astId":6613,"contract":"test/AuditTest/MaliciousUserCanObtainSoloRewards.t.sol:MaliciousUserCanObtainSoloRewards","label":"selectors","offset":0,"slot":"1","type":"t_array(t_bytes4)dyn_storage"}]},"t_struct(FuzzInterface)6620_storage":{"encoding":"inplace","label":"struct StdInvariant.FuzzInterface","numberOfBytes":"64","members":[{"astId":6616,"contract":"test/AuditTest/MaliciousUserCanObtainSoloRewards.t.sol:MaliciousUserCanObtainSoloRewards","label":"addr","offset":0,"slot":"0","type":"t_address"},{"astId":6619,"contract":"test/AuditTest/MaliciousUserCanObtainSoloRewards.t.sol:MaliciousUserCanObtainSoloRewards","label":"artifacts","offset":0,"slot":"1","type":"t_array(t_string_storage)dyn_storage"}]},"t_struct(FuzzSelector)6608_storage":{"encoding":"inplace","label":"struct StdInvariant.FuzzSelector","numberOfBytes":"64","members":[{"astId":6604,"contract":"test/AuditTest/MaliciousUserCanObtainSoloRewards.t.sol:MaliciousUserCanObtainSoloRewards","label":"addr","offset":0,"slot":"0","type":"t_address"},{"astId":6607,"contract":"test/AuditTest/MaliciousUserCanObtainSoloRewards.t.sol:MaliciousUserCanObtainSoloRewards","label":"selectors","offset":0,"slot":"1","type":"t_array(t_bytes4)dyn_storage"}]},"t_struct(ModifyLiquidityParams)48993_storage":{"encoding":"inplace","label":"struct IPoolManager.ModifyLiquidityParams","numberOfBytes":"96","members":[{"astId":48986,"contract":"test/AuditTest/MaliciousUserCanObtainSoloRewards.t.sol:MaliciousUserCanObtainSoloRewards","label":"tickLower","offset":0,"slot":"0","type":"t_int24"},{"astId":48988,"contract":"test/AuditTest/MaliciousUserCanObtainSoloRewards.t.sol:MaliciousUserCanObtainSoloRewards","label":"tickUpper","offset":3,"slot":"0","type":"t_int24"},{"astId":48990,"contract":"test/AuditTest/MaliciousUserCanObtainSoloRewards.t.sol:MaliciousUserCanObtainSoloRewards","label":"liquidityDelta","offset":0,"slot":"1","type":"t_int256"},{"astId":48992,"contract":"test/AuditTest/MaliciousUserCanObtainSoloRewards.t.sol:MaliciousUserCanObtainSoloRewards","label":"salt","offset":0,"slot":"2","type":"t_bytes32"}]},"t_struct(PoolKey)60453_storage":{"encoding":"inplace","label":"struct PoolKey","numberOfBytes":"96","members":[{"astId":60438,"contract":"test/AuditTest/MaliciousUserCanObtainSoloRewards.t.sol:MaliciousUserCanObtainSoloRewards","label":"currency0","offset":0,"slot":"0","type":"t_userDefinedValueType(Currency)60107"},{"astId":60442,"contract":"test/AuditTest/MaliciousUserCanObtainSoloRewards.t.sol:MaliciousUserCanObtainSoloRewards","label":"currency1","offset":0,"slot":"1","type":"t_userDefinedValueType(Currency)60107"},{"astId":60445,"contract":"test/AuditTest/MaliciousUserCanObtainSoloRewards.t.sol:MaliciousUserCanObtainSoloRewards","label":"fee","offset":20,"slot":"1","type":"t_uint24"},{"astId":60448,"contract":"test/AuditTest/MaliciousUserCanObtainSoloRewards.t.sol:MaliciousUserCanObtainSoloRewards","label":"tickSpacing","offset":23,"slot":"1","type":"t_int24"},{"astId":60452,"contract":"test/AuditTest/MaliciousUserCanObtainSoloRewards.t.sol:MaliciousUserCanObtainSoloRewards","label":"hooks","offset":0,"slot":"2","type":"t_contract(IHooks)48824"}]},"t_struct(StdStorage)8017_storage":{"encoding":"inplace","label":"struct StdStorage","numberOfBytes":"256","members":[{"astId":8001,"contract":"test/AuditTest/MaliciousUserCanObtainSoloRewards.t.sol:MaliciousUserCanObtainSoloRewards","label":"finds","offset":0,"slot":"0","type":"t_mapping(t_address,t_mapping(t_bytes4,t_mapping(t_bytes32,t_struct(FindData)7992_storage)))"},{"astId":8004,"contract":"test/AuditTest/MaliciousUserCanObtainSoloRewards.t.sol:MaliciousUserCanObtainSoloRewards","label":"_keys","offset":0,"slot":"1","type":"t_array(t_bytes32)dyn_storage"},{"astId":8006,"contract":"test/AuditTest/MaliciousUserCanObtainSoloRewards.t.sol:MaliciousUserCanObtainSoloRewards","label":"_sig","offset":0,"slot":"2","type":"t_bytes4"},{"astId":8008,"contract":"test/AuditTest/MaliciousUserCanObtainSoloRewards.t.sol:MaliciousUserCanObtainSoloRewards","label":"_depth","offset":0,"slot":"3","type":"t_uint256"},{"astId":8010,"contract":"test/AuditTest/MaliciousUserCanObtainSoloRewards.t.sol:MaliciousUserCanObtainSoloRewards","label":"_target","offset":0,"slot":"4","type":"t_address"},{"astId":8012,"contract":"test/AuditTest/MaliciousUserCanObtainSoloRewards.t.sol:MaliciousUserCanObtainSoloRewards","label":"_set","offset":0,"slot":"5","type":"t_bytes32"},{"astId":8014,"contract":"test/AuditTest/MaliciousUserCanObtainSoloRewards.t.sol:MaliciousUserCanObtainSoloRewards","label":"_enable_packed_slots","offset":0,"slot":"6","type":"t_bool"},{"astId":8016,"contract":"test/AuditTest/MaliciousUserCanObtainSoloRewards.t.sol:MaliciousUserCanObtainSoloRewards","label":"_calldata","offset":0,"slot":"7","type":"t_bytes_storage"}]},"t_struct(SwapParams)49021_storage":{"encoding":"inplace","label":"struct IPoolManager.SwapParams","numberOfBytes":"96","members":[{"astId":49014,"contract":"test/AuditTest/MaliciousUserCanObtainSoloRewards.t.sol:MaliciousUserCanObtainSoloRewards","label":"zeroForOne","offset":0,"slot":"0","type":"t_bool"},{"astId":49017,"contract":"test/AuditTest/MaliciousUserCanObtainSoloRewards.t.sol:MaliciousUserCanObtainSoloRewards","label":"amountSpecified","offset":0,"slot":"1","type":"t_int256"},{"astId":49020,"contract":"test/AuditTest/MaliciousUserCanObtainSoloRewards.t.sol:MaliciousUserCanObtainSoloRewards","label":"sqrtPriceLimitX96","offset":0,"slot":"2","type":"t_uint160"}]},"t_uint160":{"encoding":"inplace","label":"uint160","numberOfBytes":"20"},"t_uint24":{"encoding":"inplace","label":"uint24","numberOfBytes":"3"},"t_uint256":{"encoding":"inplace","label":"uint256","numberOfBytes":"32"},"t_userDefinedValueType(Currency)60107":{"encoding":"inplace","label":"Currency","numberOfBytes":"20"},"t_userDefinedValueType(PoolId)60407":{"encoding":"inplace","label":"PoolId","numberOfBytes":"32"}}},"evm":{"bytecode":{"object":"60806040526001600c5f6101000a81548160ff0219169083151502179055506001601f5f6101000a81548160ff02191690831515021790555060405180608001604052807fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff8860020b8152602001607860020b8152602001670de0b6b3a764000081526020015f801b81525060205f820151815f015f6101000a81548162ffffff021916908360020b62ffffff1602179055506020820151815f0160036101000a81548162ffffff021916908360020b62ffffff1602179055506040820151816001015560608201518160020155505060405180608001604052807fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff8860020b8152602001607860020b81526020017ffffffffffffffffffffffffffffffffffffffffffffffffff21f494c589c000081526020015f801b81525060235f820151815f015f6101000a81548162ffffff021916908360020b62ffffff1602179055506020820151815f0160036101000a81548162ffffff021916908360020b62ffffff1602179055506040820151816001015560608201518160020155505060405180606001604052806001151581526020017fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff9c81526020016bb504f333f9de6484597d89b373ffffffffffffffffffffffffffffffffffffffff1681525060265f820151815f015f6101000a81548160ff021916908315150217905550602082015181600101556040820151816002015f6101000a81548173ffffffffffffffffffffffffffffffffffffffff021916908373ffffffffffffffffffffffffffffffffffffffff1602179055505050600e60425f6101000a81548173ffffffffffffffffffffffffffffffffffffffff021916908373ffffffffffffffffffffffffffffffffffffffff16021790555060425f9054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff165f1973ffffffffffffffffffffffffffffffffffffffff16901b60435f6101000a81548173ffffffffffffffffffffffffffffffffffffffff021916908373ffffffffffffffffffffffffffffffffffffffff1602179055506103a36040518060400160405280601081526020017f646576656c6f706572416464726573730000000000000000000000000000000081525061049b60201b60201c565b60495f6101000a81548173ffffffffffffffffffffffffffffffffffffffff021916908373ffffffffffffffffffffffffffffffffffffffff16021790555073360e68faccca8ca495c1b759fd9eee466db9fb32604a5f6101000a81548173ffffffffffffffffffffffffffffffffffffffff021916908373ffffffffffffffffffffffffffffffffffffffff16021790555073360e68faccca8ca495c1b759fd9eee466db9fb32604b5f6101000a81548173ffffffffffffffffffffffffffffffffffffffff021916908373ffffffffffffffffffffffffffffffffffffffff160217905550348015610495575f80fd5b506107c4565b5f6104ab826104b560201b60201c565b5080915050919050565b5f80826040516020016104c8919061065f565b604051602081830303815290604052805190602001205f1c90507f885cb69240a935d632d79c317109709ecfa91a80626ff3989d68f67f5b1dd12d5f1c73ffffffffffffffffffffffffffffffffffffffff1663ffa18649826040518263ffffffff1660e01b815260040161053d919061068d565b602060405180830381865afa158015610558573d5f803e3d5ffd5b505050506040513d601f19601f8201168201806040525081019061057c9190610704565b91507f885cb69240a935d632d79c317109709ecfa91a80626ff3989d68f67f5b1dd12d5f1c73ffffffffffffffffffffffffffffffffffffffff1663c657c71883856040518363ffffffff1660e01b81526004016105db929190610796565b5f604051808303815f87803b1580156105f2575f80fd5b505af1158015610604573d5f803e3d5ffd5b50505050915091565b5f81519050919050565b5f81905092915050565b8281835e5f83830152505050565b5f6106398261060d565b6106438185610617565b9350610653818560208601610621565b80840191505092915050565b5f61066a828461062f565b915081905092915050565b5f819050919050565b61068781610675565b82525050565b5f6020820190506106a05f83018461067e565b92915050565b5f80fd5b5f73ffffffffffffffffffffffffffffffffffffffff82169050919050565b5f6106d3826106aa565b9050919050565b6106e3816106c9565b81146106ed575f80fd5b50565b5f815190506106fe816106da565b92915050565b5f60208284031215610719576107186106a6565b5b5f610726848285016106f0565b91505092915050565b610738816106c9565b82525050565b5f82825260208201905092915050565b5f601f19601f8301169050919050565b5f6107688261060d565b610772818561073e565b9350610782818560208601610621565b61078b8161074e565b840191505092915050565b5f6040820190506107a95f83018561072f565b81810360208301526107bb818461075e565b90509392505050565b61a371806107d15f395ff3fe60806040526004361061019f575f3560e01c806366d9a9a0116100eb578063b1a73b8a11610089578063bc7c55ed11610063578063bc7c55ed14610550578063c7b8e15d1461057a578063e20c9f71146105a4578063fa7626d4146105ce576101a6565b8063b1a73b8a146104d0578063b5508aa9146104fc578063ba414fa614610526576101a6565b80638b8cf341116100c55780638b8cf34114610425578063916a17c61461044f57806393ad73ed14610479578063b0464fdc146104a6576101a6565b806366d9a9a0146103a75780636afdd850146103d157806385226c81146103fb576101a6565b80633e5e3c2311610158578063478a807b11610132578063478a807b146103135780634cf088d914610329578063542524dd146103535780635a9d7a681461037d576101a6565b80633e5e3c23146102955780633f7286f4146102bf5780633fc8cef3146102e9576101a6565b80630373b885146101aa5780630a9254e4146101d45780631ed7831c146101ea5780632abca154146102145780632ade38801461023e57806339cd201314610268576101a6565b366101a657005b5f80fd5b3480156101b5575f80fd5b506101be6105f8565b6040516101cb9190612519565b60405180910390f35b3480156101df575f80fd5b506101e861061d565b005b3480156101f5575f80fd5b506101fe610e2c565b60405161020b91906125fa565b60405180910390f35b34801561021f575f80fd5b50610228610eb7565b604051610235919061264b565b60405180910390f35b348015610249575f80fd5b50610252610edc565b60405161025f9190612884565b60405180910390f35b348015610273575f80fd5b5061027c611060565b60405161028c94939291906128ef565b60405180910390f35b3480156102a0575f80fd5b506102a9611095565b6040516102b691906125fa565b60405180910390f35b3480156102ca575f80fd5b506102d3611120565b6040516102e091906125fa565b60405180910390f35b3480156102f4575f80fd5b506102fd6111ab565b60405161030a9190612941565b60405180910390f35b34801561031e575f80fd5b506103276111c3565b005b348015610334575f80fd5b5061033d6115ef565b60405161034a919061297a565b60405180910390f35b34801561035e575f80fd5b50610367611614565b60405161037491906129a2565b60405180910390f35b348015610388575f80fd5b50610391611638565b60405161039e91906129db565b60405180910390f35b3480156103b2575f80fd5b506103bb61165d565b6040516103c89190612bd2565b60405180910390f35b3480156103dc575f80fd5b506103e56117df565b6040516103f29190612c12565b60405180910390f35b348015610406575f80fd5b5061040f6117f2565b60405161041c9190612cae565b60405180910390f35b348015610430575f80fd5b506104396118c6565b6040516104469190612ce6565b60405180910390f35b34801561045a575f80fd5b506104636118cc565b6040516104709190612df4565b60405180910390f35b348015610484575f80fd5b5061048d611a13565b60405161049d94939291906128ef565b60405180910390f35b3480156104b1575f80fd5b506104ba611a48565b6040516104c79190612df4565b60405180910390f35b3480156104db575f80fd5b506104e4611b8f565b6040516104f393929190612e2e565b60405180910390f35b348015610507575f80fd5b50610510611bd1565b60405161051d9190612cae565b60405180910390f35b348015610531575f80fd5b5061053a611ca5565b6040516105479190612e63565b60405180910390f35b34801561055b575f80fd5b50610564611db9565b6040516105719190612e9c565b60405180910390f35b348015610585575f80fd5b5061058e611dde565b60405161059b91906129a2565b60405180910390f35b3480156105af575f80fd5b506105b8611df3565b6040516105c591906125fa565b60405180910390f35b3480156105d9575f80fd5b506105e2611e7e565b6040516105ef9190612e63565b60405180910390f35b604d5f9054906101000a900473ffffffffffffffffffffffffffffffffffffffff1681565b7f885cb69240a935d632d79c317109709ecfa91a80626ff3989d68f67f5b1dd12d5f1c73ffffffffffffffffffffffffffffffffffffffff166306447d5660495f9054906101000a900473ffffffffffffffffffffffffffffffffffffffff166040518263ffffffff1660e01b81526004016106999190612941565b5f604051808303815f87803b1580156106b0575f80fd5b505af11580156106c2573d5f803e3d5ffd5b5050505060126040516106d490612404565b6106de9190612f9e565b604051809103905ff0801580156106f7573d5f803e3d5ffd5b5060475f6101000a81548173ffffffffffffffffffffffffffffffffffffffff021916908373ffffffffffffffffffffffffffffffffffffffff1602179055505f7342420000000000000000000000000000000000006110006080610200610800612000171717171890505f604b5f9054906101000a900473ffffffffffffffffffffffffffffffffffffffff1660475f9054906101000a900473ffffffffffffffffffffffffffffffffffffffff1660495f9054906101000a900473ffffffffffffffffffffffffffffffffffffffff16604a5f9054906101000a900473ffffffffffffffffffffffffffffffffffffffff166040516020016107fe949392919061301d565b604051602081830303815290604052905061084f6040518060400160405280601f81526020017f537570657244434147617567652e736f6c3a53757065724443414761756765008152508284611e90565b8160445f6101000a81548173ffffffffffffffffffffffffffffffffffffffff021916908373ffffffffffffffffffffffffffffffffffffffff16021790555060475f9054906101000a900473ffffffffffffffffffffffffffffffffffffffff16604b5f9054906101000a900473ffffffffffffffffffffffffffffffffffffffff16604a5f9054906101000a900473ffffffffffffffffffffffffffffffffffffffff1660495f9054906101000a900473ffffffffffffffffffffffffffffffffffffffff1660445f9054906101000a900473ffffffffffffffffffffffffffffffffffffffff1660405161094590612411565b610953959493929190613080565b604051809103905ff08015801561096c573d5f803e3d5ffd5b5060465f6101000a81548173ffffffffffffffffffffffffffffffffffffffff021916908373ffffffffffffffffffffffffffffffffffffffff16021790555060475f9054906101000a900473ffffffffffffffffffffffffffffffffffffffff16606460495f9054906101000a900473ffffffffffffffffffffffffffffffffffffffff166040516109fe9061241e565b610a0a9392919061310a565b604051809103905ff080158015610a23573d5f803e3d5ffd5b5060455f6101000a81548173ffffffffffffffffffffffffffffffffffffffff021916908373ffffffffffffffffffffffffffffffffffffffff16021790555060445f9054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16638ff3909960455f9054906101000a900473ffffffffffffffffffffffffffffffffffffffff166040518263ffffffff1660e01b8152600401610ade9190612941565b5f604051808303815f87803b158015610af5575f80fd5b505af1158015610b07573d5f803e3d5ffd5b5050505060445f9054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff1663420d046360465f9054906101000a900473ffffffffffffffffffffffffffffffffffffffff166040518263ffffffff1660e01b8152600401610b869190612941565b5f604051808303815f87803b158015610b9d575f80fd5b505af1158015610baf573d5f803e3d5ffd5b5050505060465f9054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16634586332260445f9054906101000a900473ffffffffffffffffffffffffffffffffffffffff166040518263ffffffff1660e01b8152600401610c2e919061313f565b5f604051808303815f87803b158015610c45575f80fd5b505af1158015610c57573d5f803e3d5ffd5b5050505060455f9054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff166355a68ed360445f9054906101000a900473ffffffffffffffffffffffffffffffffffffffff166040518263ffffffff1660e01b8152600401610cd69190612941565b5f604051808303815f87803b158015610ced575f80fd5b505af1158015610cff573d5f803e3d5ffd5b5050505060475f9054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff1663f2fde38b60445f9054906101000a900473ffffffffffffffffffffffffffffffffffffffff166040518263ffffffff1660e01b8152600401610d7e9190612941565b5f604051808303815f87803b158015610d95575f80fd5b505af1158015610da7573d5f803e3d5ffd5b505050507f885cb69240a935d632d79c317109709ecfa91a80626ff3989d68f67f5b1dd12d5f1c73ffffffffffffffffffffffffffffffffffffffff166390c5013b6040518163ffffffff1660e01b81526004015f604051808303815f87803b158015610e12575f80fd5b505af1158015610e24573d5f803e3d5ffd5b505050505050565b60606016805480602002602001604051908101604052809291908181526020018280548015610ead57602002820191905f5260205f20905b815f9054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff1681526020019060010190808311610e64575b5050505050905090565b60475f9054906101000a900473ffffffffffffffffffffffffffffffffffffffff1681565b6060601e805480602002602001604051908101604052809291908181526020015f905b82821015611057578382905f5260205f2090600202016040518060400160405290815f82015f9054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16815260200160018201805480602002602001604051908101604052809291908181526020015f905b82821015611040578382905f5260205f20018054610fb590613185565b80601f0160208091040260200160405190810160405280929190818152602001828054610fe190613185565b801561102c5780601f106110035761010080835404028352916020019161102c565b820191905f5260205f20905b81548152906001019060200180831161100f57829003601f168201915b505050505081526020019060010190610f98565b505050508152505081526020019060010190610eff565b50505050905090565b6023805f015f9054906101000a900460020b90805f0160039054906101000a900460020b908060010154908060020154905084565b6060601880548060200260200160405190810160405280929190818152602001828054801561111657602002820191905f5260205f20905b815f9054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16815260200190600101908083116110cd575b5050505050905090565b606060178054806020026020016040519081016040528092919081815260200182805480156111a157602002820191905f5260205f20905b815f9054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff1681526020019060010190808311611158575b5050505050905090565b7382af49447d8a07e3bd95bd0d56f35241523fbab181565b5f60475f9054906101000a900473ffffffffffffffffffffffffffffffffffffffff1690505f7382af49447d8a07e3bd95bd0d56f35241523fbab190505f6c0100000000000000000000000090507f885cb69240a935d632d79c317109709ecfa91a80626ff3989d68f67f5b1dd12d5f1c73ffffffffffffffffffffffffffffffffffffffff166306447d5660495f9054906101000a900473ffffffffffffffffffffffffffffffffffffffff166040518263ffffffff1660e01b815260040161128d9190612941565b5f604051808303815f87803b1580156112a4575f80fd5b505af11580156112b6573d5f803e3d5ffd5b505050505f603c90505f6112cf85856280000085611ea1565b9050604b5f9054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16636276cbbe82856040518363ffffffff1660e01b815260040161132d929190613276565b6020604051808303815f875af1158015611349573d5f803e3d5ffd5b505050506040513d601f19601f8201168201806040525081019061136d91906132d8565b507f885cb69240a935d632d79c317109709ecfa91a80626ff3989d68f67f5b1dd12d5f1c73ffffffffffffffffffffffffffffffffffffffff166390c5013b6040518163ffffffff1660e01b81526004015f604051808303815f87803b1580156113d5575f80fd5b505af11580156113e7573d5f803e3d5ffd5b505050505f61142a6040518060400160405280600d81526020017f6d616c6963696f75735573657200000000000000000000000000000000000000815250612010565b90507f885cb69240a935d632d79c317109709ecfa91a80626ff3989d68f67f5b1dd12d5f1c73ffffffffffffffffffffffffffffffffffffffff166306447d56826040518263ffffffff1660e01b81526004016114879190612941565b5f604051808303815f87803b15801561149e575f80fd5b505af11580156114b0573d5f803e3d5ffd5b505050505f605090505f6114c988886280000085611ea1565b9050604b5f9054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16636276cbbe82886040518363ffffffff1660e01b8152600401611527929190613276565b6020604051808303815f875af1158015611543573d5f803e3d5ffd5b505050506040513d601f19601f8201168201806040525081019061156791906132d8565b507f885cb69240a935d632d79c317109709ecfa91a80626ff3989d68f67f5b1dd12d5f1c73ffffffffffffffffffffffffffffffffffffffff166390c5013b6040518163ffffffff1660e01b81526004015f604051808303815f87803b1580156115cf575f80fd5b505af11580156115e1573d5f803e3d5ffd5b505050505050505050505050565b60455f9054906101000a900473ffffffffffffffffffffffffffffffffffffffff1681565b600173fffd8963efd1fc6a506488495d951d5263988d266116359190613330565b81565b604c5f9054906101000a900473ffffffffffffffffffffffffffffffffffffffff1681565b6060601b805480602002602001604051908101604052809291908181526020015f905b828210156117d6578382905f5260205f2090600202016040518060400160405290815f820180546116b090613185565b80601f01602080910402602001604051908101604052809291908181526020018280546116dc90613185565b80156117275780601f106116fe57610100808354040283529160200191611727565b820191905f5260205f20905b81548152906001019060200180831161170a57829003601f168201915b50505050508152602001600182018054806020026020016040519081016040528092919081815260200182805480156117be57602002820191905f5260205f20905f905b82829054906101000a900460e01b7bffffffffffffffffffffffffffffffffffffffffffffffffffffffff19168152602001906004019060208260030104928301926001038202915080841161176b5790505b50505050508152505081526020019060010190611680565b50505050905090565b6e22d473030f116ddee9f6b43ac78ba381565b6060601a805480602002602001604051908101604052809291908181526020015f905b828210156118bd578382905f5260205f2001805461183290613185565b80601f016020809104026020016040519081016040528092919081815260200182805461185e90613185565b80156118a95780601f10611880576101008083540402835291602001916118a9565b820191905f5260205f20905b81548152906001019060200180831161188c57829003601f168201915b505050505081526020019060010190611815565b50505050905090565b61138881565b6060601d805480602002602001604051908101604052809291908181526020015f905b82821015611a0a578382905f5260205f2090600202016040518060400160405290815f82015f9054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff168152602001600182018054806020026020016040519081016040528092919081815260200182805480156119f257602002820191905f5260205f20905f905b82829054906101000a900460e01b7bffffffffffffffffffffffffffffffffffffffffffffffffffffffff19168152602001906004019060208260030104928301926001038202915080841161199f5790505b505050505081525050815260200190600101906118ef565b50505050905090565b6020805f015f9054906101000a900460020b90805f0160039054906101000a900460020b908060010154908060020154905084565b6060601c805480602002602001604051908101604052809291908181526020015f905b82821015611b86578382905f5260205f2090600202016040518060400160405290815f82015f9054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16815260200160018201805480602002602001604051908101604052809291908181526020018280548015611b6e57602002820191905f5260205f20905f905b82829054906101000a900460e01b7bffffffffffffffffffffffffffffffffffffffffffffffffffffffff191681526020019060040190602082600301049283019260010382029150808411611b1b5790505b50505050508152505081526020019060010190611a6b565b50505050905090565b6026805f015f9054906101000a900460ff1690806001015490806002015f9054906101000a900473ffffffffffffffffffffffffffffffffffffffff16905083565b60606019805480602002602001604051908101604052809291908181526020015f905b82821015611c9c578382905f5260205f20018054611c1190613185565b80601f0160208091040260200160405190810160405280929190818152602001828054611c3d90613185565b8015611c885780601f10611c5f57610100808354040283529160200191611c88565b820191905f5260205f20905b815481529060010190602001808311611c6b57829003601f168201915b505050505081526020019060010190611bf4565b50505050905090565b5f60085f9054906101000a900460ff1615611cd05760085f9054906101000a900460ff169050611db6565b5f801b7f885cb69240a935d632d79c317109709ecfa91a80626ff3989d68f67f5b1dd12d5f1c73ffffffffffffffffffffffffffffffffffffffff1663667f9d707f885cb69240a935d632d79c317109709ecfa91a80626ff3989d68f67f5b1dd12d5f1c7f6661696c656400000000000000000000000000000000000000000000000000006040518363ffffffff1660e01b8152600401611d72929190613377565b602060405180830381865afa158015611d8d573d5f803e3d5ffd5b505050506040513d601f19601f82011682018060405250810190611db191906133c8565b141590505b90565b60465f9054906101000a900473ffffffffffffffffffffffffffffffffffffffff1681565b60016401000276a3611df091906133f3565b81565b60606015805480602002602001604051908101604052809291908181526020018280548015611e7457602002820191905f5260205f20905b815f9054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff1681526020019060010190808311611e2b575b5050505050905090565b601f5f9054906101000a900460ff1681565b611e9c83835f84612024565b505050565b611ea961242b565b8373ffffffffffffffffffffffffffffffffffffffff168573ffffffffffffffffffffffffffffffffffffffff1610611f73576040518060a001604052808573ffffffffffffffffffffffffffffffffffffffff1681526020018673ffffffffffffffffffffffffffffffffffffffff1681526020018462ffffff1681526020018360020b815260200160445f9054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16815250612006565b6040518060a001604052808673ffffffffffffffffffffffffffffffffffffffff1681526020018573ffffffffffffffffffffffffffffffffffffffff1681526020018462ffffff1681526020018360020b815260200160445f9054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff168152505b9050949350505050565b5f61201a826122ac565b5080915050919050565b5f7f885cb69240a935d632d79c317109709ecfa91a80626ff3989d68f67f5b1dd12d5f1c73ffffffffffffffffffffffffffffffffffffffff16638d1cc925866040518263ffffffff1660e01b81526004016120809190613472565b5f60405180830381865afa15801561209a573d5f803e3d5ffd5b505050506040513d5f823e3d601f19601f820116820180604052508101906120c291906135b0565b90507f885cb69240a935d632d79c317109709ecfa91a80626ff3989d68f67f5b1dd12d5f1c73ffffffffffffffffffffffffffffffffffffffff1663b4d6c78283838760405160200161211692919061363b565b6040516020818303038152906040526040518363ffffffff1660e01b81526004016121429291906136a6565b5f604051808303815f87803b158015612159575f80fd5b505af115801561216b573d5f803e3d5ffd5b505050505f808373ffffffffffffffffffffffffffffffffffffffff1685604051612195906136f7565b5f6040518083038185875af1925050503d805f81146121cf576040519150601f19603f3d011682016040523d82523d5f602084013e6121d4565b606091505b509150915081612219576040517f08c379a0000000000000000000000000000000000000000000000000000000008152600401612210906137a1565b60405180910390fd5b7f885cb69240a935d632d79c317109709ecfa91a80626ff3989d68f67f5b1dd12d5f1c73ffffffffffffffffffffffffffffffffffffffff1663b4d6c78285836040518363ffffffff1660e01b81526004016122769291906136a6565b5f604051808303815f87803b15801561228d575f80fd5b505af115801561229f573d5f803e3d5ffd5b5050505050505050505050565b5f80826040516020016122bf91906137f9565b604051602081830303815290604052805190602001205f1c90507f885cb69240a935d632d79c317109709ecfa91a80626ff3989d68f67f5b1dd12d5f1c73ffffffffffffffffffffffffffffffffffffffff1663ffa18649826040518263ffffffff1660e01b81526004016123349190612ce6565b602060405180830381865afa15801561234f573d5f803e3d5ffd5b505050506040513d601f19601f820116820180604052508101906123739190613839565b91507f885cb69240a935d632d79c317109709ecfa91a80626ff3989d68f67f5b1dd12d5f1c73ffffffffffffffffffffffffffffffffffffffff1663c657c71883856040518363ffffffff1660e01b81526004016123d2929190613864565b5f604051808303815f87803b1580156123e9575f80fd5b505af11580156123fb573d5f803e3d5ffd5b50505050915091565b6118ff8061389383390190565b6130468061519283390190565b612164806181d883390190565b6040518060a001604052805f73ffffffffffffffffffffffffffffffffffffffff1681526020015f73ffffffffffffffffffffffffffffffffffffffff1681526020015f62ffffff1681526020015f60020b81526020015f73ffffffffffffffffffffffffffffffffffffffff1681525090565b5f73ffffffffffffffffffffffffffffffffffffffff82169050919050565b5f819050919050565b5f6124e16124dc6124d78461249f565b6124be565b61249f565b9050919050565b5f6124f2826124c7565b9050919050565b5f612503826124e8565b9050919050565b612513816124f9565b82525050565b5f60208201905061252c5f83018461250a565b92915050565b5f81519050919050565b5f82825260208201905092915050565b5f819050602082019050919050565b5f6125658261249f565b9050919050565b6125758161255b565b82525050565b5f612586838361256c565b60208301905092915050565b5f602082019050919050565b5f6125a882612532565b6125b2818561253c565b93506125bd8361254c565b805f5b838110156125ed5781516125d4888261257b565b97506125df83612592565b9250506001810190506125c0565b5085935050505092915050565b5f6020820190508181035f830152612612818461259e565b905092915050565b5f612624826124c7565b9050919050565b5f6126358261261a565b9050919050565b6126458161262b565b82525050565b5f60208201905061265e5f83018461263c565b92915050565b5f81519050919050565b5f82825260208201905092915050565b5f819050602082019050919050565b5f81519050919050565b5f82825260208201905092915050565b5f819050602082019050919050565b5f81519050919050565b5f82825260208201905092915050565b8281835e5f83830152505050565b5f601f19601f8301169050919050565b5f6126f8826126b6565b61270281856126c0565b93506127128185602086016126d0565b61271b816126de565b840191505092915050565b5f61273183836126ee565b905092915050565b5f602082019050919050565b5f61274f8261268d565b6127598185612697565b93508360208202850161276b856126a7565b805f5b858110156127a657848403895281516127878582612726565b945061279283612739565b925060208a0199505060018101905061276e565b50829750879550505050505092915050565b5f604083015f8301516127cd5f86018261256c565b50602083015184820360208601526127e58282612745565b9150508091505092915050565b5f6127fd83836127b8565b905092915050565b5f602082019050919050565b5f61281b82612664565b612825818561266e565b9350836020820285016128378561267e565b805f5b85811015612872578484038952815161285385826127f2565b945061285e83612805565b925060208a0199505060018101905061283a565b50829750879550505050505092915050565b5f6020820190508181035f83015261289c8184612811565b905092915050565b5f8160020b9050919050565b6128b9816128a4565b82525050565b5f819050919050565b6128d1816128bf565b82525050565b5f819050919050565b6128e9816128d7565b82525050565b5f6080820190506129025f8301876128b0565b61290f60208301866128b0565b61291c60408301856128c8565b61292960608301846128e0565b95945050505050565b61293b8161255b565b82525050565b5f6020820190506129545f830184612932565b92915050565b5f6129648261261a565b9050919050565b6129748161295a565b82525050565b5f60208201905061298d5f83018461296b565b92915050565b61299c8161249f565b82525050565b5f6020820190506129b55f830184612993565b92915050565b5f6129c58261261a565b9050919050565b6129d5816129bb565b82525050565b5f6020820190506129ee5f8301846129cc565b92915050565b5f81519050919050565b5f82825260208201905092915050565b5f819050602082019050919050565b5f81519050919050565b5f82825260208201905092915050565b5f819050602082019050919050565b5f7fffffffff0000000000000000000000000000000000000000000000000000000082169050919050565b612a7a81612a46565b82525050565b5f612a8b8383612a71565b60208301905092915050565b5f602082019050919050565b5f612aad82612a1d565b612ab78185612a27565b9350612ac283612a37565b805f5b83811015612af2578151612ad98882612a80565b9750612ae483612a97565b925050600181019050612ac5565b5085935050505092915050565b5f604083015f8301518482035f860152612b1982826126ee565b91505060208301518482036020860152612b338282612aa3565b9150508091505092915050565b5f612b4b8383612aff565b905092915050565b5f602082019050919050565b5f612b69826129f4565b612b7381856129fe565b935083602082028501612b8585612a0e565b805f5b85811015612bc05784840389528151612ba18582612b40565b9450612bac83612b53565b925060208a01995050600181019050612b88565b50829750879550505050505092915050565b5f6020820190508181035f830152612bea8184612b5f565b905092915050565b5f612bfc8261261a565b9050919050565b612c0c81612bf2565b82525050565b5f602082019050612c255f830184612c03565b92915050565b5f82825260208201905092915050565b5f612c458261268d565b612c4f8185612c2b565b935083602082028501612c61856126a7565b805f5b85811015612c9c5784840389528151612c7d8582612726565b9450612c8883612739565b925060208a01995050600181019050612c64565b50829750879550505050505092915050565b5f6020820190508181035f830152612cc68184612c3b565b905092915050565b5f819050919050565b612ce081612cce565b82525050565b5f602082019050612cf95f830184612cd7565b92915050565b5f81519050919050565b5f82825260208201905092915050565b5f819050602082019050919050565b5f604083015f830151612d3d5f86018261256c565b5060208301518482036020860152612d558282612aa3565b9150508091505092915050565b5f612d6d8383612d28565b905092915050565b5f602082019050919050565b5f612d8b82612cff565b612d958185612d09565b935083602082028501612da785612d19565b805f5b85811015612de25784840389528151612dc38582612d62565b9450612dce83612d75565b925060208a01995050600181019050612daa565b50829750879550505050505092915050565b5f6020820190508181035f830152612e0c8184612d81565b905092915050565b5f8115159050919050565b612e2881612e14565b82525050565b5f606082019050612e415f830186612e1f565b612e4e60208301856128c8565b612e5b6040830184612993565b949350505050565b5f602082019050612e765f830184612e1f565b92915050565b5f612e868261261a565b9050919050565b612e9681612e7c565b82525050565b5f602082019050612eaf5f830184612e8d565b92915050565b5f82825260208201905092915050565b7f53757065722044434120546f6b656e00000000000000000000000000000000005f82015250565b5f612ef9600f83612eb5565b9150612f0482612ec5565b602082019050919050565b7f53444341000000000000000000000000000000000000000000000000000000005f82015250565b5f612f43600483612eb5565b9150612f4e82612f0f565b602082019050919050565b5f819050919050565b5f60ff82169050919050565b5f612f88612f83612f7e84612f59565b6124be565b612f62565b9050919050565b612f9881612f6e565b82525050565b5f6060820190508181035f830152612fb581612eed565b90508181036020830152612fc881612f37565b9050612fd76040830184612f8f565b92915050565b5f612fe78261261a565b9050919050565b612ff781612fdd565b82525050565b5f6130078261261a565b9050919050565b61301781612ffd565b82525050565b5f6080820190506130305f830187612fee565b61303d602083018661263c565b61304a6040830185612932565b613057606083018461300e565b95945050505050565b5f61306a8261261a565b9050919050565b61307a81613060565b82525050565b5f60a0820190506130935f830188612932565b6130a06020830187612fee565b6130ad604083018661300e565b6130ba6060830185612932565b6130c76080830184613071565b9695505050505050565b5f819050919050565b5f6130f46130ef6130ea846130d1565b6124be565b612cce565b9050919050565b613104816130da565b82525050565b5f60608201905061311d5f830186612932565b61312a60208301856130fb565b6131376040830184612932565b949350505050565b5f6020820190506131525f830184613071565b92915050565b7f4e487b71000000000000000000000000000000000000000000000000000000005f52602260045260245ffd5b5f600282049050600182168061319c57607f821691505b6020821081036131af576131ae613158565b5b50919050565b5f6131bf8261261a565b9050919050565b6131cf816131b5565b82525050565b5f62ffffff82169050919050565b6131ec816131d5565b82525050565b6131fb816128a4565b82525050565b61320a81613060565b82525050565b60a082015f8201516132245f8501826131c6565b50602082015161323760208501826131c6565b50604082015161324a60408501826131e3565b50606082015161325d60608501826131f2565b5060808201516132706080850182613201565b50505050565b5f60c0820190506132895f830185613210565b61329660a0830184612993565b9392505050565b5f604051905090565b5f80fd5b5f80fd5b6132b7816128a4565b81146132c1575f80fd5b50565b5f815190506132d2816132ae565b92915050565b5f602082840312156132ed576132ec6132a6565b5b5f6132fa848285016132c4565b91505092915050565b7f4e487b71000000000000000000000000000000000000000000000000000000005f52601160045260245ffd5b5f61333a8261249f565b91506133458361249f565b9250828203905073ffffffffffffffffffffffffffffffffffffffff81111561337157613370613303565b5b92915050565b5f60408201905061338a5f830185612932565b61339760208301846128e0565b9392505050565b6133a7816128d7565b81146133b1575f80fd5b50565b5f815190506133c28161339e565b92915050565b5f602082840312156133dd576133dc6132a6565b5b5f6133ea848285016133b4565b91505092915050565b5f6133fd8261249f565b91506134088361249f565b9250828201905073ffffffffffffffffffffffffffffffffffffffff81111561343457613433613303565b5b92915050565b5f613444826126b6565b61344e8185612eb5565b935061345e8185602086016126d0565b613467816126de565b840191505092915050565b5f6020820190508181035f83015261348a818461343a565b905092915050565b5f80fd5b5f80fd5b7f4e487b71000000000000000000000000000000000000000000000000000000005f52604160045260245ffd5b6134d0826126de565b810181811067ffffffffffffffff821117156134ef576134ee61349a565b5b80604052505050565b5f61350161329d565b905061350d82826134c7565b919050565b5f67ffffffffffffffff82111561352c5761352b61349a565b5b613535826126de565b9050602081019050919050565b5f61355461354f84613512565b6134f8565b9050828152602081018484840111156135705761356f613496565b5b61357b8482856126d0565b509392505050565b5f82601f83011261359757613596613492565b5b81516135a7848260208601613542565b91505092915050565b5f602082840312156135c5576135c46132a6565b5b5f82015167ffffffffffffffff8111156135e2576135e16132aa565b5b6135ee84828501613583565b91505092915050565b5f81519050919050565b5f81905092915050565b5f613615826135f7565b61361f8185613601565b935061362f8185602086016126d0565b80840191505092915050565b5f613646828561360b565b9150613652828461360b565b91508190509392505050565b5f82825260208201905092915050565b5f613678826135f7565b613682818561365e565b93506136928185602086016126d0565b61369b816126de565b840191505092915050565b5f6040820190506136b95f830185612932565b81810360208301526136cb818461366e565b90509392505050565b50565b5f6136e25f83613601565b91506136ed826136d4565b5f82019050919050565b5f613701826136d7565b9150819050919050565b7f537464436865617473206465706c6f79436f6465546f28737472696e672c62795f8201527f7465732c75696e743235362c61646472657373293a204661696c656420746f2060208201527f6372656174652072756e74696d652062797465636f64652e0000000000000000604082015250565b5f61378b605883612eb5565b91506137968261370b565b606082019050919050565b5f6020820190508181035f8301526137b88161377f565b9050919050565b5f81905092915050565b5f6137d3826126b6565b6137dd81856137bf565b93506137ed8185602086016126d0565b80840191505092915050565b5f61380482846137c9565b915081905092915050565b6138188161255b565b8114613822575f80fd5b50565b5f815190506138338161380f565b92915050565b5f6020828403121561384e5761384d6132a6565b5b5f61385b84828501613825565b91505092915050565b5f6040820190506138775f830185612932565b8181036020830152613889818461343a565b9050939250505056fe608060405234801561000f575f80fd5b506040516118ff3803806118ff83398181016040528101906100319190610235565b825f908161003f91906104ca565b50816001908161004f91906104ca565b508060025f6101000a81548160ff021916908360ff1602179055503360045f6101000a81548173ffffffffffffffffffffffffffffffffffffffff021916908373ffffffffffffffffffffffffffffffffffffffff160217905550505050610599565b5f604051905090565b5f80fd5b5f80fd5b5f80fd5b5f80fd5b5f601f19601f8301169050919050565b7f4e487b71000000000000000000000000000000000000000000000000000000005f52604160045260245ffd5b610111826100cb565b810181811067ffffffffffffffff821117156101305761012f6100db565b5b80604052505050565b5f6101426100b2565b905061014e8282610108565b919050565b5f67ffffffffffffffff82111561016d5761016c6100db565b5b610176826100cb565b9050602081019050919050565b8281835e5f83830152505050565b5f6101a361019e84610153565b610139565b9050828152602081018484840111156101bf576101be6100c7565b5b6101ca848285610183565b509392505050565b5f82601f8301126101e6576101e56100c3565b5b81516101f6848260208601610191565b91505092915050565b5f60ff82169050919050565b610214816101ff565b811461021e575f80fd5b50565b5f8151905061022f8161020b565b92915050565b5f805f6060848603121561024c5761024b6100bb565b5b5f84015167ffffffffffffffff811115610269576102686100bf565b5b610275868287016101d2565b935050602084015167ffffffffffffffff811115610296576102956100bf565b5b6102a2868287016101d2565b92505060406102b386828701610221565b9150509250925092565b5f81519050919050565b7f4e487b71000000000000000000000000000000000000000000000000000000005f52602260045260245ffd5b5f600282049050600182168061030b57607f821691505b60208210810361031e5761031d6102c7565b5b50919050565b5f819050815f5260205f209050919050565b5f6020601f8301049050919050565b5f82821b905092915050565b5f600883026103807fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff82610345565b61038a8683610345565b95508019841693508086168417925050509392505050565b5f819050919050565b5f819050919050565b5f6103ce6103c96103c4846103a2565b6103ab565b6103a2565b9050919050565b5f819050919050565b6103e7836103b4565b6103fb6103f3826103d5565b848454610351565b825550505050565b5f90565b61040f610403565b61041a8184846103de565b505050565b5b8181101561043d576104325f82610407565b600181019050610420565b5050565b601f8211156104825761045381610324565b61045c84610336565b8101602085101561046b578190505b61047f61047785610336565b83018261041f565b50505b505050565b5f82821c905092915050565b5f6104a25f1984600802610487565b1980831691505092915050565b5f6104ba8383610493565b9150826002028217905092915050565b6104d3826102bd565b67ffffffffffffffff8111156104ec576104eb6100db565b5b6104f682546102f4565b610501828285610441565b5f60209050601f831160018114610532575f8415610520578287015190505b61052a85826104af565b865550610591565b601f19841661054086610324565b5f5b8281101561056757848901518255600182019150602085019450602081019050610542565b868310156105845784890151610580601f891682610493565b8355505b6001600288020188555050505b505050505050565b611359806105a65f395ff3fe608060405234801561000f575f80fd5b50600436106100fe575f3560e01c806370a0823111610095578063c501562811610064578063c5015628146102ae578063dd62ed3e146102cc578063e2919faf146102fc578063f2fde38b1461031a576100fe565b806370a08231146102125780638da5cb5b1461024257806395d89b4114610260578063a9059cbb1461027e576100fe565b806323b872dd116100d157806323b872dd1461018a578063313ce567146101ba57806340c10f19146101d8578063705e75c2146101f4576100fe565b806306fdde0314610102578063095ea7b31461012057806318160ddd146101505780631dfc984d1461016e575b5f80fd5b61010a610336565b6040516101179190610cdf565b60405180910390f35b61013a60048036038101906101359190610d90565b6103c1565b6040516101479190610de8565b60405180910390f35b610158610449565b6040516101659190610e10565b60405180910390f35b61018860048036038101906101839190610e53565b61044f565b005b6101a4600480360381019061019f9190610e7e565b61046b565b6040516101b19190610de8565b60405180910390f35b6101c2610735565b6040516101cf9190610ee9565b60405180910390f35b6101f260048036038101906101ed9190610d90565b610747565b005b6101fc610845565b6040516102099190610de8565b60405180910390f35b61022c60048036038101906102279190610f02565b610857565b6040516102399190610e10565b60405180910390f35b61024a61086c565b6040516102579190610f3c565b60405180910390f35b610268610891565b6040516102759190610cdf565b60405180910390f35b61029860048036038101906102939190610d90565b61091d565b6040516102a59190610de8565b60405180910390f35b6102b6610ae4565b6040516102c39190610f3c565b60405180910390f35b6102e660048036038101906102e19190610f55565b610b09565b6040516102f39190610e10565b60405180910390f35b610304610b29565b6040516103119190610e10565b60405180910390f35b610334600480360381019061032f9190610f02565b610b2f565b005b5f805461034290610fc0565b80601f016020809104026020016040519081016040528092919081815260200182805461036e90610fc0565b80156103b95780601f10610390576101008083540402835291602001916103b9565b820191905f5260205f20905b81548152906001019060200180831161039c57829003601f168201915b505050505081565b5f8160065f3373ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff1681526020019081526020015f205f8573ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff1681526020019081526020015f20819055506001905092915050565b60035481565b8060095f6101000a81548160ff02191690831515021790555050565b5f60095f9054906101000a900460ff16156104bb576040517f08c379a00000000000000000000000000000000000000000000000000000000081526004016104b29061103a565b60405180910390fd5b8160055f8673ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff1681526020019081526020015f2054101561053b576040517f08c379a0000000000000000000000000000000000000000000000000000000008152600401610532906110c8565b60405180910390fd5b8160065f8673ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff1681526020019081526020015f205f3373ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff1681526020019081526020015f205410156105f6576040517f08c379a00000000000000000000000000000000000000000000000000000000081526004016105ed90611156565b60405180910390fd5b8160065f8673ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff1681526020019081526020015f205f3373ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff1681526020019081526020015f205f82825461067d91906111a1565b925050819055508160055f8673ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff1681526020019081526020015f205f8282546106d091906111a1565b925050819055508160055f8573ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff1681526020019081526020015f205f82825461072391906111d4565b92505081905550600190509392505050565b60025f9054906101000a900460ff1681565b60045f9054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff163373ffffffffffffffffffffffffffffffffffffffff16146107d6576040517f08c379a00000000000000000000000000000000000000000000000000000000081526004016107cd90611277565b60405180910390fd5b8060035f8282546107e791906111d4565b925050819055508060055f8473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff1681526020019081526020015f205f82825461083a91906111d4565b925050819055505050565b60095f9054906101000a900460ff1681565b6005602052805f5260405f205f915090505481565b60045f9054906101000a900473ffffffffffffffffffffffffffffffffffffffff1681565b6001805461089e90610fc0565b80601f01602080910402602001604051908101604052809291908181526020018280546108ca90610fc0565b80156109155780601f106108ec57610100808354040283529160200191610915565b820191905f5260205f20905b8154815290600101906020018083116108f857829003601f168201915b505050505081565b5f60095f9054906101000a900460ff161561096d576040517f08c379a00000000000000000000000000000000000000000000000000000000081526004016109649061103a565b60405180910390fd5b8160055f3373ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff1681526020019081526020015f205410156109ed576040517f08c379a00000000000000000000000000000000000000000000000000000000081526004016109e4906110c8565b60405180910390fd5b8160055f3373ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff1681526020019081526020015f205f828254610a3991906111a1565b925050819055508160055f8573ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff1681526020019081526020015f205f828254610a8c91906111d4565b92505081905550816008819055508260075f6101000a81548173ffffffffffffffffffffffffffffffffffffffff021916908373ffffffffffffffffffffffffffffffffffffffff1602179055506001905092915050565b60075f9054906101000a900473ffffffffffffffffffffffffffffffffffffffff1681565b6006602052815f5260405f20602052805f5260405f205f91509150505481565b60085481565b60045f9054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff163373ffffffffffffffffffffffffffffffffffffffff1614610bbe576040517f08c379a0000000000000000000000000000000000000000000000000000000008152600401610bb590611277565b60405180910390fd5b5f73ffffffffffffffffffffffffffffffffffffffff168173ffffffffffffffffffffffffffffffffffffffff1603610c2c576040517f08c379a0000000000000000000000000000000000000000000000000000000008152600401610c2390611305565b60405180910390fd5b8060045f6101000a81548173ffffffffffffffffffffffffffffffffffffffff021916908373ffffffffffffffffffffffffffffffffffffffff16021790555050565b5f81519050919050565b5f82825260208201905092915050565b8281835e5f83830152505050565b5f601f19601f8301169050919050565b5f610cb182610c6f565b610cbb8185610c79565b9350610ccb818560208601610c89565b610cd481610c97565b840191505092915050565b5f6020820190508181035f830152610cf78184610ca7565b905092915050565b5f80fd5b5f73ffffffffffffffffffffffffffffffffffffffff82169050919050565b5f610d2c82610d03565b9050919050565b610d3c81610d22565b8114610d46575f80fd5b50565b5f81359050610d5781610d33565b92915050565b5f819050919050565b610d6f81610d5d565b8114610d79575f80fd5b50565b5f81359050610d8a81610d66565b92915050565b5f8060408385031215610da657610da5610cff565b5b5f610db385828601610d49565b9250506020610dc485828601610d7c565b9150509250929050565b5f8115159050919050565b610de281610dce565b82525050565b5f602082019050610dfb5f830184610dd9565b92915050565b610e0a81610d5d565b82525050565b5f602082019050610e235f830184610e01565b92915050565b610e3281610dce565b8114610e3c575f80fd5b50565b5f81359050610e4d81610e29565b92915050565b5f60208284031215610e6857610e67610cff565b5b5f610e7584828501610e3f565b91505092915050565b5f805f60608486031215610e9557610e94610cff565b5b5f610ea286828701610d49565b9350506020610eb386828701610d49565b9250506040610ec486828701610d7c565b9150509250925092565b5f60ff82169050919050565b610ee381610ece565b82525050565b5f602082019050610efc5f830184610eda565b92915050565b5f60208284031215610f1757610f16610cff565b5b5f610f2484828501610d49565b91505092915050565b610f3681610d22565b82525050565b5f602082019050610f4f5f830184610f2d565b92915050565b5f8060408385031215610f6b57610f6a610cff565b5b5f610f7885828601610d49565b9250506020610f8985828601610d49565b9150509250929050565b7f4e487b71000000000000000000000000000000000000000000000000000000005f52602260045260245ffd5b5f6002820490506001821680610fd757607f821691505b602082108103610fea57610fe9610f93565b5b50919050565b7f4d6f636b4552433230546f6b656e3a20526576657274205265717565737465645f82015250565b5f611024602083610c79565b915061102f82610ff0565b602082019050919050565b5f6020820190508181035f83015261105181611018565b9050919050565b7f4d6f636b4552433230546f6b656e3a20496e73756666696369656e742062616c5f8201527f616e636500000000000000000000000000000000000000000000000000000000602082015250565b5f6110b2602483610c79565b91506110bd82611058565b604082019050919050565b5f6020820190508181035f8301526110df816110a6565b9050919050565b7f4d6f636b4552433230546f6b656e3a20496e73756666696369656e7420616c6c5f8201527f6f77616e63650000000000000000000000000000000000000000000000000000602082015250565b5f611140602683610c79565b915061114b826110e6565b604082019050919050565b5f6020820190508181035f83015261116d81611134565b9050919050565b7f4e487b71000000000000000000000000000000000000000000000000000000005f52601160045260245ffd5b5f6111ab82610d5d565b91506111b683610d5d565b92508282039050818111156111ce576111cd611174565b5b92915050565b5f6111de82610d5d565b91506111e983610d5d565b925082820190508082111561120157611200611174565b5b92915050565b7f4d6f636b4552433230546f6b656e3a2063616c6c6572206973206e6f742074685f8201527f65206f776e657200000000000000000000000000000000000000000000000000602082015250565b5f611261602783610c79565b915061126c82611207565b604082019050919050565b5f6020820190508181035f83015261128e81611255565b9050919050565b7f4d6f636b4552433230546f6b656e3a206e6577206f776e6572206973207468655f8201527f207a65726f206164647265737300000000000000000000000000000000000000602082015250565b5f6112ef602d83610c79565b91506112fa82611295565b604082019050919050565b5f6020820190508181035f83015261131c816112e3565b905091905056fea264697066735822122074efed53d7d27228a89ac8da294bc7db7f579b8a05b65311ada62eaf5fb7383564736f6c634300081a003360e0604052683635c9adc5dea0000060035534801561001c575f80fd5b50604051613046380380613046833981810160405281019061003e9190610410565b815f73ffffffffffffffffffffffffffffffffffffffff168173ffffffffffffffffffffffffffffffffffffffff16036100af575f6040517f1e4fbdf70000000000000000000000000000000000000000000000000000000081526004016100a69190610496565b60405180910390fd5b6100be8161020a60201b60201c565b505f73ffffffffffffffffffffffffffffffffffffffff168573ffffffffffffffffffffffffffffffffffffffff1603610124576040517fba0c1ac200000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b8473ffffffffffffffffffffffffffffffffffffffff1660c08173ffffffffffffffffffffffffffffffffffffffff16815250508373ffffffffffffffffffffffffffffffffffffffff1660808173ffffffffffffffffffffffffffffffffffffffff16815250508273ffffffffffffffffffffffffffffffffffffffff1660a08173ffffffffffffffffffffffffffffffffffffffff16815250508060025f6101000a81548173ffffffffffffffffffffffffffffffffffffffff021916908373ffffffffffffffffffffffffffffffffffffffff16021790555050505050506104af565b60015f6101000a81549073ffffffffffffffffffffffffffffffffffffffff021916905561023d8161024060201b60201c565b50565b5f805f9054906101000a900473ffffffffffffffffffffffffffffffffffffffff169050815f806101000a81548173ffffffffffffffffffffffffffffffffffffffff021916908373ffffffffffffffffffffffffffffffffffffffff1602179055508173ffffffffffffffffffffffffffffffffffffffff168173ffffffffffffffffffffffffffffffffffffffff167f8be0079c531659141344cd1fd0a4f28419497f9722a3daafe3b4186f6b6457e060405160405180910390a35050565b5f80fd5b5f73ffffffffffffffffffffffffffffffffffffffff82169050919050565b5f61032e82610305565b9050919050565b61033e81610324565b8114610348575f80fd5b50565b5f8151905061035981610335565b92915050565b5f61036982610324565b9050919050565b6103798161035f565b8114610383575f80fd5b50565b5f8151905061039481610370565b92915050565b5f6103a482610324565b9050919050565b6103b48161039a565b81146103be575f80fd5b50565b5f815190506103cf816103ab565b92915050565b5f6103df82610324565b9050919050565b6103ef816103d5565b81146103f9575f80fd5b50565b5f8151905061040a816103e6565b92915050565b5f805f805f60a0868803121561042957610428610301565b5b5f6104368882890161034b565b955050602061044788828901610386565b9450506040610458888289016103c1565b93505060606104698882890161034b565b925050608061047a888289016103fc565b9150509295509295909350565b61049081610324565b82525050565b5f6020820190506104a95f830184610487565b92915050565b60805160a05160c051612b356105115f395f81816102d60152610f9a01525f81816104e4015281816107a4015281816109ef01528181610b4201528181610dcf01528181610eec015261117201525f8181610a1301526114e80152612b355ff3fe608060405234801561000f575f80fd5b50600436106100fe575f3560e01c80636905028c116100955780638da5cb5b116100645780638da5cb5b1461024c578063e30c39781461026a578063e69ec65314610288578063f2fde38b146102b8576100fe565b80636905028c146101ec578063715018a61461021c57806379ba50971461022657806383f1a99114610230576100fe565b806345863322116100d1578063458633221461017857806351f3b4bd146101945780635246a591146101b057806362308e85146101ce576100fe565b8063126a8024146101025780631aeffea914610120578063252cf2d21461013e578063282567b41461015c575b5f80fd5b61010a6102d4565b6040516101179190611de8565b60405180910390f35b6101286102f8565b6040516101359190611e5c565b60405180910390f35b61014661031d565b6040516101539190611e8d565b60405180910390f35b61017660048036038101906101719190611edd565b610323565b005b610192600480360381019061018d9190611f43565b610375565b005b6101ae60048036038101906101a99190611f98565b61043b565b005b6101b86109ed565b6040516101c59190611ff6565b60405180910390f35b6101d6610a11565b6040516101e3919061202f565b60405180910390f35b61020660048036038101906102019190611edd565b610a35565b6040516102139190611de8565b60405180910390f35b610224610a65565b005b61022e610a78565b005b61024a6004803603810190610245919061206a565b610b06565b005b61025461127e565b6040516102619190611de8565b60405180910390f35b6102726112a5565b60405161027f9190611de8565b60405180910390f35b6102a2600480360381019061029d91906120a8565b6112cd565b6040516102af91906120ed565b60405180910390f35b6102d260048036038101906102cd91906120a8565b6112ea565b005b7f000000000000000000000000000000000000000000000000000000000000000081565b60025f9054906101000a900473ffffffffffffffffffffffffffffffffffffffff1681565b60035481565b61032b611396565b5f6003549050816003819055507fd18c85fe8a5776467c327fa33312c6113129233ddb47deabaa91b8396b8158798183604051610369929190612106565b60405180910390a15050565b61037d611396565b8073ffffffffffffffffffffffffffffffffffffffff1660025f9054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff167f7606bd4a057092573eb59005c3ee8b72a9939ed0f677304d644b87d3bcb1c33e60405160405180910390a38060025f6101000a81548173ffffffffffffffffffffffffffffffffffffffff021916908373ffffffffffffffffffffffffffffffffffffffff16021790555050565b610443611396565b5f820361047c576040517f325e582700000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b5f73ffffffffffffffffffffffffffffffffffffffff168173ffffffffffffffffffffffffffffffffffffffff16036104e1576040517f7efc4d2000000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b5f7f000000000000000000000000000000000000000000000000000000000000000073ffffffffffffffffffffffffffffffffffffffff16637ba03aad846040518263ffffffff1660e01b815260040161053b9190611e8d565b60c060405180830381865afa158015610556573d5f803e3d5ffd5b505050506040513d601f19601f8201168201806040525081019061057a9190612318565b5090505f815f015190505f826020015190505f8273ffffffffffffffffffffffffffffffffffffffff166370a08231866040518263ffffffff1660e01b81526004016105c69190611de8565b602060405180830381865afa1580156105e1573d5f803e3d5ffd5b505050506040513d601f19601f82011682018060405250810190610605919061236a565b90505f8273ffffffffffffffffffffffffffffffffffffffff166370a08231876040518263ffffffff1660e01b81526004016106419190611de8565b602060405180830381865afa15801561065c573d5f803e3d5ffd5b505050506040513d601f19601f82011682018060405250810190610680919061236a565b90505f600160116040516020016106989291906123d5565b60405160208183030381529060405290505f600267ffffffffffffffff8111156106c5576106c4612141565b5b6040519080825280602002602001820160405280156106f857816020015b60608152602001906001900390816106e35790505b509050885f805f60405180602001604052805f81525060405160200161072295949392919061248a565b604051602081830303815290604052815f81518110610744576107436124e2565b5b60200260200101819052508585896040516020016107649392919061252f565b60405160208183030381529060405281600181518110610787576107866124e2565b5b60200260200101819052505f603c426107a09190612591565b90507f000000000000000000000000000000000000000000000000000000000000000073ffffffffffffffffffffffffffffffffffffffff1663dd46508f84846040516020016107f19291906126c7565b604051602081830303815290604052836040518363ffffffff1660e01b815260040161081e9291906126fc565b5f604051808303815f87803b158015610835575f80fd5b505af1158015610847573d5f803e3d5ffd5b505050505f8773ffffffffffffffffffffffffffffffffffffffff166370a082318b6040518263ffffffff1660e01b81526004016108859190611de8565b602060405180830381865afa1580156108a0573d5f803e3d5ffd5b505050506040513d601f19601f820116820180604052508101906108c4919061236a565b90505f8773ffffffffffffffffffffffffffffffffffffffff166370a082318c6040518263ffffffff1660e01b81526004016109009190611de8565b602060405180830381865afa15801561091b573d5f803e3d5ffd5b505050506040513d601f19601f8201168201806040525081019061093f919061236a565b90505f878361094e919061272a565b90505f878361095d919061272a565b90508973ffffffffffffffffffffffffffffffffffffffff168b73ffffffffffffffffffffffffffffffffffffffff168e73ffffffffffffffffffffffffffffffffffffffff167f572f183ae7932bec57f7cba7466e8531bc5f455f1df21554b0b1a1c2d0ff48f385856040516109d5929190612106565b60405180910390a45050505050505050505050505050565b7f000000000000000000000000000000000000000000000000000000000000000081565b7f000000000000000000000000000000000000000000000000000000000000000081565b6005602052805f5260405f205f915054906101000a900473ffffffffffffffffffffffffffffffffffffffff1681565b610a6d611396565b610a765f61141d565b565b5f610a8161144d565b90508073ffffffffffffffffffffffffffffffffffffffff16610aa26112a5565b73ffffffffffffffffffffffffffffffffffffffff1614610afa57806040517f118cdaa7000000000000000000000000000000000000000000000000000000008152600401610af19190611de8565b60405180910390fd5b610b038161141d565b50565b5f8203610b3f576040517f325e582700000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b5f7f000000000000000000000000000000000000000000000000000000000000000073ffffffffffffffffffffffffffffffffffffffff16637ba03aad846040518263ffffffff1660e01b8152600401610b999190611e8d565b60c060405180830381865afa158015610bb4573d5f803e3d5ffd5b505050506040513d601f19601f82011682018060405250810190610bd89190612318565b509050815f016020810190610bed9190612771565b73ffffffffffffffffffffffffffffffffffffffff16815f015173ffffffffffffffffffffffffffffffffffffffff16141580610c6c5750816020016020810190610c389190612771565b73ffffffffffffffffffffffffffffffffffffffff16816020015173ffffffffffffffffffffffffffffffffffffffff1614155b80610c975750816040016020810190610c8591906127b0565b62ffffff16816040015162ffffff1614155b80610cbe5750816060016020810190610cb091906127ef565b60020b816060015160020b14155b80610d0b5750816080016020810190610cd79190611f43565b73ffffffffffffffffffffffffffffffffffffffff16816080015173ffffffffffffffffffffffffffffffffffffffff1614155b15610d42576040517fd9d12f8700000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b60025f9054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16816080015173ffffffffffffffffffffffffffffffffffffffff1614610dcc576040517fb99fee9300000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b5f7f000000000000000000000000000000000000000000000000000000000000000073ffffffffffffffffffffffffffffffffffffffff166389097a6a856040518263ffffffff1660e01b8152600401610e269190611e8d565b602060405180830381865afa158015610e41573d5f803e3d5ffd5b505050506040513d601f19601f82011682018060405250810190610e65919061281a565b90505f610e7182611454565b90505f610e7d83611463565b9050610e8c8460600151611472565b60020b8260020b141580610eb25750610ea884606001516114b3565b60020b8160020b14155b15610ee9576040517f82bf81ee00000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b5f7f000000000000000000000000000000000000000000000000000000000000000073ffffffffffffffffffffffffffffffffffffffff16631efeed33886040518263ffffffff1660e01b8152600401610f439190611e8d565b602060405180830381865afa158015610f5e573d5f803e3d5ffd5b505050506040513d601f19601f82011682018060405250810190610f82919061286f565b90505f80610f92878686866114d7565b915091505f807f000000000000000000000000000000000000000000000000000000000000000073ffffffffffffffffffffffffffffffffffffffff16895f015173ffffffffffffffffffffffffffffffffffffffff1603610ffd5788602001519150839050611007565b885f015191508290505b60045f8373ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff1681526020019081526020015f205f9054906101000a900460ff1615611088576040517fe9184aec00000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b6003548110156110c4576040517fe3790cbd00000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b600160045f8473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff1681526020019081526020015f205f6101000a81548160ff0219169083151502179055508160055f8d81526020019081526020015f205f6101000a81548173ffffffffffffffffffffffffffffffffffffffff021916908373ffffffffffffffffffffffffffffffffffffffff16021790555050505050505050507f000000000000000000000000000000000000000000000000000000000000000073ffffffffffffffffffffffffffffffffffffffff166323b872dd3330866040518463ffffffff1660e01b81526004016111cd9392919061289a565b5f604051808303815f87803b1580156111e4575f80fd5b505af11580156111f6573d5f803e3d5ffd5b505050508260055f8581526020019081526020015f205f9054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff167f42e9c725c052ee6448302c3f7f2f1b4c0549a31e6555c62a9f489f32ebc4e776836040516112719190612971565b60405180910390a3505050565b5f805f9054906101000a900473ffffffffffffffffffffffffffffffffffffffff16905090565b5f60015f9054906101000a900473ffffffffffffffffffffffffffffffffffffffff16905090565b6004602052805f5260405f205f915054906101000a900460ff1681565b6112f2611396565b8060015f6101000a81548173ffffffffffffffffffffffffffffffffffffffff021916908373ffffffffffffffffffffffffffffffffffffffff1602179055508073ffffffffffffffffffffffffffffffffffffffff1661135161127e565b73ffffffffffffffffffffffffffffffffffffffff167f38d16b8cac22d99fc7c124b9cd0de2d3fa1faef420bfe791d8c362d765e2270060405160405180910390a350565b61139e61144d565b73ffffffffffffffffffffffffffffffffffffffff166113bc61127e565b73ffffffffffffffffffffffffffffffffffffffff161461141b576113df61144d565b6040517f118cdaa70000000000000000000000000000000000000000000000000000000081526004016114129190611de8565b60405180910390fd5b565b60015f6101000a81549073ffffffffffffffffffffffffffffffffffffffff021916905561144a81611564565b50565b5f33905090565b5f8160081c60020b9050919050565b5f8160201c60020b9050919050565b5f818260020b7ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff2761860020b816114aa576114a961298a565b5b05029050919050565b5f818260020b620d89e860020b816114ce576114cd61298a565b5b05029050919050565b5f805f61152b6114e688611625565b7f000000000000000000000000000000000000000000000000000000000000000073ffffffffffffffffffffffffffffffffffffffff1661163190919063ffffffff16565b50505090505f61153a876116ff565b90505f611546876116ff565b905061155483838389611a59565b9450945050505094509492505050565b5f805f9054906101000a900473ffffffffffffffffffffffffffffffffffffffff169050815f806101000a81548173ffffffffffffffffffffffffffffffffffffffff021916908373ffffffffffffffffffffffffffffffffffffffff1602179055508173ffffffffffffffffffffffffffffffffffffffff168173ffffffffffffffffffffffffffffffffffffffff167f8be0079c531659141344cd1fd0a4f28419497f9722a3daafe3b4186f6b6457e060405160405180910390a35050565b5f60a082209050919050565b5f805f805f61163f86611b4a565b90505f8773ffffffffffffffffffffffffffffffffffffffff16631e2eaeaf836040518263ffffffff1660e01b815260040161167b91906129cf565b602060405180830381865afa158015611696573d5f803e3d5ffd5b505050506040513d601f19601f820116820180604052508101906116ba9190612a12565b905073ffffffffffffffffffffffffffffffffffffffff811695508060a01c60020b945062ffffff8160b81c16935062ffffff8160d01c169250505092959194509250565b5f808260020b92508260ff1d8381018118915050620d89e860020b81111561175b5761175a83638b86327a60e01b7bffffffffffffffffffffffffffffffffffffffffffffffffffffffff1916611b7e90919063ffffffff16565b5b5f600182166ffffcb933bd6fad37aa2d162d1a594001600160801b1802600160801b1890505f60028316146117a45760806ffff97272373d413259a46990580e213a8202901c90505b5f60048316146117c85760806ffff2e50f5f656932ef12357cf3c7fdcc8202901c90505b5f60088316146117ec5760806fffe5caca7e10e4e61c3624eaa0941cd08202901c90505b5f60108316146118105760806fffcb9843d60f6159c9db58835c9266448202901c90505b5f60208316146118345760806fff973b41fa98c081472e6896dfb254c08202901c90505b5f60408316146118585760806fff2ea16466c96a3843ec78b326b528618202901c90505b5f608083161461187c5760806ffe5dee046a99a2a811c461f1969c30538202901c90505b5f6101008316146118a15760806ffcbe86c7900a88aedcffc83b479aa3a48202901c90505b5f6102008316146118c65760806ff987a7253ac413176f2b074cf7815e548202901c90505b5f6104008316146118eb5760806ff3392b0822b70005940c7a398e4b70f38202901c90505b5f6108008316146119105760806fe7159475a2c29b7443b29c7fa6e889d98202901c90505b5f6110008316146119355760806fd097f3bdfd2022b8845ad8f792aa58258202901c90505b5f61200083161461195a5760806fa9f746462d870fdf8a65dc1f90e061e58202901c90505b5f61400083161461197f5760806f70d869a156d2a1b890bb3df62baf32f78202901c90505b5f6180008316146119a45760806f31be135f97d08fd981231505542fcfa68202901c90505b5f620100008316146119ca5760806f09aa508b5b7a84e1c677de54f3e99bc98202901c90505b5f620200008316146119ef5760806e5d6af8dedb81196699c329225ee6048202901c90505b5f62040000831614611a135760806d2216e584f5fa1ea926041bedfe988202901c90505b5f62080000831614611a355760806b048a170391f7dc42444e8fa28202901c90505b5f841315611a4457805f190490505b60018060201b03810160201c92505050919050565b5f808373ffffffffffffffffffffffffffffffffffffffff168573ffffffffffffffffffffffffffffffffffffffff161115611a9a57838580955081965050505b8473ffffffffffffffffffffffffffffffffffffffff168673ffffffffffffffffffffffffffffffffffffffff1611611adf57611ad8858585611b8d565b9150611b41565b8373ffffffffffffffffffffffffffffffffffffffff168673ffffffffffffffffffffffffffffffffffffffff161015611b3257611b1e868585611b8d565b9150611b2b858785611c52565b9050611b40565b611b3d858585611c52565b90505b5b94509492505050565b5f8160065f1b604051602001611b61929190612a5d565b604051602081830303815290604052805190602001209050919050565b815f528060020b60045260245ffd5b5f8273ffffffffffffffffffffffffffffffffffffffff168473ffffffffffffffffffffffffffffffffffffffff161115611bcd57828480945081955050505b8373ffffffffffffffffffffffffffffffffffffffff16611c3f606060ff16846fffffffffffffffffffffffffffffffff16901b8686611c0d9190612a88565b73ffffffffffffffffffffffffffffffffffffffff168673ffffffffffffffffffffffffffffffffffffffff16611ce6565b611c499190612acf565b90509392505050565b5f8273ffffffffffffffffffffffffffffffffffffffff168473ffffffffffffffffffffffffffffffffffffffff161115611c9257828480945081955050505b611cdd826fffffffffffffffffffffffffffffffff168585611cb49190612a88565b73ffffffffffffffffffffffffffffffffffffffff166c01000000000000000000000000611ce6565b90509392505050565b5f8083850290505f801985870982811083820303915050808411611d08575f80fd5b5f8103611d1b5783820492505050611da2565b5f8486880990508281118203915080830392505f85865f0316905080860495508084049350600181825f0304019050808302841793505f600287600302189050808702600203810290508087026002038102905080870260020381029050808702600203810290508087026002038102905080870260020381029050808502955050505050505b9392505050565b5f73ffffffffffffffffffffffffffffffffffffffff82169050919050565b5f611dd282611da9565b9050919050565b611de281611dc8565b82525050565b5f602082019050611dfb5f830184611dd9565b92915050565b5f819050919050565b5f611e24611e1f611e1a84611da9565b611e01565b611da9565b9050919050565b5f611e3582611e0a565b9050919050565b5f611e4682611e2b565b9050919050565b611e5681611e3c565b82525050565b5f602082019050611e6f5f830184611e4d565b92915050565b5f819050919050565b611e8781611e75565b82525050565b5f602082019050611ea05f830184611e7e565b92915050565b5f604051905090565b5f80fd5b611ebc81611e75565b8114611ec6575f80fd5b50565b5f81359050611ed781611eb3565b92915050565b5f60208284031215611ef257611ef1611eaf565b5b5f611eff84828501611ec9565b91505092915050565b5f611f1282611dc8565b9050919050565b611f2281611f08565b8114611f2c575f80fd5b50565b5f81359050611f3d81611f19565b92915050565b5f60208284031215611f5857611f57611eaf565b5b5f611f6584828501611f2f565b91505092915050565b611f7781611dc8565b8114611f81575f80fd5b50565b5f81359050611f9281611f6e565b92915050565b5f8060408385031215611fae57611fad611eaf565b5b5f611fbb85828601611ec9565b9250506020611fcc85828601611f84565b9150509250929050565b5f611fe082611e2b565b9050919050565b611ff081611fd6565b82525050565b5f6020820190506120095f830184611fe7565b92915050565b5f61201982611e2b565b9050919050565b6120298161200f565b82525050565b5f6020820190506120425f830184612020565b92915050565b5f80fd5b5f60a0828403121561206157612060612048565b5b81905092915050565b5f8060c083850312156120805761207f611eaf565b5b5f61208d85828601611ec9565b925050602061209e8582860161204c565b9150509250929050565b5f602082840312156120bd576120bc611eaf565b5b5f6120ca84828501611f84565b91505092915050565b5f8115159050919050565b6120e7816120d3565b82525050565b5f6020820190506121005f8301846120de565b92915050565b5f6040820190506121195f830185611e7e565b6121266020830184611e7e565b9392505050565b5f80fd5b5f601f19601f8301169050919050565b7f4e487b71000000000000000000000000000000000000000000000000000000005f52604160045260245ffd5b61217782612131565b810181811067ffffffffffffffff8211171561219657612195612141565b5b80604052505050565b5f6121a8611ea6565b90506121b4828261216e565b919050565b6121c281611dc8565b81146121cc575f80fd5b50565b5f815190506121dd816121b9565b92915050565b5f62ffffff82169050919050565b6121fa816121e3565b8114612204575f80fd5b50565b5f81519050612215816121f1565b92915050565b5f8160020b9050919050565b6122308161221b565b811461223a575f80fd5b50565b5f8151905061224b81612227565b92915050565b5f8151905061225f81611f19565b92915050565b5f60a0828403121561227a5761227961212d565b5b61228460a061219f565b90505f612293848285016121cf565b5f8301525060206122a6848285016121cf565b60208301525060406122ba84828501612207565b60408301525060606122ce8482850161223d565b60608301525060806122e284828501612251565b60808301525092915050565b6122f781611e75565b8114612301575f80fd5b50565b5f81519050612312816122ee565b92915050565b5f8060c0838503121561232e5761232d611eaf565b5b5f61233b85828601612265565b92505060a061234c85828601612304565b9150509250929050565b5f8151905061236481611eb3565b92915050565b5f6020828403121561237f5761237e611eaf565b5b5f61238c84828501612356565b91505092915050565b5f60ff82169050919050565b5f8160f81b9050919050565b5f6123b7826123a1565b9050919050565b6123cf6123ca82612395565b6123ad565b82525050565b5f6123e082856123be565b6001820191506123f082846123be565b6001820191508190509392505050565b5f6fffffffffffffffffffffffffffffffff82169050919050565b61242481612400565b82525050565b5f81519050919050565b5f82825260208201905092915050565b8281835e5f83830152505050565b5f61245c8261242a565b6124668185612434565b9350612476818560208601612444565b61247f81612131565b840191505092915050565b5f60a08201905061249d5f830188611e7e565b6124aa6020830187611e7e565b6124b7604083018661241b565b6124c4606083018561241b565b81810360808301526124d68184612452565b90509695505050505050565b7f4e487b71000000000000000000000000000000000000000000000000000000005f52603260045260245ffd5b5f61251982611e2b565b9050919050565b6125298161250f565b82525050565b5f6060820190506125425f830186612520565b61254f6020830185612520565b61255c6040830184611dd9565b949350505050565b7f4e487b71000000000000000000000000000000000000000000000000000000005f52601160045260245ffd5b5f61259b82611e75565b91506125a683611e75565b92508282019050808211156125be576125bd612564565b5b92915050565b5f81519050919050565b5f82825260208201905092915050565b5f819050602082019050919050565b5f82825260208201905092915050565b5f6126078261242a565b61261181856125ed565b9350612621818560208601612444565b61262a81612131565b840191505092915050565b5f61264083836125fd565b905092915050565b5f602082019050919050565b5f61265e826125c4565b61266881856125ce565b93508360208202850161267a856125de565b805f5b858110156126b557848403895281516126968582612635565b94506126a183612648565b925060208a0199505060018101905061267d565b50829750879550505050505092915050565b5f6040820190508181035f8301526126df8185612452565b905081810360208301526126f38184612654565b90509392505050565b5f6040820190508181035f8301526127148185612452565b90506127236020830184611e7e565b9392505050565b5f61273482611e75565b915061273f83611e75565b925082820390508181111561275757612756612564565b5b92915050565b5f8135905061276b816121b9565b92915050565b5f6020828403121561278657612785611eaf565b5b5f6127938482850161275d565b91505092915050565b5f813590506127aa816121f1565b92915050565b5f602082840312156127c5576127c4611eaf565b5b5f6127d28482850161279c565b91505092915050565b5f813590506127e981612227565b92915050565b5f6020828403121561280457612803611eaf565b5b5f612811848285016127db565b91505092915050565b5f6020828403121561282f5761282e611eaf565b5b5f61283c84828501612304565b91505092915050565b61284e81612400565b8114612858575f80fd5b50565b5f8151905061286981612845565b92915050565b5f6020828403121561288457612883611eaf565b5b5f6128918482850161285b565b91505092915050565b5f6060820190506128ad5f830186611dd9565b6128ba6020830185611dd9565b6128c76040830184611e7e565b949350505050565b6128d88161250f565b82525050565b6128e7816121e3565b82525050565b6128f68161221b565b82525050565b61290581611e3c565b82525050565b60a082015f82015161291f5f8501826128cf565b50602082015161293260208501826128cf565b50604082015161294560408501826128de565b50606082015161295860608501826128ed565b50608082015161296b60808501826128fc565b50505050565b5f60a0820190506129845f83018461290b565b92915050565b7f4e487b71000000000000000000000000000000000000000000000000000000005f52601260045260245ffd5b5f819050919050565b6129c9816129b7565b82525050565b5f6020820190506129e25f8301846129c0565b92915050565b6129f1816129b7565b81146129fb575f80fd5b50565b5f81519050612a0c816129e8565b92915050565b5f60208284031215612a2757612a26611eaf565b5b5f612a34848285016129fe565b91505092915050565b5f819050919050565b612a57612a52826129b7565b612a3d565b82525050565b5f612a688285612a46565b602082019150612a788284612a46565b6020820191508190509392505050565b5f612a9282611da9565b9150612a9d83611da9565b9250828203905073ffffffffffffffffffffffffffffffffffffffff811115612ac957612ac8612564565b5b92915050565b5f612ad982611e75565b9150612ae483611e75565b925082612af457612af361298a565b5b82820490509291505056fea264697066735822122026a8a362917d5849af742bdd4070890c98b53f17ecd950683917fa3e9699607b64736f6c634300081a003360a060405234801561000f575f80fd5b50604051612164380380612164833981810160405281019061003191906102e9565b805f73ffffffffffffffffffffffffffffffffffffffff168173ffffffffffffffffffffffffffffffffffffffff16036100a2575f6040517f1e4fbdf70000000000000000000000000000000000000000000000000000000081526004016100999190610348565b60405180910390fd5b6100b18161016160201b60201c565b505f73ffffffffffffffffffffffffffffffffffffffff168373ffffffffffffffffffffffffffffffffffffffff1603610117576040517f954302aa00000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b8273ffffffffffffffffffffffffffffffffffffffff1660808173ffffffffffffffffffffffffffffffffffffffff16815250508160038190555042600481905550505050610361565b60015f6101000a81549073ffffffffffffffffffffffffffffffffffffffff02191690556101948161019760201b60201c565b50565b5f805f9054906101000a900473ffffffffffffffffffffffffffffffffffffffff169050815f806101000a81548173ffffffffffffffffffffffffffffffffffffffff021916908373ffffffffffffffffffffffffffffffffffffffff1602179055508173ffffffffffffffffffffffffffffffffffffffff168173ffffffffffffffffffffffffffffffffffffffff167f8be0079c531659141344cd1fd0a4f28419497f9722a3daafe3b4186f6b6457e060405160405180910390a35050565b5f80fd5b5f73ffffffffffffffffffffffffffffffffffffffff82169050919050565b5f6102858261025c565b9050919050565b6102958161027b565b811461029f575f80fd5b50565b5f815190506102b08161028c565b92915050565b5f819050919050565b6102c8816102b6565b81146102d2575f80fd5b50565b5f815190506102e3816102bf565b92915050565b5f805f60608486031215610300576102ff610258565b5b5f61030d868287016102a2565b935050602061031e868287016102d5565b925050604061032f868287016102a2565b9150509250925092565b6103428161027b565b82525050565b5f60208201905061035b5f830184610339565b92915050565b608051611ddd6103875f395f818161055301528181610a4601526110060152611ddd5ff3fe608060405234801561000f575f80fd5b5060043610610135575f3560e01c8063a6f19c84116100b6578063ca0dcf161161007a578063ca0dcf1614610327578063dbe2193f14610345578063e30c397814610361578063e9ee2fa91461037f578063f2fde38b1461039d578063fa9ddf09146103b957610135565b8063a6f19c8414610283578063adc9772e146102a1578063ae1a01a2146102bd578063bbc19ab0146102ed578063c2a672e01461030b57610135565b8063715018a6116100fd578063715018a6146101f157806379ba5097146101fb578063862d2d7c146102055780638da5cb5b14610235578063978e08d71461025357610135565b80633710d4c71461013957806347a13cea1461016957806353ed252f1461019957806355a68ed3146101b7578063567e98f9146101d3575b5f80fd5b610153600480360381019061014e919061193d565b6103ea565b6040516101609190611993565b60405180910390f35b610183600480360381019061017e91906119ac565b61046c565b6040516101909190611993565b60405180910390f35b6101a1610551565b6040516101ae91906119e6565b60405180910390f35b6101d160048036038101906101cc91906119ac565b610575565b005b6101db610668565b6040516101e89190611993565b60405180910390f35b6101f961066e565b005b610203610681565b005b61021f600480360381019061021a919061193d565b61070f565b60405161022c9190611993565b60405180910390f35b61023d61072f565b60405161024a91906119e6565b60405180910390f35b61026d600480360381019061026891906119ac565b610756565b60405161027a9190611993565b60405180910390f35b61028b610889565b60405161029891906119e6565b60405180910390f35b6102bb60048036038101906102b69190611a29565b6108ae565b005b6102d760048036038101906102d291906119ac565b610ca6565b6040516102e49190611b1e565b60405180910390f35b6102f5610cf4565b6040516103029190611993565b60405180910390f35b61032560048036038101906103209190611a29565b610cfa565b005b61032f61110a565b60405161033c9190611993565b60405180910390f35b61035f600480360381019061035a9190611b3e565b611110565b005b610369611218565b60405161037691906119e6565b60405180910390f35b610387611240565b6040516103949190611993565b60405180910390f35b6103b760048036038101906103b291906119ac565b611246565b005b6103d360048036038101906103ce91906119ac565b6112f2565b6040516103e1929190611b69565b60405180910390f35b5f60085f8473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff1681526020019081526020015f205f8373ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff1681526020019081526020015f2054905092915050565b5f8060075f8473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff1681526020019081526020015f2090505f815f015414806104bf57505f600654145b156104cd575f91505061054c565b5f60055490505f600454426104e29190611bbd565b90505f811115610521575f600354826104fb9190611bf0565b905061051281670de0b6b3a7640000600654611347565b8361051d9190611c31565b9250505b610546835f01548460010154846105389190611bbd565b670de0b6b3a7640000611347565b93505050505b919050565b7f000000000000000000000000000000000000000000000000000000000000000081565b61057d61142c565b5f73ffffffffffffffffffffffffffffffffffffffff168173ffffffffffffffffffffffffffffffffffffffff16036105e2576040517f954302aa00000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b8060025f6101000a81548173ffffffffffffffffffffffffffffffffffffffff021916908373ffffffffffffffffffffffffffffffffffffffff1602179055508073ffffffffffffffffffffffffffffffffffffffff167fb947d28129d3b40272a411eeee3a2842c6335a0f0269abf492e8c20218bf02b060405160405180910390a250565b60065481565b61067661142c565b61067f5f6114b3565b565b5f61068a6114e3565b90508073ffffffffffffffffffffffffffffffffffffffff166106ab611218565b73ffffffffffffffffffffffffffffffffffffffff161461070357806040517f118cdaa70000000000000000000000000000000000000000000000000000000081526004016106fa91906119e6565b60405180910390fd5b61070c816114b3565b50565b6008602052815f5260405f20602052805f5260405f205f91509150505481565b5f805f9054906101000a900473ffffffffffffffffffffffffffffffffffffffff16905090565b5f60025f9054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff163373ffffffffffffffffffffffffffffffffffffffff16146107dd576040517f8f5c579500000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b6107e56114ea565b5f60075f8473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff1681526020019081526020015f2090505f815f015403610838575f915050610884565b5f816001015460055461084b9190611bbd565b90505f810361085e575f92505050610884565b610874825f015482670de0b6b3a7640000611347565b9250600554826001018190555050505b919050565b60025f9054906101000a900473ffffffffffffffffffffffffffffffffffffffff1681565b5f81036108e7576040517f1f52e43300000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b5f73ffffffffffffffffffffffffffffffffffffffff1660025f9054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff160361096d576040517f954302aa00000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b60025f9054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff1663e69ec653836040518263ffffffff1660e01b81526004016109c791906119e6565b602060405180830381865afa1580156109e2573d5f803e3d5ffd5b505050506040513d601f19601f82011682018060405250810190610a069190611c99565b610a3c576040517fd0b5530500000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b610a446114ea565b7f000000000000000000000000000000000000000000000000000000000000000073ffffffffffffffffffffffffffffffffffffffff166323b872dd3330846040518463ffffffff1660e01b8152600401610aa193929190611cc4565b6020604051808303815f875af1158015610abd573d5f803e3d5ffd5b505050506040513d601f19601f82011682018060405250810190610ae19190611c99565b505f60075f8473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff1681526020019081526020015f20905081815f015f828254610b349190611c31565b9250508190555060055481600101819055508160065f828254610b579190611c31565b925050819055508160085f3373ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff1681526020019081526020015f205f8573ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff1681526020019081526020015f205f828254610be59190611c31565b92505081905550610c3b8360095f3373ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff1681526020019081526020015f2061159490919063ffffffff16565b503373ffffffffffffffffffffffffffffffffffffffff168373ffffffffffffffffffffffffffffffffffffffff167f5dac0c1b1112564a045ba943c9d50270893e8e826c49be8e7073adc713ab7bd784604051610c999190611993565b60405180910390a3505050565b6060610ced60095f8473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff1681526020019081526020015f206115c1565b9050919050565b60045481565b5f8103610d33576040517f1f52e43300000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b5f60075f8473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff1681526020019081526020015f20905081815f01541015610db0576040517ff1a31f7300000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b8160085f3373ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff1681526020019081526020015f205f8573ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff1681526020019081526020015f20541015610e62576040517ff1a31f7300000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b610e6a6114ea565b81815f015f828254610e7c9190611bbd565b9250508190555060055481600101819055508160065f828254610e9f9190611bbd565b925050819055508160085f3373ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff1681526020019081526020015f205f8573ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff1681526020019081526020015f205f828254610f2d9190611bbd565b925050819055505f60085f3373ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff1681526020019081526020015f205f8573ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff1681526020019081526020015f205403611004576110028360095f3373ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff1681526020019081526020015f206115e090919063ffffffff16565b505b7f000000000000000000000000000000000000000000000000000000000000000073ffffffffffffffffffffffffffffffffffffffff1663a9059cbb33846040518363ffffffff1660e01b815260040161105f929190611cf9565b6020604051808303815f875af115801561107b573d5f803e3d5ffd5b505050506040513d601f19601f8201168201806040525081019061109f9190611c99565b503373ffffffffffffffffffffffffffffffffffffffff168373ffffffffffffffffffffffffffffffffffffffff167fd8654fcc8cf5b36d30b3f5e4688fc78118e6d68de60b9994e09902268b57c3e3846040516110fd9190611993565b60405180910390a3505050565b60035481565b61111861072f565b73ffffffffffffffffffffffffffffffffffffffff163373ffffffffffffffffffffffffffffffffffffffff16141580156111a0575060025f9054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff163373ffffffffffffffffffffffffffffffffffffffff1614155b156111d7576040517f5b767c8000000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b806003819055507fe043e3e44450462f070ef41d0ee43c33ea863ea59eaee8da6f27377b8ba88c358160405161120d9190611993565b60405180910390a150565b5f60015f9054906101000a900473ffffffffffffffffffffffffffffffffffffffff16905090565b60055481565b61124e61142c565b8060015f6101000a81548173ffffffffffffffffffffffffffffffffffffffff021916908373ffffffffffffffffffffffffffffffffffffffff1602179055508073ffffffffffffffffffffffffffffffffffffffff166112ad61072f565b73ffffffffffffffffffffffffffffffffffffffff167f38d16b8cac22d99fc7c124b9cd0de2d3fa1faef420bfe791d8c362d765e2270060405160405180910390a350565b5f805f60075f8573ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff1681526020019081526020015f209050805f015481600101549250925050915091565b5f8083850290505f8019858709828110838203039150505f810361137f5783828161137557611374611d20565b5b0492505050611425565b80841161139e5761139d6113985f86146012601161160d565b611626565b5b5f8486880990508281118203915080830392505f855f038616905080860495508084049350600181825f0304019050808302841793505f600287600302189050808702600203810290508087026002038102905080870260020381029050808702600203810290508087026002038102905080870260020381029050808502955050505050505b9392505050565b6114346114e3565b73ffffffffffffffffffffffffffffffffffffffff1661145261072f565b73ffffffffffffffffffffffffffffffffffffffff16146114b1576114756114e3565b6040517f118cdaa70000000000000000000000000000000000000000000000000000000081526004016114a891906119e6565b60405180910390fd5b565b60015f6101000a81549073ffffffffffffffffffffffffffffffffffffffff02191690556114e081611637565b50565b5f33905090565b5f6006540315611592575f600454426115039190611bbd565b90505f81036115125750611592565b5f600354826115219190611bf0565b905061153881670de0b6b3a7640000600654611347565b60055f8282546115489190611c31565b92505081905550426004819055507f22da3973732aa4a277b604da5282200d162428ccee60e8d996fc614e8b3d583e6005546040516115879190611993565b60405180910390a150505b565b5f6115b9835f018373ffffffffffffffffffffffffffffffffffffffff165f1b6116f8565b905092915050565b60605f6115cf835f0161175f565b905060608190508092505050919050565b5f611605835f018373ffffffffffffffffffffffffffffffffffffffff165f1b6117b8565b905092915050565b5f611617846118b4565b82841802821890509392505050565b634e487b715f52806020526024601cfd5b5f805f9054906101000a900473ffffffffffffffffffffffffffffffffffffffff169050815f806101000a81548173ffffffffffffffffffffffffffffffffffffffff021916908373ffffffffffffffffffffffffffffffffffffffff1602179055508173ffffffffffffffffffffffffffffffffffffffff168173ffffffffffffffffffffffffffffffffffffffff167f8be0079c531659141344cd1fd0a4f28419497f9722a3daafe3b4186f6b6457e060405160405180910390a35050565b5f61170383836118bf565b61175557825f0182908060018154018082558091505060019003905f5260205f20015f9091909190915055825f0180549050836001015f8481526020019081526020015f208190555060019050611759565b5f90505b92915050565b6060815f018054806020026020016040519081016040528092919081815260200182805480156117ac57602002820191905f5260205f20905b815481526020019060010190808311611798575b50505050509050919050565b5f80836001015f8481526020019081526020015f205490505f81146118a9575f6001826117e59190611bbd565b90505f6001865f01805490506117fb9190611bbd565b9050808214611861575f865f01828154811061181a57611819611d4d565b5b905f5260205f200154905080875f01848154811061183b5761183a611d4d565b5b905f5260205f20018190555083876001015f8381526020019081526020015f2081905550505b855f0180548061187457611873611d7a565b5b600190038181905f5260205f20015f90559055856001015f8681526020019081526020015f205f9055600193505050506118ae565b5f9150505b92915050565b5f8115159050919050565b5f80836001015f8481526020019081526020015f20541415905092915050565b5f80fd5b5f73ffffffffffffffffffffffffffffffffffffffff82169050919050565b5f61190c826118e3565b9050919050565b61191c81611902565b8114611926575f80fd5b50565b5f8135905061193781611913565b92915050565b5f8060408385031215611953576119526118df565b5b5f61196085828601611929565b925050602061197185828601611929565b9150509250929050565b5f819050919050565b61198d8161197b565b82525050565b5f6020820190506119a65f830184611984565b92915050565b5f602082840312156119c1576119c06118df565b5b5f6119ce84828501611929565b91505092915050565b6119e081611902565b82525050565b5f6020820190506119f95f8301846119d7565b92915050565b611a088161197b565b8114611a12575f80fd5b50565b5f81359050611a23816119ff565b92915050565b5f8060408385031215611a3f57611a3e6118df565b5b5f611a4c85828601611929565b9250506020611a5d85828601611a15565b9150509250929050565b5f81519050919050565b5f82825260208201905092915050565b5f819050602082019050919050565b611a9981611902565b82525050565b5f611aaa8383611a90565b60208301905092915050565b5f602082019050919050565b5f611acc82611a67565b611ad68185611a71565b9350611ae183611a81565b805f5b83811015611b11578151611af88882611a9f565b9750611b0383611ab6565b925050600181019050611ae4565b5085935050505092915050565b5f6020820190508181035f830152611b368184611ac2565b905092915050565b5f60208284031215611b5357611b526118df565b5b5f611b6084828501611a15565b91505092915050565b5f604082019050611b7c5f830185611984565b611b896020830184611984565b9392505050565b7f4e487b71000000000000000000000000000000000000000000000000000000005f52601160045260245ffd5b5f611bc78261197b565b9150611bd28361197b565b9250828203905081811115611bea57611be9611b90565b5b92915050565b5f611bfa8261197b565b9150611c058361197b565b9250828202611c138161197b565b91508282048414831517611c2a57611c29611b90565b5b5092915050565b5f611c3b8261197b565b9150611c468361197b565b9250828201905080821115611c5e57611c5d611b90565b5b92915050565b5f8115159050919050565b611c7881611c64565b8114611c82575f80fd5b50565b5f81519050611c9381611c6f565b92915050565b5f60208284031215611cae57611cad6118df565b5b5f611cbb84828501611c85565b91505092915050565b5f606082019050611cd75f8301866119d7565b611ce460208301856119d7565b611cf16040830184611984565b949350505050565b5f604082019050611d0c5f8301856119d7565b611d196020830184611984565b9392505050565b7f4e487b71000000000000000000000000000000000000000000000000000000005f52601260045260245ffd5b7f4e487b71000000000000000000000000000000000000000000000000000000005f52603260045260245ffd5b7f4e487b71000000000000000000000000000000000000000000000000000000005f52603160045260245ffdfea2646970667358221220ee06c8588c4b378cc7cd825ac3d6fdb13b5db3697da224bc0af511c5fd3903a364736f6c634300081a0033a2646970667358221220107b116d6ccc27f24b84723e37b7aae1f32ba705df9fec0c6cd602ab7321c38b64736f6c634300081a0033","sourceMap":"2257:4052:150:-:0;;;3166:4:2;3126:44;;;;;;;;;;;;;;;;;;;;1038:4:12;1016:26;;;;;;;;;;;;;;;;;;;;2389:100:102;;;;;;;;2436:4;2389:100;;;;;;2453:3;2389:100;;;;;;2474:4;2389:100;;;;2486:1;2389:100;;;;;2320:169;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;2571:101;;;;;;;;2618:4;2571:101;;;;;;2635:3;2571:101;;;;;;2656:5;2571:101;;;;2669:1;2571:101;;;;;2495:177;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;2731:101;;;;;;;;2768:4;2731:101;;;;;;2791:4;2731:101;;;;356:29:100;2731:101:102;;;;;2678:154;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;3534:2;3504:32;;;;;;;;;;;;;;;;;;;;3596:19;;;;;;;;;;;3580:36;;3589:1;3580:11;:36;;;;3542:74;;;;;;;;;;;;;;;;;;;;2610:28:150;;;;;;;;;;;;;;;;;;:8;;;:28;;:::i;:::-;2590:48;;;;;;;;;;;;;;;;;;;;2696:42;2644:95;;;;;;;;;;;;;;;;;;;;2768:42;2746:64;;;;;;;;;;;;;;;;;;;;2257:4052;;;;;;;;;;;;20760:125:3;20824:12;20858:20;20873:4;20858:14;;;:20;;:::i;:::-;20848:30;;;;;20760:125;;;:::o;20479:242::-;20549:12;20563:18;20641:4;20624:22;;;;;;;;:::i;:::-;;;;;;;;;;;;;20614:33;;;;;;20606:42;;20593:55;;318:28;310:37;;20665:7;;;20673:10;20665:19;;;;;;;;;;;;;;;:::i;:::-;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;:::i;:::-;20658:26;;318:28;310:37;;20694:8;;;20703:4;20709;20694:20;;;;;;;;;;;;;;;;:::i;:::-;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;20479:242;;;:::o;7:99:153:-;59:6;93:5;87:12;77:22;;7:99;;;:::o;112:148::-;214:11;251:3;236:18;;112:148;;;;:::o;266:139::-;355:6;350:3;345;339:23;396:1;387:6;382:3;378:16;371:27;266:139;;;:::o;411:390::-;517:3;545:39;578:5;545:39;:::i;:::-;600:89;682:6;677:3;600:89;:::i;:::-;593:96;;698:65;756:6;751:3;744:4;737:5;733:16;698:65;:::i;:::-;788:6;783:3;779:16;772:23;;521:280;411:390;;;;:::o;807:275::-;939:3;961:95;1052:3;1043:6;961:95;:::i;:::-;954:102;;1073:3;1066:10;;807:275;;;;:::o;1088:77::-;1125:7;1154:5;1143:16;;1088:77;;;:::o;1171:118::-;1258:24;1276:5;1258:24;:::i;:::-;1253:3;1246:37;1171:118;;:::o;1295:222::-;1388:4;1426:2;1415:9;1411:18;1403:26;;1439:71;1507:1;1496:9;1492:17;1483:6;1439:71;:::i;:::-;1295:222;;;;:::o;1604:117::-;1713:1;1710;1703:12;1850:126;1887:7;1927:42;1920:5;1916:54;1905:65;;1850:126;;;:::o;1982:96::-;2019:7;2048:24;2066:5;2048:24;:::i;:::-;2037:35;;1982:96;;;:::o;2084:122::-;2157:24;2175:5;2157:24;:::i;:::-;2150:5;2147:35;2137:63;;2196:1;2193;2186:12;2137:63;2084:122;:::o;2212:143::-;2269:5;2300:6;2294:13;2285:22;;2316:33;2343:5;2316:33;:::i;:::-;2212:143;;;;:::o;2361:351::-;2431:6;2480:2;2468:9;2459:7;2455:23;2451:32;2448:119;;;2486:79;;:::i;:::-;2448:119;2606:1;2631:64;2687:7;2678:6;2667:9;2663:22;2631:64;:::i;:::-;2621:74;;2577:128;2361:351;;;;:::o;2718:118::-;2805:24;2823:5;2805:24;:::i;:::-;2800:3;2793:37;2718:118;;:::o;2842:169::-;2926:11;2960:6;2955:3;2948:19;3000:4;2995:3;2991:14;2976:29;;2842:169;;;;:::o;3017:102::-;3058:6;3109:2;3105:7;3100:2;3093:5;3089:14;3085:28;3075:38;;3017:102;;;:::o;3125:377::-;3213:3;3241:39;3274:5;3241:39;:::i;:::-;3296:71;3360:6;3355:3;3296:71;:::i;:::-;3289:78;;3376:65;3434:6;3429:3;3422:4;3415:5;3411:16;3376:65;:::i;:::-;3466:29;3488:6;3466:29;:::i;:::-;3461:3;3457:39;3450:46;;3217:285;3125:377;;;;:::o;3508:423::-;3649:4;3687:2;3676:9;3672:18;3664:26;;3700:71;3768:1;3757:9;3753:17;3744:6;3700:71;:::i;:::-;3818:9;3812:4;3808:20;3803:2;3792:9;3788:18;3781:48;3846:78;3919:4;3910:6;3846:78;:::i;:::-;3838:86;;3508:423;;;;;:::o;2257:4052:150:-;;;;;;;","linkReferences":{}},"deployedBytecode":{"object":"60806040526004361061019f575f3560e01c806366d9a9a0116100eb578063b1a73b8a11610089578063bc7c55ed11610063578063bc7c55ed14610550578063c7b8e15d1461057a578063e20c9f71146105a4578063fa7626d4146105ce576101a6565b8063b1a73b8a146104d0578063b5508aa9146104fc578063ba414fa614610526576101a6565b80638b8cf341116100c55780638b8cf34114610425578063916a17c61461044f57806393ad73ed14610479578063b0464fdc146104a6576101a6565b806366d9a9a0146103a75780636afdd850146103d157806385226c81146103fb576101a6565b80633e5e3c2311610158578063478a807b11610132578063478a807b146103135780634cf088d914610329578063542524dd146103535780635a9d7a681461037d576101a6565b80633e5e3c23146102955780633f7286f4146102bf5780633fc8cef3146102e9576101a6565b80630373b885146101aa5780630a9254e4146101d45780631ed7831c146101ea5780632abca154146102145780632ade38801461023e57806339cd201314610268576101a6565b366101a657005b5f80fd5b3480156101b5575f80fd5b506101be6105f8565b6040516101cb9190612519565b60405180910390f35b3480156101df575f80fd5b506101e861061d565b005b3480156101f5575f80fd5b506101fe610e2c565b60405161020b91906125fa565b60405180910390f35b34801561021f575f80fd5b50610228610eb7565b604051610235919061264b565b60405180910390f35b348015610249575f80fd5b50610252610edc565b60405161025f9190612884565b60405180910390f35b348015610273575f80fd5b5061027c611060565b60405161028c94939291906128ef565b60405180910390f35b3480156102a0575f80fd5b506102a9611095565b6040516102b691906125fa565b60405180910390f35b3480156102ca575f80fd5b506102d3611120565b6040516102e091906125fa565b60405180910390f35b3480156102f4575f80fd5b506102fd6111ab565b60405161030a9190612941565b60405180910390f35b34801561031e575f80fd5b506103276111c3565b005b348015610334575f80fd5b5061033d6115ef565b60405161034a919061297a565b60405180910390f35b34801561035e575f80fd5b50610367611614565b60405161037491906129a2565b60405180910390f35b348015610388575f80fd5b50610391611638565b60405161039e91906129db565b60405180910390f35b3480156103b2575f80fd5b506103bb61165d565b6040516103c89190612bd2565b60405180910390f35b3480156103dc575f80fd5b506103e56117df565b6040516103f29190612c12565b60405180910390f35b348015610406575f80fd5b5061040f6117f2565b60405161041c9190612cae565b60405180910390f35b348015610430575f80fd5b506104396118c6565b6040516104469190612ce6565b60405180910390f35b34801561045a575f80fd5b506104636118cc565b6040516104709190612df4565b60405180910390f35b348015610484575f80fd5b5061048d611a13565b60405161049d94939291906128ef565b60405180910390f35b3480156104b1575f80fd5b506104ba611a48565b6040516104c79190612df4565b60405180910390f35b3480156104db575f80fd5b506104e4611b8f565b6040516104f393929190612e2e565b60405180910390f35b348015610507575f80fd5b50610510611bd1565b60405161051d9190612cae565b60405180910390f35b348015610531575f80fd5b5061053a611ca5565b6040516105479190612e63565b60405180910390f35b34801561055b575f80fd5b50610564611db9565b6040516105719190612e9c565b60405180910390f35b348015610585575f80fd5b5061058e611dde565b60405161059b91906129a2565b60405180910390f35b3480156105af575f80fd5b506105b8611df3565b6040516105c591906125fa565b60405180910390f35b3480156105d9575f80fd5b506105e2611e7e565b6040516105ef9190612e63565b60405180910390f35b604d5f9054906101000a900473ffffffffffffffffffffffffffffffffffffffff1681565b7f885cb69240a935d632d79c317109709ecfa91a80626ff3989d68f67f5b1dd12d5f1c73ffffffffffffffffffffffffffffffffffffffff166306447d5660495f9054906101000a900473ffffffffffffffffffffffffffffffffffffffff166040518263ffffffff1660e01b81526004016106999190612941565b5f604051808303815f87803b1580156106b0575f80fd5b505af11580156106c2573d5f803e3d5ffd5b5050505060126040516106d490612404565b6106de9190612f9e565b604051809103905ff0801580156106f7573d5f803e3d5ffd5b5060475f6101000a81548173ffffffffffffffffffffffffffffffffffffffff021916908373ffffffffffffffffffffffffffffffffffffffff1602179055505f7342420000000000000000000000000000000000006110006080610200610800612000171717171890505f604b5f9054906101000a900473ffffffffffffffffffffffffffffffffffffffff1660475f9054906101000a900473ffffffffffffffffffffffffffffffffffffffff1660495f9054906101000a900473ffffffffffffffffffffffffffffffffffffffff16604a5f9054906101000a900473ffffffffffffffffffffffffffffffffffffffff166040516020016107fe949392919061301d565b604051602081830303815290604052905061084f6040518060400160405280601f81526020017f537570657244434147617567652e736f6c3a53757065724443414761756765008152508284611e90565b8160445f6101000a81548173ffffffffffffffffffffffffffffffffffffffff021916908373ffffffffffffffffffffffffffffffffffffffff16021790555060475f9054906101000a900473ffffffffffffffffffffffffffffffffffffffff16604b5f9054906101000a900473ffffffffffffffffffffffffffffffffffffffff16604a5f9054906101000a900473ffffffffffffffffffffffffffffffffffffffff1660495f9054906101000a900473ffffffffffffffffffffffffffffffffffffffff1660445f9054906101000a900473ffffffffffffffffffffffffffffffffffffffff1660405161094590612411565b610953959493929190613080565b604051809103905ff08015801561096c573d5f803e3d5ffd5b5060465f6101000a81548173ffffffffffffffffffffffffffffffffffffffff021916908373ffffffffffffffffffffffffffffffffffffffff16021790555060475f9054906101000a900473ffffffffffffffffffffffffffffffffffffffff16606460495f9054906101000a900473ffffffffffffffffffffffffffffffffffffffff166040516109fe9061241e565b610a0a9392919061310a565b604051809103905ff080158015610a23573d5f803e3d5ffd5b5060455f6101000a81548173ffffffffffffffffffffffffffffffffffffffff021916908373ffffffffffffffffffffffffffffffffffffffff16021790555060445f9054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16638ff3909960455f9054906101000a900473ffffffffffffffffffffffffffffffffffffffff166040518263ffffffff1660e01b8152600401610ade9190612941565b5f604051808303815f87803b158015610af5575f80fd5b505af1158015610b07573d5f803e3d5ffd5b5050505060445f9054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff1663420d046360465f9054906101000a900473ffffffffffffffffffffffffffffffffffffffff166040518263ffffffff1660e01b8152600401610b869190612941565b5f604051808303815f87803b158015610b9d575f80fd5b505af1158015610baf573d5f803e3d5ffd5b5050505060465f9054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16634586332260445f9054906101000a900473ffffffffffffffffffffffffffffffffffffffff166040518263ffffffff1660e01b8152600401610c2e919061313f565b5f604051808303815f87803b158015610c45575f80fd5b505af1158015610c57573d5f803e3d5ffd5b5050505060455f9054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff166355a68ed360445f9054906101000a900473ffffffffffffffffffffffffffffffffffffffff166040518263ffffffff1660e01b8152600401610cd69190612941565b5f604051808303815f87803b158015610ced575f80fd5b505af1158015610cff573d5f803e3d5ffd5b5050505060475f9054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff1663f2fde38b60445f9054906101000a900473ffffffffffffffffffffffffffffffffffffffff166040518263ffffffff1660e01b8152600401610d7e9190612941565b5f604051808303815f87803b158015610d95575f80fd5b505af1158015610da7573d5f803e3d5ffd5b505050507f885cb69240a935d632d79c317109709ecfa91a80626ff3989d68f67f5b1dd12d5f1c73ffffffffffffffffffffffffffffffffffffffff166390c5013b6040518163ffffffff1660e01b81526004015f604051808303815f87803b158015610e12575f80fd5b505af1158015610e24573d5f803e3d5ffd5b505050505050565b60606016805480602002602001604051908101604052809291908181526020018280548015610ead57602002820191905f5260205f20905b815f9054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff1681526020019060010190808311610e64575b5050505050905090565b60475f9054906101000a900473ffffffffffffffffffffffffffffffffffffffff1681565b6060601e805480602002602001604051908101604052809291908181526020015f905b82821015611057578382905f5260205f2090600202016040518060400160405290815f82015f9054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16815260200160018201805480602002602001604051908101604052809291908181526020015f905b82821015611040578382905f5260205f20018054610fb590613185565b80601f0160208091040260200160405190810160405280929190818152602001828054610fe190613185565b801561102c5780601f106110035761010080835404028352916020019161102c565b820191905f5260205f20905b81548152906001019060200180831161100f57829003601f168201915b505050505081526020019060010190610f98565b505050508152505081526020019060010190610eff565b50505050905090565b6023805f015f9054906101000a900460020b90805f0160039054906101000a900460020b908060010154908060020154905084565b6060601880548060200260200160405190810160405280929190818152602001828054801561111657602002820191905f5260205f20905b815f9054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16815260200190600101908083116110cd575b5050505050905090565b606060178054806020026020016040519081016040528092919081815260200182805480156111a157602002820191905f5260205f20905b815f9054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff1681526020019060010190808311611158575b5050505050905090565b7382af49447d8a07e3bd95bd0d56f35241523fbab181565b5f60475f9054906101000a900473ffffffffffffffffffffffffffffffffffffffff1690505f7382af49447d8a07e3bd95bd0d56f35241523fbab190505f6c0100000000000000000000000090507f885cb69240a935d632d79c317109709ecfa91a80626ff3989d68f67f5b1dd12d5f1c73ffffffffffffffffffffffffffffffffffffffff166306447d5660495f9054906101000a900473ffffffffffffffffffffffffffffffffffffffff166040518263ffffffff1660e01b815260040161128d9190612941565b5f604051808303815f87803b1580156112a4575f80fd5b505af11580156112b6573d5f803e3d5ffd5b505050505f603c90505f6112cf85856280000085611ea1565b9050604b5f9054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16636276cbbe82856040518363ffffffff1660e01b815260040161132d929190613276565b6020604051808303815f875af1158015611349573d5f803e3d5ffd5b505050506040513d601f19601f8201168201806040525081019061136d91906132d8565b507f885cb69240a935d632d79c317109709ecfa91a80626ff3989d68f67f5b1dd12d5f1c73ffffffffffffffffffffffffffffffffffffffff166390c5013b6040518163ffffffff1660e01b81526004015f604051808303815f87803b1580156113d5575f80fd5b505af11580156113e7573d5f803e3d5ffd5b505050505f61142a6040518060400160405280600d81526020017f6d616c6963696f75735573657200000000000000000000000000000000000000815250612010565b90507f885cb69240a935d632d79c317109709ecfa91a80626ff3989d68f67f5b1dd12d5f1c73ffffffffffffffffffffffffffffffffffffffff166306447d56826040518263ffffffff1660e01b81526004016114879190612941565b5f604051808303815f87803b15801561149e575f80fd5b505af11580156114b0573d5f803e3d5ffd5b505050505f605090505f6114c988886280000085611ea1565b9050604b5f9054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16636276cbbe82886040518363ffffffff1660e01b8152600401611527929190613276565b6020604051808303815f875af1158015611543573d5f803e3d5ffd5b505050506040513d601f19601f8201168201806040525081019061156791906132d8565b507f885cb69240a935d632d79c317109709ecfa91a80626ff3989d68f67f5b1dd12d5f1c73ffffffffffffffffffffffffffffffffffffffff166390c5013b6040518163ffffffff1660e01b81526004015f604051808303815f87803b1580156115cf575f80fd5b505af11580156115e1573d5f803e3d5ffd5b505050505050505050505050565b60455f9054906101000a900473ffffffffffffffffffffffffffffffffffffffff1681565b600173fffd8963efd1fc6a506488495d951d5263988d266116359190613330565b81565b604c5f9054906101000a900473ffffffffffffffffffffffffffffffffffffffff1681565b6060601b805480602002602001604051908101604052809291908181526020015f905b828210156117d6578382905f5260205f2090600202016040518060400160405290815f820180546116b090613185565b80601f01602080910402602001604051908101604052809291908181526020018280546116dc90613185565b80156117275780601f106116fe57610100808354040283529160200191611727565b820191905f5260205f20905b81548152906001019060200180831161170a57829003601f168201915b50505050508152602001600182018054806020026020016040519081016040528092919081815260200182805480156117be57602002820191905f5260205f20905f905b82829054906101000a900460e01b7bffffffffffffffffffffffffffffffffffffffffffffffffffffffff19168152602001906004019060208260030104928301926001038202915080841161176b5790505b50505050508152505081526020019060010190611680565b50505050905090565b6e22d473030f116ddee9f6b43ac78ba381565b6060601a805480602002602001604051908101604052809291908181526020015f905b828210156118bd578382905f5260205f2001805461183290613185565b80601f016020809104026020016040519081016040528092919081815260200182805461185e90613185565b80156118a95780601f10611880576101008083540402835291602001916118a9565b820191905f5260205f20905b81548152906001019060200180831161188c57829003601f168201915b505050505081526020019060010190611815565b50505050905090565b61138881565b6060601d805480602002602001604051908101604052809291908181526020015f905b82821015611a0a578382905f5260205f2090600202016040518060400160405290815f82015f9054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff168152602001600182018054806020026020016040519081016040528092919081815260200182805480156119f257602002820191905f5260205f20905f905b82829054906101000a900460e01b7bffffffffffffffffffffffffffffffffffffffffffffffffffffffff19168152602001906004019060208260030104928301926001038202915080841161199f5790505b505050505081525050815260200190600101906118ef565b50505050905090565b6020805f015f9054906101000a900460020b90805f0160039054906101000a900460020b908060010154908060020154905084565b6060601c805480602002602001604051908101604052809291908181526020015f905b82821015611b86578382905f5260205f2090600202016040518060400160405290815f82015f9054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16815260200160018201805480602002602001604051908101604052809291908181526020018280548015611b6e57602002820191905f5260205f20905f905b82829054906101000a900460e01b7bffffffffffffffffffffffffffffffffffffffffffffffffffffffff191681526020019060040190602082600301049283019260010382029150808411611b1b5790505b50505050508152505081526020019060010190611a6b565b50505050905090565b6026805f015f9054906101000a900460ff1690806001015490806002015f9054906101000a900473ffffffffffffffffffffffffffffffffffffffff16905083565b60606019805480602002602001604051908101604052809291908181526020015f905b82821015611c9c578382905f5260205f20018054611c1190613185565b80601f0160208091040260200160405190810160405280929190818152602001828054611c3d90613185565b8015611c885780601f10611c5f57610100808354040283529160200191611c88565b820191905f5260205f20905b815481529060010190602001808311611c6b57829003601f168201915b505050505081526020019060010190611bf4565b50505050905090565b5f60085f9054906101000a900460ff1615611cd05760085f9054906101000a900460ff169050611db6565b5f801b7f885cb69240a935d632d79c317109709ecfa91a80626ff3989d68f67f5b1dd12d5f1c73ffffffffffffffffffffffffffffffffffffffff1663667f9d707f885cb69240a935d632d79c317109709ecfa91a80626ff3989d68f67f5b1dd12d5f1c7f6661696c656400000000000000000000000000000000000000000000000000006040518363ffffffff1660e01b8152600401611d72929190613377565b602060405180830381865afa158015611d8d573d5f803e3d5ffd5b505050506040513d601f19601f82011682018060405250810190611db191906133c8565b141590505b90565b60465f9054906101000a900473ffffffffffffffffffffffffffffffffffffffff1681565b60016401000276a3611df091906133f3565b81565b60606015805480602002602001604051908101604052809291908181526020018280548015611e7457602002820191905f5260205f20905b815f9054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff1681526020019060010190808311611e2b575b5050505050905090565b601f5f9054906101000a900460ff1681565b611e9c83835f84612024565b505050565b611ea961242b565b8373ffffffffffffffffffffffffffffffffffffffff168573ffffffffffffffffffffffffffffffffffffffff1610611f73576040518060a001604052808573ffffffffffffffffffffffffffffffffffffffff1681526020018673ffffffffffffffffffffffffffffffffffffffff1681526020018462ffffff1681526020018360020b815260200160445f9054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16815250612006565b6040518060a001604052808673ffffffffffffffffffffffffffffffffffffffff1681526020018573ffffffffffffffffffffffffffffffffffffffff1681526020018462ffffff1681526020018360020b815260200160445f9054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff168152505b9050949350505050565b5f61201a826122ac565b5080915050919050565b5f7f885cb69240a935d632d79c317109709ecfa91a80626ff3989d68f67f5b1dd12d5f1c73ffffffffffffffffffffffffffffffffffffffff16638d1cc925866040518263ffffffff1660e01b81526004016120809190613472565b5f60405180830381865afa15801561209a573d5f803e3d5ffd5b505050506040513d5f823e3d601f19601f820116820180604052508101906120c291906135b0565b90507f885cb69240a935d632d79c317109709ecfa91a80626ff3989d68f67f5b1dd12d5f1c73ffffffffffffffffffffffffffffffffffffffff1663b4d6c78283838760405160200161211692919061363b565b6040516020818303038152906040526040518363ffffffff1660e01b81526004016121429291906136a6565b5f604051808303815f87803b158015612159575f80fd5b505af115801561216b573d5f803e3d5ffd5b505050505f808373ffffffffffffffffffffffffffffffffffffffff1685604051612195906136f7565b5f6040518083038185875af1925050503d805f81146121cf576040519150601f19603f3d011682016040523d82523d5f602084013e6121d4565b606091505b509150915081612219576040517f08c379a0000000000000000000000000000000000000000000000000000000008152600401612210906137a1565b60405180910390fd5b7f885cb69240a935d632d79c317109709ecfa91a80626ff3989d68f67f5b1dd12d5f1c73ffffffffffffffffffffffffffffffffffffffff1663b4d6c78285836040518363ffffffff1660e01b81526004016122769291906136a6565b5f604051808303815f87803b15801561228d575f80fd5b505af115801561229f573d5f803e3d5ffd5b5050505050505050505050565b5f80826040516020016122bf91906137f9565b604051602081830303815290604052805190602001205f1c90507f885cb69240a935d632d79c317109709ecfa91a80626ff3989d68f67f5b1dd12d5f1c73ffffffffffffffffffffffffffffffffffffffff1663ffa18649826040518263ffffffff1660e01b81526004016123349190612ce6565b602060405180830381865afa15801561234f573d5f803e3d5ffd5b505050506040513d601f19601f820116820180604052508101906123739190613839565b91507f885cb69240a935d632d79c317109709ecfa91a80626ff3989d68f67f5b1dd12d5f1c73ffffffffffffffffffffffffffffffffffffffff1663c657c71883856040518363ffffffff1660e01b81526004016123d2929190613864565b5f604051808303815f87803b1580156123e9575f80fd5b505af11580156123fb573d5f803e3d5ffd5b50505050915091565b6118ff8061389383390190565b6130468061519283390190565b612164806181d883390190565b6040518060a001604052805f73ffffffffffffffffffffffffffffffffffffffff1681526020015f73ffffffffffffffffffffffffffffffffffffffff1681526020015f62ffffff1681526020015f60020b81526020015f73ffffffffffffffffffffffffffffffffffffffff1681525090565b5f73ffffffffffffffffffffffffffffffffffffffff82169050919050565b5f819050919050565b5f6124e16124dc6124d78461249f565b6124be565b61249f565b9050919050565b5f6124f2826124c7565b9050919050565b5f612503826124e8565b9050919050565b612513816124f9565b82525050565b5f60208201905061252c5f83018461250a565b92915050565b5f81519050919050565b5f82825260208201905092915050565b5f819050602082019050919050565b5f6125658261249f565b9050919050565b6125758161255b565b82525050565b5f612586838361256c565b60208301905092915050565b5f602082019050919050565b5f6125a882612532565b6125b2818561253c565b93506125bd8361254c565b805f5b838110156125ed5781516125d4888261257b565b97506125df83612592565b9250506001810190506125c0565b5085935050505092915050565b5f6020820190508181035f830152612612818461259e565b905092915050565b5f612624826124c7565b9050919050565b5f6126358261261a565b9050919050565b6126458161262b565b82525050565b5f60208201905061265e5f83018461263c565b92915050565b5f81519050919050565b5f82825260208201905092915050565b5f819050602082019050919050565b5f81519050919050565b5f82825260208201905092915050565b5f819050602082019050919050565b5f81519050919050565b5f82825260208201905092915050565b8281835e5f83830152505050565b5f601f19601f8301169050919050565b5f6126f8826126b6565b61270281856126c0565b93506127128185602086016126d0565b61271b816126de565b840191505092915050565b5f61273183836126ee565b905092915050565b5f602082019050919050565b5f61274f8261268d565b6127598185612697565b93508360208202850161276b856126a7565b805f5b858110156127a657848403895281516127878582612726565b945061279283612739565b925060208a0199505060018101905061276e565b50829750879550505050505092915050565b5f604083015f8301516127cd5f86018261256c565b50602083015184820360208601526127e58282612745565b9150508091505092915050565b5f6127fd83836127b8565b905092915050565b5f602082019050919050565b5f61281b82612664565b612825818561266e565b9350836020820285016128378561267e565b805f5b85811015612872578484038952815161285385826127f2565b945061285e83612805565b925060208a0199505060018101905061283a565b50829750879550505050505092915050565b5f6020820190508181035f83015261289c8184612811565b905092915050565b5f8160020b9050919050565b6128b9816128a4565b82525050565b5f819050919050565b6128d1816128bf565b82525050565b5f819050919050565b6128e9816128d7565b82525050565b5f6080820190506129025f8301876128b0565b61290f60208301866128b0565b61291c60408301856128c8565b61292960608301846128e0565b95945050505050565b61293b8161255b565b82525050565b5f6020820190506129545f830184612932565b92915050565b5f6129648261261a565b9050919050565b6129748161295a565b82525050565b5f60208201905061298d5f83018461296b565b92915050565b61299c8161249f565b82525050565b5f6020820190506129b55f830184612993565b92915050565b5f6129c58261261a565b9050919050565b6129d5816129bb565b82525050565b5f6020820190506129ee5f8301846129cc565b92915050565b5f81519050919050565b5f82825260208201905092915050565b5f819050602082019050919050565b5f81519050919050565b5f82825260208201905092915050565b5f819050602082019050919050565b5f7fffffffff0000000000000000000000000000000000000000000000000000000082169050919050565b612a7a81612a46565b82525050565b5f612a8b8383612a71565b60208301905092915050565b5f602082019050919050565b5f612aad82612a1d565b612ab78185612a27565b9350612ac283612a37565b805f5b83811015612af2578151612ad98882612a80565b9750612ae483612a97565b925050600181019050612ac5565b5085935050505092915050565b5f604083015f8301518482035f860152612b1982826126ee565b91505060208301518482036020860152612b338282612aa3565b9150508091505092915050565b5f612b4b8383612aff565b905092915050565b5f602082019050919050565b5f612b69826129f4565b612b7381856129fe565b935083602082028501612b8585612a0e565b805f5b85811015612bc05784840389528151612ba18582612b40565b9450612bac83612b53565b925060208a01995050600181019050612b88565b50829750879550505050505092915050565b5f6020820190508181035f830152612bea8184612b5f565b905092915050565b5f612bfc8261261a565b9050919050565b612c0c81612bf2565b82525050565b5f602082019050612c255f830184612c03565b92915050565b5f82825260208201905092915050565b5f612c458261268d565b612c4f8185612c2b565b935083602082028501612c61856126a7565b805f5b85811015612c9c5784840389528151612c7d8582612726565b9450612c8883612739565b925060208a01995050600181019050612c64565b50829750879550505050505092915050565b5f6020820190508181035f830152612cc68184612c3b565b905092915050565b5f819050919050565b612ce081612cce565b82525050565b5f602082019050612cf95f830184612cd7565b92915050565b5f81519050919050565b5f82825260208201905092915050565b5f819050602082019050919050565b5f604083015f830151612d3d5f86018261256c565b5060208301518482036020860152612d558282612aa3565b9150508091505092915050565b5f612d6d8383612d28565b905092915050565b5f602082019050919050565b5f612d8b82612cff565b612d958185612d09565b935083602082028501612da785612d19565b805f5b85811015612de25784840389528151612dc38582612d62565b9450612dce83612d75565b925060208a01995050600181019050612daa565b50829750879550505050505092915050565b5f6020820190508181035f830152612e0c8184612d81565b905092915050565b5f8115159050919050565b612e2881612e14565b82525050565b5f606082019050612e415f830186612e1f565b612e4e60208301856128c8565b612e5b6040830184612993565b949350505050565b5f602082019050612e765f830184612e1f565b92915050565b5f612e868261261a565b9050919050565b612e9681612e7c565b82525050565b5f602082019050612eaf5f830184612e8d565b92915050565b5f82825260208201905092915050565b7f53757065722044434120546f6b656e00000000000000000000000000000000005f82015250565b5f612ef9600f83612eb5565b9150612f0482612ec5565b602082019050919050565b7f53444341000000000000000000000000000000000000000000000000000000005f82015250565b5f612f43600483612eb5565b9150612f4e82612f0f565b602082019050919050565b5f819050919050565b5f60ff82169050919050565b5f612f88612f83612f7e84612f59565b6124be565b612f62565b9050919050565b612f9881612f6e565b82525050565b5f6060820190508181035f830152612fb581612eed565b90508181036020830152612fc881612f37565b9050612fd76040830184612f8f565b92915050565b5f612fe78261261a565b9050919050565b612ff781612fdd565b82525050565b5f6130078261261a565b9050919050565b61301781612ffd565b82525050565b5f6080820190506130305f830187612fee565b61303d602083018661263c565b61304a6040830185612932565b613057606083018461300e565b95945050505050565b5f61306a8261261a565b9050919050565b61307a81613060565b82525050565b5f60a0820190506130935f830188612932565b6130a06020830187612fee565b6130ad604083018661300e565b6130ba6060830185612932565b6130c76080830184613071565b9695505050505050565b5f819050919050565b5f6130f46130ef6130ea846130d1565b6124be565b612cce565b9050919050565b613104816130da565b82525050565b5f60608201905061311d5f830186612932565b61312a60208301856130fb565b6131376040830184612932565b949350505050565b5f6020820190506131525f830184613071565b92915050565b7f4e487b71000000000000000000000000000000000000000000000000000000005f52602260045260245ffd5b5f600282049050600182168061319c57607f821691505b6020821081036131af576131ae613158565b5b50919050565b5f6131bf8261261a565b9050919050565b6131cf816131b5565b82525050565b5f62ffffff82169050919050565b6131ec816131d5565b82525050565b6131fb816128a4565b82525050565b61320a81613060565b82525050565b60a082015f8201516132245f8501826131c6565b50602082015161323760208501826131c6565b50604082015161324a60408501826131e3565b50606082015161325d60608501826131f2565b5060808201516132706080850182613201565b50505050565b5f60c0820190506132895f830185613210565b61329660a0830184612993565b9392505050565b5f604051905090565b5f80fd5b5f80fd5b6132b7816128a4565b81146132c1575f80fd5b50565b5f815190506132d2816132ae565b92915050565b5f602082840312156132ed576132ec6132a6565b5b5f6132fa848285016132c4565b91505092915050565b7f4e487b71000000000000000000000000000000000000000000000000000000005f52601160045260245ffd5b5f61333a8261249f565b91506133458361249f565b9250828203905073ffffffffffffffffffffffffffffffffffffffff81111561337157613370613303565b5b92915050565b5f60408201905061338a5f830185612932565b61339760208301846128e0565b9392505050565b6133a7816128d7565b81146133b1575f80fd5b50565b5f815190506133c28161339e565b92915050565b5f602082840312156133dd576133dc6132a6565b5b5f6133ea848285016133b4565b91505092915050565b5f6133fd8261249f565b91506134088361249f565b9250828201905073ffffffffffffffffffffffffffffffffffffffff81111561343457613433613303565b5b92915050565b5f613444826126b6565b61344e8185612eb5565b935061345e8185602086016126d0565b613467816126de565b840191505092915050565b5f6020820190508181035f83015261348a818461343a565b905092915050565b5f80fd5b5f80fd5b7f4e487b71000000000000000000000000000000000000000000000000000000005f52604160045260245ffd5b6134d0826126de565b810181811067ffffffffffffffff821117156134ef576134ee61349a565b5b80604052505050565b5f61350161329d565b905061350d82826134c7565b919050565b5f67ffffffffffffffff82111561352c5761352b61349a565b5b613535826126de565b9050602081019050919050565b5f61355461354f84613512565b6134f8565b9050828152602081018484840111156135705761356f613496565b5b61357b8482856126d0565b509392505050565b5f82601f83011261359757613596613492565b5b81516135a7848260208601613542565b91505092915050565b5f602082840312156135c5576135c46132a6565b5b5f82015167ffffffffffffffff8111156135e2576135e16132aa565b5b6135ee84828501613583565b91505092915050565b5f81519050919050565b5f81905092915050565b5f613615826135f7565b61361f8185613601565b935061362f8185602086016126d0565b80840191505092915050565b5f613646828561360b565b9150613652828461360b565b91508190509392505050565b5f82825260208201905092915050565b5f613678826135f7565b613682818561365e565b93506136928185602086016126d0565b61369b816126de565b840191505092915050565b5f6040820190506136b95f830185612932565b81810360208301526136cb818461366e565b90509392505050565b50565b5f6136e25f83613601565b91506136ed826136d4565b5f82019050919050565b5f613701826136d7565b9150819050919050565b7f537464436865617473206465706c6f79436f6465546f28737472696e672c62795f8201527f7465732c75696e743235362c61646472657373293a204661696c656420746f2060208201527f6372656174652072756e74696d652062797465636f64652e0000000000000000604082015250565b5f61378b605883612eb5565b91506137968261370b565b606082019050919050565b5f6020820190508181035f8301526137b88161377f565b9050919050565b5f81905092915050565b5f6137d3826126b6565b6137dd81856137bf565b93506137ed8185602086016126d0565b80840191505092915050565b5f61380482846137c9565b915081905092915050565b6138188161255b565b8114613822575f80fd5b50565b5f815190506138338161380f565b92915050565b5f6020828403121561384e5761384d6132a6565b5b5f61385b84828501613825565b91505092915050565b5f6040820190506138775f830185612932565b8181036020830152613889818461343a565b9050939250505056fe608060405234801561000f575f80fd5b506040516118ff3803806118ff83398181016040528101906100319190610235565b825f908161003f91906104ca565b50816001908161004f91906104ca565b508060025f6101000a81548160ff021916908360ff1602179055503360045f6101000a81548173ffffffffffffffffffffffffffffffffffffffff021916908373ffffffffffffffffffffffffffffffffffffffff160217905550505050610599565b5f604051905090565b5f80fd5b5f80fd5b5f80fd5b5f80fd5b5f601f19601f8301169050919050565b7f4e487b71000000000000000000000000000000000000000000000000000000005f52604160045260245ffd5b610111826100cb565b810181811067ffffffffffffffff821117156101305761012f6100db565b5b80604052505050565b5f6101426100b2565b905061014e8282610108565b919050565b5f67ffffffffffffffff82111561016d5761016c6100db565b5b610176826100cb565b9050602081019050919050565b8281835e5f83830152505050565b5f6101a361019e84610153565b610139565b9050828152602081018484840111156101bf576101be6100c7565b5b6101ca848285610183565b509392505050565b5f82601f8301126101e6576101e56100c3565b5b81516101f6848260208601610191565b91505092915050565b5f60ff82169050919050565b610214816101ff565b811461021e575f80fd5b50565b5f8151905061022f8161020b565b92915050565b5f805f6060848603121561024c5761024b6100bb565b5b5f84015167ffffffffffffffff811115610269576102686100bf565b5b610275868287016101d2565b935050602084015167ffffffffffffffff811115610296576102956100bf565b5b6102a2868287016101d2565b92505060406102b386828701610221565b9150509250925092565b5f81519050919050565b7f4e487b71000000000000000000000000000000000000000000000000000000005f52602260045260245ffd5b5f600282049050600182168061030b57607f821691505b60208210810361031e5761031d6102c7565b5b50919050565b5f819050815f5260205f209050919050565b5f6020601f8301049050919050565b5f82821b905092915050565b5f600883026103807fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff82610345565b61038a8683610345565b95508019841693508086168417925050509392505050565b5f819050919050565b5f819050919050565b5f6103ce6103c96103c4846103a2565b6103ab565b6103a2565b9050919050565b5f819050919050565b6103e7836103b4565b6103fb6103f3826103d5565b848454610351565b825550505050565b5f90565b61040f610403565b61041a8184846103de565b505050565b5b8181101561043d576104325f82610407565b600181019050610420565b5050565b601f8211156104825761045381610324565b61045c84610336565b8101602085101561046b578190505b61047f61047785610336565b83018261041f565b50505b505050565b5f82821c905092915050565b5f6104a25f1984600802610487565b1980831691505092915050565b5f6104ba8383610493565b9150826002028217905092915050565b6104d3826102bd565b67ffffffffffffffff8111156104ec576104eb6100db565b5b6104f682546102f4565b610501828285610441565b5f60209050601f831160018114610532575f8415610520578287015190505b61052a85826104af565b865550610591565b601f19841661054086610324565b5f5b8281101561056757848901518255600182019150602085019450602081019050610542565b868310156105845784890151610580601f891682610493565b8355505b6001600288020188555050505b505050505050565b611359806105a65f395ff3fe608060405234801561000f575f80fd5b50600436106100fe575f3560e01c806370a0823111610095578063c501562811610064578063c5015628146102ae578063dd62ed3e146102cc578063e2919faf146102fc578063f2fde38b1461031a576100fe565b806370a08231146102125780638da5cb5b1461024257806395d89b4114610260578063a9059cbb1461027e576100fe565b806323b872dd116100d157806323b872dd1461018a578063313ce567146101ba57806340c10f19146101d8578063705e75c2146101f4576100fe565b806306fdde0314610102578063095ea7b31461012057806318160ddd146101505780631dfc984d1461016e575b5f80fd5b61010a610336565b6040516101179190610cdf565b60405180910390f35b61013a60048036038101906101359190610d90565b6103c1565b6040516101479190610de8565b60405180910390f35b610158610449565b6040516101659190610e10565b60405180910390f35b61018860048036038101906101839190610e53565b61044f565b005b6101a4600480360381019061019f9190610e7e565b61046b565b6040516101b19190610de8565b60405180910390f35b6101c2610735565b6040516101cf9190610ee9565b60405180910390f35b6101f260048036038101906101ed9190610d90565b610747565b005b6101fc610845565b6040516102099190610de8565b60405180910390f35b61022c60048036038101906102279190610f02565b610857565b6040516102399190610e10565b60405180910390f35b61024a61086c565b6040516102579190610f3c565b60405180910390f35b610268610891565b6040516102759190610cdf565b60405180910390f35b61029860048036038101906102939190610d90565b61091d565b6040516102a59190610de8565b60405180910390f35b6102b6610ae4565b6040516102c39190610f3c565b60405180910390f35b6102e660048036038101906102e19190610f55565b610b09565b6040516102f39190610e10565b60405180910390f35b610304610b29565b6040516103119190610e10565b60405180910390f35b610334600480360381019061032f9190610f02565b610b2f565b005b5f805461034290610fc0565b80601f016020809104026020016040519081016040528092919081815260200182805461036e90610fc0565b80156103b95780601f10610390576101008083540402835291602001916103b9565b820191905f5260205f20905b81548152906001019060200180831161039c57829003601f168201915b505050505081565b5f8160065f3373ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff1681526020019081526020015f205f8573ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff1681526020019081526020015f20819055506001905092915050565b60035481565b8060095f6101000a81548160ff02191690831515021790555050565b5f60095f9054906101000a900460ff16156104bb576040517f08c379a00000000000000000000000000000000000000000000000000000000081526004016104b29061103a565b60405180910390fd5b8160055f8673ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff1681526020019081526020015f2054101561053b576040517f08c379a0000000000000000000000000000000000000000000000000000000008152600401610532906110c8565b60405180910390fd5b8160065f8673ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff1681526020019081526020015f205f3373ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff1681526020019081526020015f205410156105f6576040517f08c379a00000000000000000000000000000000000000000000000000000000081526004016105ed90611156565b60405180910390fd5b8160065f8673ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff1681526020019081526020015f205f3373ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff1681526020019081526020015f205f82825461067d91906111a1565b925050819055508160055f8673ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff1681526020019081526020015f205f8282546106d091906111a1565b925050819055508160055f8573ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff1681526020019081526020015f205f82825461072391906111d4565b92505081905550600190509392505050565b60025f9054906101000a900460ff1681565b60045f9054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff163373ffffffffffffffffffffffffffffffffffffffff16146107d6576040517f08c379a00000000000000000000000000000000000000000000000000000000081526004016107cd90611277565b60405180910390fd5b8060035f8282546107e791906111d4565b925050819055508060055f8473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff1681526020019081526020015f205f82825461083a91906111d4565b925050819055505050565b60095f9054906101000a900460ff1681565b6005602052805f5260405f205f915090505481565b60045f9054906101000a900473ffffffffffffffffffffffffffffffffffffffff1681565b6001805461089e90610fc0565b80601f01602080910402602001604051908101604052809291908181526020018280546108ca90610fc0565b80156109155780601f106108ec57610100808354040283529160200191610915565b820191905f5260205f20905b8154815290600101906020018083116108f857829003601f168201915b505050505081565b5f60095f9054906101000a900460ff161561096d576040517f08c379a00000000000000000000000000000000000000000000000000000000081526004016109649061103a565b60405180910390fd5b8160055f3373ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff1681526020019081526020015f205410156109ed576040517f08c379a00000000000000000000000000000000000000000000000000000000081526004016109e4906110c8565b60405180910390fd5b8160055f3373ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff1681526020019081526020015f205f828254610a3991906111a1565b925050819055508160055f8573ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff1681526020019081526020015f205f828254610a8c91906111d4565b92505081905550816008819055508260075f6101000a81548173ffffffffffffffffffffffffffffffffffffffff021916908373ffffffffffffffffffffffffffffffffffffffff1602179055506001905092915050565b60075f9054906101000a900473ffffffffffffffffffffffffffffffffffffffff1681565b6006602052815f5260405f20602052805f5260405f205f91509150505481565b60085481565b60045f9054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff163373ffffffffffffffffffffffffffffffffffffffff1614610bbe576040517f08c379a0000000000000000000000000000000000000000000000000000000008152600401610bb590611277565b60405180910390fd5b5f73ffffffffffffffffffffffffffffffffffffffff168173ffffffffffffffffffffffffffffffffffffffff1603610c2c576040517f08c379a0000000000000000000000000000000000000000000000000000000008152600401610c2390611305565b60405180910390fd5b8060045f6101000a81548173ffffffffffffffffffffffffffffffffffffffff021916908373ffffffffffffffffffffffffffffffffffffffff16021790555050565b5f81519050919050565b5f82825260208201905092915050565b8281835e5f83830152505050565b5f601f19601f8301169050919050565b5f610cb182610c6f565b610cbb8185610c79565b9350610ccb818560208601610c89565b610cd481610c97565b840191505092915050565b5f6020820190508181035f830152610cf78184610ca7565b905092915050565b5f80fd5b5f73ffffffffffffffffffffffffffffffffffffffff82169050919050565b5f610d2c82610d03565b9050919050565b610d3c81610d22565b8114610d46575f80fd5b50565b5f81359050610d5781610d33565b92915050565b5f819050919050565b610d6f81610d5d565b8114610d79575f80fd5b50565b5f81359050610d8a81610d66565b92915050565b5f8060408385031215610da657610da5610cff565b5b5f610db385828601610d49565b9250506020610dc485828601610d7c565b9150509250929050565b5f8115159050919050565b610de281610dce565b82525050565b5f602082019050610dfb5f830184610dd9565b92915050565b610e0a81610d5d565b82525050565b5f602082019050610e235f830184610e01565b92915050565b610e3281610dce565b8114610e3c575f80fd5b50565b5f81359050610e4d81610e29565b92915050565b5f60208284031215610e6857610e67610cff565b5b5f610e7584828501610e3f565b91505092915050565b5f805f60608486031215610e9557610e94610cff565b5b5f610ea286828701610d49565b9350506020610eb386828701610d49565b9250506040610ec486828701610d7c565b9150509250925092565b5f60ff82169050919050565b610ee381610ece565b82525050565b5f602082019050610efc5f830184610eda565b92915050565b5f60208284031215610f1757610f16610cff565b5b5f610f2484828501610d49565b91505092915050565b610f3681610d22565b82525050565b5f602082019050610f4f5f830184610f2d565b92915050565b5f8060408385031215610f6b57610f6a610cff565b5b5f610f7885828601610d49565b9250506020610f8985828601610d49565b9150509250929050565b7f4e487b71000000000000000000000000000000000000000000000000000000005f52602260045260245ffd5b5f6002820490506001821680610fd757607f821691505b602082108103610fea57610fe9610f93565b5b50919050565b7f4d6f636b4552433230546f6b656e3a20526576657274205265717565737465645f82015250565b5f611024602083610c79565b915061102f82610ff0565b602082019050919050565b5f6020820190508181035f83015261105181611018565b9050919050565b7f4d6f636b4552433230546f6b656e3a20496e73756666696369656e742062616c5f8201527f616e636500000000000000000000000000000000000000000000000000000000602082015250565b5f6110b2602483610c79565b91506110bd82611058565b604082019050919050565b5f6020820190508181035f8301526110df816110a6565b9050919050565b7f4d6f636b4552433230546f6b656e3a20496e73756666696369656e7420616c6c5f8201527f6f77616e63650000000000000000000000000000000000000000000000000000602082015250565b5f611140602683610c79565b915061114b826110e6565b604082019050919050565b5f6020820190508181035f83015261116d81611134565b9050919050565b7f4e487b71000000000000000000000000000000000000000000000000000000005f52601160045260245ffd5b5f6111ab82610d5d565b91506111b683610d5d565b92508282039050818111156111ce576111cd611174565b5b92915050565b5f6111de82610d5d565b91506111e983610d5d565b925082820190508082111561120157611200611174565b5b92915050565b7f4d6f636b4552433230546f6b656e3a2063616c6c6572206973206e6f742074685f8201527f65206f776e657200000000000000000000000000000000000000000000000000602082015250565b5f611261602783610c79565b915061126c82611207565b604082019050919050565b5f6020820190508181035f83015261128e81611255565b9050919050565b7f4d6f636b4552433230546f6b656e3a206e6577206f776e6572206973207468655f8201527f207a65726f206164647265737300000000000000000000000000000000000000602082015250565b5f6112ef602d83610c79565b91506112fa82611295565b604082019050919050565b5f6020820190508181035f83015261131c816112e3565b905091905056fea264697066735822122074efed53d7d27228a89ac8da294bc7db7f579b8a05b65311ada62eaf5fb7383564736f6c634300081a003360e0604052683635c9adc5dea0000060035534801561001c575f80fd5b50604051613046380380613046833981810160405281019061003e9190610410565b815f73ffffffffffffffffffffffffffffffffffffffff168173ffffffffffffffffffffffffffffffffffffffff16036100af575f6040517f1e4fbdf70000000000000000000000000000000000000000000000000000000081526004016100a69190610496565b60405180910390fd5b6100be8161020a60201b60201c565b505f73ffffffffffffffffffffffffffffffffffffffff168573ffffffffffffffffffffffffffffffffffffffff1603610124576040517fba0c1ac200000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b8473ffffffffffffffffffffffffffffffffffffffff1660c08173ffffffffffffffffffffffffffffffffffffffff16815250508373ffffffffffffffffffffffffffffffffffffffff1660808173ffffffffffffffffffffffffffffffffffffffff16815250508273ffffffffffffffffffffffffffffffffffffffff1660a08173ffffffffffffffffffffffffffffffffffffffff16815250508060025f6101000a81548173ffffffffffffffffffffffffffffffffffffffff021916908373ffffffffffffffffffffffffffffffffffffffff16021790555050505050506104af565b60015f6101000a81549073ffffffffffffffffffffffffffffffffffffffff021916905561023d8161024060201b60201c565b50565b5f805f9054906101000a900473ffffffffffffffffffffffffffffffffffffffff169050815f806101000a81548173ffffffffffffffffffffffffffffffffffffffff021916908373ffffffffffffffffffffffffffffffffffffffff1602179055508173ffffffffffffffffffffffffffffffffffffffff168173ffffffffffffffffffffffffffffffffffffffff167f8be0079c531659141344cd1fd0a4f28419497f9722a3daafe3b4186f6b6457e060405160405180910390a35050565b5f80fd5b5f73ffffffffffffffffffffffffffffffffffffffff82169050919050565b5f61032e82610305565b9050919050565b61033e81610324565b8114610348575f80fd5b50565b5f8151905061035981610335565b92915050565b5f61036982610324565b9050919050565b6103798161035f565b8114610383575f80fd5b50565b5f8151905061039481610370565b92915050565b5f6103a482610324565b9050919050565b6103b48161039a565b81146103be575f80fd5b50565b5f815190506103cf816103ab565b92915050565b5f6103df82610324565b9050919050565b6103ef816103d5565b81146103f9575f80fd5b50565b5f8151905061040a816103e6565b92915050565b5f805f805f60a0868803121561042957610428610301565b5b5f6104368882890161034b565b955050602061044788828901610386565b9450506040610458888289016103c1565b93505060606104698882890161034b565b925050608061047a888289016103fc565b9150509295509295909350565b61049081610324565b82525050565b5f6020820190506104a95f830184610487565b92915050565b60805160a05160c051612b356105115f395f81816102d60152610f9a01525f81816104e4015281816107a4015281816109ef01528181610b4201528181610dcf01528181610eec015261117201525f8181610a1301526114e80152612b355ff3fe608060405234801561000f575f80fd5b50600436106100fe575f3560e01c80636905028c116100955780638da5cb5b116100645780638da5cb5b1461024c578063e30c39781461026a578063e69ec65314610288578063f2fde38b146102b8576100fe565b80636905028c146101ec578063715018a61461021c57806379ba50971461022657806383f1a99114610230576100fe565b806345863322116100d1578063458633221461017857806351f3b4bd146101945780635246a591146101b057806362308e85146101ce576100fe565b8063126a8024146101025780631aeffea914610120578063252cf2d21461013e578063282567b41461015c575b5f80fd5b61010a6102d4565b6040516101179190611de8565b60405180910390f35b6101286102f8565b6040516101359190611e5c565b60405180910390f35b61014661031d565b6040516101539190611e8d565b60405180910390f35b61017660048036038101906101719190611edd565b610323565b005b610192600480360381019061018d9190611f43565b610375565b005b6101ae60048036038101906101a99190611f98565b61043b565b005b6101b86109ed565b6040516101c59190611ff6565b60405180910390f35b6101d6610a11565b6040516101e3919061202f565b60405180910390f35b61020660048036038101906102019190611edd565b610a35565b6040516102139190611de8565b60405180910390f35b610224610a65565b005b61022e610a78565b005b61024a6004803603810190610245919061206a565b610b06565b005b61025461127e565b6040516102619190611de8565b60405180910390f35b6102726112a5565b60405161027f9190611de8565b60405180910390f35b6102a2600480360381019061029d91906120a8565b6112cd565b6040516102af91906120ed565b60405180910390f35b6102d260048036038101906102cd91906120a8565b6112ea565b005b7f000000000000000000000000000000000000000000000000000000000000000081565b60025f9054906101000a900473ffffffffffffffffffffffffffffffffffffffff1681565b60035481565b61032b611396565b5f6003549050816003819055507fd18c85fe8a5776467c327fa33312c6113129233ddb47deabaa91b8396b8158798183604051610369929190612106565b60405180910390a15050565b61037d611396565b8073ffffffffffffffffffffffffffffffffffffffff1660025f9054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff167f7606bd4a057092573eb59005c3ee8b72a9939ed0f677304d644b87d3bcb1c33e60405160405180910390a38060025f6101000a81548173ffffffffffffffffffffffffffffffffffffffff021916908373ffffffffffffffffffffffffffffffffffffffff16021790555050565b610443611396565b5f820361047c576040517f325e582700000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b5f73ffffffffffffffffffffffffffffffffffffffff168173ffffffffffffffffffffffffffffffffffffffff16036104e1576040517f7efc4d2000000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b5f7f000000000000000000000000000000000000000000000000000000000000000073ffffffffffffffffffffffffffffffffffffffff16637ba03aad846040518263ffffffff1660e01b815260040161053b9190611e8d565b60c060405180830381865afa158015610556573d5f803e3d5ffd5b505050506040513d601f19601f8201168201806040525081019061057a9190612318565b5090505f815f015190505f826020015190505f8273ffffffffffffffffffffffffffffffffffffffff166370a08231866040518263ffffffff1660e01b81526004016105c69190611de8565b602060405180830381865afa1580156105e1573d5f803e3d5ffd5b505050506040513d601f19601f82011682018060405250810190610605919061236a565b90505f8273ffffffffffffffffffffffffffffffffffffffff166370a08231876040518263ffffffff1660e01b81526004016106419190611de8565b602060405180830381865afa15801561065c573d5f803e3d5ffd5b505050506040513d601f19601f82011682018060405250810190610680919061236a565b90505f600160116040516020016106989291906123d5565b60405160208183030381529060405290505f600267ffffffffffffffff8111156106c5576106c4612141565b5b6040519080825280602002602001820160405280156106f857816020015b60608152602001906001900390816106e35790505b509050885f805f60405180602001604052805f81525060405160200161072295949392919061248a565b604051602081830303815290604052815f81518110610744576107436124e2565b5b60200260200101819052508585896040516020016107649392919061252f565b60405160208183030381529060405281600181518110610787576107866124e2565b5b60200260200101819052505f603c426107a09190612591565b90507f000000000000000000000000000000000000000000000000000000000000000073ffffffffffffffffffffffffffffffffffffffff1663dd46508f84846040516020016107f19291906126c7565b604051602081830303815290604052836040518363ffffffff1660e01b815260040161081e9291906126fc565b5f604051808303815f87803b158015610835575f80fd5b505af1158015610847573d5f803e3d5ffd5b505050505f8773ffffffffffffffffffffffffffffffffffffffff166370a082318b6040518263ffffffff1660e01b81526004016108859190611de8565b602060405180830381865afa1580156108a0573d5f803e3d5ffd5b505050506040513d601f19601f820116820180604052508101906108c4919061236a565b90505f8773ffffffffffffffffffffffffffffffffffffffff166370a082318c6040518263ffffffff1660e01b81526004016109009190611de8565b602060405180830381865afa15801561091b573d5f803e3d5ffd5b505050506040513d601f19601f8201168201806040525081019061093f919061236a565b90505f878361094e919061272a565b90505f878361095d919061272a565b90508973ffffffffffffffffffffffffffffffffffffffff168b73ffffffffffffffffffffffffffffffffffffffff168e73ffffffffffffffffffffffffffffffffffffffff167f572f183ae7932bec57f7cba7466e8531bc5f455f1df21554b0b1a1c2d0ff48f385856040516109d5929190612106565b60405180910390a45050505050505050505050505050565b7f000000000000000000000000000000000000000000000000000000000000000081565b7f000000000000000000000000000000000000000000000000000000000000000081565b6005602052805f5260405f205f915054906101000a900473ffffffffffffffffffffffffffffffffffffffff1681565b610a6d611396565b610a765f61141d565b565b5f610a8161144d565b90508073ffffffffffffffffffffffffffffffffffffffff16610aa26112a5565b73ffffffffffffffffffffffffffffffffffffffff1614610afa57806040517f118cdaa7000000000000000000000000000000000000000000000000000000008152600401610af19190611de8565b60405180910390fd5b610b038161141d565b50565b5f8203610b3f576040517f325e582700000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b5f7f000000000000000000000000000000000000000000000000000000000000000073ffffffffffffffffffffffffffffffffffffffff16637ba03aad846040518263ffffffff1660e01b8152600401610b999190611e8d565b60c060405180830381865afa158015610bb4573d5f803e3d5ffd5b505050506040513d601f19601f82011682018060405250810190610bd89190612318565b509050815f016020810190610bed9190612771565b73ffffffffffffffffffffffffffffffffffffffff16815f015173ffffffffffffffffffffffffffffffffffffffff16141580610c6c5750816020016020810190610c389190612771565b73ffffffffffffffffffffffffffffffffffffffff16816020015173ffffffffffffffffffffffffffffffffffffffff1614155b80610c975750816040016020810190610c8591906127b0565b62ffffff16816040015162ffffff1614155b80610cbe5750816060016020810190610cb091906127ef565b60020b816060015160020b14155b80610d0b5750816080016020810190610cd79190611f43565b73ffffffffffffffffffffffffffffffffffffffff16816080015173ffffffffffffffffffffffffffffffffffffffff1614155b15610d42576040517fd9d12f8700000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b60025f9054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16816080015173ffffffffffffffffffffffffffffffffffffffff1614610dcc576040517fb99fee9300000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b5f7f000000000000000000000000000000000000000000000000000000000000000073ffffffffffffffffffffffffffffffffffffffff166389097a6a856040518263ffffffff1660e01b8152600401610e269190611e8d565b602060405180830381865afa158015610e41573d5f803e3d5ffd5b505050506040513d601f19601f82011682018060405250810190610e65919061281a565b90505f610e7182611454565b90505f610e7d83611463565b9050610e8c8460600151611472565b60020b8260020b141580610eb25750610ea884606001516114b3565b60020b8160020b14155b15610ee9576040517f82bf81ee00000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b5f7f000000000000000000000000000000000000000000000000000000000000000073ffffffffffffffffffffffffffffffffffffffff16631efeed33886040518263ffffffff1660e01b8152600401610f439190611e8d565b602060405180830381865afa158015610f5e573d5f803e3d5ffd5b505050506040513d601f19601f82011682018060405250810190610f82919061286f565b90505f80610f92878686866114d7565b915091505f807f000000000000000000000000000000000000000000000000000000000000000073ffffffffffffffffffffffffffffffffffffffff16895f015173ffffffffffffffffffffffffffffffffffffffff1603610ffd5788602001519150839050611007565b885f015191508290505b60045f8373ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff1681526020019081526020015f205f9054906101000a900460ff1615611088576040517fe9184aec00000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b6003548110156110c4576040517fe3790cbd00000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b600160045f8473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff1681526020019081526020015f205f6101000a81548160ff0219169083151502179055508160055f8d81526020019081526020015f205f6101000a81548173ffffffffffffffffffffffffffffffffffffffff021916908373ffffffffffffffffffffffffffffffffffffffff16021790555050505050505050507f000000000000000000000000000000000000000000000000000000000000000073ffffffffffffffffffffffffffffffffffffffff166323b872dd3330866040518463ffffffff1660e01b81526004016111cd9392919061289a565b5f604051808303815f87803b1580156111e4575f80fd5b505af11580156111f6573d5f803e3d5ffd5b505050508260055f8581526020019081526020015f205f9054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff167f42e9c725c052ee6448302c3f7f2f1b4c0549a31e6555c62a9f489f32ebc4e776836040516112719190612971565b60405180910390a3505050565b5f805f9054906101000a900473ffffffffffffffffffffffffffffffffffffffff16905090565b5f60015f9054906101000a900473ffffffffffffffffffffffffffffffffffffffff16905090565b6004602052805f5260405f205f915054906101000a900460ff1681565b6112f2611396565b8060015f6101000a81548173ffffffffffffffffffffffffffffffffffffffff021916908373ffffffffffffffffffffffffffffffffffffffff1602179055508073ffffffffffffffffffffffffffffffffffffffff1661135161127e565b73ffffffffffffffffffffffffffffffffffffffff167f38d16b8cac22d99fc7c124b9cd0de2d3fa1faef420bfe791d8c362d765e2270060405160405180910390a350565b61139e61144d565b73ffffffffffffffffffffffffffffffffffffffff166113bc61127e565b73ffffffffffffffffffffffffffffffffffffffff161461141b576113df61144d565b6040517f118cdaa70000000000000000000000000000000000000000000000000000000081526004016114129190611de8565b60405180910390fd5b565b60015f6101000a81549073ffffffffffffffffffffffffffffffffffffffff021916905561144a81611564565b50565b5f33905090565b5f8160081c60020b9050919050565b5f8160201c60020b9050919050565b5f818260020b7ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff2761860020b816114aa576114a961298a565b5b05029050919050565b5f818260020b620d89e860020b816114ce576114cd61298a565b5b05029050919050565b5f805f61152b6114e688611625565b7f000000000000000000000000000000000000000000000000000000000000000073ffffffffffffffffffffffffffffffffffffffff1661163190919063ffffffff16565b50505090505f61153a876116ff565b90505f611546876116ff565b905061155483838389611a59565b9450945050505094509492505050565b5f805f9054906101000a900473ffffffffffffffffffffffffffffffffffffffff169050815f806101000a81548173ffffffffffffffffffffffffffffffffffffffff021916908373ffffffffffffffffffffffffffffffffffffffff1602179055508173ffffffffffffffffffffffffffffffffffffffff168173ffffffffffffffffffffffffffffffffffffffff167f8be0079c531659141344cd1fd0a4f28419497f9722a3daafe3b4186f6b6457e060405160405180910390a35050565b5f60a082209050919050565b5f805f805f61163f86611b4a565b90505f8773ffffffffffffffffffffffffffffffffffffffff16631e2eaeaf836040518263ffffffff1660e01b815260040161167b91906129cf565b602060405180830381865afa158015611696573d5f803e3d5ffd5b505050506040513d601f19601f820116820180604052508101906116ba9190612a12565b905073ffffffffffffffffffffffffffffffffffffffff811695508060a01c60020b945062ffffff8160b81c16935062ffffff8160d01c169250505092959194509250565b5f808260020b92508260ff1d8381018118915050620d89e860020b81111561175b5761175a83638b86327a60e01b7bffffffffffffffffffffffffffffffffffffffffffffffffffffffff1916611b7e90919063ffffffff16565b5b5f600182166ffffcb933bd6fad37aa2d162d1a594001600160801b1802600160801b1890505f60028316146117a45760806ffff97272373d413259a46990580e213a8202901c90505b5f60048316146117c85760806ffff2e50f5f656932ef12357cf3c7fdcc8202901c90505b5f60088316146117ec5760806fffe5caca7e10e4e61c3624eaa0941cd08202901c90505b5f60108316146118105760806fffcb9843d60f6159c9db58835c9266448202901c90505b5f60208316146118345760806fff973b41fa98c081472e6896dfb254c08202901c90505b5f60408316146118585760806fff2ea16466c96a3843ec78b326b528618202901c90505b5f608083161461187c5760806ffe5dee046a99a2a811c461f1969c30538202901c90505b5f6101008316146118a15760806ffcbe86c7900a88aedcffc83b479aa3a48202901c90505b5f6102008316146118c65760806ff987a7253ac413176f2b074cf7815e548202901c90505b5f6104008316146118eb5760806ff3392b0822b70005940c7a398e4b70f38202901c90505b5f6108008316146119105760806fe7159475a2c29b7443b29c7fa6e889d98202901c90505b5f6110008316146119355760806fd097f3bdfd2022b8845ad8f792aa58258202901c90505b5f61200083161461195a5760806fa9f746462d870fdf8a65dc1f90e061e58202901c90505b5f61400083161461197f5760806f70d869a156d2a1b890bb3df62baf32f78202901c90505b5f6180008316146119a45760806f31be135f97d08fd981231505542fcfa68202901c90505b5f620100008316146119ca5760806f09aa508b5b7a84e1c677de54f3e99bc98202901c90505b5f620200008316146119ef5760806e5d6af8dedb81196699c329225ee6048202901c90505b5f62040000831614611a135760806d2216e584f5fa1ea926041bedfe988202901c90505b5f62080000831614611a355760806b048a170391f7dc42444e8fa28202901c90505b5f841315611a4457805f190490505b60018060201b03810160201c92505050919050565b5f808373ffffffffffffffffffffffffffffffffffffffff168573ffffffffffffffffffffffffffffffffffffffff161115611a9a57838580955081965050505b8473ffffffffffffffffffffffffffffffffffffffff168673ffffffffffffffffffffffffffffffffffffffff1611611adf57611ad8858585611b8d565b9150611b41565b8373ffffffffffffffffffffffffffffffffffffffff168673ffffffffffffffffffffffffffffffffffffffff161015611b3257611b1e868585611b8d565b9150611b2b858785611c52565b9050611b40565b611b3d858585611c52565b90505b5b94509492505050565b5f8160065f1b604051602001611b61929190612a5d565b604051602081830303815290604052805190602001209050919050565b815f528060020b60045260245ffd5b5f8273ffffffffffffffffffffffffffffffffffffffff168473ffffffffffffffffffffffffffffffffffffffff161115611bcd57828480945081955050505b8373ffffffffffffffffffffffffffffffffffffffff16611c3f606060ff16846fffffffffffffffffffffffffffffffff16901b8686611c0d9190612a88565b73ffffffffffffffffffffffffffffffffffffffff168673ffffffffffffffffffffffffffffffffffffffff16611ce6565b611c499190612acf565b90509392505050565b5f8273ffffffffffffffffffffffffffffffffffffffff168473ffffffffffffffffffffffffffffffffffffffff161115611c9257828480945081955050505b611cdd826fffffffffffffffffffffffffffffffff168585611cb49190612a88565b73ffffffffffffffffffffffffffffffffffffffff166c01000000000000000000000000611ce6565b90509392505050565b5f8083850290505f801985870982811083820303915050808411611d08575f80fd5b5f8103611d1b5783820492505050611da2565b5f8486880990508281118203915080830392505f85865f0316905080860495508084049350600181825f0304019050808302841793505f600287600302189050808702600203810290508087026002038102905080870260020381029050808702600203810290508087026002038102905080870260020381029050808502955050505050505b9392505050565b5f73ffffffffffffffffffffffffffffffffffffffff82169050919050565b5f611dd282611da9565b9050919050565b611de281611dc8565b82525050565b5f602082019050611dfb5f830184611dd9565b92915050565b5f819050919050565b5f611e24611e1f611e1a84611da9565b611e01565b611da9565b9050919050565b5f611e3582611e0a565b9050919050565b5f611e4682611e2b565b9050919050565b611e5681611e3c565b82525050565b5f602082019050611e6f5f830184611e4d565b92915050565b5f819050919050565b611e8781611e75565b82525050565b5f602082019050611ea05f830184611e7e565b92915050565b5f604051905090565b5f80fd5b611ebc81611e75565b8114611ec6575f80fd5b50565b5f81359050611ed781611eb3565b92915050565b5f60208284031215611ef257611ef1611eaf565b5b5f611eff84828501611ec9565b91505092915050565b5f611f1282611dc8565b9050919050565b611f2281611f08565b8114611f2c575f80fd5b50565b5f81359050611f3d81611f19565b92915050565b5f60208284031215611f5857611f57611eaf565b5b5f611f6584828501611f2f565b91505092915050565b611f7781611dc8565b8114611f81575f80fd5b50565b5f81359050611f9281611f6e565b92915050565b5f8060408385031215611fae57611fad611eaf565b5b5f611fbb85828601611ec9565b9250506020611fcc85828601611f84565b9150509250929050565b5f611fe082611e2b565b9050919050565b611ff081611fd6565b82525050565b5f6020820190506120095f830184611fe7565b92915050565b5f61201982611e2b565b9050919050565b6120298161200f565b82525050565b5f6020820190506120425f830184612020565b92915050565b5f80fd5b5f60a0828403121561206157612060612048565b5b81905092915050565b5f8060c083850312156120805761207f611eaf565b5b5f61208d85828601611ec9565b925050602061209e8582860161204c565b9150509250929050565b5f602082840312156120bd576120bc611eaf565b5b5f6120ca84828501611f84565b91505092915050565b5f8115159050919050565b6120e7816120d3565b82525050565b5f6020820190506121005f8301846120de565b92915050565b5f6040820190506121195f830185611e7e565b6121266020830184611e7e565b9392505050565b5f80fd5b5f601f19601f8301169050919050565b7f4e487b71000000000000000000000000000000000000000000000000000000005f52604160045260245ffd5b61217782612131565b810181811067ffffffffffffffff8211171561219657612195612141565b5b80604052505050565b5f6121a8611ea6565b90506121b4828261216e565b919050565b6121c281611dc8565b81146121cc575f80fd5b50565b5f815190506121dd816121b9565b92915050565b5f62ffffff82169050919050565b6121fa816121e3565b8114612204575f80fd5b50565b5f81519050612215816121f1565b92915050565b5f8160020b9050919050565b6122308161221b565b811461223a575f80fd5b50565b5f8151905061224b81612227565b92915050565b5f8151905061225f81611f19565b92915050565b5f60a0828403121561227a5761227961212d565b5b61228460a061219f565b90505f612293848285016121cf565b5f8301525060206122a6848285016121cf565b60208301525060406122ba84828501612207565b60408301525060606122ce8482850161223d565b60608301525060806122e284828501612251565b60808301525092915050565b6122f781611e75565b8114612301575f80fd5b50565b5f81519050612312816122ee565b92915050565b5f8060c0838503121561232e5761232d611eaf565b5b5f61233b85828601612265565b92505060a061234c85828601612304565b9150509250929050565b5f8151905061236481611eb3565b92915050565b5f6020828403121561237f5761237e611eaf565b5b5f61238c84828501612356565b91505092915050565b5f60ff82169050919050565b5f8160f81b9050919050565b5f6123b7826123a1565b9050919050565b6123cf6123ca82612395565b6123ad565b82525050565b5f6123e082856123be565b6001820191506123f082846123be565b6001820191508190509392505050565b5f6fffffffffffffffffffffffffffffffff82169050919050565b61242481612400565b82525050565b5f81519050919050565b5f82825260208201905092915050565b8281835e5f83830152505050565b5f61245c8261242a565b6124668185612434565b9350612476818560208601612444565b61247f81612131565b840191505092915050565b5f60a08201905061249d5f830188611e7e565b6124aa6020830187611e7e565b6124b7604083018661241b565b6124c4606083018561241b565b81810360808301526124d68184612452565b90509695505050505050565b7f4e487b71000000000000000000000000000000000000000000000000000000005f52603260045260245ffd5b5f61251982611e2b565b9050919050565b6125298161250f565b82525050565b5f6060820190506125425f830186612520565b61254f6020830185612520565b61255c6040830184611dd9565b949350505050565b7f4e487b71000000000000000000000000000000000000000000000000000000005f52601160045260245ffd5b5f61259b82611e75565b91506125a683611e75565b92508282019050808211156125be576125bd612564565b5b92915050565b5f81519050919050565b5f82825260208201905092915050565b5f819050602082019050919050565b5f82825260208201905092915050565b5f6126078261242a565b61261181856125ed565b9350612621818560208601612444565b61262a81612131565b840191505092915050565b5f61264083836125fd565b905092915050565b5f602082019050919050565b5f61265e826125c4565b61266881856125ce565b93508360208202850161267a856125de565b805f5b858110156126b557848403895281516126968582612635565b94506126a183612648565b925060208a0199505060018101905061267d565b50829750879550505050505092915050565b5f6040820190508181035f8301526126df8185612452565b905081810360208301526126f38184612654565b90509392505050565b5f6040820190508181035f8301526127148185612452565b90506127236020830184611e7e565b9392505050565b5f61273482611e75565b915061273f83611e75565b925082820390508181111561275757612756612564565b5b92915050565b5f8135905061276b816121b9565b92915050565b5f6020828403121561278657612785611eaf565b5b5f6127938482850161275d565b91505092915050565b5f813590506127aa816121f1565b92915050565b5f602082840312156127c5576127c4611eaf565b5b5f6127d28482850161279c565b91505092915050565b5f813590506127e981612227565b92915050565b5f6020828403121561280457612803611eaf565b5b5f612811848285016127db565b91505092915050565b5f6020828403121561282f5761282e611eaf565b5b5f61283c84828501612304565b91505092915050565b61284e81612400565b8114612858575f80fd5b50565b5f8151905061286981612845565b92915050565b5f6020828403121561288457612883611eaf565b5b5f6128918482850161285b565b91505092915050565b5f6060820190506128ad5f830186611dd9565b6128ba6020830185611dd9565b6128c76040830184611e7e565b949350505050565b6128d88161250f565b82525050565b6128e7816121e3565b82525050565b6128f68161221b565b82525050565b61290581611e3c565b82525050565b60a082015f82015161291f5f8501826128cf565b50602082015161293260208501826128cf565b50604082015161294560408501826128de565b50606082015161295860608501826128ed565b50608082015161296b60808501826128fc565b50505050565b5f60a0820190506129845f83018461290b565b92915050565b7f4e487b71000000000000000000000000000000000000000000000000000000005f52601260045260245ffd5b5f819050919050565b6129c9816129b7565b82525050565b5f6020820190506129e25f8301846129c0565b92915050565b6129f1816129b7565b81146129fb575f80fd5b50565b5f81519050612a0c816129e8565b92915050565b5f60208284031215612a2757612a26611eaf565b5b5f612a34848285016129fe565b91505092915050565b5f819050919050565b612a57612a52826129b7565b612a3d565b82525050565b5f612a688285612a46565b602082019150612a788284612a46565b6020820191508190509392505050565b5f612a9282611da9565b9150612a9d83611da9565b9250828203905073ffffffffffffffffffffffffffffffffffffffff811115612ac957612ac8612564565b5b92915050565b5f612ad982611e75565b9150612ae483611e75565b925082612af457612af361298a565b5b82820490509291505056fea264697066735822122026a8a362917d5849af742bdd4070890c98b53f17ecd950683917fa3e9699607b64736f6c634300081a003360a060405234801561000f575f80fd5b50604051612164380380612164833981810160405281019061003191906102e9565b805f73ffffffffffffffffffffffffffffffffffffffff168173ffffffffffffffffffffffffffffffffffffffff16036100a2575f6040517f1e4fbdf70000000000000000000000000000000000000000000000000000000081526004016100999190610348565b60405180910390fd5b6100b18161016160201b60201c565b505f73ffffffffffffffffffffffffffffffffffffffff168373ffffffffffffffffffffffffffffffffffffffff1603610117576040517f954302aa00000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b8273ffffffffffffffffffffffffffffffffffffffff1660808173ffffffffffffffffffffffffffffffffffffffff16815250508160038190555042600481905550505050610361565b60015f6101000a81549073ffffffffffffffffffffffffffffffffffffffff02191690556101948161019760201b60201c565b50565b5f805f9054906101000a900473ffffffffffffffffffffffffffffffffffffffff169050815f806101000a81548173ffffffffffffffffffffffffffffffffffffffff021916908373ffffffffffffffffffffffffffffffffffffffff1602179055508173ffffffffffffffffffffffffffffffffffffffff168173ffffffffffffffffffffffffffffffffffffffff167f8be0079c531659141344cd1fd0a4f28419497f9722a3daafe3b4186f6b6457e060405160405180910390a35050565b5f80fd5b5f73ffffffffffffffffffffffffffffffffffffffff82169050919050565b5f6102858261025c565b9050919050565b6102958161027b565b811461029f575f80fd5b50565b5f815190506102b08161028c565b92915050565b5f819050919050565b6102c8816102b6565b81146102d2575f80fd5b50565b5f815190506102e3816102bf565b92915050565b5f805f60608486031215610300576102ff610258565b5b5f61030d868287016102a2565b935050602061031e868287016102d5565b925050604061032f868287016102a2565b9150509250925092565b6103428161027b565b82525050565b5f60208201905061035b5f830184610339565b92915050565b608051611ddd6103875f395f818161055301528181610a4601526110060152611ddd5ff3fe608060405234801561000f575f80fd5b5060043610610135575f3560e01c8063a6f19c84116100b6578063ca0dcf161161007a578063ca0dcf1614610327578063dbe2193f14610345578063e30c397814610361578063e9ee2fa91461037f578063f2fde38b1461039d578063fa9ddf09146103b957610135565b8063a6f19c8414610283578063adc9772e146102a1578063ae1a01a2146102bd578063bbc19ab0146102ed578063c2a672e01461030b57610135565b8063715018a6116100fd578063715018a6146101f157806379ba5097146101fb578063862d2d7c146102055780638da5cb5b14610235578063978e08d71461025357610135565b80633710d4c71461013957806347a13cea1461016957806353ed252f1461019957806355a68ed3146101b7578063567e98f9146101d3575b5f80fd5b610153600480360381019061014e919061193d565b6103ea565b6040516101609190611993565b60405180910390f35b610183600480360381019061017e91906119ac565b61046c565b6040516101909190611993565b60405180910390f35b6101a1610551565b6040516101ae91906119e6565b60405180910390f35b6101d160048036038101906101cc91906119ac565b610575565b005b6101db610668565b6040516101e89190611993565b60405180910390f35b6101f961066e565b005b610203610681565b005b61021f600480360381019061021a919061193d565b61070f565b60405161022c9190611993565b60405180910390f35b61023d61072f565b60405161024a91906119e6565b60405180910390f35b61026d600480360381019061026891906119ac565b610756565b60405161027a9190611993565b60405180910390f35b61028b610889565b60405161029891906119e6565b60405180910390f35b6102bb60048036038101906102b69190611a29565b6108ae565b005b6102d760048036038101906102d291906119ac565b610ca6565b6040516102e49190611b1e565b60405180910390f35b6102f5610cf4565b6040516103029190611993565b60405180910390f35b61032560048036038101906103209190611a29565b610cfa565b005b61032f61110a565b60405161033c9190611993565b60405180910390f35b61035f600480360381019061035a9190611b3e565b611110565b005b610369611218565b60405161037691906119e6565b60405180910390f35b610387611240565b6040516103949190611993565b60405180910390f35b6103b760048036038101906103b291906119ac565b611246565b005b6103d360048036038101906103ce91906119ac565b6112f2565b6040516103e1929190611b69565b60405180910390f35b5f60085f8473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff1681526020019081526020015f205f8373ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff1681526020019081526020015f2054905092915050565b5f8060075f8473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff1681526020019081526020015f2090505f815f015414806104bf57505f600654145b156104cd575f91505061054c565b5f60055490505f600454426104e29190611bbd565b90505f811115610521575f600354826104fb9190611bf0565b905061051281670de0b6b3a7640000600654611347565b8361051d9190611c31565b9250505b610546835f01548460010154846105389190611bbd565b670de0b6b3a7640000611347565b93505050505b919050565b7f000000000000000000000000000000000000000000000000000000000000000081565b61057d61142c565b5f73ffffffffffffffffffffffffffffffffffffffff168173ffffffffffffffffffffffffffffffffffffffff16036105e2576040517f954302aa00000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b8060025f6101000a81548173ffffffffffffffffffffffffffffffffffffffff021916908373ffffffffffffffffffffffffffffffffffffffff1602179055508073ffffffffffffffffffffffffffffffffffffffff167fb947d28129d3b40272a411eeee3a2842c6335a0f0269abf492e8c20218bf02b060405160405180910390a250565b60065481565b61067661142c565b61067f5f6114b3565b565b5f61068a6114e3565b90508073ffffffffffffffffffffffffffffffffffffffff166106ab611218565b73ffffffffffffffffffffffffffffffffffffffff161461070357806040517f118cdaa70000000000000000000000000000000000000000000000000000000081526004016106fa91906119e6565b60405180910390fd5b61070c816114b3565b50565b6008602052815f5260405f20602052805f5260405f205f91509150505481565b5f805f9054906101000a900473ffffffffffffffffffffffffffffffffffffffff16905090565b5f60025f9054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff163373ffffffffffffffffffffffffffffffffffffffff16146107dd576040517f8f5c579500000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b6107e56114ea565b5f60075f8473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff1681526020019081526020015f2090505f815f015403610838575f915050610884565b5f816001015460055461084b9190611bbd565b90505f810361085e575f92505050610884565b610874825f015482670de0b6b3a7640000611347565b9250600554826001018190555050505b919050565b60025f9054906101000a900473ffffffffffffffffffffffffffffffffffffffff1681565b5f81036108e7576040517f1f52e43300000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b5f73ffffffffffffffffffffffffffffffffffffffff1660025f9054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff160361096d576040517f954302aa00000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b60025f9054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff1663e69ec653836040518263ffffffff1660e01b81526004016109c791906119e6565b602060405180830381865afa1580156109e2573d5f803e3d5ffd5b505050506040513d601f19601f82011682018060405250810190610a069190611c99565b610a3c576040517fd0b5530500000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b610a446114ea565b7f000000000000000000000000000000000000000000000000000000000000000073ffffffffffffffffffffffffffffffffffffffff166323b872dd3330846040518463ffffffff1660e01b8152600401610aa193929190611cc4565b6020604051808303815f875af1158015610abd573d5f803e3d5ffd5b505050506040513d601f19601f82011682018060405250810190610ae19190611c99565b505f60075f8473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff1681526020019081526020015f20905081815f015f828254610b349190611c31565b9250508190555060055481600101819055508160065f828254610b579190611c31565b925050819055508160085f3373ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff1681526020019081526020015f205f8573ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff1681526020019081526020015f205f828254610be59190611c31565b92505081905550610c3b8360095f3373ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff1681526020019081526020015f2061159490919063ffffffff16565b503373ffffffffffffffffffffffffffffffffffffffff168373ffffffffffffffffffffffffffffffffffffffff167f5dac0c1b1112564a045ba943c9d50270893e8e826c49be8e7073adc713ab7bd784604051610c999190611993565b60405180910390a3505050565b6060610ced60095f8473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff1681526020019081526020015f206115c1565b9050919050565b60045481565b5f8103610d33576040517f1f52e43300000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b5f60075f8473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff1681526020019081526020015f20905081815f01541015610db0576040517ff1a31f7300000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b8160085f3373ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff1681526020019081526020015f205f8573ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff1681526020019081526020015f20541015610e62576040517ff1a31f7300000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b610e6a6114ea565b81815f015f828254610e7c9190611bbd565b9250508190555060055481600101819055508160065f828254610e9f9190611bbd565b925050819055508160085f3373ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff1681526020019081526020015f205f8573ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff1681526020019081526020015f205f828254610f2d9190611bbd565b925050819055505f60085f3373ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff1681526020019081526020015f205f8573ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff1681526020019081526020015f205403611004576110028360095f3373ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff1681526020019081526020015f206115e090919063ffffffff16565b505b7f000000000000000000000000000000000000000000000000000000000000000073ffffffffffffffffffffffffffffffffffffffff1663a9059cbb33846040518363ffffffff1660e01b815260040161105f929190611cf9565b6020604051808303815f875af115801561107b573d5f803e3d5ffd5b505050506040513d601f19601f8201168201806040525081019061109f9190611c99565b503373ffffffffffffffffffffffffffffffffffffffff168373ffffffffffffffffffffffffffffffffffffffff167fd8654fcc8cf5b36d30b3f5e4688fc78118e6d68de60b9994e09902268b57c3e3846040516110fd9190611993565b60405180910390a3505050565b60035481565b61111861072f565b73ffffffffffffffffffffffffffffffffffffffff163373ffffffffffffffffffffffffffffffffffffffff16141580156111a0575060025f9054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff163373ffffffffffffffffffffffffffffffffffffffff1614155b156111d7576040517f5b767c8000000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b806003819055507fe043e3e44450462f070ef41d0ee43c33ea863ea59eaee8da6f27377b8ba88c358160405161120d9190611993565b60405180910390a150565b5f60015f9054906101000a900473ffffffffffffffffffffffffffffffffffffffff16905090565b60055481565b61124e61142c565b8060015f6101000a81548173ffffffffffffffffffffffffffffffffffffffff021916908373ffffffffffffffffffffffffffffffffffffffff1602179055508073ffffffffffffffffffffffffffffffffffffffff166112ad61072f565b73ffffffffffffffffffffffffffffffffffffffff167f38d16b8cac22d99fc7c124b9cd0de2d3fa1faef420bfe791d8c362d765e2270060405160405180910390a350565b5f805f60075f8573ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff1681526020019081526020015f209050805f015481600101549250925050915091565b5f8083850290505f8019858709828110838203039150505f810361137f5783828161137557611374611d20565b5b0492505050611425565b80841161139e5761139d6113985f86146012601161160d565b611626565b5b5f8486880990508281118203915080830392505f855f038616905080860495508084049350600181825f0304019050808302841793505f600287600302189050808702600203810290508087026002038102905080870260020381029050808702600203810290508087026002038102905080870260020381029050808502955050505050505b9392505050565b6114346114e3565b73ffffffffffffffffffffffffffffffffffffffff1661145261072f565b73ffffffffffffffffffffffffffffffffffffffff16146114b1576114756114e3565b6040517f118cdaa70000000000000000000000000000000000000000000000000000000081526004016114a891906119e6565b60405180910390fd5b565b60015f6101000a81549073ffffffffffffffffffffffffffffffffffffffff02191690556114e081611637565b50565b5f33905090565b5f6006540315611592575f600454426115039190611bbd565b90505f81036115125750611592565b5f600354826115219190611bf0565b905061153881670de0b6b3a7640000600654611347565b60055f8282546115489190611c31565b92505081905550426004819055507f22da3973732aa4a277b604da5282200d162428ccee60e8d996fc614e8b3d583e6005546040516115879190611993565b60405180910390a150505b565b5f6115b9835f018373ffffffffffffffffffffffffffffffffffffffff165f1b6116f8565b905092915050565b60605f6115cf835f0161175f565b905060608190508092505050919050565b5f611605835f018373ffffffffffffffffffffffffffffffffffffffff165f1b6117b8565b905092915050565b5f611617846118b4565b82841802821890509392505050565b634e487b715f52806020526024601cfd5b5f805f9054906101000a900473ffffffffffffffffffffffffffffffffffffffff169050815f806101000a81548173ffffffffffffffffffffffffffffffffffffffff021916908373ffffffffffffffffffffffffffffffffffffffff1602179055508173ffffffffffffffffffffffffffffffffffffffff168173ffffffffffffffffffffffffffffffffffffffff167f8be0079c531659141344cd1fd0a4f28419497f9722a3daafe3b4186f6b6457e060405160405180910390a35050565b5f61170383836118bf565b61175557825f0182908060018154018082558091505060019003905f5260205f20015f9091909190915055825f0180549050836001015f8481526020019081526020015f208190555060019050611759565b5f90505b92915050565b6060815f018054806020026020016040519081016040528092919081815260200182805480156117ac57602002820191905f5260205f20905b815481526020019060010190808311611798575b50505050509050919050565b5f80836001015f8481526020019081526020015f205490505f81146118a9575f6001826117e59190611bbd565b90505f6001865f01805490506117fb9190611bbd565b9050808214611861575f865f01828154811061181a57611819611d4d565b5b905f5260205f200154905080875f01848154811061183b5761183a611d4d565b5b905f5260205f20018190555083876001015f8381526020019081526020015f2081905550505b855f0180548061187457611873611d7a565b5b600190038181905f5260205f20015f90559055856001015f8681526020019081526020015f205f9055600193505050506118ae565b5f9150505b92915050565b5f8115159050919050565b5f80836001015f8481526020019081526020015f20541415905092915050565b5f80fd5b5f73ffffffffffffffffffffffffffffffffffffffff82169050919050565b5f61190c826118e3565b9050919050565b61191c81611902565b8114611926575f80fd5b50565b5f8135905061193781611913565b92915050565b5f8060408385031215611953576119526118df565b5b5f61196085828601611929565b925050602061197185828601611929565b9150509250929050565b5f819050919050565b61198d8161197b565b82525050565b5f6020820190506119a65f830184611984565b92915050565b5f602082840312156119c1576119c06118df565b5b5f6119ce84828501611929565b91505092915050565b6119e081611902565b82525050565b5f6020820190506119f95f8301846119d7565b92915050565b611a088161197b565b8114611a12575f80fd5b50565b5f81359050611a23816119ff565b92915050565b5f8060408385031215611a3f57611a3e6118df565b5b5f611a4c85828601611929565b9250506020611a5d85828601611a15565b9150509250929050565b5f81519050919050565b5f82825260208201905092915050565b5f819050602082019050919050565b611a9981611902565b82525050565b5f611aaa8383611a90565b60208301905092915050565b5f602082019050919050565b5f611acc82611a67565b611ad68185611a71565b9350611ae183611a81565b805f5b83811015611b11578151611af88882611a9f565b9750611b0383611ab6565b925050600181019050611ae4565b5085935050505092915050565b5f6020820190508181035f830152611b368184611ac2565b905092915050565b5f60208284031215611b5357611b526118df565b5b5f611b6084828501611a15565b91505092915050565b5f604082019050611b7c5f830185611984565b611b896020830184611984565b9392505050565b7f4e487b71000000000000000000000000000000000000000000000000000000005f52601160045260245ffd5b5f611bc78261197b565b9150611bd28361197b565b9250828203905081811115611bea57611be9611b90565b5b92915050565b5f611bfa8261197b565b9150611c058361197b565b9250828202611c138161197b565b91508282048414831517611c2a57611c29611b90565b5b5092915050565b5f611c3b8261197b565b9150611c468361197b565b9250828201905080821115611c5e57611c5d611b90565b5b92915050565b5f8115159050919050565b611c7881611c64565b8114611c82575f80fd5b50565b5f81519050611c9381611c6f565b92915050565b5f60208284031215611cae57611cad6118df565b5b5f611cbb84828501611c85565b91505092915050565b5f606082019050611cd75f8301866119d7565b611ce460208301856119d7565b611cf16040830184611984565b949350505050565b5f604082019050611d0c5f8301856119d7565b611d196020830184611984565b9392505050565b7f4e487b71000000000000000000000000000000000000000000000000000000005f52601260045260245ffd5b7f4e487b71000000000000000000000000000000000000000000000000000000005f52603260045260245ffd5b7f4e487b71000000000000000000000000000000000000000000000000000000005f52603160045260245ffdfea2646970667358221220ee06c8588c4b378cc7cd825ac3d6fdb13b5db3697da224bc0af511c5fd3903a364736f6c634300081a0033a2646970667358221220107b116d6ccc27f24b84723e37b7aae1f32ba705df9fec0c6cd602ab7321c38b64736f6c634300081a0033","sourceMap":"2257:4052:150:-:0;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;3135:27;;;;;;;;;;;;;:::i;:::-;;;;;;;:::i;:::-;;;;;;;;3169:1154;;;;;;;;;;;;;:::i;:::-;;2907:134:5;;;;;;;;;;;;;:::i;:::-;;;;;;;:::i;:::-;;;;;;;;2535:30:150;;;;;;;;;;;;;:::i;:::-;;;;;;;:::i;:::-;;;;;;;;3823:151:5;;;;;;;;;;;;;:::i;:::-;;;;;;;:::i;:::-;;;;;;;;2495:177:102;;;;;;;;;;;;;:::i;:::-;;;;;;;;;;:::i;:::-;;;;;;;;3684:133:5;;;;;;;;;;;;;:::i;:::-;;;;;;;:::i;:::-;;;;;;;;3385:141;;;;;;;;;;;;;:::i;:::-;;;;;;;:::i;:::-;;;;;;;;2817:73:150;;;;;;;;;;;;;:::i;:::-;;;;;;;:::i;:::-;;;;;;;;4330:1296;;;;;;;;;;;;;:::i;:::-;;2462:30;;;;;;;;;;;;;:::i;:::-;;;;;;;:::i;:::-;;;;;;;;2244:69:102;;;;;;;;;;;;;:::i;:::-;;;;;;;:::i;:::-;;;;;;;;3087:42:150;;;;;;;;;;;;;:::i;:::-;;;;;;;:::i;:::-;;;;;;;;3193:186:5;;;;;;;;;;;;;:::i;:::-;;;;;;;:::i;:::-;;;;;;;;2896:107:150;;;;;;;;;;;;;:::i;:::-;;;;;;;:::i;:::-;;;;;;;;3047:140:5;;;;;;;;;;;;;:::i;:::-;;;;;;;:::i;:::-;;;;;;;;3033:48:150;;;;;;;;;;;;;:::i;:::-;;;;;;;:::i;:::-;;;;;;;;3532:146:5;;;;;;;;;;;;;:::i;:::-;;;;;;;:::i;:::-;;;;;;;;2320:169:102;;;;;;;;;;;;;:::i;:::-;;;;;;;;;;:::i;:::-;;;;;;;;2754:147:5;;;;;;;;;;;;;:::i;:::-;;;;;;;:::i;:::-;;;;;;;;2678:154:102;;;;;;;;;;;;;:::i;:::-;;;;;;;;;:::i;:::-;;;;;;;;2459:141:5;;;;;;;;;;;;;:::i;:::-;;;;;;;:::i;:::-;;;;;;;;1243:204:1;;;;;;;;;;;;;:::i;:::-;;;;;;;:::i;:::-;;;;;;;;2498:30:150;;;;;;;;;;;;;:::i;:::-;;;;;;;:::i;:::-;;;;;;;;2169:69:102;;;;;;;;;;;;;:::i;:::-;;;;;;;:::i;:::-;;;;;;;;2606:142:5;;;;;;;;;;;;;:::i;:::-;;;;;;;:::i;:::-;;;;;;;;1016:26:12;;;;;;;;;;;;;:::i;:::-;;;;;;;:::i;:::-;;;;;;;;3135:27:150;;;;;;;;;;;;;:::o;3169:1154::-;317:28:0;309:37;;3203:13:150;;;3217:9;;;;;;;;;;;3203:24;;;;;;;;;;;;;;;:::i;:::-;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;3295:2;3249:49;;;;;:::i;:::-;;;;;:::i;:::-;;;;;;;;;;;;;;;;;;;;;;;;3238:8;;:60;;;;;;;;;;;;;;;;;;3316:13;3570;1382:7:67;1713:6;1587;1450:7;1319;3378:62:150;:99;:144;:174;3353:231;3316:278;;3604:28;3659:11;;;;;;;;;;;3673:8;;;;;;;;;;;3683:9;;;;;;;;;;;3694:15;;;;;;;;;;;3635:75;;;;;;;;;;;:::i;:::-;;;;;;;;;;;;;3604:106;;3721:71;;;;;;;;;;;;;;;;;;3769:15;3786:5;3721:12;:71::i;:::-;3823:5;3802:4;;:27;;;;;;;;;;;;;;;;;;3877:8;;;;;;;;;;;3901:11;;;;;;;;;;;3932:15;;;;;;;;;;;3950:9;;;;;;;;;;;3976:4;;;;;;;;;;;3849:134;;;;;:::i;:::-;;;;;;;;;:::i;:::-;;;;;;;;;;;;;;;;;;;;;;;;3839:7;;:144;;;;;;;;;;;;;;;;;;4031:8;;;;;;;;;;;4042:3;4047:9;;;;;;;;;;;4003:54;;;;;:::i;:::-;;;;;;;:::i;:::-;;;;;;;;;;;;;;;;;;;;;;;;3993:7;;:64;;;;;;;;;;;;;;;;;;4069:4;;;;;;;;;;;:15;;;4093:7;;;;;;;;;;;4069:33;;;;;;;;;;;;;;;:::i;:::-;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;4113:4;;;;;;;;;;;:15;;;4137:7;;;;;;;;;;;4113:33;;;;;;;;;;;;;;;:::i;:::-;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;4158:7;;;;;;;;;;;:22;;;4188:4;;;;;;;;;;;4158:36;;;;;;;;;;;;;;;:::i;:::-;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;4205:7;;;;;;;;;;;:16;;;4230:4;;;;;;;;;;;4205:31;;;;;;;;;;;;;;;:::i;:::-;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;4248:8;;;;;;;;;;;:26;;;4283:4;;;;;;;;;;;4248:41;;;;;;;;;;;;;;;:::i;:::-;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;317:28:0;309:37;;4299:12:150;;;:14;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;3193:1130;;3169:1154::o;2907:134:5:-;2954:33;3018:16;2999:35;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;2907:134;:::o;2535:30:150:-;;;;;;;;;;;;;:::o;3823:151:5:-;3872:42;3948:19;3926:41;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;:::i;:::-;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;:::i;:::-;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;3823:151;:::o;2495:177:102:-;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;:::o;3684:133:5:-;3730:33;3794:16;3775:35;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;3684:133;:::o;3385:141::-;3433:35;3501:18;3480:39;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;3385:141;:::o;2817:73:150:-;2848:42;2817:73;:::o;4330:1296::-;4423:14;4448:8;;;;;;;;;;;4423:34;;4467:14;2848:42;4467:30;;4508:20;4531:29;4508:52;;317:28:0;309:37;;4592:13:150;;;4606:9;;;;;;;;;;;4592:24;;;;;;;;;;;;;;;:::i;:::-;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;4737:26;4766:2;4737:31;;4779:23;4805:83;4820:6;4828;552:8:68;4867:20:150;4805:14;:83::i;:::-;4779:109;;4915:11;;;;;;;;;;;4902:36;;;4939:8;4949:12;4902:60;;;;;;;;;;;;;;;;:::i;:::-;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;:::i;:::-;;317:28:0;309:37;;4972:12:150;;;:14;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;4999:21;5023:25;;;;;;;;;;;;;;;;;;:8;:25::i;:::-;4999:49;;317:28:0;309:37;;5059:13:150;;;5073;5059:28;;;;;;;;;;;;;;;:::i;:::-;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;5349:30;5382:2;5349:35;;5400:27;5430:87;5445:6;5453;552:8:68;5492:24:150;5430:14;:87::i;:::-;5400:117;;5544:11;;;;;;;;;;;5531:36;;;5568:12;5582;5531:64;;;;;;;;;;;;;;;;:::i;:::-;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;:::i;:::-;;317:28:0;309:37;;5605:12:150;;;:14;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;4412:1214;;;;;;;;4330:1296::o;2462:30::-;;;;;;;;;;;;;:::o;2244:69:102:-;2312:1;2042:49:81;2286:27:102;;;;:::i;:::-;2244:69;:::o;3087:42:150:-;;;;;;;;;;;;;:::o;3193:186:5:-;3249:56;3346:26;3317:55;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;:::i;:::-;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;:::i;:::-;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;3193:186;:::o;2896:107:150:-;2960:42;2896:107;:::o;3047:140:5:-;3095:34;3162:18;3141:39;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;:::i;:::-;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;:::i;:::-;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;3047:140;:::o;3033:48:150:-;3077:4;3033:48;:::o;3532:146:5:-;3580:40;3653:18;3632:39;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;3532:146;:::o;2320:169:102:-;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;:::o;2754:147:5:-;2803:40;2876:18;2855:39;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;2754:147;:::o;2678:154:102:-;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;:::o;2459:141:5:-;2508:34;2575:18;2554:39;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;:::i;:::-;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;:::i;:::-;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;2459:141;:::o;1243:204:1:-;1282:4;1302:7;;;;;;;;;;;1298:143;;;1332:7;;;;;;;;;;;1325:14;;;;1298:143;1428:1;1420:10;;219:28;211:37;;1377:7;;;219:28;211:37;;1398:17;1377:39;;;;;;;;;;;;;;;;:::i;:::-;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;:::i;:::-;:53;;1370:60;;1243:204;;:::o;2498:30:150:-;;;;;;;;;;;;;:::o;2169:69:102:-;2237:1;1862:10:81;2211:27:102;;;;:::i;:::-;2169:69;:::o;2606:142:5:-;2655:35;2723:18;2702:39;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;2606:142;:::o;1016:26:12:-;;;;;;;;;;;;;:::o;30859:144:3:-;30962:34;30975:4;30981;30987:1;30990:5;30962:12;:34::i;:::-;30859:144;;;:::o;5640:665:150:-;5750:18;;:::i;:::-;5805:6;5796:15;;:6;:15;;;:502;;6070:228;;;;;;;;6121:6;6070:228;;;;;;6171:6;6070:228;;;;;;6201:3;6070:228;;;;;;6235:11;6070:228;;;;;;6278:4;;;;;;;;;;;6070:228;;;;;5796:502;;;5826:229;;;;;;;;5877:6;5826:229;;;;;;5927:6;5826:229;;;;;;5957:3;5826:229;;;;;;5991:11;5826:229;;;;;;6035:4;;;;;;;;;;;5826:229;;;;;5796:502;5789:509;;5640:665;;;;;;:::o;20760:125:3:-;20824:12;20858:20;20873:4;20858:14;:20::i;:::-;20848:30;;;;;20760:125;;;:::o;31009:475::-;31127:25;24724:28;24716:37;;31155:10;;;31166:4;31155:16;;;;;;;;;;;;;;;:::i;:::-;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;:::i;:::-;31127:44;;24724:28;24716:37;;31181:7;;;31189:5;31213:12;31227:4;31196:36;;;;;;;;;:::i;:::-;;;;;;;;;;;;;31181:52;;;;;;;;;;;;;;;;:::i;:::-;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;31244:12;31258:28;31290:5;:10;;31308:5;31290:28;;;;;:::i;:::-;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;31243:75;;;;31336:7;31328:108;;;;;;;;;;;;:::i;:::-;;;;;;;;;24724:28;24716:37;;31446:7;;;31454:5;31461:15;31446:31;;;;;;;;;;;;;;;;:::i;:::-;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;31117:367;;;31009:475;;;;:::o;20479:242::-;20549:12;20563:18;20641:4;20624:22;;;;;;;;:::i;:::-;;;;;;;;;;;;;20614:33;;;;;;20606:42;;20593:55;;318:28;310:37;;20665:7;;;20673:10;20665:19;;;;;;;;;;;;;;;:::i;:::-;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;:::i;:::-;20658:26;;318:28;310:37;;20694:8;;;20703:4;20709;20694:20;;;;;;;;;;;;;;;;:::i;:::-;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;20479:242;;;:::o;-1:-1:-1:-;;;;;;;;:::o;:::-;;;;;;;;:::o;:::-;;;;;;;;:::o;:::-;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;:::o;7:126:153:-;44:7;84:42;77:5;73:54;62:65;;7:126;;;:::o;139:60::-;167:3;188:5;181:12;;139:60;;;:::o;205:142::-;255:9;288:53;306:34;315:24;333:5;315:24;:::i;:::-;306:34;:::i;:::-;288:53;:::i;:::-;275:66;;205:142;;;:::o;353:134::-;411:9;444:37;475:5;444:37;:::i;:::-;431:50;;353:134;;;:::o;493:167::-;576:9;609:45;648:5;609:45;:::i;:::-;596:58;;493:167;;;:::o;666:197::-;786:70;850:5;786:70;:::i;:::-;781:3;774:83;666:197;;:::o;869:288::-;995:4;1033:2;1022:9;1018:18;1010:26;;1046:104;1147:1;1136:9;1132:17;1123:6;1046:104;:::i;:::-;869:288;;;;:::o;1163:114::-;1230:6;1264:5;1258:12;1248:22;;1163:114;;;:::o;1283:184::-;1382:11;1416:6;1411:3;1404:19;1456:4;1451:3;1447:14;1432:29;;1283:184;;;;:::o;1473:132::-;1540:4;1563:3;1555:11;;1593:4;1588:3;1584:14;1576:22;;1473:132;;;:::o;1611:96::-;1648:7;1677:24;1695:5;1677:24;:::i;:::-;1666:35;;1611:96;;;:::o;1713:108::-;1790:24;1808:5;1790:24;:::i;:::-;1785:3;1778:37;1713:108;;:::o;1827:179::-;1896:10;1917:46;1959:3;1951:6;1917:46;:::i;:::-;1995:4;1990:3;1986:14;1972:28;;1827:179;;;;:::o;2012:113::-;2082:4;2114;2109:3;2105:14;2097:22;;2012:113;;;:::o;2161:732::-;2280:3;2309:54;2357:5;2309:54;:::i;:::-;2379:86;2458:6;2453:3;2379:86;:::i;:::-;2372:93;;2489:56;2539:5;2489:56;:::i;:::-;2568:7;2599:1;2584:284;2609:6;2606:1;2603:13;2584:284;;;2685:6;2679:13;2712:63;2771:3;2756:13;2712:63;:::i;:::-;2705:70;;2798:60;2851:6;2798:60;:::i;:::-;2788:70;;2644:224;2631:1;2628;2624:9;2619:14;;2584:284;;;2588:14;2884:3;2877:10;;2285:608;;;2161:732;;;;:::o;2899:373::-;3042:4;3080:2;3069:9;3065:18;3057:26;;3129:9;3123:4;3119:20;3115:1;3104:9;3100:17;3093:47;3157:108;3260:4;3251:6;3157:108;:::i;:::-;3149:116;;2899:373;;;;:::o;3278:126::-;3328:9;3361:37;3392:5;3361:37;:::i;:::-;3348:50;;3278:126;;;:::o;3410:150::-;3484:9;3517:37;3548:5;3517:37;:::i;:::-;3504:50;;3410:150;;;:::o;3566:179::-;3677:61;3732:5;3677:61;:::i;:::-;3672:3;3665:74;3566:179;;:::o;3751:270::-;3868:4;3906:2;3895:9;3891:18;3883:26;;3919:95;4011:1;4000:9;3996:17;3987:6;3919:95;:::i;:::-;3751:270;;;;:::o;4027:145::-;4125:6;4159:5;4153:12;4143:22;;4027:145;;;:::o;4178:215::-;4308:11;4342:6;4337:3;4330:19;4382:4;4377:3;4373:14;4358:29;;4178:215;;;;:::o;4399:163::-;4497:4;4520:3;4512:11;;4550:4;4545:3;4541:14;4533:22;;4399:163;;;:::o;4568:124::-;4645:6;4679:5;4673:12;4663:22;;4568:124;;;:::o;4698:184::-;4797:11;4831:6;4826:3;4819:19;4871:4;4866:3;4862:14;4847:29;;4698:184;;;;:::o;4888:142::-;4965:4;4988:3;4980:11;;5018:4;5013:3;5009:14;5001:22;;4888:142;;;:::o;5036:99::-;5088:6;5122:5;5116:12;5106:22;;5036:99;;;:::o;5141:159::-;5215:11;5249:6;5244:3;5237:19;5289:4;5284:3;5280:14;5265:29;;5141:159;;;;:::o;5306:139::-;5395:6;5390:3;5385;5379:23;5436:1;5427:6;5422:3;5418:16;5411:27;5306:139;;;:::o;5451:102::-;5492:6;5543:2;5539:7;5534:2;5527:5;5523:14;5519:28;5509:38;;5451:102;;;:::o;5559:357::-;5637:3;5665:39;5698:5;5665:39;:::i;:::-;5720:61;5774:6;5769:3;5720:61;:::i;:::-;5713:68;;5790:65;5848:6;5843:3;5836:4;5829:5;5825:16;5790:65;:::i;:::-;5880:29;5902:6;5880:29;:::i;:::-;5875:3;5871:39;5864:46;;5641:275;5559:357;;;;:::o;5922:196::-;6011:10;6046:66;6108:3;6100:6;6046:66;:::i;:::-;6032:80;;5922:196;;;;:::o;6124:123::-;6204:4;6236;6231:3;6227:14;6219:22;;6124:123;;;:::o;6281:971::-;6410:3;6439:64;6497:5;6439:64;:::i;:::-;6519:86;6598:6;6593:3;6519:86;:::i;:::-;6512:93;;6631:3;6676:4;6668:6;6664:17;6659:3;6655:27;6706:66;6766:5;6706:66;:::i;:::-;6795:7;6826:1;6811:396;6836:6;6833:1;6830:13;6811:396;;;6907:9;6901:4;6897:20;6892:3;6885:33;6958:6;6952:13;6986:84;7065:4;7050:13;6986:84;:::i;:::-;6978:92;;7093:70;7156:6;7093:70;:::i;:::-;7083:80;;7192:4;7187:3;7183:14;7176:21;;6871:336;6858:1;6855;6851:9;6846:14;;6811:396;;;6815:14;7223:4;7216:11;;7243:3;7236:10;;6415:837;;;;;6281:971;;;;:::o;7336:663::-;7457:3;7493:4;7488:3;7484:14;7580:4;7573:5;7569:16;7563:23;7599:63;7656:4;7651:3;7647:14;7633:12;7599:63;:::i;:::-;7508:164;7759:4;7752:5;7748:16;7742:23;7812:3;7806:4;7802:14;7795:4;7790:3;7786:14;7779:38;7838:123;7956:4;7942:12;7838:123;:::i;:::-;7830:131;;7682:290;7989:4;7982:11;;7462:537;7336:663;;;;:::o;8005:280::-;8136:10;8171:108;8275:3;8267:6;8171:108;:::i;:::-;8157:122;;8005:280;;;;:::o;8291:144::-;8392:4;8424;8419:3;8415:14;8407:22;;8291:144;;;:::o;8523:1159::-;8704:3;8733:85;8812:5;8733:85;:::i;:::-;8834:117;8944:6;8939:3;8834:117;:::i;:::-;8827:124;;8977:3;9022:4;9014:6;9010:17;9005:3;9001:27;9052:87;9133:5;9052:87;:::i;:::-;9162:7;9193:1;9178:459;9203:6;9200:1;9197:13;9178:459;;;9274:9;9268:4;9264:20;9259:3;9252:33;9325:6;9319:13;9353:126;9474:4;9459:13;9353:126;:::i;:::-;9345:134;;9502:91;9586:6;9502:91;:::i;:::-;9492:101;;9622:4;9617:3;9613:14;9606:21;;9238:399;9225:1;9222;9218:9;9213:14;;9178:459;;;9182:14;9653:4;9646:11;;9673:3;9666:10;;8709:973;;;;;8523:1159;;;;:::o;9688:497::-;9893:4;9931:2;9920:9;9916:18;9908:26;;9980:9;9974:4;9970:20;9966:1;9955:9;9951:17;9944:47;10008:170;10173:4;10164:6;10008:170;:::i;:::-;10000:178;;9688:497;;;;:::o;10191:90::-;10226:7;10269:5;10266:1;10255:20;10244:31;;10191:90;;;:::o;10287:112::-;10370:22;10386:5;10370:22;:::i;:::-;10365:3;10358:35;10287:112;;:::o;10405:76::-;10441:7;10470:5;10459:16;;10405:76;;;:::o;10487:115::-;10572:23;10589:5;10572:23;:::i;:::-;10567:3;10560:36;10487:115;;:::o;10608:77::-;10645:7;10674:5;10663:16;;10608:77;;;:::o;10691:118::-;10778:24;10796:5;10778:24;:::i;:::-;10773:3;10766:37;10691:118;;:::o;10815:533::-;10982:4;11020:3;11009:9;11005:19;10997:27;;11034:67;11098:1;11087:9;11083:17;11074:6;11034:67;:::i;:::-;11111:68;11175:2;11164:9;11160:18;11151:6;11111:68;:::i;:::-;11189:70;11255:2;11244:9;11240:18;11231:6;11189:70;:::i;:::-;11269:72;11337:2;11326:9;11322:18;11313:6;11269:72;:::i;:::-;10815:533;;;;;;;:::o;11354:118::-;11441:24;11459:5;11441:24;:::i;:::-;11436:3;11429:37;11354:118;;:::o;11478:222::-;11571:4;11609:2;11598:9;11594:18;11586:26;;11622:71;11690:1;11679:9;11675:17;11666:6;11622:71;:::i;:::-;11478:222;;;;:::o;11706:151::-;11781:9;11814:37;11845:5;11814:37;:::i;:::-;11801:50;;11706:151;;;:::o;11863:181::-;11975:62;12031:5;11975:62;:::i;:::-;11970:3;11963:75;11863:181;;:::o;12050:272::-;12168:4;12206:2;12195:9;12191:18;12183:26;;12219:96;12312:1;12301:9;12297:17;12288:6;12219:96;:::i;:::-;12050:272;;;;:::o;12328:118::-;12415:24;12433:5;12415:24;:::i;:::-;12410:3;12403:37;12328:118;;:::o;12452:222::-;12545:4;12583:2;12572:9;12568:18;12560:26;;12596:71;12664:1;12653:9;12649:17;12640:6;12596:71;:::i;:::-;12452:222;;;;:::o;12680:155::-;12759:9;12792:37;12823:5;12792:37;:::i;:::-;12779:50;;12680:155;;;:::o;12841:189::-;12957:66;13017:5;12957:66;:::i;:::-;12952:3;12945:79;12841:189;;:::o;13036:280::-;13158:4;13196:2;13185:9;13181:18;13173:26;;13209:100;13306:1;13295:9;13291:17;13282:6;13209:100;:::i;:::-;13036:280;;;;:::o;13322:152::-;13427:6;13461:5;13455:12;13445:22;;13322:152;;;:::o;13480:222::-;13617:11;13651:6;13646:3;13639:19;13691:4;13686:3;13682:14;13667:29;;13480:222;;;;:::o;13708:170::-;13813:4;13836:3;13828:11;;13866:4;13861:3;13857:14;13849:22;;13708:170;;;:::o;13884:113::-;13950:6;13984:5;13978:12;13968:22;;13884:113;;;:::o;14003:173::-;14091:11;14125:6;14120:3;14113:19;14165:4;14160:3;14156:14;14141:29;;14003:173;;;;:::o;14182:131::-;14248:4;14271:3;14263:11;;14301:4;14296:3;14292:14;14284:22;;14182:131;;;:::o;14319:149::-;14355:7;14395:66;14388:5;14384:78;14373:89;;14319:149;;;:::o;14474:105::-;14549:23;14566:5;14549:23;:::i;:::-;14544:3;14537:36;14474:105;;:::o;14585:175::-;14652:10;14673:44;14713:3;14705:6;14673:44;:::i;:::-;14749:4;14744:3;14740:14;14726:28;;14585:175;;;;:::o;14766:112::-;14835:4;14867;14862:3;14858:14;14850:22;;14766:112;;;:::o;14912:704::-;15019:3;15048:53;15095:5;15048:53;:::i;:::-;15117:75;15185:6;15180:3;15117:75;:::i;:::-;15110:82;;15216:55;15265:5;15216:55;:::i;:::-;15294:7;15325:1;15310:281;15335:6;15332:1;15329:13;15310:281;;;15411:6;15405:13;15438:61;15495:3;15480:13;15438:61;:::i;:::-;15431:68;;15522:59;15574:6;15522:59;:::i;:::-;15512:69;;15370:221;15357:1;15354;15350:9;15345:14;;15310:281;;;15314:14;15607:3;15600:10;;15024:592;;;14912:704;;;;:::o;15714:730::-;15849:3;15885:4;15880:3;15876:14;15976:4;15969:5;15965:16;15959:23;16029:3;16023:4;16019:14;16012:4;16007:3;16003:14;15996:38;16055:73;16123:4;16109:12;16055:73;:::i;:::-;16047:81;;15900:239;16226:4;16219:5;16215:16;16209:23;16279:3;16273:4;16269:14;16262:4;16257:3;16253:14;16246:38;16305:101;16401:4;16387:12;16305:101;:::i;:::-;16297:109;;16149:268;16434:4;16427:11;;15854:590;15714:730;;;;:::o;16450:308::-;16595:10;16630:122;16748:3;16740:6;16630:122;:::i;:::-;16616:136;;16450:308;;;;:::o;16764:151::-;16872:4;16904;16899:3;16895:14;16887:22;;16764:151;;;:::o;17017:1215::-;17212:3;17241:92;17327:5;17241:92;:::i;:::-;17349:124;17466:6;17461:3;17349:124;:::i;:::-;17342:131;;17499:3;17544:4;17536:6;17532:17;17527:3;17523:27;17574:94;17662:5;17574:94;:::i;:::-;17691:7;17722:1;17707:480;17732:6;17729:1;17726:13;17707:480;;;17803:9;17797:4;17793:20;17788:3;17781:33;17854:6;17848:13;17882:140;18017:4;18002:13;17882:140;:::i;:::-;17874:148;;18045:98;18136:6;18045:98;:::i;:::-;18035:108;;18172:4;18167:3;18163:14;18156:21;;17767:420;17754:1;17751;17747:9;17742:14;;17707:480;;;17711:14;18203:4;18196:11;;18223:3;18216:10;;17217:1015;;;;;17017:1215;;;;:::o;18238:525::-;18457:4;18495:2;18484:9;18480:18;18472:26;;18544:9;18538:4;18534:20;18530:1;18519:9;18515:17;18508:47;18572:184;18751:4;18742:6;18572:184;:::i;:::-;18564:192;;18238:525;;;;:::o;18769:154::-;18847:9;18880:37;18911:5;18880:37;:::i;:::-;18867:50;;18769:154;;;:::o;18929:187::-;19044:65;19103:5;19044:65;:::i;:::-;19039:3;19032:78;18929:187;;:::o;19122:278::-;19243:4;19281:2;19270:9;19266:18;19258:26;;19294:99;19390:1;19379:9;19375:17;19366:6;19294:99;:::i;:::-;19122:278;;;;:::o;19406:194::-;19515:11;19549:6;19544:3;19537:19;19589:4;19584:3;19580:14;19565:29;;19406:194;;;;:::o;19634:991::-;19773:3;19802:64;19860:5;19802:64;:::i;:::-;19882:96;19971:6;19966:3;19882:96;:::i;:::-;19875:103;;20004:3;20049:4;20041:6;20037:17;20032:3;20028:27;20079:66;20139:5;20079:66;:::i;:::-;20168:7;20199:1;20184:396;20209:6;20206:1;20203:13;20184:396;;;20280:9;20274:4;20270:20;20265:3;20258:33;20331:6;20325:13;20359:84;20438:4;20423:13;20359:84;:::i;:::-;20351:92;;20466:70;20529:6;20466:70;:::i;:::-;20456:80;;20565:4;20560:3;20556:14;20549:21;;20244:336;20231:1;20228;20224:9;20219:14;;20184:396;;;20188:14;20596:4;20589:11;;20616:3;20609:10;;19778:847;;;;;19634:991;;;;:::o;20631:413::-;20794:4;20832:2;20821:9;20817:18;20809:26;;20881:9;20875:4;20871:20;20867:1;20856:9;20852:17;20845:47;20909:128;21032:4;21023:6;20909:128;:::i;:::-;20901:136;;20631:413;;;;:::o;21050:77::-;21087:7;21116:5;21105:16;;21050:77;;;:::o;21133:118::-;21220:24;21238:5;21220:24;:::i;:::-;21215:3;21208:37;21133:118;;:::o;21257:222::-;21350:4;21388:2;21377:9;21373:18;21365:26;;21401:71;21469:1;21458:9;21454:17;21445:6;21401:71;:::i;:::-;21257:222;;;;:::o;21485:144::-;21582:6;21616:5;21610:12;21600:22;;21485:144;;;:::o;21635:214::-;21764:11;21798:6;21793:3;21786:19;21838:4;21833:3;21829:14;21814:29;;21635:214;;;;:::o;21855:162::-;21952:4;21975:3;21967:11;;22005:4;22000:3;21996:14;21988:22;;21855:162;;;:::o;22099:639::-;22218:3;22254:4;22249:3;22245:14;22341:4;22334:5;22330:16;22324:23;22360:63;22417:4;22412:3;22408:14;22394:12;22360:63;:::i;:::-;22269:164;22520:4;22513:5;22509:16;22503:23;22573:3;22567:4;22563:14;22556:4;22551:3;22547:14;22540:38;22599:101;22695:4;22681:12;22599:101;:::i;:::-;22591:109;;22443:268;22728:4;22721:11;;22223:515;22099:639;;;;:::o;22744:276::-;22873:10;22908:106;23010:3;23002:6;22908:106;:::i;:::-;22894:120;;22744:276;;;;:::o;23026:143::-;23126:4;23158;23153:3;23149:14;23141:22;;23026:143;;;:::o;23255:1151::-;23434:3;23463:84;23541:5;23463:84;:::i;:::-;23563:116;23672:6;23667:3;23563:116;:::i;:::-;23556:123;;23705:3;23750:4;23742:6;23738:17;23733:3;23729:27;23780:86;23860:5;23780:86;:::i;:::-;23889:7;23920:1;23905:456;23930:6;23927:1;23924:13;23905:456;;;24001:9;23995:4;23991:20;23986:3;23979:33;24052:6;24046:13;24080:124;24199:4;24184:13;24080:124;:::i;:::-;24072:132;;24227:90;24310:6;24227:90;:::i;:::-;24217:100;;24346:4;24341:3;24337:14;24330:21;;23965:396;23952:1;23949;23945:9;23940:14;;23905:456;;;23909:14;24377:4;24370:11;;24397:3;24390:10;;23439:967;;;;;23255:1151;;;;:::o;24412:493::-;24615:4;24653:2;24642:9;24638:18;24630:26;;24702:9;24696:4;24692:20;24688:1;24677:9;24673:17;24666:47;24730:168;24893:4;24884:6;24730:168;:::i;:::-;24722:176;;24412:493;;;;:::o;24911:90::-;24945:7;24988:5;24981:13;24974:21;24963:32;;24911:90;;;:::o;25007:109::-;25088:21;25103:5;25088:21;:::i;:::-;25083:3;25076:34;25007:109;;:::o;25122:426::-;25263:4;25301:2;25290:9;25286:18;25278:26;;25314:65;25376:1;25365:9;25361:17;25352:6;25314:65;:::i;:::-;25389:70;25455:2;25444:9;25440:18;25431:6;25389:70;:::i;:::-;25469:72;25537:2;25526:9;25522:18;25513:6;25469:72;:::i;:::-;25122:426;;;;;;:::o;25554:210::-;25641:4;25679:2;25668:9;25664:18;25656:26;;25692:65;25754:1;25743:9;25739:17;25730:6;25692:65;:::i;:::-;25554:210;;;;:::o;25770:151::-;25845:9;25878:37;25909:5;25878:37;:::i;:::-;25865:50;;25770:151;;;:::o;25927:181::-;26039:62;26095:5;26039:62;:::i;:::-;26034:3;26027:75;25927:181;;:::o;26114:272::-;26232:4;26270:2;26259:9;26255:18;26247:26;;26283:96;26376:1;26365:9;26361:17;26352:6;26283:96;:::i;:::-;26114:272;;;;:::o;26392:169::-;26476:11;26510:6;26505:3;26498:19;26550:4;26545:3;26541:14;26526:29;;26392:169;;;;:::o;26567:165::-;26707:17;26703:1;26695:6;26691:14;26684:41;26567:165;:::o;26738:366::-;26880:3;26901:67;26965:2;26960:3;26901:67;:::i;:::-;26894:74;;26977:93;27066:3;26977:93;:::i;:::-;27095:2;27090:3;27086:12;27079:19;;26738:366;;;:::o;27110:154::-;27250:6;27246:1;27238:6;27234:14;27227:30;27110:154;:::o;27270:365::-;27412:3;27433:66;27497:1;27492:3;27433:66;:::i;:::-;27426:73;;27508:93;27597:3;27508:93;:::i;:::-;27626:2;27621:3;27617:12;27610:19;;27270:365;;;:::o;27641:86::-;27687:7;27716:5;27705:16;;27641:86;;;:::o;27733:::-;27768:7;27808:4;27801:5;27797:16;27786:27;;27733:86;;;:::o;27825:156::-;27882:9;27915:60;27931:43;27940:33;27967:5;27940:33;:::i;:::-;27931:43;:::i;:::-;27915:60;:::i;:::-;27902:73;;27825:156;;;:::o;27987:145::-;28081:44;28119:5;28081:44;:::i;:::-;28076:3;28069:57;27987:145;;:::o;28138:850::-;28440:4;28478:2;28467:9;28463:18;28455:26;;28527:9;28521:4;28517:20;28513:1;28502:9;28498:17;28491:47;28555:131;28681:4;28555:131;:::i;:::-;28547:139;;28733:9;28727:4;28723:20;28718:2;28707:9;28703:18;28696:48;28761:131;28887:4;28761:131;:::i;:::-;28753:139;;28902:79;28977:2;28966:9;28962:18;28953:6;28902:79;:::i;:::-;28138:850;;;;:::o;28994:148::-;29066:9;29099:37;29130:5;29099:37;:::i;:::-;29086:50;;28994:148;;;:::o;29148:175::-;29257:59;29310:5;29257:59;:::i;:::-;29252:3;29245:72;29148:175;;:::o;29329:152::-;29405:9;29438:37;29469:5;29438:37;:::i;:::-;29425:50;;29329:152;;;:::o;29487:183::-;29600:63;29657:5;29600:63;:::i;:::-;29595:3;29588:76;29487:183;;:::o;29676:697::-;29925:4;29963:3;29952:9;29948:19;29940:27;;29977:93;30067:1;30056:9;30052:17;30043:6;29977:93;:::i;:::-;30080:96;30172:2;30161:9;30157:18;30148:6;30080:96;:::i;:::-;30186:72;30254:2;30243:9;30239:18;30230:6;30186:72;:::i;:::-;30268:98;30362:2;30351:9;30347:18;30338:6;30268:98;:::i;:::-;29676:697;;;;;;;:::o;30379:142::-;30445:9;30478:37;30509:5;30478:37;:::i;:::-;30465:50;;30379:142;;;:::o;30527:163::-;30630:53;30677:5;30630:53;:::i;:::-;30625:3;30618:66;30527:163;;:::o;30696:792::-;30965:4;31003:3;30992:9;30988:19;30980:27;;31017:71;31085:1;31074:9;31070:17;31061:6;31017:71;:::i;:::-;31098:94;31188:2;31177:9;31173:18;31164:6;31098:94;:::i;:::-;31202:98;31296:2;31285:9;31281:18;31272:6;31202:98;:::i;:::-;31310:72;31378:2;31367:9;31363:18;31354:6;31310:72;:::i;:::-;31392:89;31476:3;31465:9;31461:19;31452:6;31392:89;:::i;:::-;30696:792;;;;;;;;:::o;31494:87::-;31541:7;31570:5;31559:16;;31494:87;;;:::o;31587:162::-;31647:9;31680:63;31698:44;31707:34;31735:5;31707:34;:::i;:::-;31698:44;:::i;:::-;31680:63;:::i;:::-;31667:76;;31587:162;;;:::o;31755:151::-;31852:47;31893:5;31852:47;:::i;:::-;31847:3;31840:60;31755:151;;:::o;31912:462::-;32071:4;32109:2;32098:9;32094:18;32086:26;;32122:71;32190:1;32179:9;32175:17;32166:6;32122:71;:::i;:::-;32203:82;32281:2;32270:9;32266:18;32257:6;32203:82;:::i;:::-;32295:72;32363:2;32352:9;32348:18;32339:6;32295:72;:::i;:::-;31912:462;;;;;;:::o;32380:254::-;32489:4;32527:2;32516:9;32512:18;32504:26;;32540:87;32624:1;32613:9;32609:17;32600:6;32540:87;:::i;:::-;32380:254;;;;:::o;32640:180::-;32688:77;32685:1;32678:88;32785:4;32782:1;32775:15;32809:4;32806:1;32799:15;32826:320;32870:6;32907:1;32901:4;32897:12;32887:22;;32954:1;32948:4;32944:12;32975:18;32965:81;;33031:4;33023:6;33019:17;33009:27;;32965:81;33093:2;33085:6;33082:14;33062:18;33059:38;33056:84;;33112:18;;:::i;:::-;33056:84;32877:269;32826:320;;;:::o;33152:126::-;33202:9;33235:37;33266:5;33235:37;:::i;:::-;33222:50;;33152:126;;;:::o;33284:151::-;33391:37;33422:5;33391:37;:::i;:::-;33386:3;33379:50;33284:151;;:::o;33441:91::-;33477:7;33517:8;33510:5;33506:20;33495:31;;33441:91;;;:::o;33538:105::-;33613:23;33630:5;33613:23;:::i;:::-;33608:3;33601:36;33538:105;;:::o;33649:102::-;33722:22;33738:5;33722:22;:::i;:::-;33717:3;33710:35;33649:102;;:::o;33757:153::-;33850:53;33897:5;33850:53;:::i;:::-;33845:3;33838:66;33757:153;;:::o;33956:1118::-;34105:4;34100:3;34096:14;34197:4;34190:5;34186:16;34180:23;34216:93;34303:4;34298:3;34294:14;34280:12;34216:93;:::i;:::-;34120:199;34406:4;34399:5;34395:16;34389:23;34425:93;34512:4;34507:3;34503:14;34489:12;34425:93;:::i;:::-;34329:199;34609:4;34602:5;34598:16;34592:23;34628:61;34683:4;34678:3;34674:14;34660:12;34628:61;:::i;:::-;34538:161;34788:4;34781:5;34777:16;34771:23;34807:59;34860:4;34855:3;34851:14;34837:12;34807:59;:::i;:::-;34709:167;34959:4;34952:5;34948:16;34942:23;34978:79;35051:4;35046:3;35042:14;35028:12;34978:79;:::i;:::-;34886:181;34074:1000;33956:1118;;:::o;35080:438::-;35253:4;35291:3;35280:9;35276:19;35268:27;;35305:123;35425:1;35414:9;35410:17;35401:6;35305:123;:::i;:::-;35438:73;35506:3;35495:9;35491:19;35482:6;35438:73;:::i;:::-;35080:438;;;;;:::o;35524:75::-;35557:6;35590:2;35584:9;35574:19;;35524:75;:::o;35605:117::-;35714:1;35711;35704:12;35728:117;35837:1;35834;35827:12;35851:118;35922:22;35938:5;35922:22;:::i;:::-;35915:5;35912:33;35902:61;;35959:1;35956;35949:12;35902:61;35851:118;:::o;35975:139::-;36030:5;36061:6;36055:13;36046:22;;36077:31;36102:5;36077:31;:::i;:::-;35975:139;;;;:::o;36120:347::-;36188:6;36237:2;36225:9;36216:7;36212:23;36208:32;36205:119;;;36243:79;;:::i;:::-;36205:119;36363:1;36388:62;36442:7;36433:6;36422:9;36418:22;36388:62;:::i;:::-;36378:72;;36334:126;36120:347;;;;:::o;36473:180::-;36521:77;36518:1;36511:88;36618:4;36615:1;36608:15;36642:4;36639:1;36632:15;36659:235;36699:4;36719:20;36737:1;36719:20;:::i;:::-;36714:25;;36753:20;36771:1;36753:20;:::i;:::-;36748:25;;36797:1;36794;36790:9;36782:17;;36821:42;36815:4;36812:52;36809:78;;;36867:18;;:::i;:::-;36809:78;36659:235;;;;:::o;36900:332::-;37021:4;37059:2;37048:9;37044:18;37036:26;;37072:71;37140:1;37129:9;37125:17;37116:6;37072:71;:::i;:::-;37153:72;37221:2;37210:9;37206:18;37197:6;37153:72;:::i;:::-;36900:332;;;;;:::o;37238:122::-;37311:24;37329:5;37311:24;:::i;:::-;37304:5;37301:35;37291:63;;37350:1;37347;37340:12;37291:63;37238:122;:::o;37366:143::-;37423:5;37454:6;37448:13;37439:22;;37470:33;37497:5;37470:33;:::i;:::-;37366:143;;;;:::o;37515:351::-;37585:6;37634:2;37622:9;37613:7;37609:23;37605:32;37602:119;;;37640:79;;:::i;:::-;37602:119;37760:1;37785:64;37841:7;37832:6;37821:9;37817:22;37785:64;:::i;:::-;37775:74;;37731:128;37515:351;;;;:::o;37872:232::-;37912:3;37931:20;37949:1;37931:20;:::i;:::-;37926:25;;37965:20;37983:1;37965:20;:::i;:::-;37960:25;;38008:1;38005;38001:9;37994:16;;38031:42;38026:3;38023:51;38020:77;;;38077:18;;:::i;:::-;38020:77;37872:232;;;;:::o;38110:377::-;38198:3;38226:39;38259:5;38226:39;:::i;:::-;38281:71;38345:6;38340:3;38281:71;:::i;:::-;38274:78;;38361:65;38419:6;38414:3;38407:4;38400:5;38396:16;38361:65;:::i;:::-;38451:29;38473:6;38451:29;:::i;:::-;38446:3;38442:39;38435:46;;38202:285;38110:377;;;;:::o;38493:313::-;38606:4;38644:2;38633:9;38629:18;38621:26;;38693:9;38687:4;38683:20;38679:1;38668:9;38664:17;38657:47;38721:78;38794:4;38785:6;38721:78;:::i;:::-;38713:86;;38493:313;;;;:::o;38812:117::-;38921:1;38918;38911:12;38935:117;39044:1;39041;39034:12;39058:180;39106:77;39103:1;39096:88;39203:4;39200:1;39193:15;39227:4;39224:1;39217:15;39244:281;39327:27;39349:4;39327:27;:::i;:::-;39319:6;39315:40;39457:6;39445:10;39442:22;39421:18;39409:10;39406:34;39403:62;39400:88;;;39468:18;;:::i;:::-;39400:88;39508:10;39504:2;39497:22;39287:238;39244:281;;:::o;39531:129::-;39565:6;39592:20;;:::i;:::-;39582:30;;39621:33;39649:4;39641:6;39621:33;:::i;:::-;39531:129;;;:::o;39666:307::-;39727:4;39817:18;39809:6;39806:30;39803:56;;;39839:18;;:::i;:::-;39803:56;39877:29;39899:6;39877:29;:::i;:::-;39869:37;;39961:4;39955;39951:15;39943:23;;39666:307;;;:::o;39979:432::-;40067:5;40092:65;40108:48;40149:6;40108:48;:::i;:::-;40092:65;:::i;:::-;40083:74;;40180:6;40173:5;40166:21;40218:4;40211:5;40207:16;40256:3;40247:6;40242:3;40238:16;40235:25;40232:112;;;40263:79;;:::i;:::-;40232:112;40353:52;40398:6;40393:3;40388;40353:52;:::i;:::-;40073:338;39979:432;;;;;:::o;40430:353::-;40496:5;40545:3;40538:4;40530:6;40526:17;40522:27;40512:122;;40553:79;;:::i;:::-;40512:122;40663:6;40657:13;40688:89;40773:3;40765:6;40758:4;40750:6;40746:17;40688:89;:::i;:::-;40679:98;;40502:281;40430:353;;;;:::o;40789:522::-;40868:6;40917:2;40905:9;40896:7;40892:23;40888:32;40885:119;;;40923:79;;:::i;:::-;40885:119;41064:1;41053:9;41049:17;41043:24;41094:18;41086:6;41083:30;41080:117;;;41116:79;;:::i;:::-;41080:117;41221:73;41286:7;41277:6;41266:9;41262:22;41221:73;:::i;:::-;41211:83;;41014:290;40789:522;;;;:::o;41317:98::-;41368:6;41402:5;41396:12;41386:22;;41317:98;;;:::o;41421:147::-;41522:11;41559:3;41544:18;;41421:147;;;;:::o;41574:386::-;41678:3;41706:38;41738:5;41706:38;:::i;:::-;41760:88;41841:6;41836:3;41760:88;:::i;:::-;41753:95;;41857:65;41915:6;41910:3;41903:4;41896:5;41892:16;41857:65;:::i;:::-;41947:6;41942:3;41938:16;41931:23;;41682:278;41574:386;;;;:::o;41966:427::-;42142:3;42164:93;42253:3;42244:6;42164:93;:::i;:::-;42157:100;;42274:93;42363:3;42354:6;42274:93;:::i;:::-;42267:100;;42384:3;42377:10;;41966:427;;;;;:::o;42399:168::-;42482:11;42516:6;42511:3;42504:19;42556:4;42551:3;42547:14;42532:29;;42399:168;;;;:::o;42573:373::-;42659:3;42687:38;42719:5;42687:38;:::i;:::-;42741:70;42804:6;42799:3;42741:70;:::i;:::-;42734:77;;42820:65;42878:6;42873:3;42866:4;42859:5;42855:16;42820:65;:::i;:::-;42910:29;42932:6;42910:29;:::i;:::-;42905:3;42901:39;42894:46;;42663:283;42573:373;;;;:::o;42952:419::-;43091:4;43129:2;43118:9;43114:18;43106:26;;43142:71;43210:1;43199:9;43195:17;43186:6;43142:71;:::i;:::-;43260:9;43254:4;43250:20;43245:2;43234:9;43230:18;43223:48;43288:76;43359:4;43350:6;43288:76;:::i;:::-;43280:84;;42952:419;;;;;:::o;43377:114::-;;:::o;43497:398::-;43656:3;43677:83;43758:1;43753:3;43677:83;:::i;:::-;43670:90;;43769:93;43858:3;43769:93;:::i;:::-;43887:1;43882:3;43878:11;43871:18;;43497:398;;;:::o;43901:379::-;44085:3;44107:147;44250:3;44107:147;:::i;:::-;44100:154;;44271:3;44264:10;;43901:379;;;:::o;44286:312::-;44426:34;44422:1;44414:6;44410:14;44403:58;44495:34;44490:2;44482:6;44478:15;44471:59;44564:26;44559:2;44551:6;44547:15;44540:51;44286:312;:::o;44604:366::-;44746:3;44767:67;44831:2;44826:3;44767:67;:::i;:::-;44760:74;;44843:93;44932:3;44843:93;:::i;:::-;44961:2;44956:3;44952:12;44945:19;;44604:366;;;:::o;44976:419::-;45142:4;45180:2;45169:9;45165:18;45157:26;;45229:9;45223:4;45219:20;45215:1;45204:9;45200:17;45193:47;45257:131;45383:4;45257:131;:::i;:::-;45249:139;;44976:419;;;:::o;45401:148::-;45503:11;45540:3;45525:18;;45401:148;;;;:::o;45555:390::-;45661:3;45689:39;45722:5;45689:39;:::i;:::-;45744:89;45826:6;45821:3;45744:89;:::i;:::-;45737:96;;45842:65;45900:6;45895:3;45888:4;45881:5;45877:16;45842:65;:::i;:::-;45932:6;45927:3;45923:16;45916:23;;45665:280;45555:390;;;;:::o;45951:275::-;46083:3;46105:95;46196:3;46187:6;46105:95;:::i;:::-;46098:102;;46217:3;46210:10;;45951:275;;;;:::o;46232:122::-;46305:24;46323:5;46305:24;:::i;:::-;46298:5;46295:35;46285:63;;46344:1;46341;46334:12;46285:63;46232:122;:::o;46360:143::-;46417:5;46448:6;46442:13;46433:22;;46464:33;46491:5;46464:33;:::i;:::-;46360:143;;;;:::o;46509:351::-;46579:6;46628:2;46616:9;46607:7;46603:23;46599:32;46596:119;;;46634:79;;:::i;:::-;46596:119;46754:1;46779:64;46835:7;46826:6;46815:9;46811:22;46779:64;:::i;:::-;46769:74;;46725:128;46509:351;;;;:::o;46866:423::-;47007:4;47045:2;47034:9;47030:18;47022:26;;47058:71;47126:1;47115:9;47111:17;47102:6;47058:71;:::i;:::-;47176:9;47170:4;47166:20;47161:2;47150:9;47146:18;47139:48;47204:78;47277:4;47268:6;47204:78;:::i;:::-;47196:86;;46866:423;;;;;:::o","linkReferences":{}},"methodIdentifiers":{"IS_TEST()":"fa7626d4","LIQUIDITY_PARAMS()":"93ad73ed","MAX_PRICE_LIMIT()":"542524dd","MIN_PRICE_LIMIT()":"c7b8e15d","PERMIT2()":"6afdd850","REMOVE_LIQUIDITY_PARAMS()":"39cd2013","SWAP_PARAMS()":"b1a73b8a","UNSUBSCRIBE_LIMIT()":"8b8cf341","dcaToken()":"2abca154","excludeArtifacts()":"b5508aa9","excludeContracts()":"e20c9f71","excludeSelectors()":"b0464fdc","excludeSenders()":"1ed7831c","failed()":"ba414fa6","listing()":"bc7c55ed","posM()":"0373b885","setUp()":"0a9254e4","staking()":"4cf088d9","targetArtifactSelectors()":"66d9a9a0","targetArtifacts()":"85226c81","targetContracts()":"3f7286f4","targetInterfaces()":"2ade3880","targetSelectors()":"916a17c6","targetSenders()":"3e5e3c23","test_maliciousUserCanObtainSoloRewardsByCreatingIndividualPools()":"478a807b","tokenDescriptor()":"5a9d7a68","weth()":"3fc8cef3"}}}}},"sources":{"lib/forge-std/src/Base.sol":{"id":0,"ast":{}},"lib/forge-std/src/StdAssertions.sol":{"id":1,"ast":{}},"lib/forge-std/src/StdChains.sol":{"id":2,"ast":{}},"lib/forge-std/src/StdCheats.sol":{"id":3,"ast":{}},"lib/forge-std/src/StdError.sol":{"id":4,"ast":{}},"lib/forge-std/src/StdInvariant.sol":{"id":5,"ast":{}},"lib/forge-std/src/StdJson.sol":{"id":6,"ast":{}},"lib/forge-std/src/StdMath.sol":{"id":7,"ast":{}},"lib/forge-std/src/StdStorage.sol":{"id":8,"ast":{}},"lib/forge-std/src/StdStyle.sol":{"id":9,"ast":{}},"lib/forge-std/src/StdToml.sol":{"id":10,"ast":{}},"lib/forge-std/src/StdUtils.sol":{"id":11,"ast":{}},"lib/forge-std/src/Test.sol":{"id":12,"ast":{}},"lib/forge-std/src/Vm.sol":{"id":13,"ast":{}},"lib/forge-std/src/console.sol":{"id":14,"ast":{}},"lib/forge-std/src/console2.sol":{"id":15,"ast":{}},"lib/forge-std/src/interfaces/IMulticall3.sol":{"id":16,"ast":{}},"lib/forge-std/src/safeconsole.sol":{"id":17,"ast":{}},"lib/openzeppelin-contracts/contracts/access/AccessControl.sol":{"id":18,"ast":{}},"lib/openzeppelin-contracts/contracts/access/IAccessControl.sol":{"id":19,"ast":{}},"lib/openzeppelin-contracts/contracts/access/Ownable.sol":{"id":20,"ast":{}},"lib/openzeppelin-contracts/contracts/access/Ownable2Step.sol":{"id":21,"ast":{}},"lib/openzeppelin-contracts/contracts/token/ERC20/IERC20.sol":{"id":22,"ast":{}},"lib/openzeppelin-contracts/contracts/token/ERC721/IERC721.sol":{"id":23,"ast":{}},"lib/openzeppelin-contracts/contracts/utils/Context.sol":{"id":24,"ast":{}},"lib/openzeppelin-contracts/contracts/utils/Panic.sol":{"id":25,"ast":{}},"lib/openzeppelin-contracts/contracts/utils/introspection/ERC165.sol":{"id":26,"ast":{}},"lib/openzeppelin-contracts/contracts/utils/introspection/IERC165.sol":{"id":27,"ast":{}},"lib/openzeppelin-contracts/contracts/utils/math/Math.sol":{"id":28,"ast":{}},"lib/openzeppelin-contracts/contracts/utils/math/SafeCast.sol":{"id":29,"ast":{}},"lib/openzeppelin-contracts/contracts/utils/structs/EnumerableSet.sol":{"id":30,"ast":{}},"lib/v4-core/lib/solmate/src/auth/Owned.sol":{"id":31,"ast":{}},"lib/v4-core/lib/solmate/src/test/utils/mocks/MockERC20.sol":{"id":32,"ast":{}},"lib/v4-core/lib/solmate/src/tokens/ERC20.sol":{"id":33,"ast":{}},"lib/v4-core/lib/solmate/src/tokens/ERC721.sol":{"id":34,"ast":{}},"lib/v4-core/src/libraries/BitMath.sol":{"id":35,"ast":{}},"lib/v4-core/src/libraries/CustomRevert.sol":{"id":36,"ast":{}},"lib/v4-core/src/libraries/FixedPoint96.sol":{"id":37,"ast":{}},"lib/v4-core/src/libraries/FullMath.sol":{"id":38,"ast":{}},"lib/v4-core/src/libraries/TickMath.sol":{"id":39,"ast":{}},"lib/v4-core/test/utils/LiquidityAmounts.sol":{"id":40,"ast":{}},"lib/v4-periphery/lib/permit2/src/interfaces/IAllowanceTransfer.sol":{"id":41,"ast":{}},"lib/v4-periphery/lib/permit2/src/interfaces/IEIP712.sol":{"id":42,"ast":{}},"lib/v4-periphery/lib/permit2/src/interfaces/IERC1271.sol":{"id":43,"ast":{}},"lib/v4-periphery/lib/permit2/src/libraries/SignatureVerification.sol":{"id":44,"ast":{}},"lib/v4-periphery/lib/v4-core/src/ERC6909.sol":{"id":45,"ast":{}},"lib/v4-periphery/lib/v4-core/src/ERC6909Claims.sol":{"id":46,"ast":{}},"lib/v4-periphery/lib/v4-core/src/Extsload.sol":{"id":47,"ast":{}},"lib/v4-periphery/lib/v4-core/src/Exttload.sol":{"id":48,"ast":{}},"lib/v4-periphery/lib/v4-core/src/NoDelegateCall.sol":{"id":49,"ast":{}},"lib/v4-periphery/lib/v4-core/src/PoolManager.sol":{"id":50,"ast":{}},"lib/v4-periphery/lib/v4-core/src/ProtocolFees.sol":{"id":51,"ast":{}},"lib/v4-periphery/lib/v4-core/src/interfaces/IExtsload.sol":{"id":52,"ast":{}},"lib/v4-periphery/lib/v4-core/src/interfaces/IExttload.sol":{"id":53,"ast":{}},"lib/v4-periphery/lib/v4-core/src/interfaces/IHooks.sol":{"id":54,"ast":{}},"lib/v4-periphery/lib/v4-core/src/interfaces/IPoolManager.sol":{"id":55,"ast":{}},"lib/v4-periphery/lib/v4-core/src/interfaces/IProtocolFees.sol":{"id":56,"ast":{}},"lib/v4-periphery/lib/v4-core/src/interfaces/callback/IUnlockCallback.sol":{"id":57,"ast":{}},"lib/v4-periphery/lib/v4-core/src/interfaces/external/IERC20Minimal.sol":{"id":58,"ast":{}},"lib/v4-periphery/lib/v4-core/src/interfaces/external/IERC6909Claims.sol":{"id":59,"ast":{}},"lib/v4-periphery/lib/v4-core/src/libraries/BitMath.sol":{"id":60,"ast":{}},"lib/v4-periphery/lib/v4-core/src/libraries/CurrencyDelta.sol":{"id":61,"ast":{}},"lib/v4-periphery/lib/v4-core/src/libraries/CurrencyReserves.sol":{"id":62,"ast":{}},"lib/v4-periphery/lib/v4-core/src/libraries/CustomRevert.sol":{"id":63,"ast":{}},"lib/v4-periphery/lib/v4-core/src/libraries/FixedPoint128.sol":{"id":64,"ast":{}},"lib/v4-periphery/lib/v4-core/src/libraries/FixedPoint96.sol":{"id":65,"ast":{}},"lib/v4-periphery/lib/v4-core/src/libraries/FullMath.sol":{"id":66,"ast":{}},"lib/v4-periphery/lib/v4-core/src/libraries/Hooks.sol":{"id":67,"ast":{}},"lib/v4-periphery/lib/v4-core/src/libraries/LPFeeLibrary.sol":{"id":68,"ast":{}},"lib/v4-periphery/lib/v4-core/src/libraries/LiquidityMath.sol":{"id":69,"ast":{}},"lib/v4-periphery/lib/v4-core/src/libraries/Lock.sol":{"id":70,"ast":{}},"lib/v4-periphery/lib/v4-core/src/libraries/NonzeroDeltaCount.sol":{"id":71,"ast":{}},"lib/v4-periphery/lib/v4-core/src/libraries/ParseBytes.sol":{"id":72,"ast":{}},"lib/v4-periphery/lib/v4-core/src/libraries/Pool.sol":{"id":73,"ast":{}},"lib/v4-periphery/lib/v4-core/src/libraries/Position.sol":{"id":74,"ast":{}},"lib/v4-periphery/lib/v4-core/src/libraries/ProtocolFeeLibrary.sol":{"id":75,"ast":{}},"lib/v4-periphery/lib/v4-core/src/libraries/SafeCast.sol":{"id":76,"ast":{}},"lib/v4-periphery/lib/v4-core/src/libraries/SqrtPriceMath.sol":{"id":77,"ast":{}},"lib/v4-periphery/lib/v4-core/src/libraries/StateLibrary.sol":{"id":78,"ast":{}},"lib/v4-periphery/lib/v4-core/src/libraries/SwapMath.sol":{"id":79,"ast":{}},"lib/v4-periphery/lib/v4-core/src/libraries/TickBitmap.sol":{"id":80,"ast":{}},"lib/v4-periphery/lib/v4-core/src/libraries/TickMath.sol":{"id":81,"ast":{}},"lib/v4-periphery/lib/v4-core/src/libraries/TransientStateLibrary.sol":{"id":82,"ast":{}},"lib/v4-periphery/lib/v4-core/src/libraries/UnsafeMath.sol":{"id":83,"ast":{}},"lib/v4-periphery/lib/v4-core/src/test/ActionsRouter.sol":{"id":84,"ast":{}},"lib/v4-periphery/lib/v4-core/src/test/PoolClaimsTest.sol":{"id":85,"ast":{}},"lib/v4-periphery/lib/v4-core/src/test/PoolDonateTest.sol":{"id":86,"ast":{}},"lib/v4-periphery/lib/v4-core/src/test/PoolModifyLiquidityTest.sol":{"id":87,"ast":{}},"lib/v4-periphery/lib/v4-core/src/test/PoolModifyLiquidityTestNoChecks.sol":{"id":88,"ast":{}},"lib/v4-periphery/lib/v4-core/src/test/PoolNestedActionsTest.sol":{"id":89,"ast":{}},"lib/v4-periphery/lib/v4-core/src/test/PoolSwapTest.sol":{"id":90,"ast":{}},"lib/v4-periphery/lib/v4-core/src/test/PoolTakeTest.sol":{"id":91,"ast":{}},"lib/v4-periphery/lib/v4-core/src/test/PoolTestBase.sol":{"id":92,"ast":{}},"lib/v4-periphery/lib/v4-core/src/test/SwapRouterNoChecks.sol":{"id":93,"ast":{}},"lib/v4-periphery/lib/v4-core/src/types/BalanceDelta.sol":{"id":94,"ast":{}},"lib/v4-periphery/lib/v4-core/src/types/BeforeSwapDelta.sol":{"id":95,"ast":{}},"lib/v4-periphery/lib/v4-core/src/types/Currency.sol":{"id":96,"ast":{}},"lib/v4-periphery/lib/v4-core/src/types/PoolId.sol":{"id":97,"ast":{}},"lib/v4-periphery/lib/v4-core/src/types/PoolKey.sol":{"id":98,"ast":{}},"lib/v4-periphery/lib/v4-core/src/types/Slot0.sol":{"id":99,"ast":{}},"lib/v4-periphery/lib/v4-core/test/utils/Constants.sol":{"id":100,"ast":{}},"lib/v4-periphery/lib/v4-core/test/utils/CurrencySettler.sol":{"id":101,"ast":{}},"lib/v4-periphery/lib/v4-core/test/utils/Deployers.sol":{"id":102,"ast":{}},"lib/v4-periphery/lib/v4-core/test/utils/LiquidityAmounts.sol":{"id":103,"ast":{}},"lib/v4-periphery/lib/v4-core/test/utils/SortTokens.sol":{"id":104,"ast":{}},"lib/v4-periphery/src/PositionManager.sol":{"id":105,"ast":{}},"lib/v4-periphery/src/base/BaseActionsRouter.sol":{"id":106,"ast":{}},"lib/v4-periphery/src/base/DeltaResolver.sol":{"id":107,"ast":{}},"lib/v4-periphery/src/base/EIP712_v4.sol":{"id":108,"ast":{}},"lib/v4-periphery/src/base/ERC721Permit_v4.sol":{"id":109,"ast":{}},"lib/v4-periphery/src/base/ImmutableState.sol":{"id":110,"ast":{}},"lib/v4-periphery/src/base/Multicall_v4.sol":{"id":111,"ast":{}},"lib/v4-periphery/src/base/NativeWrapper.sol":{"id":112,"ast":{}},"lib/v4-periphery/src/base/Notifier.sol":{"id":113,"ast":{}},"lib/v4-periphery/src/base/Permit2Forwarder.sol":{"id":114,"ast":{}},"lib/v4-periphery/src/base/PoolInitializer_v4.sol":{"id":115,"ast":{}},"lib/v4-periphery/src/base/ReentrancyLock.sol":{"id":116,"ast":{}},"lib/v4-periphery/src/base/SafeCallback.sol":{"id":117,"ast":{}},"lib/v4-periphery/src/base/UnorderedNonce.sol":{"id":118,"ast":{}},"lib/v4-periphery/src/interfaces/IEIP712_v4.sol":{"id":119,"ast":{}},"lib/v4-periphery/src/interfaces/IERC721Permit_v4.sol":{"id":120,"ast":{}},"lib/v4-periphery/src/interfaces/IImmutableState.sol":{"id":121,"ast":{}},"lib/v4-periphery/src/interfaces/IMulticall_v4.sol":{"id":122,"ast":{}},"lib/v4-periphery/src/interfaces/INotifier.sol":{"id":123,"ast":{}},"lib/v4-periphery/src/interfaces/IPermit2Forwarder.sol":{"id":124,"ast":{}},"lib/v4-periphery/src/interfaces/IPoolInitializer_v4.sol":{"id":125,"ast":{}},"lib/v4-periphery/src/interfaces/IPositionDescriptor.sol":{"id":126,"ast":{}},"lib/v4-periphery/src/interfaces/IPositionManager.sol":{"id":127,"ast":{}},"lib/v4-periphery/src/interfaces/ISubscriber.sol":{"id":128,"ast":{}},"lib/v4-periphery/src/interfaces/IUnorderedNonce.sol":{"id":129,"ast":{}},"lib/v4-periphery/src/interfaces/IV4Router.sol":{"id":130,"ast":{}},"lib/v4-periphery/src/interfaces/external/IWETH9.sol":{"id":131,"ast":{}},"lib/v4-periphery/src/libraries/ActionConstants.sol":{"id":132,"ast":{}},"lib/v4-periphery/src/libraries/Actions.sol":{"id":133,"ast":{}},"lib/v4-periphery/src/libraries/CalldataDecoder.sol":{"id":134,"ast":{}},"lib/v4-periphery/src/libraries/ERC721PermitHash.sol":{"id":135,"ast":{}},"lib/v4-periphery/src/libraries/LiquidityAmounts.sol":{"id":136,"ast":{}},"lib/v4-periphery/src/libraries/Locker.sol":{"id":137,"ast":{}},"lib/v4-periphery/src/libraries/PathKey.sol":{"id":138,"ast":{}},"lib/v4-periphery/src/libraries/PositionInfoLibrary.sol":{"id":139,"ast":{}},"lib/v4-periphery/src/libraries/SlippageCheck.sol":{"id":140,"ast":{}},"lib/v4-periphery/src/utils/BaseHook.sol":{"id":141,"ast":{}},"src/SuperDCAGauge.sol":{"id":142,"ast":{}},"src/SuperDCAListing.sol":{"id":143,"ast":{}},"src/SuperDCAStaking.sol":{"id":144,"ast":{}},"src/interfaces/IMsgSender.sol":{"id":145,"ast":{}},"src/interfaces/ISuperDCAGauge.sol":{"id":146,"ast":{}},"src/interfaces/ISuperDCAListing.sol":{"id":147,"ast":{}},"src/interfaces/ISuperDCAStaking.sol":{"id":148,"ast":{}},"src/interfaces/ISuperchainERC20.sol":{"id":149,"ast":{}},"test/AuditTest/MaliciousUserCanObtainSoloRewards.t.sol":{"id":150,"ast":{"absolutePath":"test/AuditTest/MaliciousUserCanObtainSoloRewards.t.sol","id":70784,"exportedSymbols":{"Actions":[66300],"BalanceDelta":[59893],"Currency":[60107],"CurrencyLibrary":[60401],"Deployers":[61822],"FeesCollectionMock":[70877],"Hooks":[51011],"IAccessControl":[39425],"IAllowanceTransfer":[46443],"IERC20":[39737],"IHooks":[48824],"IPoolManager":[49123],"IPositionDescriptor":[65921],"IPositionManager":[66026],"IWETH9":[66195],"LPFeeLibrary":[51160],"MaliciousUserCanObtainSoloRewards":[70783],"MockERC20Token":[71135],"PoolId":[60407],"PoolIdLibrary":[60421],"PoolKey":[60453],"PositionManager":[63890],"SafeCast":[53351],"StdAssertions":[2695],"StdChains":[3648],"StdCheats":[6533],"StdInvariant":[6893],"StdStorage":[8017],"StdStyle":[11185],"StdUtils":[12856],"SuperDCAGauge":[68777],"SuperDCAListing":[69515],"SuperDCAStaking":[70184],"Test":[12908],"TestBase":[65],"TickMath":[55537],"TransientStateLibrary":[55673],"Vm":[17688],"console":[25804],"console2":[25804],"safeconsole":[39046],"stdError":[6599],"stdJson":[7837],"stdMath":[7979],"stdStorage":[9974],"stdToml":[12129]},"nodeType":"SourceUnit","src":"39:6270:150","nodes":[{"id":70357,"nodeType":"PragmaDirective","src":"39:24:150","nodes":[],"literals":["solidity","^","0.8",".22"]},{"id":70358,"nodeType":"ImportDirective","src":"65:28:150","nodes":[],"absolutePath":"lib/forge-std/src/Test.sol","file":"forge-std/Test.sol","nameLocation":"-1:-1:-1","scope":70784,"sourceUnit":12909,"symbolAliases":[],"unitAlias":""},{"id":70359,"nodeType":"ImportDirective","src":"94:31:150","nodes":[],"absolutePath":"lib/forge-std/src/console.sol","file":"forge-std/console.sol","nameLocation":"-1:-1:-1","scope":70784,"sourceUnit":25805,"symbolAliases":[],"unitAlias":""},{"id":70361,"nodeType":"ImportDirective","src":"126:67:150","nodes":[],"absolutePath":"lib/v4-periphery/src/libraries/Actions.sol","file":"lib/v4-periphery/src/libraries/Actions.sol","nameLocation":"-1:-1:-1","scope":70784,"sourceUnit":66301,"symbolAliases":[{"foreign":{"id":70360,"name":"Actions","nodeType":"Identifier","overloadedDeclarations":[],"referencedDeclaration":66300,"src":"134:7:150","typeDescriptions":{}},"nameLocation":"-1:-1:-1"}],"unitAlias":""},{"id":70364,"nodeType":"ImportDirective","src":"194:71:150","nodes":[],"absolutePath":"lib/v4-periphery/lib/v4-core/src/libraries/Hooks.sol","file":"@uniswap/v4-core/src/libraries/Hooks.sol","nameLocation":"-1:-1:-1","scope":70784,"sourceUnit":51012,"symbolAliases":[{"foreign":{"id":70362,"name":"Hooks","nodeType":"Identifier","overloadedDeclarations":[],"referencedDeclaration":51011,"src":"202:5:150","typeDescriptions":{}},"nameLocation":"-1:-1:-1"},{"foreign":{"id":70363,"name":"IHooks","nodeType":"Identifier","overloadedDeclarations":[],"referencedDeclaration":48824,"src":"209:6:150","typeDescriptions":{}},"nameLocation":"-1:-1:-1"}],"unitAlias":""},{"id":70366,"nodeType":"ImportDirective","src":"266:78:150","nodes":[],"absolutePath":"lib/v4-periphery/lib/v4-core/src/interfaces/IPoolManager.sol","file":"@uniswap/v4-core/src/interfaces/IPoolManager.sol","nameLocation":"-1:-1:-1","scope":70784,"sourceUnit":49124,"symbolAliases":[{"foreign":{"id":70365,"name":"IPoolManager","nodeType":"Identifier","overloadedDeclarations":[],"referencedDeclaration":49123,"src":"274:12:150","typeDescriptions":{}},"nameLocation":"-1:-1:-1"}],"unitAlias":""},{"id":70368,"nodeType":"ImportDirective","src":"345:63:150","nodes":[],"absolutePath":"lib/v4-periphery/lib/v4-core/src/types/PoolKey.sol","file":"@uniswap/v4-core/src/types/PoolKey.sol","nameLocation":"-1:-1:-1","scope":70784,"sourceUnit":60454,"symbolAliases":[{"foreign":{"id":70367,"name":"PoolKey","nodeType":"Identifier","overloadedDeclarations":[],"referencedDeclaration":60453,"src":"353:7:150","typeDescriptions":{}},"nameLocation":"-1:-1:-1"}],"unitAlias":""},{"id":70371,"nodeType":"ImportDirective","src":"409:76:150","nodes":[],"absolutePath":"lib/v4-periphery/lib/v4-core/src/types/PoolId.sol","file":"@uniswap/v4-core/src/types/PoolId.sol","nameLocation":"-1:-1:-1","scope":70784,"sourceUnit":60422,"symbolAliases":[{"foreign":{"id":70369,"name":"PoolId","nodeType":"Identifier","overloadedDeclarations":[],"referencedDeclaration":60407,"src":"417:6:150","typeDescriptions":{}},"nameLocation":"-1:-1:-1"},{"foreign":{"id":70370,"name":"PoolIdLibrary","nodeType":"Identifier","overloadedDeclarations":[],"referencedDeclaration":60421,"src":"425:13:150","typeDescriptions":{}},"nameLocation":"-1:-1:-1"}],"unitAlias":""},{"id":70374,"nodeType":"ImportDirective","src":"486:82:150","nodes":[],"absolutePath":"lib/v4-periphery/lib/v4-core/src/types/Currency.sol","file":"@uniswap/v4-core/src/types/Currency.sol","nameLocation":"-1:-1:-1","scope":70784,"sourceUnit":60402,"symbolAliases":[{"foreign":{"id":70372,"name":"Currency","nodeType":"Identifier","overloadedDeclarations":[],"referencedDeclaration":60107,"src":"494:8:150","typeDescriptions":{}},"nameLocation":"-1:-1:-1"},{"foreign":{"id":70373,"name":"CurrencyLibrary","nodeType":"Identifier","overloadedDeclarations":[],"referencedDeclaration":60401,"src":"504:15:150","typeDescriptions":{}},"nameLocation":"-1:-1:-1"}],"unitAlias":""},{"id":70376,"nodeType":"ImportDirective","src":"569:58:150","nodes":[],"absolutePath":"src/SuperDCAGauge.sol","file":"../../src/SuperDCAGauge.sol","nameLocation":"-1:-1:-1","scope":70784,"sourceUnit":68778,"symbolAliases":[{"foreign":{"id":70375,"name":"SuperDCAGauge","nodeType":"Identifier","overloadedDeclarations":[],"referencedDeclaration":68777,"src":"577:13:150","typeDescriptions":{}},"nameLocation":"-1:-1:-1"}],"unitAlias":""},{"id":70378,"nodeType":"ImportDirective","src":"628:62:150","nodes":[],"absolutePath":"src/SuperDCAStaking.sol","file":"../../src/SuperDCAStaking.sol","nameLocation":"-1:-1:-1","scope":70784,"sourceUnit":70185,"symbolAliases":[{"foreign":{"id":70377,"name":"SuperDCAStaking","nodeType":"Identifier","overloadedDeclarations":[],"referencedDeclaration":70184,"src":"636:15:150","typeDescriptions":{}},"nameLocation":"-1:-1:-1"}],"unitAlias":""},{"id":70380,"nodeType":"ImportDirective","src":"691:62:150","nodes":[],"absolutePath":"src/SuperDCAListing.sol","file":"../../src/SuperDCAListing.sol","nameLocation":"-1:-1:-1","scope":70784,"sourceUnit":69516,"symbolAliases":[{"foreign":{"id":70379,"name":"SuperDCAListing","nodeType":"Identifier","overloadedDeclarations":[],"referencedDeclaration":69515,"src":"699:15:150","typeDescriptions":{}},"nameLocation":"-1:-1:-1"}],"unitAlias":""},{"id":70382,"nodeType":"ImportDirective","src":"754:68:150","nodes":[],"absolutePath":"lib/v4-periphery/lib/v4-core/test/utils/Deployers.sol","file":"@uniswap/v4-core/test/utils/Deployers.sol","nameLocation":"-1:-1:-1","scope":70784,"sourceUnit":61823,"symbolAliases":[{"foreign":{"id":70381,"name":"Deployers","nodeType":"Identifier","overloadedDeclarations":[],"referencedDeclaration":61822,"src":"762:9:150","typeDescriptions":{}},"nameLocation":"-1:-1:-1"}],"unitAlias":""},{"id":70384,"nodeType":"ImportDirective","src":"823:66:150","nodes":[],"absolutePath":"lib/v4-periphery/lib/v4-core/src/interfaces/IHooks.sol","file":"@uniswap/v4-core/src/interfaces/IHooks.sol","nameLocation":"-1:-1:-1","scope":70784,"sourceUnit":48825,"symbolAliases":[{"foreign":{"id":70383,"name":"IHooks","nodeType":"Identifier","overloadedDeclarations":[],"referencedDeclaration":48824,"src":"831:6:150","typeDescriptions":{}},"nameLocation":"-1:-1:-1"}],"unitAlias":""},{"id":70386,"nodeType":"ImportDirective","src":"890:69:150","nodes":[],"absolutePath":"lib/v4-periphery/lib/v4-core/src/libraries/TickMath.sol","file":"@uniswap/v4-core/src/libraries/TickMath.sol","nameLocation":"-1:-1:-1","scope":70784,"sourceUnit":55538,"symbolAliases":[{"foreign":{"id":70385,"name":"TickMath","nodeType":"Identifier","overloadedDeclarations":[],"referencedDeclaration":55537,"src":"898:8:150","typeDescriptions":{}},"nameLocation":"-1:-1:-1"}],"unitAlias":""},{"id":70388,"nodeType":"ImportDirective","src":"960:40:150","nodes":[],"absolutePath":"lib/forge-std/src/Test.sol","file":"forge-std/Test.sol","nameLocation":"-1:-1:-1","scope":70784,"sourceUnit":12909,"symbolAliases":[{"foreign":{"id":70387,"name":"Test","nodeType":"Identifier","overloadedDeclarations":[],"referencedDeclaration":12908,"src":"968:4:150","typeDescriptions":{}},"nameLocation":"-1:-1:-1"}],"unitAlias":""},{"id":70390,"nodeType":"ImportDirective","src":"1001:59:150","nodes":[],"absolutePath":"test/mocks/MockERC20Token.sol","file":"../mocks/MockERC20Token.sol","nameLocation":"-1:-1:-1","scope":70784,"sourceUnit":71136,"symbolAliases":[{"foreign":{"id":70389,"name":"MockERC20Token","nodeType":"Identifier","overloadedDeclarations":[],"referencedDeclaration":71135,"src":"1009:14:150","typeDescriptions":{}},"nameLocation":"-1:-1:-1"}],"unitAlias":""},{"id":70392,"nodeType":"ImportDirective","src":"1061:67:150","nodes":[],"absolutePath":"test/mocks/FeesCollectionMock.sol","file":"../mocks/FeesCollectionMock.sol","nameLocation":"-1:-1:-1","scope":70784,"sourceUnit":70878,"symbolAliases":[{"foreign":{"id":70391,"name":"FeesCollectionMock","nodeType":"Identifier","overloadedDeclarations":[],"referencedDeclaration":70877,"src":"1069:18:150","typeDescriptions":{}},"nameLocation":"-1:-1:-1"}],"unitAlias":""},{"id":70394,"nodeType":"ImportDirective","src":"1129:73:150","nodes":[],"absolutePath":"lib/v4-periphery/lib/v4-core/src/types/BalanceDelta.sol","file":"@uniswap/v4-core/src/types/BalanceDelta.sol","nameLocation":"-1:-1:-1","scope":70784,"sourceUnit":60052,"symbolAliases":[{"foreign":{"id":70393,"name":"BalanceDelta","nodeType":"Identifier","overloadedDeclarations":[],"referencedDeclaration":59893,"src":"1137:12:150","typeDescriptions":{}},"nameLocation":"-1:-1:-1"}],"unitAlias":""},{"id":70396,"nodeType":"ImportDirective","src":"1203:69:150","nodes":[],"absolutePath":"lib/v4-periphery/lib/v4-core/src/libraries/SafeCast.sol","file":"@uniswap/v4-core/src/libraries/SafeCast.sol","nameLocation":"-1:-1:-1","scope":70784,"sourceUnit":53352,"symbolAliases":[{"foreign":{"id":70395,"name":"SafeCast","nodeType":"Identifier","overloadedDeclarations":[],"referencedDeclaration":53351,"src":"1211:8:150","typeDescriptions":{}},"nameLocation":"-1:-1:-1"}],"unitAlias":""},{"id":70398,"nodeType":"ImportDirective","src":"1273:77:150","nodes":[],"absolutePath":"lib/v4-periphery/lib/v4-core/src/libraries/LPFeeLibrary.sol","file":"@uniswap/v4-core/src/libraries/LPFeeLibrary.sol","nameLocation":"-1:-1:-1","scope":70784,"sourceUnit":51161,"symbolAliases":[{"foreign":{"id":70397,"name":"LPFeeLibrary","nodeType":"Identifier","overloadedDeclarations":[],"referencedDeclaration":51160,"src":"1281:12:150","typeDescriptions":{}},"nameLocation":"-1:-1:-1"}],"unitAlias":""},{"id":70400,"nodeType":"ImportDirective","src":"1351:95:150","nodes":[],"absolutePath":"lib/v4-periphery/lib/v4-core/src/libraries/TransientStateLibrary.sol","file":"@uniswap/v4-core/src/libraries/TransientStateLibrary.sol","nameLocation":"-1:-1:-1","scope":70784,"sourceUnit":55674,"symbolAliases":[{"foreign":{"id":70399,"name":"TransientStateLibrary","nodeType":"Identifier","overloadedDeclarations":[],"referencedDeclaration":55673,"src":"1359:21:150","typeDescriptions":{}},"nameLocation":"-1:-1:-1"}],"unitAlias":""},{"id":70402,"nodeType":"ImportDirective","src":"1447:73:150","nodes":[],"absolutePath":"lib/v4-periphery/src/PositionManager.sol","file":"lib/v4-periphery/src/PositionManager.sol","nameLocation":"-1:-1:-1","scope":70784,"sourceUnit":63891,"symbolAliases":[{"foreign":{"id":70401,"name":"PositionManager","nodeType":"Identifier","overloadedDeclarations":[],"referencedDeclaration":63890,"src":"1455:15:150","typeDescriptions":{}},"nameLocation":"-1:-1:-1"}],"unitAlias":""},{"id":70404,"nodeType":"ImportDirective","src":"1521:86:150","nodes":[],"absolutePath":"lib/v4-periphery/src/interfaces/IPositionManager.sol","file":"lib/v4-periphery/src/interfaces/IPositionManager.sol","nameLocation":"-1:-1:-1","scope":70784,"sourceUnit":66027,"symbolAliases":[{"foreign":{"id":70403,"name":"IPositionManager","nodeType":"Identifier","overloadedDeclarations":[],"referencedDeclaration":66026,"src":"1529:16:150","typeDescriptions":{}},"nameLocation":"-1:-1:-1"}],"unitAlias":""},{"id":70406,"nodeType":"ImportDirective","src":"1608:70:150","nodes":[],"absolutePath":"lib/openzeppelin-contracts/contracts/token/ERC20/IERC20.sol","file":"@openzeppelin/contracts/token/ERC20/IERC20.sol","nameLocation":"-1:-1:-1","scope":70784,"sourceUnit":39738,"symbolAliases":[{"foreign":{"id":70405,"name":"IERC20","nodeType":"Identifier","overloadedDeclarations":[],"referencedDeclaration":39737,"src":"1616:6:150","typeDescriptions":{}},"nameLocation":"-1:-1:-1"}],"unitAlias":""},{"id":70408,"nodeType":"ImportDirective","src":"1679:81:150","nodes":[],"absolutePath":"lib/v4-periphery/lib/permit2/src/interfaces/IAllowanceTransfer.sol","file":"permit2/src/interfaces/IAllowanceTransfer.sol","nameLocation":"-1:-1:-1","scope":70784,"sourceUnit":46444,"symbolAliases":[{"foreign":{"id":70407,"name":"IAllowanceTransfer","nodeType":"Identifier","overloadedDeclarations":[],"referencedDeclaration":46443,"src":"1687:18:150","typeDescriptions":{}},"nameLocation":"-1:-1:-1"}],"unitAlias":""},{"id":70410,"nodeType":"ImportDirective","src":"1761:92:150","nodes":[],"absolutePath":"lib/v4-periphery/src/interfaces/IPositionDescriptor.sol","file":"lib/v4-periphery/src/interfaces/IPositionDescriptor.sol","nameLocation":"-1:-1:-1","scope":70784,"sourceUnit":65922,"symbolAliases":[{"foreign":{"id":70409,"name":"IPositionDescriptor","nodeType":"Identifier","overloadedDeclarations":[],"referencedDeclaration":65921,"src":"1769:19:150","typeDescriptions":{}},"nameLocation":"-1:-1:-1"}],"unitAlias":""},{"id":70412,"nodeType":"ImportDirective","src":"1854:75:150","nodes":[],"absolutePath":"lib/v4-periphery/src/interfaces/external/IWETH9.sol","file":"lib/v4-periphery/src/interfaces/external/IWETH9.sol","nameLocation":"-1:-1:-1","scope":70784,"sourceUnit":66196,"symbolAliases":[{"foreign":{"id":70411,"name":"IWETH9","nodeType":"Identifier","overloadedDeclarations":[],"referencedDeclaration":66195,"src":"1862:6:150","typeDescriptions":{}},"nameLocation":"-1:-1:-1"}],"unitAlias":""},{"id":70414,"nodeType":"ImportDirective","src":"1930:81:150","nodes":[],"absolutePath":"lib/openzeppelin-contracts/contracts/access/IAccessControl.sol","file":"@openzeppelin/contracts/access/IAccessControl.sol","nameLocation":"-1:-1:-1","scope":70784,"sourceUnit":39426,"symbolAliases":[{"foreign":{"id":70413,"name":"IAccessControl","nodeType":"Identifier","overloadedDeclarations":[],"referencedDeclaration":39425,"src":"1938:14:150","typeDescriptions":{}},"nameLocation":"-1:-1:-1"}],"unitAlias":""},{"id":70416,"nodeType":"ImportDirective","src":"2012:70:150","nodes":[],"absolutePath":"lib/openzeppelin-contracts/contracts/token/ERC20/IERC20.sol","file":"@openzeppelin/contracts/token/ERC20/IERC20.sol","nameLocation":"-1:-1:-1","scope":70784,"sourceUnit":39738,"symbolAliases":[{"foreign":{"id":70415,"name":"IERC20","nodeType":"Identifier","overloadedDeclarations":[],"referencedDeclaration":39737,"src":"2020:6:150","typeDescriptions":{}},"nameLocation":"-1:-1:-1"}],"unitAlias":""},{"id":70783,"nodeType":"ContractDefinition","src":"2257:4052:150","nodes":[{"id":70424,"nodeType":"UsingForDirective","src":"2325:32:150","nodes":[],"global":false,"libraryName":{"id":70421,"name":"PoolIdLibrary","nameLocations":["2331:13:150"],"nodeType":"IdentifierPath","referencedDeclaration":60421,"src":"2331:13:150"},"typeName":{"id":70423,"nodeType":"UserDefinedTypeName","pathNode":{"id":70422,"name":"PoolKey","nameLocations":["2349:7:150"],"nodeType":"IdentifierPath","referencedDeclaration":60453,"src":"2349:7:150"},"referencedDeclaration":60453,"src":"2349:7:150","typeDescriptions":{"typeIdentifier":"t_struct$_PoolKey_$60453_storage_ptr","typeString":"struct PoolKey"}}},{"id":70428,"nodeType":"UsingForDirective","src":"2362:35:150","nodes":[],"global":false,"libraryName":{"id":70425,"name":"CurrencyLibrary","nameLocations":["2368:15:150"],"nodeType":"IdentifierPath","referencedDeclaration":60401,"src":"2368:15:150"},"typeName":{"id":70427,"nodeType":"UserDefinedTypeName","pathNode":{"id":70426,"name":"Currency","nameLocations":["2388:8:150"],"nodeType":"IdentifierPath","referencedDeclaration":60107,"src":"2388:8:150"},"referencedDeclaration":60107,"src":"2388:8:150","typeDescriptions":{"typeIdentifier":"t_userDefinedValueType$_Currency_$60107","typeString":"Currency"}}},{"id":70431,"nodeType":"UsingForDirective","src":"2402:30:150","nodes":[],"global":false,"libraryName":{"id":70429,"name":"LPFeeLibrary","nameLocations":["2408:12:150"],"nodeType":"IdentifierPath","referencedDeclaration":51160,"src":"2408:12:150"},"typeName":{"id":70430,"name":"uint24","nodeType":"ElementaryTypeName","src":"2425:6:150","typeDescriptions":{"typeIdentifier":"t_uint24","typeString":"uint24"}}},{"id":70434,"nodeType":"VariableDeclaration","src":"2438:18:150","nodes":[],"constant":false,"mutability":"mutable","name":"hook","nameLocation":"2452:4:150","scope":70783,"stateVariable":true,"storageLocation":"default","typeDescriptions":{"typeIdentifier":"t_contract$_SuperDCAGauge_$68777","typeString":"contract SuperDCAGauge"},"typeName":{"id":70433,"nodeType":"UserDefinedTypeName","pathNode":{"id":70432,"name":"SuperDCAGauge","nameLocations":["2438:13:150"],"nodeType":"IdentifierPath","referencedDeclaration":68777,"src":"2438:13:150"},"referencedDeclaration":68777,"src":"2438:13:150","typeDescriptions":{"typeIdentifier":"t_contract$_SuperDCAGauge_$68777","typeString":"contract SuperDCAGauge"}},"visibility":"internal"},{"id":70437,"nodeType":"VariableDeclaration","src":"2462:30:150","nodes":[],"constant":false,"functionSelector":"4cf088d9","mutability":"mutable","name":"staking","nameLocation":"2485:7:150","scope":70783,"stateVariable":true,"storageLocation":"default","typeDescriptions":{"typeIdentifier":"t_contract$_SuperDCAStaking_$70184","typeString":"contract SuperDCAStaking"},"typeName":{"id":70436,"nodeType":"UserDefinedTypeName","pathNode":{"id":70435,"name":"SuperDCAStaking","nameLocations":["2462:15:150"],"nodeType":"IdentifierPath","referencedDeclaration":70184,"src":"2462:15:150"},"referencedDeclaration":70184,"src":"2462:15:150","typeDescriptions":{"typeIdentifier":"t_contract$_SuperDCAStaking_$70184","typeString":"contract SuperDCAStaking"}},"visibility":"public"},{"id":70440,"nodeType":"VariableDeclaration","src":"2498:30:150","nodes":[],"constant":false,"functionSelector":"bc7c55ed","mutability":"mutable","name":"listing","nameLocation":"2521:7:150","scope":70783,"stateVariable":true,"storageLocation":"default","typeDescriptions":{"typeIdentifier":"t_contract$_SuperDCAListing_$69515","typeString":"contract SuperDCAListing"},"typeName":{"id":70439,"nodeType":"UserDefinedTypeName","pathNode":{"id":70438,"name":"SuperDCAListing","nameLocations":["2498:15:150"],"nodeType":"IdentifierPath","referencedDeclaration":69515,"src":"2498:15:150"},"referencedDeclaration":69515,"src":"2498:15:150","typeDescriptions":{"typeIdentifier":"t_contract$_SuperDCAListing_$69515","typeString":"contract SuperDCAListing"}},"visibility":"public"},{"id":70443,"nodeType":"VariableDeclaration","src":"2535:30:150","nodes":[],"constant":false,"functionSelector":"2abca154","mutability":"mutable","name":"dcaToken","nameLocation":"2557:8:150","scope":70783,"stateVariable":true,"storageLocation":"default","typeDescriptions":{"typeIdentifier":"t_contract$_MockERC20Token_$71135","typeString":"contract MockERC20Token"},"typeName":{"id":70442,"nodeType":"UserDefinedTypeName","pathNode":{"id":70441,"name":"MockERC20Token","nameLocations":["2535:14:150"],"nodeType":"IdentifierPath","referencedDeclaration":71135,"src":"2535:14:150"},"referencedDeclaration":71135,"src":"2535:14:150","typeDescriptions":{"typeIdentifier":"t_contract$_MockERC20Token_$71135","typeString":"contract MockERC20Token"}},"visibility":"public"},{"id":70446,"nodeType":"VariableDeclaration","src":"2571:13:150","nodes":[],"constant":false,"mutability":"mutable","name":"poolId","nameLocation":"2578:6:150","scope":70783,"stateVariable":true,"storageLocation":"default","typeDescriptions":{"typeIdentifier":"t_userDefinedValueType$_PoolId_$60407","typeString":"PoolId"},"typeName":{"id":70445,"nodeType":"UserDefinedTypeName","pathNode":{"id":70444,"name":"PoolId","nameLocations":["2571:6:150"],"nodeType":"IdentifierPath","referencedDeclaration":60407,"src":"2571:6:150"},"referencedDeclaration":60407,"src":"2571:6:150","typeDescriptions":{"typeIdentifier":"t_userDefinedValueType$_PoolId_$60407","typeString":"PoolId"}},"visibility":"internal"},{"id":70451,"nodeType":"VariableDeclaration","src":"2590:48:150","nodes":[],"constant":false,"mutability":"mutable","name":"developer","nameLocation":"2598:9:150","scope":70783,"stateVariable":true,"storageLocation":"default","typeDescriptions":{"typeIdentifier":"t_address","typeString":"address"},"typeName":{"id":70447,"name":"address","nodeType":"ElementaryTypeName","src":"2590:7:150","stateMutability":"nonpayable","typeDescriptions":{"typeIdentifier":"t_address","typeString":"address"}},"value":{"arguments":[{"hexValue":"646576656c6f70657241646472657373","id":70449,"isConstant":false,"isLValue":false,"isPure":true,"kind":"string","lValueRequested":false,"nodeType":"Literal","src":"2619:18:150","typeDescriptions":{"typeIdentifier":"t_stringliteral_0135fb7341f2954271cfb996f1317712b707433606c49feed356f3efb96128de","typeString":"literal_string \"developerAddress\""},"value":"developerAddress"}],"expression":{"argumentTypes":[{"typeIdentifier":"t_stringliteral_0135fb7341f2954271cfb996f1317712b707433606c49feed356f3efb96128de","typeString":"literal_string \"developerAddress\""}],"id":70448,"name":"makeAddr","nodeType":"Identifier","overloadedDeclarations":[],"referencedDeclaration":5500,"src":"2610:8:150","typeDescriptions":{"typeIdentifier":"t_function_internal_nonpayable$_t_string_memory_ptr_$returns$_t_address_$","typeString":"function (string memory) returns (address)"}},"id":70450,"isConstant":false,"isLValue":false,"isPure":false,"kind":"functionCall","lValueRequested":false,"nameLocations":[],"names":[],"nodeType":"FunctionCall","src":"2610:28:150","tryCall":false,"typeDescriptions":{"typeIdentifier":"t_address","typeString":"address"}},"visibility":"internal"},{"id":70457,"nodeType":"VariableDeclaration","src":"2644:95:150","nodes":[],"constant":false,"mutability":"mutable","name":"positionManager","nameLocation":"2661:15:150","scope":70783,"stateVariable":true,"storageLocation":"default","typeDescriptions":{"typeIdentifier":"t_contract$_IPositionManager_$66026","typeString":"contract IPositionManager"},"typeName":{"id":70453,"nodeType":"UserDefinedTypeName","pathNode":{"id":70452,"name":"IPositionManager","nameLocations":["2644:16:150"],"nodeType":"IdentifierPath","referencedDeclaration":66026,"src":"2644:16:150"},"referencedDeclaration":66026,"src":"2644:16:150","typeDescriptions":{"typeIdentifier":"t_contract$_IPositionManager_$66026","typeString":"contract IPositionManager"}},"value":{"arguments":[{"hexValue":"307833363045363866614363636138634134393563314237353946643945456534363664623946423332","id":70455,"isConstant":false,"isLValue":false,"isPure":true,"kind":"number","lValueRequested":false,"nodeType":"Literal","src":"2696:42:150","typeDescriptions":{"typeIdentifier":"t_address","typeString":"address"},"value":"0x360E68faCcca8cA495c1B759Fd9EEe466db9FB32"}],"expression":{"argumentTypes":[{"typeIdentifier":"t_address","typeString":"address"}],"id":70454,"name":"IPositionManager","nodeType":"Identifier","overloadedDeclarations":[],"referencedDeclaration":66026,"src":"2679:16:150","typeDescriptions":{"typeIdentifier":"t_type$_t_contract$_IPositionManager_$66026_$","typeString":"type(contract IPositionManager)"}},"id":70456,"isConstant":false,"isLValue":false,"isPure":true,"kind":"typeConversion","lValueRequested":false,"nameLocations":[],"names":[],"nodeType":"FunctionCall","src":"2679:60:150","tryCall":false,"typeDescriptions":{"typeIdentifier":"t_contract$_IPositionManager_$66026","typeString":"contract IPositionManager"}},"visibility":"internal"},{"id":70460,"nodeType":"VariableDeclaration","src":"2746:64:150","nodes":[],"constant":false,"mutability":"mutable","name":"poolManager","nameLocation":"2754:11:150","scope":70783,"stateVariable":true,"storageLocation":"default","typeDescriptions":{"typeIdentifier":"t_address","typeString":"address"},"typeName":{"id":70458,"name":"address","nodeType":"ElementaryTypeName","src":"2746:7:150","stateMutability":"nonpayable","typeDescriptions":{"typeIdentifier":"t_address","typeString":"address"}},"value":{"hexValue":"307833363045363866614363636138634134393563314237353946643945456534363664623946423332","id":70459,"isConstant":false,"isLValue":false,"isPure":true,"kind":"number","lValueRequested":false,"nodeType":"Literal","src":"2768:42:150","typeDescriptions":{"typeIdentifier":"t_address","typeString":"address"},"value":"0x360E68faCcca8cA495c1B759Fd9EEe466db9FB32"},"visibility":"internal"},{"id":70463,"nodeType":"VariableDeclaration","src":"2817:73:150","nodes":[],"constant":true,"functionSelector":"3fc8cef3","mutability":"constant","name":"weth","nameLocation":"2841:4:150","scope":70783,"stateVariable":true,"storageLocation":"default","typeDescriptions":{"typeIdentifier":"t_address","typeString":"address"},"typeName":{"id":70461,"name":"address","nodeType":"ElementaryTypeName","src":"2817:7:150","stateMutability":"nonpayable","typeDescriptions":{"typeIdentifier":"t_address","typeString":"address"}},"value":{"hexValue":"307838326146343934343744386130376533626439354244306435366633353234313532336642616231","id":70462,"isConstant":false,"isLValue":false,"isPure":true,"kind":"number","lValueRequested":false,"nodeType":"Literal","src":"2848:42:150","typeDescriptions":{"typeIdentifier":"t_address","typeString":"address"},"value":"0x82aF49447D8a07e3bd95BD0d56f35241523fBab1"},"visibility":"public"},{"id":70469,"nodeType":"VariableDeclaration","src":"2896:107:150","nodes":[],"constant":true,"functionSelector":"6afdd850","mutability":"constant","name":"PERMIT2","nameLocation":"2931:7:150","scope":70783,"stateVariable":true,"storageLocation":"default","typeDescriptions":{"typeIdentifier":"t_contract$_IAllowanceTransfer_$46443","typeString":"contract IAllowanceTransfer"},"typeName":{"id":70465,"nodeType":"UserDefinedTypeName","pathNode":{"id":70464,"name":"IAllowanceTransfer","nameLocations":["2896:18:150"],"nodeType":"IdentifierPath","referencedDeclaration":46443,"src":"2896:18:150"},"referencedDeclaration":46443,"src":"2896:18:150","typeDescriptions":{"typeIdentifier":"t_contract$_IAllowanceTransfer_$46443","typeString":"contract IAllowanceTransfer"}},"value":{"arguments":[{"hexValue":"307830303030303030303030323244343733303330463131366444454539463642343361433738424133","id":70467,"isConstant":false,"isLValue":false,"isPure":true,"kind":"number","lValueRequested":false,"nodeType":"Literal","src":"2960:42:150","typeDescriptions":{"typeIdentifier":"t_address","typeString":"address"},"value":"0x000000000022D473030F116dDEE9F6B43aC78BA3"}],"expression":{"argumentTypes":[{"typeIdentifier":"t_address","typeString":"address"}],"id":70466,"name":"IAllowanceTransfer","nodeType":"Identifier","overloadedDeclarations":[],"referencedDeclaration":46443,"src":"2941:18:150","typeDescriptions":{"typeIdentifier":"t_type$_t_contract$_IAllowanceTransfer_$46443_$","typeString":"type(contract IAllowanceTransfer)"}},"id":70468,"isConstant":false,"isLValue":false,"isPure":true,"kind":"typeConversion","lValueRequested":false,"nameLocations":[],"names":[],"nodeType":"FunctionCall","src":"2941:62:150","tryCall":false,"typeDescriptions":{"typeIdentifier":"t_contract$_IAllowanceTransfer_$46443","typeString":"contract IAllowanceTransfer"}},"visibility":"public"},{"id":70472,"nodeType":"VariableDeclaration","src":"3033:48:150","nodes":[],"constant":true,"functionSelector":"8b8cf341","mutability":"constant","name":"UNSUBSCRIBE_LIMIT","nameLocation":"3057:17:150","scope":70783,"stateVariable":true,"storageLocation":"default","typeDescriptions":{"typeIdentifier":"t_uint256","typeString":"uint256"},"typeName":{"id":70470,"name":"uint256","nodeType":"ElementaryTypeName","src":"3033:7:150","typeDescriptions":{"typeIdentifier":"t_uint256","typeString":"uint256"}},"value":{"hexValue":"35303030","id":70471,"isConstant":false,"isLValue":false,"isPure":true,"kind":"number","lValueRequested":false,"nodeType":"Literal","src":"3077:4:150","typeDescriptions":{"typeIdentifier":"t_rational_5000_by_1","typeString":"int_const 5000"},"value":"5000"},"visibility":"public"},{"id":70475,"nodeType":"VariableDeclaration","src":"3087:42:150","nodes":[],"constant":false,"functionSelector":"5a9d7a68","mutability":"mutable","name":"tokenDescriptor","nameLocation":"3114:15:150","scope":70783,"stateVariable":true,"storageLocation":"default","typeDescriptions":{"typeIdentifier":"t_contract$_IPositionDescriptor_$65921","typeString":"contract IPositionDescriptor"},"typeName":{"id":70474,"nodeType":"UserDefinedTypeName","pathNode":{"id":70473,"name":"IPositionDescriptor","nameLocations":["3087:19:150"],"nodeType":"IdentifierPath","referencedDeclaration":65921,"src":"3087:19:150"},"referencedDeclaration":65921,"src":"3087:19:150","typeDescriptions":{"typeIdentifier":"t_contract$_IPositionDescriptor_$65921","typeString":"contract IPositionDescriptor"}},"visibility":"public"},{"id":70478,"nodeType":"VariableDeclaration","src":"3135:27:150","nodes":[],"constant":false,"functionSelector":"0373b885","mutability":"mutable","name":"posM","nameLocation":"3158:4:150","scope":70783,"stateVariable":true,"storageLocation":"default","typeDescriptions":{"typeIdentifier":"t_contract$_PositionManager_$63890","typeString":"contract PositionManager"},"typeName":{"id":70477,"nodeType":"UserDefinedTypeName","pathNode":{"id":70476,"name":"PositionManager","nameLocations":["3135:15:150"],"nodeType":"IdentifierPath","referencedDeclaration":63890,"src":"3135:15:150"},"referencedDeclaration":63890,"src":"3135:15:150","typeDescriptions":{"typeIdentifier":"t_contract$_PositionManager_$63890","typeString":"contract PositionManager"}},"visibility":"public"},{"id":70636,"nodeType":"FunctionDefinition","src":"3169:1154:150","nodes":[],"body":{"id":70635,"nodeType":"Block","src":"3193:1130:150","nodes":[],"statements":[{"expression":{"arguments":[{"id":70484,"name":"developer","nodeType":"Identifier","overloadedDeclarations":[],"referencedDeclaration":70451,"src":"3217:9:150","typeDescriptions":{"typeIdentifier":"t_address","typeString":"address"}}],"expression":{"argumentTypes":[{"typeIdentifier":"t_address","typeString":"address"}],"expression":{"id":70481,"name":"vm","nodeType":"Identifier","overloadedDeclarations":[],"referencedDeclaration":58,"src":"3203:2:150","typeDescriptions":{"typeIdentifier":"t_contract$_Vm_$17688","typeString":"contract Vm"}},"id":70483,"isConstant":false,"isLValue":false,"isPure":false,"lValueRequested":false,"memberLocation":"3206:10:150","memberName":"startPrank","nodeType":"MemberAccess","referencedDeclaration":17201,"src":"3203:13:150","typeDescriptions":{"typeIdentifier":"t_function_external_nonpayable$_t_address_$returns$__$","typeString":"function (address) external"}},"id":70485,"isConstant":false,"isLValue":false,"isPure":false,"kind":"functionCall","lValueRequested":false,"nameLocations":[],"names":[],"nodeType":"FunctionCall","src":"3203:24:150","tryCall":false,"typeDescriptions":{"typeIdentifier":"t_tuple$__$","typeString":"tuple()"}},"id":70486,"nodeType":"ExpressionStatement","src":"3203:24:150"},{"expression":{"id":70495,"isConstant":false,"isLValue":false,"isPure":false,"lValueRequested":false,"leftHandSide":{"id":70487,"name":"dcaToken","nodeType":"Identifier","overloadedDeclarations":[],"referencedDeclaration":70443,"src":"3238:8:150","typeDescriptions":{"typeIdentifier":"t_contract$_MockERC20Token_$71135","typeString":"contract MockERC20Token"}},"nodeType":"Assignment","operator":"=","rightHandSide":{"arguments":[{"hexValue":"53757065722044434120546f6b656e","id":70491,"isConstant":false,"isLValue":false,"isPure":true,"kind":"string","lValueRequested":false,"nodeType":"Literal","src":"3268:17:150","typeDescriptions":{"typeIdentifier":"t_stringliteral_5e2b3d22961633b6cd50519e42c170d76384a1b55c35770aa7e7df79c7494d8d","typeString":"literal_string \"Super DCA Token\""},"value":"Super DCA Token"},{"hexValue":"53444341","id":70492,"isConstant":false,"isLValue":false,"isPure":true,"kind":"string","lValueRequested":false,"nodeType":"Literal","src":"3287:6:150","typeDescriptions":{"typeIdentifier":"t_stringliteral_a1b4e6d71a92d3c60bea052d1f477f8a3407be2828fb0a026bdd75fb2bfdad52","typeString":"literal_string \"SDCA\""},"value":"SDCA"},{"hexValue":"3138","id":70493,"isConstant":false,"isLValue":false,"isPure":true,"kind":"number","lValueRequested":false,"nodeType":"Literal","src":"3295:2:150","typeDescriptions":{"typeIdentifier":"t_rational_18_by_1","typeString":"int_const 18"},"value":"18"}],"expression":{"argumentTypes":[{"typeIdentifier":"t_stringliteral_5e2b3d22961633b6cd50519e42c170d76384a1b55c35770aa7e7df79c7494d8d","typeString":"literal_string \"Super DCA Token\""},{"typeIdentifier":"t_stringliteral_a1b4e6d71a92d3c60bea052d1f477f8a3407be2828fb0a026bdd75fb2bfdad52","typeString":"literal_string \"SDCA\""},{"typeIdentifier":"t_rational_18_by_1","typeString":"int_const 18"}],"id":70490,"isConstant":false,"isLValue":false,"isPure":false,"lValueRequested":false,"nodeType":"NewExpression","src":"3249:18:150","typeDescriptions":{"typeIdentifier":"t_function_creation_nonpayable$_t_string_memory_ptr_$_t_string_memory_ptr_$_t_uint8_$returns$_t_contract$_MockERC20Token_$71135_$","typeString":"function (string memory,string memory,uint8) returns (contract MockERC20Token)"},"typeName":{"id":70489,"nodeType":"UserDefinedTypeName","pathNode":{"id":70488,"name":"MockERC20Token","nameLocations":["3253:14:150"],"nodeType":"IdentifierPath","referencedDeclaration":71135,"src":"3253:14:150"},"referencedDeclaration":71135,"src":"3253:14:150","typeDescriptions":{"typeIdentifier":"t_contract$_MockERC20Token_$71135","typeString":"contract MockERC20Token"}}},"id":70494,"isConstant":false,"isLValue":false,"isPure":false,"kind":"functionCall","lValueRequested":false,"nameLocations":[],"names":[],"nodeType":"FunctionCall","src":"3249:49:150","tryCall":false,"typeDescriptions":{"typeIdentifier":"t_contract$_MockERC20Token_$71135","typeString":"contract MockERC20Token"}},"src":"3238:60:150","typeDescriptions":{"typeIdentifier":"t_contract$_MockERC20Token_$71135","typeString":"contract MockERC20Token"}},"id":70496,"nodeType":"ExpressionStatement","src":"3238:60:150"},{"assignments":[70498],"declarations":[{"constant":false,"id":70498,"mutability":"mutable","name":"flags","nameLocation":"3324:5:150","nodeType":"VariableDeclaration","scope":70635,"src":"3316:13:150","stateVariable":false,"storageLocation":"default","typeDescriptions":{"typeIdentifier":"t_address","typeString":"address"},"typeName":{"id":70497,"name":"address","nodeType":"ElementaryTypeName","src":"3316:7:150","stateMutability":"nonpayable","typeDescriptions":{"typeIdentifier":"t_address","typeString":"address"}},"visibility":"internal"}],"id":70524,"initialValue":{"arguments":[{"commonType":{"typeIdentifier":"t_uint160","typeString":"uint160"},"id":70522,"isConstant":false,"isLValue":false,"isPure":true,"lValueRequested":false,"leftExpression":{"arguments":[{"commonType":{"typeIdentifier":"t_uint160","typeString":"uint160"},"id":70516,"isConstant":false,"isLValue":false,"isPure":true,"lValueRequested":false,"leftExpression":{"commonType":{"typeIdentifier":"t_uint160","typeString":"uint160"},"id":70513,"isConstant":false,"isLValue":false,"isPure":true,"lValueRequested":false,"leftExpression":{"commonType":{"typeIdentifier":"t_uint160","typeString":"uint160"},"id":70510,"isConstant":false,"isLValue":false,"isPure":true,"lValueRequested":false,"leftExpression":{"commonType":{"typeIdentifier":"t_uint160","typeString":"uint160"},"id":70507,"isConstant":false,"isLValue":false,"isPure":true,"lValueRequested":false,"leftExpression":{"expression":{"id":70503,"name":"Hooks","nodeType":"Identifier","overloadedDeclarations":[],"referencedDeclaration":51011,"src":"3378:5:150","typeDescriptions":{"typeIdentifier":"t_type$_t_contract$_Hooks_$51011_$","typeString":"type(library Hooks)"}},"id":70504,"isConstant":false,"isLValue":false,"isPure":true,"lValueRequested":false,"memberLocation":"3384:22:150","memberName":"BEFORE_INITIALIZE_FLAG","nodeType":"MemberAccess","referencedDeclaration":49902,"src":"3378:28:150","typeDescriptions":{"typeIdentifier":"t_uint160","typeString":"uint160"}},"nodeType":"BinaryOperation","operator":"|","rightExpression":{"expression":{"id":70505,"name":"Hooks","nodeType":"Identifier","overloadedDeclarations":[],"referencedDeclaration":51011,"src":"3409:5:150","typeDescriptions":{"typeIdentifier":"t_type$_t_contract$_Hooks_$51011_$","typeString":"type(library Hooks)"}},"id":70506,"isConstant":false,"isLValue":false,"isPure":true,"lValueRequested":false,"memberLocation":"3415:25:150","memberName":"BEFORE_ADD_LIQUIDITY_FLAG","nodeType":"MemberAccess","referencedDeclaration":49912,"src":"3409:31:150","typeDescriptions":{"typeIdentifier":"t_uint160","typeString":"uint160"}},"src":"3378:62:150","typeDescriptions":{"typeIdentifier":"t_uint160","typeString":"uint160"}},"nodeType":"BinaryOperation","operator":"|","rightExpression":{"expression":{"id":70508,"name":"Hooks","nodeType":"Identifier","overloadedDeclarations":[],"referencedDeclaration":51011,"src":"3443:5:150","typeDescriptions":{"typeIdentifier":"t_type$_t_contract$_Hooks_$51011_$","typeString":"type(library Hooks)"}},"id":70509,"isConstant":false,"isLValue":false,"isPure":true,"lValueRequested":false,"memberLocation":"3449:28:150","memberName":"BEFORE_REMOVE_LIQUIDITY_FLAG","nodeType":"MemberAccess","referencedDeclaration":49922,"src":"3443:34:150","typeDescriptions":{"typeIdentifier":"t_uint160","typeString":"uint160"}},"src":"3378:99:150","typeDescriptions":{"typeIdentifier":"t_uint160","typeString":"uint160"}},"nodeType":"BinaryOperation","operator":"|","rightExpression":{"expression":{"id":70511,"name":"Hooks","nodeType":"Identifier","overloadedDeclarations":[],"referencedDeclaration":51011,"src":"3500:5:150","typeDescriptions":{"typeIdentifier":"t_type$_t_contract$_Hooks_$51011_$","typeString":"type(library Hooks)"}},"id":70512,"isConstant":false,"isLValue":false,"isPure":true,"lValueRequested":false,"memberLocation":"3506:16:150","memberName":"BEFORE_SWAP_FLAG","nodeType":"MemberAccess","referencedDeclaration":49932,"src":"3500:22:150","typeDescriptions":{"typeIdentifier":"t_uint160","typeString":"uint160"}},"src":"3378:144:150","typeDescriptions":{"typeIdentifier":"t_uint160","typeString":"uint160"}},"nodeType":"BinaryOperation","operator":"|","rightExpression":{"expression":{"id":70514,"name":"Hooks","nodeType":"Identifier","overloadedDeclarations":[],"referencedDeclaration":51011,"src":"3525:5:150","typeDescriptions":{"typeIdentifier":"t_type$_t_contract$_Hooks_$51011_$","typeString":"type(library Hooks)"}},"id":70515,"isConstant":false,"isLValue":false,"isPure":true,"lValueRequested":false,"memberLocation":"3531:21:150","memberName":"AFTER_INITIALIZE_FLAG","nodeType":"MemberAccess","referencedDeclaration":49907,"src":"3525:27:150","typeDescriptions":{"typeIdentifier":"t_uint160","typeString":"uint160"}},"src":"3378:174:150","typeDescriptions":{"typeIdentifier":"t_uint160","typeString":"uint160"}}],"expression":{"argumentTypes":[{"typeIdentifier":"t_uint160","typeString":"uint160"}],"id":70502,"isConstant":false,"isLValue":false,"isPure":true,"lValueRequested":false,"nodeType":"ElementaryTypeNameExpression","src":"3353:7:150","typeDescriptions":{"typeIdentifier":"t_type$_t_uint160_$","typeString":"type(uint160)"},"typeName":{"id":70501,"name":"uint160","nodeType":"ElementaryTypeName","src":"3353:7:150","typeDescriptions":{}}},"id":70517,"isConstant":false,"isLValue":false,"isPure":true,"kind":"typeConversion","lValueRequested":false,"nameLocations":[],"names":[],"nodeType":"FunctionCall","src":"3353:213:150","tryCall":false,"typeDescriptions":{"typeIdentifier":"t_uint160","typeString":"uint160"}},"nodeType":"BinaryOperation","operator":"^","rightExpression":{"components":[{"commonType":{"typeIdentifier":"t_rational_378265240057476429726728853340661507864439816192_by_1","typeString":"int_const 3782...(40 digits omitted)...6192"},"id":70520,"isConstant":false,"isLValue":false,"isPure":true,"lValueRequested":false,"leftExpression":{"hexValue":"307834323432","id":70518,"isConstant":false,"isLValue":false,"isPure":true,"kind":"number","lValueRequested":false,"nodeType":"Literal","src":"3570:6:150","typeDescriptions":{"typeIdentifier":"t_rational_16962_by_1","typeString":"int_const 16962"},"value":"0x4242"},"nodeType":"BinaryOperation","operator":"<<","rightExpression":{"hexValue":"313434","id":70519,"isConstant":false,"isLValue":false,"isPure":true,"kind":"number","lValueRequested":false,"nodeType":"Literal","src":"3580:3:150","typeDescriptions":{"typeIdentifier":"t_rational_144_by_1","typeString":"int_const 144"},"value":"144"},"src":"3570:13:150","typeDescriptions":{"typeIdentifier":"t_rational_378265240057476429726728853340661507864439816192_by_1","typeString":"int_const 3782...(40 digits omitted)...6192"}}],"id":70521,"isConstant":false,"isInlineArray":false,"isLValue":false,"isPure":true,"lValueRequested":false,"nodeType":"TupleExpression","src":"3569:15:150","typeDescriptions":{"typeIdentifier":"t_rational_378265240057476429726728853340661507864439816192_by_1","typeString":"int_const 3782...(40 digits omitted)...6192"}},"src":"3353:231:150","typeDescriptions":{"typeIdentifier":"t_uint160","typeString":"uint160"}}],"expression":{"argumentTypes":[{"typeIdentifier":"t_uint160","typeString":"uint160"}],"id":70500,"isConstant":false,"isLValue":false,"isPure":true,"lValueRequested":false,"nodeType":"ElementaryTypeNameExpression","src":"3332:7:150","typeDescriptions":{"typeIdentifier":"t_type$_t_address_$","typeString":"type(address)"},"typeName":{"id":70499,"name":"address","nodeType":"ElementaryTypeName","src":"3332:7:150","typeDescriptions":{}}},"id":70523,"isConstant":false,"isLValue":false,"isPure":true,"kind":"typeConversion","lValueRequested":false,"nameLocations":[],"names":[],"nodeType":"FunctionCall","src":"3332:262:150","tryCall":false,"typeDescriptions":{"typeIdentifier":"t_address","typeString":"address"}},"nodeType":"VariableDeclarationStatement","src":"3316:278:150"},{"assignments":[70526],"declarations":[{"constant":false,"id":70526,"mutability":"mutable","name":"constructorArgs","nameLocation":"3617:15:150","nodeType":"VariableDeclaration","scope":70635,"src":"3604:28:150","stateVariable":false,"storageLocation":"memory","typeDescriptions":{"typeIdentifier":"t_bytes_memory_ptr","typeString":"bytes"},"typeName":{"id":70525,"name":"bytes","nodeType":"ElementaryTypeName","src":"3604:5:150","typeDescriptions":{"typeIdentifier":"t_bytes_storage_ptr","typeString":"bytes"}},"visibility":"internal"}],"id":70536,"initialValue":{"arguments":[{"arguments":[{"id":70530,"name":"poolManager","nodeType":"Identifier","overloadedDeclarations":[],"referencedDeclaration":70460,"src":"3659:11:150","typeDescriptions":{"typeIdentifier":"t_address","typeString":"address"}}],"expression":{"argumentTypes":[{"typeIdentifier":"t_address","typeString":"address"}],"id":70529,"name":"IPoolManager","nodeType":"Identifier","overloadedDeclarations":[],"referencedDeclaration":49123,"src":"3646:12:150","typeDescriptions":{"typeIdentifier":"t_type$_t_contract$_IPoolManager_$49123_$","typeString":"type(contract IPoolManager)"}},"id":70531,"isConstant":false,"isLValue":false,"isPure":false,"kind":"typeConversion","lValueRequested":false,"nameLocations":[],"names":[],"nodeType":"FunctionCall","src":"3646:25:150","tryCall":false,"typeDescriptions":{"typeIdentifier":"t_contract$_IPoolManager_$49123","typeString":"contract IPoolManager"}},{"id":70532,"name":"dcaToken","nodeType":"Identifier","overloadedDeclarations":[],"referencedDeclaration":70443,"src":"3673:8:150","typeDescriptions":{"typeIdentifier":"t_contract$_MockERC20Token_$71135","typeString":"contract MockERC20Token"}},{"id":70533,"name":"developer","nodeType":"Identifier","overloadedDeclarations":[],"referencedDeclaration":70451,"src":"3683:9:150","typeDescriptions":{"typeIdentifier":"t_address","typeString":"address"}},{"id":70534,"name":"positionManager","nodeType":"Identifier","overloadedDeclarations":[],"referencedDeclaration":70457,"src":"3694:15:150","typeDescriptions":{"typeIdentifier":"t_contract$_IPositionManager_$66026","typeString":"contract IPositionManager"}}],"expression":{"argumentTypes":[{"typeIdentifier":"t_contract$_IPoolManager_$49123","typeString":"contract IPoolManager"},{"typeIdentifier":"t_contract$_MockERC20Token_$71135","typeString":"contract MockERC20Token"},{"typeIdentifier":"t_address","typeString":"address"},{"typeIdentifier":"t_contract$_IPositionManager_$66026","typeString":"contract IPositionManager"}],"expression":{"id":70527,"name":"abi","nodeType":"Identifier","overloadedDeclarations":[],"referencedDeclaration":-1,"src":"3635:3:150","typeDescriptions":{"typeIdentifier":"t_magic_abi","typeString":"abi"}},"id":70528,"isConstant":false,"isLValue":false,"isPure":true,"lValueRequested":false,"memberLocation":"3639:6:150","memberName":"encode","nodeType":"MemberAccess","src":"3635:10:150","typeDescriptions":{"typeIdentifier":"t_function_abiencode_pure$__$returns$_t_bytes_memory_ptr_$","typeString":"function () pure returns (bytes memory)"}},"id":70535,"isConstant":false,"isLValue":false,"isPure":false,"kind":"functionCall","lValueRequested":false,"nameLocations":[],"names":[],"nodeType":"FunctionCall","src":"3635:75:150","tryCall":false,"typeDescriptions":{"typeIdentifier":"t_bytes_memory_ptr","typeString":"bytes memory"}},"nodeType":"VariableDeclarationStatement","src":"3604:106:150"},{"expression":{"arguments":[{"hexValue":"537570657244434147617567652e736f6c3a53757065724443414761756765","id":70538,"isConstant":false,"isLValue":false,"isPure":true,"kind":"string","lValueRequested":false,"nodeType":"Literal","src":"3734:33:150","typeDescriptions":{"typeIdentifier":"t_stringliteral_3e85413dfee4a629a1f8d90ec63276710684e96ea809c4b0c404460b2d162877","typeString":"literal_string \"SuperDCAGauge.sol:SuperDCAGauge\""},"value":"SuperDCAGauge.sol:SuperDCAGauge"},{"id":70539,"name":"constructorArgs","nodeType":"Identifier","overloadedDeclarations":[],"referencedDeclaration":70526,"src":"3769:15:150","typeDescriptions":{"typeIdentifier":"t_bytes_memory_ptr","typeString":"bytes memory"}},{"id":70540,"name":"flags","nodeType":"Identifier","overloadedDeclarations":[],"referencedDeclaration":70498,"src":"3786:5:150","typeDescriptions":{"typeIdentifier":"t_address","typeString":"address"}}],"expression":{"argumentTypes":[{"typeIdentifier":"t_stringliteral_3e85413dfee4a629a1f8d90ec63276710684e96ea809c4b0c404460b2d162877","typeString":"literal_string \"SuperDCAGauge.sol:SuperDCAGauge\""},{"typeIdentifier":"t_bytes_memory_ptr","typeString":"bytes memory"},{"typeIdentifier":"t_address","typeString":"address"}],"id":70537,"name":"deployCodeTo","nodeType":"Identifier","overloadedDeclarations":[6440,6457,6510],"referencedDeclaration":6457,"src":"3721:12:150","typeDescriptions":{"typeIdentifier":"t_function_internal_nonpayable$_t_string_memory_ptr_$_t_bytes_memory_ptr_$_t_address_$returns$__$","typeString":"function (string memory,bytes memory,address)"}},"id":70541,"isConstant":false,"isLValue":false,"isPure":false,"kind":"functionCall","lValueRequested":false,"nameLocations":[],"names":[],"nodeType":"FunctionCall","src":"3721:71:150","tryCall":false,"typeDescriptions":{"typeIdentifier":"t_tuple$__$","typeString":"tuple()"}},"id":70542,"nodeType":"ExpressionStatement","src":"3721:71:150"},{"expression":{"id":70547,"isConstant":false,"isLValue":false,"isPure":false,"lValueRequested":false,"leftHandSide":{"id":70543,"name":"hook","nodeType":"Identifier","overloadedDeclarations":[],"referencedDeclaration":70434,"src":"3802:4:150","typeDescriptions":{"typeIdentifier":"t_contract$_SuperDCAGauge_$68777","typeString":"contract SuperDCAGauge"}},"nodeType":"Assignment","operator":"=","rightHandSide":{"arguments":[{"id":70545,"name":"flags","nodeType":"Identifier","overloadedDeclarations":[],"referencedDeclaration":70498,"src":"3823:5:150","typeDescriptions":{"typeIdentifier":"t_address","typeString":"address"}}],"expression":{"argumentTypes":[{"typeIdentifier":"t_address","typeString":"address"}],"id":70544,"name":"SuperDCAGauge","nodeType":"Identifier","overloadedDeclarations":[],"referencedDeclaration":68777,"src":"3809:13:150","typeDescriptions":{"typeIdentifier":"t_type$_t_contract$_SuperDCAGauge_$68777_$","typeString":"type(contract SuperDCAGauge)"}},"id":70546,"isConstant":false,"isLValue":false,"isPure":false,"kind":"typeConversion","lValueRequested":false,"nameLocations":[],"names":[],"nodeType":"FunctionCall","src":"3809:20:150","tryCall":false,"typeDescriptions":{"typeIdentifier":"t_contract$_SuperDCAGauge_$68777","typeString":"contract SuperDCAGauge"}},"src":"3802:27:150","typeDescriptions":{"typeIdentifier":"t_contract$_SuperDCAGauge_$68777","typeString":"contract SuperDCAGauge"}},"id":70548,"nodeType":"ExpressionStatement","src":"3802:27:150"},{"expression":{"id":70571,"isConstant":false,"isLValue":false,"isPure":false,"lValueRequested":false,"leftHandSide":{"id":70549,"name":"listing","nodeType":"Identifier","overloadedDeclarations":[],"referencedDeclaration":70440,"src":"3839:7:150","typeDescriptions":{"typeIdentifier":"t_contract$_SuperDCAListing_$69515","typeString":"contract SuperDCAListing"}},"nodeType":"Assignment","operator":"=","rightHandSide":{"arguments":[{"arguments":[{"id":70555,"name":"dcaToken","nodeType":"Identifier","overloadedDeclarations":[],"referencedDeclaration":70443,"src":"3877:8:150","typeDescriptions":{"typeIdentifier":"t_contract$_MockERC20Token_$71135","typeString":"contract MockERC20Token"}}],"expression":{"argumentTypes":[{"typeIdentifier":"t_contract$_MockERC20Token_$71135","typeString":"contract MockERC20Token"}],"id":70554,"isConstant":false,"isLValue":false,"isPure":true,"lValueRequested":false,"nodeType":"ElementaryTypeNameExpression","src":"3869:7:150","typeDescriptions":{"typeIdentifier":"t_type$_t_address_$","typeString":"type(address)"},"typeName":{"id":70553,"name":"address","nodeType":"ElementaryTypeName","src":"3869:7:150","typeDescriptions":{}}},"id":70556,"isConstant":false,"isLValue":false,"isPure":false,"kind":"typeConversion","lValueRequested":false,"nameLocations":[],"names":[],"nodeType":"FunctionCall","src":"3869:17:150","tryCall":false,"typeDescriptions":{"typeIdentifier":"t_address","typeString":"address"}},{"arguments":[{"id":70558,"name":"poolManager","nodeType":"Identifier","overloadedDeclarations":[],"referencedDeclaration":70460,"src":"3901:11:150","typeDescriptions":{"typeIdentifier":"t_address","typeString":"address"}}],"expression":{"argumentTypes":[{"typeIdentifier":"t_address","typeString":"address"}],"id":70557,"name":"IPoolManager","nodeType":"Identifier","overloadedDeclarations":[],"referencedDeclaration":49123,"src":"3888:12:150","typeDescriptions":{"typeIdentifier":"t_type$_t_contract$_IPoolManager_$49123_$","typeString":"type(contract IPoolManager)"}},"id":70559,"isConstant":false,"isLValue":false,"isPure":false,"kind":"typeConversion","lValueRequested":false,"nameLocations":[],"names":[],"nodeType":"FunctionCall","src":"3888:25:150","tryCall":false,"typeDescriptions":{"typeIdentifier":"t_contract$_IPoolManager_$49123","typeString":"contract IPoolManager"}},{"arguments":[{"id":70561,"name":"positionManager","nodeType":"Identifier","overloadedDeclarations":[],"referencedDeclaration":70457,"src":"3932:15:150","typeDescriptions":{"typeIdentifier":"t_contract$_IPositionManager_$66026","typeString":"contract IPositionManager"}}],"expression":{"argumentTypes":[{"typeIdentifier":"t_contract$_IPositionManager_$66026","typeString":"contract IPositionManager"}],"id":70560,"name":"IPositionManager","nodeType":"Identifier","overloadedDeclarations":[],"referencedDeclaration":66026,"src":"3915:16:150","typeDescriptions":{"typeIdentifier":"t_type$_t_contract$_IPositionManager_$66026_$","typeString":"type(contract IPositionManager)"}},"id":70562,"isConstant":false,"isLValue":false,"isPure":false,"kind":"typeConversion","lValueRequested":false,"nameLocations":[],"names":[],"nodeType":"FunctionCall","src":"3915:33:150","tryCall":false,"typeDescriptions":{"typeIdentifier":"t_contract$_IPositionManager_$66026","typeString":"contract IPositionManager"}},{"id":70563,"name":"developer","nodeType":"Identifier","overloadedDeclarations":[],"referencedDeclaration":70451,"src":"3950:9:150","typeDescriptions":{"typeIdentifier":"t_address","typeString":"address"}},{"arguments":[{"arguments":[{"id":70567,"name":"hook","nodeType":"Identifier","overloadedDeclarations":[],"referencedDeclaration":70434,"src":"3976:4:150","typeDescriptions":{"typeIdentifier":"t_contract$_SuperDCAGauge_$68777","typeString":"contract SuperDCAGauge"}}],"expression":{"argumentTypes":[{"typeIdentifier":"t_contract$_SuperDCAGauge_$68777","typeString":"contract SuperDCAGauge"}],"id":70566,"isConstant":false,"isLValue":false,"isPure":true,"lValueRequested":false,"nodeType":"ElementaryTypeNameExpression","src":"3968:7:150","typeDescriptions":{"typeIdentifier":"t_type$_t_address_$","typeString":"type(address)"},"typeName":{"id":70565,"name":"address","nodeType":"ElementaryTypeName","src":"3968:7:150","typeDescriptions":{}}},"id":70568,"isConstant":false,"isLValue":false,"isPure":false,"kind":"typeConversion","lValueRequested":false,"nameLocations":[],"names":[],"nodeType":"FunctionCall","src":"3968:13:150","tryCall":false,"typeDescriptions":{"typeIdentifier":"t_address","typeString":"address"}}],"expression":{"argumentTypes":[{"typeIdentifier":"t_address","typeString":"address"}],"id":70564,"name":"IHooks","nodeType":"Identifier","overloadedDeclarations":[],"referencedDeclaration":48824,"src":"3961:6:150","typeDescriptions":{"typeIdentifier":"t_type$_t_contract$_IHooks_$48824_$","typeString":"type(contract IHooks)"}},"id":70569,"isConstant":false,"isLValue":false,"isPure":false,"kind":"typeConversion","lValueRequested":false,"nameLocations":[],"names":[],"nodeType":"FunctionCall","src":"3961:21:150","tryCall":false,"typeDescriptions":{"typeIdentifier":"t_contract$_IHooks_$48824","typeString":"contract IHooks"}}],"expression":{"argumentTypes":[{"typeIdentifier":"t_address","typeString":"address"},{"typeIdentifier":"t_contract$_IPoolManager_$49123","typeString":"contract IPoolManager"},{"typeIdentifier":"t_contract$_IPositionManager_$66026","typeString":"contract IPositionManager"},{"typeIdentifier":"t_address","typeString":"address"},{"typeIdentifier":"t_contract$_IHooks_$48824","typeString":"contract IHooks"}],"id":70552,"isConstant":false,"isLValue":false,"isPure":false,"lValueRequested":false,"nodeType":"NewExpression","src":"3849:19:150","typeDescriptions":{"typeIdentifier":"t_function_creation_nonpayable$_t_address_$_t_contract$_IPoolManager_$49123_$_t_contract$_IPositionManager_$66026_$_t_address_$_t_contract$_IHooks_$48824_$returns$_t_contract$_SuperDCAListing_$69515_$","typeString":"function (address,contract IPoolManager,contract IPositionManager,address,contract IHooks) returns (contract SuperDCAListing)"},"typeName":{"id":70551,"nodeType":"UserDefinedTypeName","pathNode":{"id":70550,"name":"SuperDCAListing","nameLocations":["3853:15:150"],"nodeType":"IdentifierPath","referencedDeclaration":69515,"src":"3853:15:150"},"referencedDeclaration":69515,"src":"3853:15:150","typeDescriptions":{"typeIdentifier":"t_contract$_SuperDCAListing_$69515","typeString":"contract SuperDCAListing"}}},"id":70570,"isConstant":false,"isLValue":false,"isPure":false,"kind":"functionCall","lValueRequested":false,"nameLocations":[],"names":[],"nodeType":"FunctionCall","src":"3849:134:150","tryCall":false,"typeDescriptions":{"typeIdentifier":"t_contract$_SuperDCAListing_$69515","typeString":"contract SuperDCAListing"}},"src":"3839:144:150","typeDescriptions":{"typeIdentifier":"t_contract$_SuperDCAListing_$69515","typeString":"contract SuperDCAListing"}},"id":70572,"nodeType":"ExpressionStatement","src":"3839:144:150"},{"expression":{"id":70584,"isConstant":false,"isLValue":false,"isPure":false,"lValueRequested":false,"leftHandSide":{"id":70573,"name":"staking","nodeType":"Identifier","overloadedDeclarations":[],"referencedDeclaration":70437,"src":"3993:7:150","typeDescriptions":{"typeIdentifier":"t_contract$_SuperDCAStaking_$70184","typeString":"contract SuperDCAStaking"}},"nodeType":"Assignment","operator":"=","rightHandSide":{"arguments":[{"arguments":[{"id":70579,"name":"dcaToken","nodeType":"Identifier","overloadedDeclarations":[],"referencedDeclaration":70443,"src":"4031:8:150","typeDescriptions":{"typeIdentifier":"t_contract$_MockERC20Token_$71135","typeString":"contract MockERC20Token"}}],"expression":{"argumentTypes":[{"typeIdentifier":"t_contract$_MockERC20Token_$71135","typeString":"contract MockERC20Token"}],"id":70578,"isConstant":false,"isLValue":false,"isPure":true,"lValueRequested":false,"nodeType":"ElementaryTypeNameExpression","src":"4023:7:150","typeDescriptions":{"typeIdentifier":"t_type$_t_address_$","typeString":"type(address)"},"typeName":{"id":70577,"name":"address","nodeType":"ElementaryTypeName","src":"4023:7:150","typeDescriptions":{}}},"id":70580,"isConstant":false,"isLValue":false,"isPure":false,"kind":"typeConversion","lValueRequested":false,"nameLocations":[],"names":[],"nodeType":"FunctionCall","src":"4023:17:150","tryCall":false,"typeDescriptions":{"typeIdentifier":"t_address","typeString":"address"}},{"hexValue":"313030","id":70581,"isConstant":false,"isLValue":false,"isPure":true,"kind":"number","lValueRequested":false,"nodeType":"Literal","src":"4042:3:150","typeDescriptions":{"typeIdentifier":"t_rational_100_by_1","typeString":"int_const 100"},"value":"100"},{"id":70582,"name":"developer","nodeType":"Identifier","overloadedDeclarations":[],"referencedDeclaration":70451,"src":"4047:9:150","typeDescriptions":{"typeIdentifier":"t_address","typeString":"address"}}],"expression":{"argumentTypes":[{"typeIdentifier":"t_address","typeString":"address"},{"typeIdentifier":"t_rational_100_by_1","typeString":"int_const 100"},{"typeIdentifier":"t_address","typeString":"address"}],"id":70576,"isConstant":false,"isLValue":false,"isPure":false,"lValueRequested":false,"nodeType":"NewExpression","src":"4003:19:150","typeDescriptions":{"typeIdentifier":"t_function_creation_nonpayable$_t_address_$_t_uint256_$_t_address_$returns$_t_contract$_SuperDCAStaking_$70184_$","typeString":"function (address,uint256,address) returns (contract SuperDCAStaking)"},"typeName":{"id":70575,"nodeType":"UserDefinedTypeName","pathNode":{"id":70574,"name":"SuperDCAStaking","nameLocations":["4007:15:150"],"nodeType":"IdentifierPath","referencedDeclaration":70184,"src":"4007:15:150"},"referencedDeclaration":70184,"src":"4007:15:150","typeDescriptions":{"typeIdentifier":"t_contract$_SuperDCAStaking_$70184","typeString":"contract SuperDCAStaking"}}},"id":70583,"isConstant":false,"isLValue":false,"isPure":false,"kind":"functionCall","lValueRequested":false,"nameLocations":[],"names":[],"nodeType":"FunctionCall","src":"4003:54:150","tryCall":false,"typeDescriptions":{"typeIdentifier":"t_contract$_SuperDCAStaking_$70184","typeString":"contract SuperDCAStaking"}},"src":"3993:64:150","typeDescriptions":{"typeIdentifier":"t_contract$_SuperDCAStaking_$70184","typeString":"contract SuperDCAStaking"}},"id":70585,"nodeType":"ExpressionStatement","src":"3993:64:150"},{"expression":{"arguments":[{"arguments":[{"id":70591,"name":"staking","nodeType":"Identifier","overloadedDeclarations":[],"referencedDeclaration":70437,"src":"4093:7:150","typeDescriptions":{"typeIdentifier":"t_contract$_SuperDCAStaking_$70184","typeString":"contract SuperDCAStaking"}}],"expression":{"argumentTypes":[{"typeIdentifier":"t_contract$_SuperDCAStaking_$70184","typeString":"contract SuperDCAStaking"}],"id":70590,"isConstant":false,"isLValue":false,"isPure":true,"lValueRequested":false,"nodeType":"ElementaryTypeNameExpression","src":"4085:7:150","typeDescriptions":{"typeIdentifier":"t_type$_t_address_$","typeString":"type(address)"},"typeName":{"id":70589,"name":"address","nodeType":"ElementaryTypeName","src":"4085:7:150","typeDescriptions":{}}},"id":70592,"isConstant":false,"isLValue":false,"isPure":false,"kind":"typeConversion","lValueRequested":false,"nameLocations":[],"names":[],"nodeType":"FunctionCall","src":"4085:16:150","tryCall":false,"typeDescriptions":{"typeIdentifier":"t_address","typeString":"address"}}],"expression":{"argumentTypes":[{"typeIdentifier":"t_address","typeString":"address"}],"expression":{"id":70586,"name":"hook","nodeType":"Identifier","overloadedDeclarations":[],"referencedDeclaration":70434,"src":"4069:4:150","typeDescriptions":{"typeIdentifier":"t_contract$_SuperDCAGauge_$68777","typeString":"contract SuperDCAGauge"}},"id":70588,"isConstant":false,"isLValue":false,"isPure":false,"lValueRequested":false,"memberLocation":"4074:10:150","memberName":"setStaking","nodeType":"MemberAccess","referencedDeclaration":68102,"src":"4069:15:150","typeDescriptions":{"typeIdentifier":"t_function_external_nonpayable$_t_address_$returns$__$","typeString":"function (address) external"}},"id":70593,"isConstant":false,"isLValue":false,"isPure":false,"kind":"functionCall","lValueRequested":false,"nameLocations":[],"names":[],"nodeType":"FunctionCall","src":"4069:33:150","tryCall":false,"typeDescriptions":{"typeIdentifier":"t_tuple$__$","typeString":"tuple()"}},"id":70594,"nodeType":"ExpressionStatement","src":"4069:33:150"},{"expression":{"arguments":[{"arguments":[{"id":70600,"name":"listing","nodeType":"Identifier","overloadedDeclarations":[],"referencedDeclaration":70440,"src":"4137:7:150","typeDescriptions":{"typeIdentifier":"t_contract$_SuperDCAListing_$69515","typeString":"contract SuperDCAListing"}}],"expression":{"argumentTypes":[{"typeIdentifier":"t_contract$_SuperDCAListing_$69515","typeString":"contract SuperDCAListing"}],"id":70599,"isConstant":false,"isLValue":false,"isPure":true,"lValueRequested":false,"nodeType":"ElementaryTypeNameExpression","src":"4129:7:150","typeDescriptions":{"typeIdentifier":"t_type$_t_address_$","typeString":"type(address)"},"typeName":{"id":70598,"name":"address","nodeType":"ElementaryTypeName","src":"4129:7:150","typeDescriptions":{}}},"id":70601,"isConstant":false,"isLValue":false,"isPure":false,"kind":"typeConversion","lValueRequested":false,"nameLocations":[],"names":[],"nodeType":"FunctionCall","src":"4129:16:150","tryCall":false,"typeDescriptions":{"typeIdentifier":"t_address","typeString":"address"}}],"expression":{"argumentTypes":[{"typeIdentifier":"t_address","typeString":"address"}],"expression":{"id":70595,"name":"hook","nodeType":"Identifier","overloadedDeclarations":[],"referencedDeclaration":70434,"src":"4113:4:150","typeDescriptions":{"typeIdentifier":"t_contract$_SuperDCAGauge_$68777","typeString":"contract SuperDCAGauge"}},"id":70597,"isConstant":false,"isLValue":false,"isPure":false,"lValueRequested":false,"memberLocation":"4118:10:150","memberName":"setListing","nodeType":"MemberAccess","referencedDeclaration":68130,"src":"4113:15:150","typeDescriptions":{"typeIdentifier":"t_function_external_nonpayable$_t_address_$returns$__$","typeString":"function (address) external"}},"id":70602,"isConstant":false,"isLValue":false,"isPure":false,"kind":"functionCall","lValueRequested":false,"nameLocations":[],"names":[],"nodeType":"FunctionCall","src":"4113:33:150","tryCall":false,"typeDescriptions":{"typeIdentifier":"t_tuple$__$","typeString":"tuple()"}},"id":70603,"nodeType":"ExpressionStatement","src":"4113:33:150"},{"expression":{"arguments":[{"arguments":[{"id":70608,"name":"hook","nodeType":"Identifier","overloadedDeclarations":[],"referencedDeclaration":70434,"src":"4188:4:150","typeDescriptions":{"typeIdentifier":"t_contract$_SuperDCAGauge_$68777","typeString":"contract SuperDCAGauge"}}],"expression":{"argumentTypes":[{"typeIdentifier":"t_contract$_SuperDCAGauge_$68777","typeString":"contract SuperDCAGauge"}],"id":70607,"name":"IHooks","nodeType":"Identifier","overloadedDeclarations":[],"referencedDeclaration":48824,"src":"4181:6:150","typeDescriptions":{"typeIdentifier":"t_type$_t_contract$_IHooks_$48824_$","typeString":"type(contract IHooks)"}},"id":70609,"isConstant":false,"isLValue":false,"isPure":false,"kind":"typeConversion","lValueRequested":false,"nameLocations":[],"names":[],"nodeType":"FunctionCall","src":"4181:12:150","tryCall":false,"typeDescriptions":{"typeIdentifier":"t_contract$_IHooks_$48824","typeString":"contract IHooks"}}],"expression":{"argumentTypes":[{"typeIdentifier":"t_contract$_IHooks_$48824","typeString":"contract IHooks"}],"expression":{"id":70604,"name":"listing","nodeType":"Identifier","overloadedDeclarations":[],"referencedDeclaration":70440,"src":"4158:7:150","typeDescriptions":{"typeIdentifier":"t_contract$_SuperDCAListing_$69515","typeString":"contract SuperDCAListing"}},"id":70606,"isConstant":false,"isLValue":false,"isPure":false,"lValueRequested":false,"memberLocation":"4166:14:150","memberName":"setHookAddress","nodeType":"MemberAccess","referencedDeclaration":68994,"src":"4158:22:150","typeDescriptions":{"typeIdentifier":"t_function_external_nonpayable$_t_contract$_IHooks_$48824_$returns$__$","typeString":"function (contract IHooks) external"}},"id":70610,"isConstant":false,"isLValue":false,"isPure":false,"kind":"functionCall","lValueRequested":false,"nameLocations":[],"names":[],"nodeType":"FunctionCall","src":"4158:36:150","tryCall":false,"typeDescriptions":{"typeIdentifier":"t_tuple$__$","typeString":"tuple()"}},"id":70611,"nodeType":"ExpressionStatement","src":"4158:36:150"},{"expression":{"arguments":[{"arguments":[{"id":70617,"name":"hook","nodeType":"Identifier","overloadedDeclarations":[],"referencedDeclaration":70434,"src":"4230:4:150","typeDescriptions":{"typeIdentifier":"t_contract$_SuperDCAGauge_$68777","typeString":"contract SuperDCAGauge"}}],"expression":{"argumentTypes":[{"typeIdentifier":"t_contract$_SuperDCAGauge_$68777","typeString":"contract SuperDCAGauge"}],"id":70616,"isConstant":false,"isLValue":false,"isPure":true,"lValueRequested":false,"nodeType":"ElementaryTypeNameExpression","src":"4222:7:150","typeDescriptions":{"typeIdentifier":"t_type$_t_address_$","typeString":"type(address)"},"typeName":{"id":70615,"name":"address","nodeType":"ElementaryTypeName","src":"4222:7:150","typeDescriptions":{}}},"id":70618,"isConstant":false,"isLValue":false,"isPure":false,"kind":"typeConversion","lValueRequested":false,"nameLocations":[],"names":[],"nodeType":"FunctionCall","src":"4222:13:150","tryCall":false,"typeDescriptions":{"typeIdentifier":"t_address","typeString":"address"}}],"expression":{"argumentTypes":[{"typeIdentifier":"t_address","typeString":"address"}],"expression":{"id":70612,"name":"staking","nodeType":"Identifier","overloadedDeclarations":[],"referencedDeclaration":70437,"src":"4205:7:150","typeDescriptions":{"typeIdentifier":"t_contract$_SuperDCAStaking_$70184","typeString":"contract SuperDCAStaking"}},"id":70614,"isConstant":false,"isLValue":false,"isPure":false,"lValueRequested":false,"memberLocation":"4213:8:150","memberName":"setGauge","nodeType":"MemberAccess","referencedDeclaration":69710,"src":"4205:16:150","typeDescriptions":{"typeIdentifier":"t_function_external_nonpayable$_t_address_$returns$__$","typeString":"function (address) external"}},"id":70619,"isConstant":false,"isLValue":false,"isPure":false,"kind":"functionCall","lValueRequested":false,"nameLocations":[],"names":[],"nodeType":"FunctionCall","src":"4205:31:150","tryCall":false,"typeDescriptions":{"typeIdentifier":"t_tuple$__$","typeString":"tuple()"}},"id":70620,"nodeType":"ExpressionStatement","src":"4205:31:150"},{"expression":{"arguments":[{"arguments":[{"id":70626,"name":"hook","nodeType":"Identifier","overloadedDeclarations":[],"referencedDeclaration":70434,"src":"4283:4:150","typeDescriptions":{"typeIdentifier":"t_contract$_SuperDCAGauge_$68777","typeString":"contract SuperDCAGauge"}}],"expression":{"argumentTypes":[{"typeIdentifier":"t_contract$_SuperDCAGauge_$68777","typeString":"contract SuperDCAGauge"}],"id":70625,"isConstant":false,"isLValue":false,"isPure":true,"lValueRequested":false,"nodeType":"ElementaryTypeNameExpression","src":"4275:7:150","typeDescriptions":{"typeIdentifier":"t_type$_t_address_$","typeString":"type(address)"},"typeName":{"id":70624,"name":"address","nodeType":"ElementaryTypeName","src":"4275:7:150","typeDescriptions":{}}},"id":70627,"isConstant":false,"isLValue":false,"isPure":false,"kind":"typeConversion","lValueRequested":false,"nameLocations":[],"names":[],"nodeType":"FunctionCall","src":"4275:13:150","tryCall":false,"typeDescriptions":{"typeIdentifier":"t_address","typeString":"address"}}],"expression":{"argumentTypes":[{"typeIdentifier":"t_address","typeString":"address"}],"expression":{"id":70621,"name":"dcaToken","nodeType":"Identifier","overloadedDeclarations":[],"referencedDeclaration":70443,"src":"4248:8:150","typeDescriptions":{"typeIdentifier":"t_contract$_MockERC20Token_$71135","typeString":"contract MockERC20Token"}},"id":70623,"isConstant":false,"isLValue":false,"isPure":false,"lValueRequested":false,"memberLocation":"4257:17:150","memberName":"transferOwnership","nodeType":"MemberAccess","referencedDeclaration":71134,"src":"4248:26:150","typeDescriptions":{"typeIdentifier":"t_function_external_nonpayable$_t_address_$returns$__$","typeString":"function (address) external"}},"id":70628,"isConstant":false,"isLValue":false,"isPure":false,"kind":"functionCall","lValueRequested":false,"nameLocations":[],"names":[],"nodeType":"FunctionCall","src":"4248:41:150","tryCall":false,"typeDescriptions":{"typeIdentifier":"t_tuple$__$","typeString":"tuple()"}},"id":70629,"nodeType":"ExpressionStatement","src":"4248:41:150"},{"expression":{"arguments":[],"expression":{"argumentTypes":[],"expression":{"id":70630,"name":"vm","nodeType":"Identifier","overloadedDeclarations":[],"referencedDeclaration":58,"src":"4299:2:150","typeDescriptions":{"typeIdentifier":"t_contract$_Vm_$17688","typeString":"contract Vm"}},"id":70632,"isConstant":false,"isLValue":false,"isPure":false,"lValueRequested":false,"memberLocation":"4302:9:150","memberName":"stopPrank","nodeType":"MemberAccess","referencedDeclaration":17245,"src":"4299:12:150","typeDescriptions":{"typeIdentifier":"t_function_external_nonpayable$__$returns$__$","typeString":"function () external"}},"id":70633,"isConstant":false,"isLValue":false,"isPure":false,"kind":"functionCall","lValueRequested":false,"nameLocations":[],"names":[],"nodeType":"FunctionCall","src":"4299:14:150","tryCall":false,"typeDescriptions":{"typeIdentifier":"t_tuple$__$","typeString":"tuple()"}},"id":70634,"nodeType":"ExpressionStatement","src":"4299:14:150"}]},"functionSelector":"0a9254e4","implemented":true,"kind":"function","modifiers":[],"name":"setUp","nameLocation":"3178:5:150","parameters":{"id":70479,"nodeType":"ParameterList","parameters":[],"src":"3183:2:150"},"returnParameters":{"id":70480,"nodeType":"ParameterList","parameters":[],"src":"3193:0:150"},"scope":70783,"stateMutability":"nonpayable","virtual":false,"visibility":"public"},{"id":70732,"nodeType":"FunctionDefinition","src":"4330:1296:150","nodes":[],"body":{"id":70731,"nodeType":"Block","src":"4412:1214:150","nodes":[],"statements":[{"assignments":[70640],"declarations":[{"constant":false,"id":70640,"mutability":"mutable","name":"tokenA","nameLocation":"4431:6:150","nodeType":"VariableDeclaration","scope":70731,"src":"4423:14:150","stateVariable":false,"storageLocation":"default","typeDescriptions":{"typeIdentifier":"t_address","typeString":"address"},"typeName":{"id":70639,"name":"address","nodeType":"ElementaryTypeName","src":"4423:7:150","stateMutability":"nonpayable","typeDescriptions":{"typeIdentifier":"t_address","typeString":"address"}},"visibility":"internal"}],"id":70645,"initialValue":{"arguments":[{"id":70643,"name":"dcaToken","nodeType":"Identifier","overloadedDeclarations":[],"referencedDeclaration":70443,"src":"4448:8:150","typeDescriptions":{"typeIdentifier":"t_contract$_MockERC20Token_$71135","typeString":"contract MockERC20Token"}}],"expression":{"argumentTypes":[{"typeIdentifier":"t_contract$_MockERC20Token_$71135","typeString":"contract MockERC20Token"}],"id":70642,"isConstant":false,"isLValue":false,"isPure":true,"lValueRequested":false,"nodeType":"ElementaryTypeNameExpression","src":"4440:7:150","typeDescriptions":{"typeIdentifier":"t_type$_t_address_$","typeString":"type(address)"},"typeName":{"id":70641,"name":"address","nodeType":"ElementaryTypeName","src":"4440:7:150","typeDescriptions":{}}},"id":70644,"isConstant":false,"isLValue":false,"isPure":false,"kind":"typeConversion","lValueRequested":false,"nameLocations":[],"names":[],"nodeType":"FunctionCall","src":"4440:17:150","tryCall":false,"typeDescriptions":{"typeIdentifier":"t_address","typeString":"address"}},"nodeType":"VariableDeclarationStatement","src":"4423:34:150"},{"assignments":[70647],"declarations":[{"constant":false,"id":70647,"mutability":"mutable","name":"tokenB","nameLocation":"4475:6:150","nodeType":"VariableDeclaration","scope":70731,"src":"4467:14:150","stateVariable":false,"storageLocation":"default","typeDescriptions":{"typeIdentifier":"t_address","typeString":"address"},"typeName":{"id":70646,"name":"address","nodeType":"ElementaryTypeName","src":"4467:7:150","stateMutability":"nonpayable","typeDescriptions":{"typeIdentifier":"t_address","typeString":"address"}},"visibility":"internal"}],"id":70652,"initialValue":{"arguments":[{"id":70650,"name":"weth","nodeType":"Identifier","overloadedDeclarations":[],"referencedDeclaration":70463,"src":"4492:4:150","typeDescriptions":{"typeIdentifier":"t_address","typeString":"address"}}],"expression":{"argumentTypes":[{"typeIdentifier":"t_address","typeString":"address"}],"id":70649,"isConstant":false,"isLValue":false,"isPure":true,"lValueRequested":false,"nodeType":"ElementaryTypeNameExpression","src":"4484:7:150","typeDescriptions":{"typeIdentifier":"t_type$_t_address_$","typeString":"type(address)"},"typeName":{"id":70648,"name":"address","nodeType":"ElementaryTypeName","src":"4484:7:150","typeDescriptions":{}}},"id":70651,"isConstant":false,"isLValue":false,"isPure":true,"kind":"typeConversion","lValueRequested":false,"nameLocations":[],"names":[],"nodeType":"FunctionCall","src":"4484:13:150","tryCall":false,"typeDescriptions":{"typeIdentifier":"t_address","typeString":"address"}},"nodeType":"VariableDeclarationStatement","src":"4467:30:150"},{"assignments":[70654],"declarations":[{"constant":false,"id":70654,"mutability":"mutable","name":"sqrtPriceX96","nameLocation":"4516:12:150","nodeType":"VariableDeclaration","scope":70731,"src":"4508:20:150","stateVariable":false,"storageLocation":"default","typeDescriptions":{"typeIdentifier":"t_uint160","typeString":"uint160"},"typeName":{"id":70653,"name":"uint160","nodeType":"ElementaryTypeName","src":"4508:7:150","typeDescriptions":{"typeIdentifier":"t_uint160","typeString":"uint160"}},"visibility":"internal"}],"id":70656,"initialValue":{"hexValue":"3739323238313632353134323634333337353933353433393530333336","id":70655,"isConstant":false,"isLValue":false,"isPure":true,"kind":"number","lValueRequested":false,"nodeType":"Literal","src":"4531:29:150","typeDescriptions":{"typeIdentifier":"t_rational_79228162514264337593543950336_by_1","typeString":"int_const 79228162514264337593543950336"},"value":"79228162514264337593543950336"},"nodeType":"VariableDeclarationStatement","src":"4508:52:150"},{"expression":{"arguments":[{"id":70660,"name":"developer","nodeType":"Identifier","overloadedDeclarations":[],"referencedDeclaration":70451,"src":"4606:9:150","typeDescriptions":{"typeIdentifier":"t_address","typeString":"address"}}],"expression":{"argumentTypes":[{"typeIdentifier":"t_address","typeString":"address"}],"expression":{"id":70657,"name":"vm","nodeType":"Identifier","overloadedDeclarations":[],"referencedDeclaration":58,"src":"4592:2:150","typeDescriptions":{"typeIdentifier":"t_contract$_Vm_$17688","typeString":"contract Vm"}},"id":70659,"isConstant":false,"isLValue":false,"isPure":false,"lValueRequested":false,"memberLocation":"4595:10:150","memberName":"startPrank","nodeType":"MemberAccess","referencedDeclaration":17201,"src":"4592:13:150","typeDescriptions":{"typeIdentifier":"t_function_external_nonpayable$_t_address_$returns$__$","typeString":"function (address) external"}},"id":70661,"isConstant":false,"isLValue":false,"isPure":false,"kind":"functionCall","lValueRequested":false,"nameLocations":[],"names":[],"nodeType":"FunctionCall","src":"4592:24:150","tryCall":false,"typeDescriptions":{"typeIdentifier":"t_tuple$__$","typeString":"tuple()"}},"id":70662,"nodeType":"ExpressionStatement","src":"4592:24:150"},{"assignments":[70664],"declarations":[{"constant":false,"id":70664,"mutability":"mutable","name":"tickSpacingLegitPool","nameLocation":"4743:20:150","nodeType":"VariableDeclaration","scope":70731,"src":"4737:26:150","stateVariable":false,"storageLocation":"default","typeDescriptions":{"typeIdentifier":"t_int24","typeString":"int24"},"typeName":{"id":70663,"name":"int24","nodeType":"ElementaryTypeName","src":"4737:5:150","typeDescriptions":{"typeIdentifier":"t_int24","typeString":"int24"}},"visibility":"internal"}],"id":70666,"initialValue":{"hexValue":"3630","id":70665,"isConstant":false,"isLValue":false,"isPure":true,"kind":"number","lValueRequested":false,"nodeType":"Literal","src":"4766:2:150","typeDescriptions":{"typeIdentifier":"t_rational_60_by_1","typeString":"int_const 60"},"value":"60"},"nodeType":"VariableDeclarationStatement","src":"4737:31:150"},{"assignments":[70669],"declarations":[{"constant":false,"id":70669,"mutability":"mutable","name":"legitKey","nameLocation":"4794:8:150","nodeType":"VariableDeclaration","scope":70731,"src":"4779:23:150","stateVariable":false,"storageLocation":"memory","typeDescriptions":{"typeIdentifier":"t_struct$_PoolKey_$60453_memory_ptr","typeString":"struct PoolKey"},"typeName":{"id":70668,"nodeType":"UserDefinedTypeName","pathNode":{"id":70667,"name":"PoolKey","nameLocations":["4779:7:150"],"nodeType":"IdentifierPath","referencedDeclaration":60453,"src":"4779:7:150"},"referencedDeclaration":60453,"src":"4779:7:150","typeDescriptions":{"typeIdentifier":"t_struct$_PoolKey_$60453_storage_ptr","typeString":"struct PoolKey"}},"visibility":"internal"}],"id":70677,"initialValue":{"arguments":[{"id":70671,"name":"tokenA","nodeType":"Identifier","overloadedDeclarations":[],"referencedDeclaration":70640,"src":"4820:6:150","typeDescriptions":{"typeIdentifier":"t_address","typeString":"address"}},{"id":70672,"name":"tokenB","nodeType":"Identifier","overloadedDeclarations":[],"referencedDeclaration":70647,"src":"4828:6:150","typeDescriptions":{"typeIdentifier":"t_address","typeString":"address"}},{"expression":{"id":70673,"name":"LPFeeLibrary","nodeType":"Identifier","overloadedDeclarations":[],"referencedDeclaration":51160,"src":"4836:12:150","typeDescriptions":{"typeIdentifier":"t_type$_t_contract$_LPFeeLibrary_$51160_$","typeString":"type(library LPFeeLibrary)"}},"id":70674,"isConstant":false,"isLValue":false,"isPure":true,"lValueRequested":false,"memberLocation":"4849:16:150","memberName":"DYNAMIC_FEE_FLAG","nodeType":"MemberAccess","referencedDeclaration":51031,"src":"4836:29:150","typeDescriptions":{"typeIdentifier":"t_uint24","typeString":"uint24"}},{"id":70675,"name":"tickSpacingLegitPool","nodeType":"Identifier","overloadedDeclarations":[],"referencedDeclaration":70664,"src":"4867:20:150","typeDescriptions":{"typeIdentifier":"t_int24","typeString":"int24"}}],"expression":{"argumentTypes":[{"typeIdentifier":"t_address","typeString":"address"},{"typeIdentifier":"t_address","typeString":"address"},{"typeIdentifier":"t_uint24","typeString":"uint24"},{"typeIdentifier":"t_int24","typeString":"int24"}],"id":70670,"name":"_createPoolKey","nodeType":"Identifier","overloadedDeclarations":[],"referencedDeclaration":70782,"src":"4805:14:150","typeDescriptions":{"typeIdentifier":"t_function_internal_view$_t_address_$_t_address_$_t_uint24_$_t_int24_$returns$_t_struct$_PoolKey_$60453_memory_ptr_$","typeString":"function (address,address,uint24,int24) view returns (struct PoolKey memory)"}},"id":70676,"isConstant":false,"isLValue":false,"isPure":false,"kind":"functionCall","lValueRequested":false,"nameLocations":[],"names":[],"nodeType":"FunctionCall","src":"4805:83:150","tryCall":false,"typeDescriptions":{"typeIdentifier":"t_struct$_PoolKey_$60453_memory_ptr","typeString":"struct PoolKey memory"}},"nodeType":"VariableDeclarationStatement","src":"4779:109:150"},{"expression":{"arguments":[{"id":70682,"name":"legitKey","nodeType":"Identifier","overloadedDeclarations":[],"referencedDeclaration":70669,"src":"4939:8:150","typeDescriptions":{"typeIdentifier":"t_struct$_PoolKey_$60453_memory_ptr","typeString":"struct PoolKey memory"}},{"id":70683,"name":"sqrtPriceX96","nodeType":"Identifier","overloadedDeclarations":[],"referencedDeclaration":70654,"src":"4949:12:150","typeDescriptions":{"typeIdentifier":"t_uint160","typeString":"uint160"}}],"expression":{"argumentTypes":[{"typeIdentifier":"t_struct$_PoolKey_$60453_memory_ptr","typeString":"struct PoolKey memory"},{"typeIdentifier":"t_uint160","typeString":"uint160"}],"expression":{"arguments":[{"id":70679,"name":"poolManager","nodeType":"Identifier","overloadedDeclarations":[],"referencedDeclaration":70460,"src":"4915:11:150","typeDescriptions":{"typeIdentifier":"t_address","typeString":"address"}}],"expression":{"argumentTypes":[{"typeIdentifier":"t_address","typeString":"address"}],"id":70678,"name":"IPoolManager","nodeType":"Identifier","overloadedDeclarations":[],"referencedDeclaration":49123,"src":"4902:12:150","typeDescriptions":{"typeIdentifier":"t_type$_t_contract$_IPoolManager_$49123_$","typeString":"type(contract IPoolManager)"}},"id":70680,"isConstant":false,"isLValue":false,"isPure":false,"kind":"typeConversion","lValueRequested":false,"nameLocations":[],"names":[],"nodeType":"FunctionCall","src":"4902:25:150","tryCall":false,"typeDescriptions":{"typeIdentifier":"t_contract$_IPoolManager_$49123","typeString":"contract IPoolManager"}},"id":70681,"isConstant":false,"isLValue":false,"isPure":false,"lValueRequested":false,"memberLocation":"4928:10:150","memberName":"initialize","nodeType":"MemberAccess","referencedDeclaration":48984,"src":"4902:36:150","typeDescriptions":{"typeIdentifier":"t_function_external_nonpayable$_t_struct$_PoolKey_$60453_memory_ptr_$_t_uint160_$returns$_t_int24_$","typeString":"function (struct PoolKey memory,uint160) external returns (int24)"}},"id":70684,"isConstant":false,"isLValue":false,"isPure":false,"kind":"functionCall","lValueRequested":false,"nameLocations":[],"names":[],"nodeType":"FunctionCall","src":"4902:60:150","tryCall":false,"typeDescriptions":{"typeIdentifier":"t_int24","typeString":"int24"}},"id":70685,"nodeType":"ExpressionStatement","src":"4902:60:150"},{"expression":{"arguments":[],"expression":{"argumentTypes":[],"expression":{"id":70686,"name":"vm","nodeType":"Identifier","overloadedDeclarations":[],"referencedDeclaration":58,"src":"4972:2:150","typeDescriptions":{"typeIdentifier":"t_contract$_Vm_$17688","typeString":"contract Vm"}},"id":70688,"isConstant":false,"isLValue":false,"isPure":false,"lValueRequested":false,"memberLocation":"4975:9:150","memberName":"stopPrank","nodeType":"MemberAccess","referencedDeclaration":17245,"src":"4972:12:150","typeDescriptions":{"typeIdentifier":"t_function_external_nonpayable$__$returns$__$","typeString":"function () external"}},"id":70689,"isConstant":false,"isLValue":false,"isPure":false,"kind":"functionCall","lValueRequested":false,"nameLocations":[],"names":[],"nodeType":"FunctionCall","src":"4972:14:150","tryCall":false,"typeDescriptions":{"typeIdentifier":"t_tuple$__$","typeString":"tuple()"}},"id":70690,"nodeType":"ExpressionStatement","src":"4972:14:150"},{"assignments":[70692],"declarations":[{"constant":false,"id":70692,"mutability":"mutable","name":"maliciousUser","nameLocation":"5007:13:150","nodeType":"VariableDeclaration","scope":70731,"src":"4999:21:150","stateVariable":false,"storageLocation":"default","typeDescriptions":{"typeIdentifier":"t_address","typeString":"address"},"typeName":{"id":70691,"name":"address","nodeType":"ElementaryTypeName","src":"4999:7:150","stateMutability":"nonpayable","typeDescriptions":{"typeIdentifier":"t_address","typeString":"address"}},"visibility":"internal"}],"id":70696,"initialValue":{"arguments":[{"hexValue":"6d616c6963696f757355736572","id":70694,"isConstant":false,"isLValue":false,"isPure":true,"kind":"string","lValueRequested":false,"nodeType":"Literal","src":"5032:15:150","typeDescriptions":{"typeIdentifier":"t_stringliteral_c87db594082051310349926c5c20c01ac6d17c904ad798fd696e81b20c673143","typeString":"literal_string \"maliciousUser\""},"value":"maliciousUser"}],"expression":{"argumentTypes":[{"typeIdentifier":"t_stringliteral_c87db594082051310349926c5c20c01ac6d17c904ad798fd696e81b20c673143","typeString":"literal_string \"maliciousUser\""}],"id":70693,"name":"makeAddr","nodeType":"Identifier","overloadedDeclarations":[],"referencedDeclaration":5500,"src":"5023:8:150","typeDescriptions":{"typeIdentifier":"t_function_internal_nonpayable$_t_string_memory_ptr_$returns$_t_address_$","typeString":"function (string memory) returns (address)"}},"id":70695,"isConstant":false,"isLValue":false,"isPure":false,"kind":"functionCall","lValueRequested":false,"nameLocations":[],"names":[],"nodeType":"FunctionCall","src":"5023:25:150","tryCall":false,"typeDescriptions":{"typeIdentifier":"t_address","typeString":"address"}},"nodeType":"VariableDeclarationStatement","src":"4999:49:150"},{"expression":{"arguments":[{"id":70700,"name":"maliciousUser","nodeType":"Identifier","overloadedDeclarations":[],"referencedDeclaration":70692,"src":"5073:13:150","typeDescriptions":{"typeIdentifier":"t_address","typeString":"address"}}],"expression":{"argumentTypes":[{"typeIdentifier":"t_address","typeString":"address"}],"expression":{"id":70697,"name":"vm","nodeType":"Identifier","overloadedDeclarations":[],"referencedDeclaration":58,"src":"5059:2:150","typeDescriptions":{"typeIdentifier":"t_contract$_Vm_$17688","typeString":"contract Vm"}},"id":70699,"isConstant":false,"isLValue":false,"isPure":false,"lValueRequested":false,"memberLocation":"5062:10:150","memberName":"startPrank","nodeType":"MemberAccess","referencedDeclaration":17201,"src":"5059:13:150","typeDescriptions":{"typeIdentifier":"t_function_external_nonpayable$_t_address_$returns$__$","typeString":"function (address) external"}},"id":70701,"isConstant":false,"isLValue":false,"isPure":false,"kind":"functionCall","lValueRequested":false,"nameLocations":[],"names":[],"nodeType":"FunctionCall","src":"5059:28:150","tryCall":false,"typeDescriptions":{"typeIdentifier":"t_tuple$__$","typeString":"tuple()"}},"id":70702,"nodeType":"ExpressionStatement","src":"5059:28:150"},{"assignments":[70704],"declarations":[{"constant":false,"id":70704,"mutability":"mutable","name":"tickSpacingMaliciousPool","nameLocation":"5355:24:150","nodeType":"VariableDeclaration","scope":70731,"src":"5349:30:150","stateVariable":false,"storageLocation":"default","typeDescriptions":{"typeIdentifier":"t_int24","typeString":"int24"},"typeName":{"id":70703,"name":"int24","nodeType":"ElementaryTypeName","src":"5349:5:150","typeDescriptions":{"typeIdentifier":"t_int24","typeString":"int24"}},"visibility":"internal"}],"id":70706,"initialValue":{"hexValue":"3830","id":70705,"isConstant":false,"isLValue":false,"isPure":true,"kind":"number","lValueRequested":false,"nodeType":"Literal","src":"5382:2:150","typeDescriptions":{"typeIdentifier":"t_rational_80_by_1","typeString":"int_const 80"},"value":"80"},"nodeType":"VariableDeclarationStatement","src":"5349:35:150"},{"assignments":[70709],"declarations":[{"constant":false,"id":70709,"mutability":"mutable","name":"maliciousKey","nameLocation":"5415:12:150","nodeType":"VariableDeclaration","scope":70731,"src":"5400:27:150","stateVariable":false,"storageLocation":"memory","typeDescriptions":{"typeIdentifier":"t_struct$_PoolKey_$60453_memory_ptr","typeString":"struct PoolKey"},"typeName":{"id":70708,"nodeType":"UserDefinedTypeName","pathNode":{"id":70707,"name":"PoolKey","nameLocations":["5400:7:150"],"nodeType":"IdentifierPath","referencedDeclaration":60453,"src":"5400:7:150"},"referencedDeclaration":60453,"src":"5400:7:150","typeDescriptions":{"typeIdentifier":"t_struct$_PoolKey_$60453_storage_ptr","typeString":"struct PoolKey"}},"visibility":"internal"}],"id":70717,"initialValue":{"arguments":[{"id":70711,"name":"tokenA","nodeType":"Identifier","overloadedDeclarations":[],"referencedDeclaration":70640,"src":"5445:6:150","typeDescriptions":{"typeIdentifier":"t_address","typeString":"address"}},{"id":70712,"name":"tokenB","nodeType":"Identifier","overloadedDeclarations":[],"referencedDeclaration":70647,"src":"5453:6:150","typeDescriptions":{"typeIdentifier":"t_address","typeString":"address"}},{"expression":{"id":70713,"name":"LPFeeLibrary","nodeType":"Identifier","overloadedDeclarations":[],"referencedDeclaration":51160,"src":"5461:12:150","typeDescriptions":{"typeIdentifier":"t_type$_t_contract$_LPFeeLibrary_$51160_$","typeString":"type(library LPFeeLibrary)"}},"id":70714,"isConstant":false,"isLValue":false,"isPure":true,"lValueRequested":false,"memberLocation":"5474:16:150","memberName":"DYNAMIC_FEE_FLAG","nodeType":"MemberAccess","referencedDeclaration":51031,"src":"5461:29:150","typeDescriptions":{"typeIdentifier":"t_uint24","typeString":"uint24"}},{"id":70715,"name":"tickSpacingMaliciousPool","nodeType":"Identifier","overloadedDeclarations":[],"referencedDeclaration":70704,"src":"5492:24:150","typeDescriptions":{"typeIdentifier":"t_int24","typeString":"int24"}}],"expression":{"argumentTypes":[{"typeIdentifier":"t_address","typeString":"address"},{"typeIdentifier":"t_address","typeString":"address"},{"typeIdentifier":"t_uint24","typeString":"uint24"},{"typeIdentifier":"t_int24","typeString":"int24"}],"id":70710,"name":"_createPoolKey","nodeType":"Identifier","overloadedDeclarations":[],"referencedDeclaration":70782,"src":"5430:14:150","typeDescriptions":{"typeIdentifier":"t_function_internal_view$_t_address_$_t_address_$_t_uint24_$_t_int24_$returns$_t_struct$_PoolKey_$60453_memory_ptr_$","typeString":"function (address,address,uint24,int24) view returns (struct PoolKey memory)"}},"id":70716,"isConstant":false,"isLValue":false,"isPure":false,"kind":"functionCall","lValueRequested":false,"nameLocations":[],"names":[],"nodeType":"FunctionCall","src":"5430:87:150","tryCall":false,"typeDescriptions":{"typeIdentifier":"t_struct$_PoolKey_$60453_memory_ptr","typeString":"struct PoolKey memory"}},"nodeType":"VariableDeclarationStatement","src":"5400:117:150"},{"expression":{"arguments":[{"id":70722,"name":"maliciousKey","nodeType":"Identifier","overloadedDeclarations":[],"referencedDeclaration":70709,"src":"5568:12:150","typeDescriptions":{"typeIdentifier":"t_struct$_PoolKey_$60453_memory_ptr","typeString":"struct PoolKey memory"}},{"id":70723,"name":"sqrtPriceX96","nodeType":"Identifier","overloadedDeclarations":[],"referencedDeclaration":70654,"src":"5582:12:150","typeDescriptions":{"typeIdentifier":"t_uint160","typeString":"uint160"}}],"expression":{"argumentTypes":[{"typeIdentifier":"t_struct$_PoolKey_$60453_memory_ptr","typeString":"struct PoolKey memory"},{"typeIdentifier":"t_uint160","typeString":"uint160"}],"expression":{"arguments":[{"id":70719,"name":"poolManager","nodeType":"Identifier","overloadedDeclarations":[],"referencedDeclaration":70460,"src":"5544:11:150","typeDescriptions":{"typeIdentifier":"t_address","typeString":"address"}}],"expression":{"argumentTypes":[{"typeIdentifier":"t_address","typeString":"address"}],"id":70718,"name":"IPoolManager","nodeType":"Identifier","overloadedDeclarations":[],"referencedDeclaration":49123,"src":"5531:12:150","typeDescriptions":{"typeIdentifier":"t_type$_t_contract$_IPoolManager_$49123_$","typeString":"type(contract IPoolManager)"}},"id":70720,"isConstant":false,"isLValue":false,"isPure":false,"kind":"typeConversion","lValueRequested":false,"nameLocations":[],"names":[],"nodeType":"FunctionCall","src":"5531:25:150","tryCall":false,"typeDescriptions":{"typeIdentifier":"t_contract$_IPoolManager_$49123","typeString":"contract IPoolManager"}},"id":70721,"isConstant":false,"isLValue":false,"isPure":false,"lValueRequested":false,"memberLocation":"5557:10:150","memberName":"initialize","nodeType":"MemberAccess","referencedDeclaration":48984,"src":"5531:36:150","typeDescriptions":{"typeIdentifier":"t_function_external_nonpayable$_t_struct$_PoolKey_$60453_memory_ptr_$_t_uint160_$returns$_t_int24_$","typeString":"function (struct PoolKey memory,uint160) external returns (int24)"}},"id":70724,"isConstant":false,"isLValue":false,"isPure":false,"kind":"functionCall","lValueRequested":false,"nameLocations":[],"names":[],"nodeType":"FunctionCall","src":"5531:64:150","tryCall":false,"typeDescriptions":{"typeIdentifier":"t_int24","typeString":"int24"}},"id":70725,"nodeType":"ExpressionStatement","src":"5531:64:150"},{"expression":{"arguments":[],"expression":{"argumentTypes":[],"expression":{"id":70726,"name":"vm","nodeType":"Identifier","overloadedDeclarations":[],"referencedDeclaration":58,"src":"5605:2:150","typeDescriptions":{"typeIdentifier":"t_contract$_Vm_$17688","typeString":"contract Vm"}},"id":70728,"isConstant":false,"isLValue":false,"isPure":false,"lValueRequested":false,"memberLocation":"5608:9:150","memberName":"stopPrank","nodeType":"MemberAccess","referencedDeclaration":17245,"src":"5605:12:150","typeDescriptions":{"typeIdentifier":"t_function_external_nonpayable$__$returns$__$","typeString":"function () external"}},"id":70729,"isConstant":false,"isLValue":false,"isPure":false,"kind":"functionCall","lValueRequested":false,"nameLocations":[],"names":[],"nodeType":"FunctionCall","src":"5605:14:150","tryCall":false,"typeDescriptions":{"typeIdentifier":"t_tuple$__$","typeString":"tuple()"}},"id":70730,"nodeType":"ExpressionStatement","src":"5605:14:150"}]},"functionSelector":"478a807b","implemented":true,"kind":"function","modifiers":[],"name":"test_maliciousUserCanObtainSoloRewardsByCreatingIndividualPools","nameLocation":"4339:63:150","parameters":{"id":70637,"nodeType":"ParameterList","parameters":[],"src":"4402:2:150"},"returnParameters":{"id":70638,"nodeType":"ParameterList","parameters":[],"src":"4412:0:150"},"scope":70783,"stateMutability":"nonpayable","virtual":false,"visibility":"public"},{"id":70782,"nodeType":"FunctionDefinition","src":"5640:665:150","nodes":[],"body":{"id":70781,"nodeType":"Block","src":"5770:535:150","nodes":[],"statements":[{"expression":{"condition":{"commonType":{"typeIdentifier":"t_address","typeString":"address"},"id":70748,"isConstant":false,"isLValue":false,"isPure":false,"lValueRequested":false,"leftExpression":{"id":70746,"name":"tokenA","nodeType":"Identifier","overloadedDeclarations":[],"referencedDeclaration":70734,"src":"5796:6:150","typeDescriptions":{"typeIdentifier":"t_address","typeString":"address"}},"nodeType":"BinaryOperation","operator":"<","rightExpression":{"id":70747,"name":"tokenB","nodeType":"Identifier","overloadedDeclarations":[],"referencedDeclaration":70736,"src":"5805:6:150","typeDescriptions":{"typeIdentifier":"t_address","typeString":"address"}},"src":"5796:15:150","typeDescriptions":{"typeIdentifier":"t_bool","typeString":"bool"}},"falseExpression":{"arguments":[{"arguments":[{"id":70767,"name":"tokenB","nodeType":"Identifier","overloadedDeclarations":[],"referencedDeclaration":70736,"src":"6121:6:150","typeDescriptions":{"typeIdentifier":"t_address","typeString":"address"}}],"expression":{"argumentTypes":[{"typeIdentifier":"t_address","typeString":"address"}],"expression":{"id":70765,"name":"Currency","nodeType":"Identifier","overloadedDeclarations":[],"referencedDeclaration":60107,"src":"6107:8:150","typeDescriptions":{"typeIdentifier":"t_type$_t_userDefinedValueType$_Currency_$60107_$","typeString":"type(Currency)"}},"id":70766,"isConstant":false,"isLValue":false,"isPure":true,"lValueRequested":false,"memberLocation":"6116:4:150","memberName":"wrap","nodeType":"MemberAccess","src":"6107:13:150","typeDescriptions":{"typeIdentifier":"t_function_wrap_pure$_t_address_$returns$_t_userDefinedValueType$_Currency_$60107_$","typeString":"function (address) pure returns (Currency)"}},"id":70768,"isConstant":false,"isLValue":false,"isPure":false,"kind":"functionCall","lValueRequested":false,"nameLocations":[],"names":[],"nodeType":"FunctionCall","src":"6107:21:150","tryCall":false,"typeDescriptions":{"typeIdentifier":"t_userDefinedValueType$_Currency_$60107","typeString":"Currency"}},{"arguments":[{"id":70771,"name":"tokenA","nodeType":"Identifier","overloadedDeclarations":[],"referencedDeclaration":70734,"src":"6171:6:150","typeDescriptions":{"typeIdentifier":"t_address","typeString":"address"}}],"expression":{"argumentTypes":[{"typeIdentifier":"t_address","typeString":"address"}],"expression":{"id":70769,"name":"Currency","nodeType":"Identifier","overloadedDeclarations":[],"referencedDeclaration":60107,"src":"6157:8:150","typeDescriptions":{"typeIdentifier":"t_type$_t_userDefinedValueType$_Currency_$60107_$","typeString":"type(Currency)"}},"id":70770,"isConstant":false,"isLValue":false,"isPure":true,"lValueRequested":false,"memberLocation":"6166:4:150","memberName":"wrap","nodeType":"MemberAccess","src":"6157:13:150","typeDescriptions":{"typeIdentifier":"t_function_wrap_pure$_t_address_$returns$_t_userDefinedValueType$_Currency_$60107_$","typeString":"function (address) pure returns (Currency)"}},"id":70772,"isConstant":false,"isLValue":false,"isPure":false,"kind":"functionCall","lValueRequested":false,"nameLocations":[],"names":[],"nodeType":"FunctionCall","src":"6157:21:150","tryCall":false,"typeDescriptions":{"typeIdentifier":"t_userDefinedValueType$_Currency_$60107","typeString":"Currency"}},{"id":70773,"name":"fee","nodeType":"Identifier","overloadedDeclarations":[],"referencedDeclaration":70738,"src":"6201:3:150","typeDescriptions":{"typeIdentifier":"t_uint24","typeString":"uint24"}},{"id":70774,"name":"tickSpacing","nodeType":"Identifier","overloadedDeclarations":[],"referencedDeclaration":70740,"src":"6235:11:150","typeDescriptions":{"typeIdentifier":"t_int24","typeString":"int24"}},{"arguments":[{"id":70776,"name":"hook","nodeType":"Identifier","overloadedDeclarations":[],"referencedDeclaration":70434,"src":"6278:4:150","typeDescriptions":{"typeIdentifier":"t_contract$_SuperDCAGauge_$68777","typeString":"contract SuperDCAGauge"}}],"expression":{"argumentTypes":[{"typeIdentifier":"t_contract$_SuperDCAGauge_$68777","typeString":"contract SuperDCAGauge"}],"id":70775,"name":"IHooks","nodeType":"Identifier","overloadedDeclarations":[],"referencedDeclaration":48824,"src":"6271:6:150","typeDescriptions":{"typeIdentifier":"t_type$_t_contract$_IHooks_$48824_$","typeString":"type(contract IHooks)"}},"id":70777,"isConstant":false,"isLValue":false,"isPure":false,"kind":"typeConversion","lValueRequested":false,"nameLocations":[],"names":[],"nodeType":"FunctionCall","src":"6271:12:150","tryCall":false,"typeDescriptions":{"typeIdentifier":"t_contract$_IHooks_$48824","typeString":"contract IHooks"}}],"expression":{"argumentTypes":[{"typeIdentifier":"t_userDefinedValueType$_Currency_$60107","typeString":"Currency"},{"typeIdentifier":"t_userDefinedValueType$_Currency_$60107","typeString":"Currency"},{"typeIdentifier":"t_uint24","typeString":"uint24"},{"typeIdentifier":"t_int24","typeString":"int24"},{"typeIdentifier":"t_contract$_IHooks_$48824","typeString":"contract IHooks"}],"id":70764,"name":"PoolKey","nodeType":"Identifier","overloadedDeclarations":[],"referencedDeclaration":60453,"src":"6070:7:150","typeDescriptions":{"typeIdentifier":"t_type$_t_struct$_PoolKey_$60453_storage_ptr_$","typeString":"type(struct PoolKey storage pointer)"}},"id":70778,"isConstant":false,"isLValue":false,"isPure":false,"kind":"structConstructorCall","lValueRequested":false,"nameLocations":["6096:9:150","6146:9:150","6196:3:150","6222:11:150","6264:5:150"],"names":["currency0","currency1","fee","tickSpacing","hooks"],"nodeType":"FunctionCall","src":"6070:228:150","tryCall":false,"typeDescriptions":{"typeIdentifier":"t_struct$_PoolKey_$60453_memory_ptr","typeString":"struct PoolKey memory"}},"id":70779,"isConstant":false,"isLValue":false,"isPure":false,"lValueRequested":false,"nodeType":"Conditional","src":"5796:502:150","trueExpression":{"arguments":[{"arguments":[{"id":70752,"name":"tokenA","nodeType":"Identifier","overloadedDeclarations":[],"referencedDeclaration":70734,"src":"5877:6:150","typeDescriptions":{"typeIdentifier":"t_address","typeString":"address"}}],"expression":{"argumentTypes":[{"typeIdentifier":"t_address","typeString":"address"}],"expression":{"id":70750,"name":"Currency","nodeType":"Identifier","overloadedDeclarations":[],"referencedDeclaration":60107,"src":"5863:8:150","typeDescriptions":{"typeIdentifier":"t_type$_t_userDefinedValueType$_Currency_$60107_$","typeString":"type(Currency)"}},"id":70751,"isConstant":false,"isLValue":false,"isPure":true,"lValueRequested":false,"memberLocation":"5872:4:150","memberName":"wrap","nodeType":"MemberAccess","src":"5863:13:150","typeDescriptions":{"typeIdentifier":"t_function_wrap_pure$_t_address_$returns$_t_userDefinedValueType$_Currency_$60107_$","typeString":"function (address) pure returns (Currency)"}},"id":70753,"isConstant":false,"isLValue":false,"isPure":false,"kind":"functionCall","lValueRequested":false,"nameLocations":[],"names":[],"nodeType":"FunctionCall","src":"5863:21:150","tryCall":false,"typeDescriptions":{"typeIdentifier":"t_userDefinedValueType$_Currency_$60107","typeString":"Currency"}},{"arguments":[{"id":70756,"name":"tokenB","nodeType":"Identifier","overloadedDeclarations":[],"referencedDeclaration":70736,"src":"5927:6:150","typeDescriptions":{"typeIdentifier":"t_address","typeString":"address"}}],"expression":{"argumentTypes":[{"typeIdentifier":"t_address","typeString":"address"}],"expression":{"id":70754,"name":"Currency","nodeType":"Identifier","overloadedDeclarations":[],"referencedDeclaration":60107,"src":"5913:8:150","typeDescriptions":{"typeIdentifier":"t_type$_t_userDefinedValueType$_Currency_$60107_$","typeString":"type(Currency)"}},"id":70755,"isConstant":false,"isLValue":false,"isPure":true,"lValueRequested":false,"memberLocation":"5922:4:150","memberName":"wrap","nodeType":"MemberAccess","src":"5913:13:150","typeDescriptions":{"typeIdentifier":"t_function_wrap_pure$_t_address_$returns$_t_userDefinedValueType$_Currency_$60107_$","typeString":"function (address) pure returns (Currency)"}},"id":70757,"isConstant":false,"isLValue":false,"isPure":false,"kind":"functionCall","lValueRequested":false,"nameLocations":[],"names":[],"nodeType":"FunctionCall","src":"5913:21:150","tryCall":false,"typeDescriptions":{"typeIdentifier":"t_userDefinedValueType$_Currency_$60107","typeString":"Currency"}},{"id":70758,"name":"fee","nodeType":"Identifier","overloadedDeclarations":[],"referencedDeclaration":70738,"src":"5957:3:150","typeDescriptions":{"typeIdentifier":"t_uint24","typeString":"uint24"}},{"id":70759,"name":"tickSpacing","nodeType":"Identifier","overloadedDeclarations":[],"referencedDeclaration":70740,"src":"5991:11:150","typeDescriptions":{"typeIdentifier":"t_int24","typeString":"int24"}},{"arguments":[{"id":70761,"name":"hook","nodeType":"Identifier","overloadedDeclarations":[],"referencedDeclaration":70434,"src":"6035:4:150","typeDescriptions":{"typeIdentifier":"t_contract$_SuperDCAGauge_$68777","typeString":"contract SuperDCAGauge"}}],"expression":{"argumentTypes":[{"typeIdentifier":"t_contract$_SuperDCAGauge_$68777","typeString":"contract SuperDCAGauge"}],"id":70760,"name":"IHooks","nodeType":"Identifier","overloadedDeclarations":[],"referencedDeclaration":48824,"src":"6028:6:150","typeDescriptions":{"typeIdentifier":"t_type$_t_contract$_IHooks_$48824_$","typeString":"type(contract IHooks)"}},"id":70762,"isConstant":false,"isLValue":false,"isPure":false,"kind":"typeConversion","lValueRequested":false,"nameLocations":[],"names":[],"nodeType":"FunctionCall","src":"6028:12:150","tryCall":false,"typeDescriptions":{"typeIdentifier":"t_contract$_IHooks_$48824","typeString":"contract IHooks"}}],"expression":{"argumentTypes":[{"typeIdentifier":"t_userDefinedValueType$_Currency_$60107","typeString":"Currency"},{"typeIdentifier":"t_userDefinedValueType$_Currency_$60107","typeString":"Currency"},{"typeIdentifier":"t_uint24","typeString":"uint24"},{"typeIdentifier":"t_int24","typeString":"int24"},{"typeIdentifier":"t_contract$_IHooks_$48824","typeString":"contract IHooks"}],"id":70749,"name":"PoolKey","nodeType":"Identifier","overloadedDeclarations":[],"referencedDeclaration":60453,"src":"5826:7:150","typeDescriptions":{"typeIdentifier":"t_type$_t_struct$_PoolKey_$60453_storage_ptr_$","typeString":"type(struct PoolKey storage pointer)"}},"id":70763,"isConstant":false,"isLValue":false,"isPure":false,"kind":"structConstructorCall","lValueRequested":false,"nameLocations":["5852:9:150","5902:9:150","5952:3:150","5978:11:150","6021:5:150"],"names":["currency0","currency1","fee","tickSpacing","hooks"],"nodeType":"FunctionCall","src":"5826:229:150","tryCall":false,"typeDescriptions":{"typeIdentifier":"t_struct$_PoolKey_$60453_memory_ptr","typeString":"struct PoolKey memory"}},"typeDescriptions":{"typeIdentifier":"t_struct$_PoolKey_$60453_memory_ptr","typeString":"struct PoolKey memory"}},"functionReturnParameters":70745,"id":70780,"nodeType":"Return","src":"5789:509:150"}]},"implemented":true,"kind":"function","modifiers":[],"name":"_createPoolKey","nameLocation":"5649:14:150","parameters":{"id":70741,"nodeType":"ParameterList","parameters":[{"constant":false,"id":70734,"mutability":"mutable","name":"tokenA","nameLocation":"5672:6:150","nodeType":"VariableDeclaration","scope":70782,"src":"5664:14:150","stateVariable":false,"storageLocation":"default","typeDescriptions":{"typeIdentifier":"t_address","typeString":"address"},"typeName":{"id":70733,"name":"address","nodeType":"ElementaryTypeName","src":"5664:7:150","stateMutability":"nonpayable","typeDescriptions":{"typeIdentifier":"t_address","typeString":"address"}},"visibility":"internal"},{"constant":false,"id":70736,"mutability":"mutable","name":"tokenB","nameLocation":"5688:6:150","nodeType":"VariableDeclaration","scope":70782,"src":"5680:14:150","stateVariable":false,"storageLocation":"default","typeDescriptions":{"typeIdentifier":"t_address","typeString":"address"},"typeName":{"id":70735,"name":"address","nodeType":"ElementaryTypeName","src":"5680:7:150","stateMutability":"nonpayable","typeDescriptions":{"typeIdentifier":"t_address","typeString":"address"}},"visibility":"internal"},{"constant":false,"id":70738,"mutability":"mutable","name":"fee","nameLocation":"5703:3:150","nodeType":"VariableDeclaration","scope":70782,"src":"5696:10:150","stateVariable":false,"storageLocation":"default","typeDescriptions":{"typeIdentifier":"t_uint24","typeString":"uint24"},"typeName":{"id":70737,"name":"uint24","nodeType":"ElementaryTypeName","src":"5696:6:150","typeDescriptions":{"typeIdentifier":"t_uint24","typeString":"uint24"}},"visibility":"internal"},{"constant":false,"id":70740,"mutability":"mutable","name":"tickSpacing","nameLocation":"5714:11:150","nodeType":"VariableDeclaration","scope":70782,"src":"5708:17:150","stateVariable":false,"storageLocation":"default","typeDescriptions":{"typeIdentifier":"t_int24","typeString":"int24"},"typeName":{"id":70739,"name":"int24","nodeType":"ElementaryTypeName","src":"5708:5:150","typeDescriptions":{"typeIdentifier":"t_int24","typeString":"int24"}},"visibility":"internal"}],"src":"5663:63:150"},"returnParameters":{"id":70745,"nodeType":"ParameterList","parameters":[{"constant":false,"id":70744,"mutability":"mutable","name":"key","nameLocation":"5765:3:150","nodeType":"VariableDeclaration","scope":70782,"src":"5750:18:150","stateVariable":false,"storageLocation":"memory","typeDescriptions":{"typeIdentifier":"t_struct$_PoolKey_$60453_memory_ptr","typeString":"struct PoolKey"},"typeName":{"id":70743,"nodeType":"UserDefinedTypeName","pathNode":{"id":70742,"name":"PoolKey","nameLocations":["5750:7:150"],"nodeType":"IdentifierPath","referencedDeclaration":60453,"src":"5750:7:150"},"referencedDeclaration":60453,"src":"5750:7:150","typeDescriptions":{"typeIdentifier":"t_struct$_PoolKey_$60453_storage_ptr","typeString":"struct PoolKey"}},"visibility":"internal"}],"src":"5749:20:150"},"scope":70783,"stateMutability":"view","virtual":false,"visibility":"internal"}],"abstract":false,"baseContracts":[{"baseName":{"id":70417,"name":"Test","nameLocations":["2303:4:150"],"nodeType":"IdentifierPath","referencedDeclaration":12908,"src":"2303:4:150"},"id":70418,"nodeType":"InheritanceSpecifier","src":"2303:4:150"},{"baseName":{"id":70419,"name":"Deployers","nameLocations":["2309:9:150"],"nodeType":"IdentifierPath","referencedDeclaration":61822,"src":"2309:9:150"},"id":70420,"nodeType":"InheritanceSpecifier","src":"2309:9:150"}],"canonicalName":"MaliciousUserCanObtainSoloRewards","contractDependencies":[69515,70184,71135],"contractKind":"contract","fullyImplemented":true,"linearizedBaseContracts":[70783,61822,12908,12856,6893,6533,5738,3648,2695,65,62],"name":"MaliciousUserCanObtainSoloRewards","nameLocation":"2266:33:150","scope":70784,"usedErrors":[],"usedEvents":[100,104,108,112,116,120,124,128,134,140,148,156,162,168,174,180,185,190,195,202,209,216]}],"license":"Apache-2.0"}},"test/mocks/FeesCollectionMock.sol":{"id":151,"ast":{}},"test/mocks/MockERC20Token.sol":{"id":152,"ast":{}}}},"solcLongVersion":"0.8.26","solcVersion":"0.8.26"}